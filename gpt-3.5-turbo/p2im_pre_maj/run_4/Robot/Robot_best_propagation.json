{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeFlag_08000110(undefined4 inputValue)\n\n{\n  if ((char)DAT_200009c8 == '\\0') {\n    DAT_200009c8._0_1_ = '\\x01';\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_flag_08000110",
                "param_1": "inputValue"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_08000134(undefined4 input_param_1,undefined4 input_param_2)\n\n{\n  return CONCAT44(input_param_2,input_param_1);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_08000134",
                "param_1": "input_param_1",
                "param_2": "input_param_2"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000158": {
            "entrypoint": "0x08000158",
            "current_name": "calculate_concatenation_08000158",
            "code": "\nulonglong calculateConcatenation_08000158(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shiftedInput2;\n  byte carry;\n  uint sum1;\n  uint shiftedInput4;\n  uint sum2;\n  uint result1;\n  uint result2;\n  int shiftAmount1;\n  uint shiftResult1;\n  uint shiftAmount2;\n  uint shiftResult2;\n  uint temp1;\n  bool temp2;\n  bool temp3;\n  bool temp4;\n  \n  result1 = input4 ^ 0x80000000;\n  shiftResult1 = input2 << 1;\n  input4 = input4 << 1;\n  temp2 = ((input2 ^ result1) & 0x7fffffff) == 0;\n  temp3 = temp2 && input1 == input3;\n  if (!temp2 || input1 != input3) {\n    temp3 = (shiftResult1 | input1) == 0;\n  }\n  if (!temp3) {\n    temp3 = (input4 | input3) == 0;\n  }\n  shiftAmount1 = (int)shiftResult1 >> 0x15;\n  if (!temp3) {\n    temp3 = shiftAmount1 == -1;\n  }\n  shiftedInput2 = (int)input4 >> 0x15;\n  if (!temp3) {\n    temp3 = shiftedInput2 == -1;\n  }\n  if (temp3) {\n    if (shiftAmount1 == -1 || shiftedInput2 == -1) {\n      shiftResult1 = result1;\n      shiftResult2 = input3;\n      if (shiftAmount1 == -1) {\n        shiftResult1 = input2;\n        shiftResult2 = input1;\n      }\n      if (shiftAmount1 != -1 || shiftedInput2 != -1) {\n        input3 = shiftResult2;\n        result1 = shiftResult1;\n      }\n      temp3 = (shiftResult2 | shiftResult1 << 0xc) == 0;\n      if (temp3) {\n        temp3 = (input3 | result1 << 0xc) == 0;\n      }\n      if (temp3) {\n        temp3 = shiftResult1 == result1;\n      }\n      if (!temp3) {\n        shiftResult1 = shiftResult1 | 0x80000;\n      }\n      return CONCAT44(shiftResult1,shiftResult2);\n    }\n    if (((input2 ^ result1) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((shiftResult1 | input1) == 0) {\n        input1 = input3;\n        input2 = result1;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != result1) {\n      return 0;\n    }\n    if (shiftResult1 >> 0x15 == 0) {\n      temp3 = (input1 & 0x80000000) != 0;\n      result1 = input2 * 2 + (uint)temp3;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)temp3)) {\n        result1 = result1 | 0x80000000;\n      }\n      return CONCAT44(result1,input1 << 1);\n    }\n    if (shiftResult1 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  shiftResult1 = shiftResult1 >> 0x15;\n  input4 = input4 >> 0x15;\n  shiftResult2 = input4 - shiftResult1;\n  temp3 = shiftResult2 != 0;\n  if (input4 < shiftResult1) {\n    shiftResult2 = -shiftResult2;\n  }\n  shiftAmount2 = input1;\n  result2 = input2;\n  if (temp3 && shiftResult1 <= input4) {\n    shiftResult1 = shiftResult1 + shiftResult2;\n    shiftAmount2 = input3;\n    result2 = result1;\n    input3 = input1;\n    result1 = input2;\n  }\n  if (0x36 < shiftResult2) {\n    return CONCAT44(result2,shiftAmount2);\n  }\n  shiftedInput4 = result2 & 0xfffff | 0x100000;\n  if ((result2 & 0x80000000) != 0) {\n    temp3 = shiftAmount2 != 0;\n    shiftAmount2 = -shiftAmount2;\n    shiftedInput4 = -shiftedInput4 - (uint)temp3;\n  }\n  result2 = result1 & 0xfffff | 0x100000;\n  if ((result1 & 0x80000000) != 0) {\n    temp3 = input3 != 0;\n    input3 = -input3;\n    result2 = -result2 - (uint)temp3;\n  }\n  if (shiftResult1 == shiftResult2) {\n    result2 = result2 ^ 0x100000;\n    if (shiftResult1 == 0) {\n      shiftedInput4 = shiftedInput4 ^ 0x100000;\n      shiftResult1 = 1;\n    }\n    else {\n      shiftResult2 = shiftResult2 - 1;\n    }\n  }\n  result1 = -shiftResult2 + 0x20;\n  if ((int)shiftResult2 < 0x21) {\n    temp1 = input3 << (result1 & 0xff);\n    input3 = input3 >> (shiftResult2 & 0xff);\n    sum1 = shiftAmount2 + input3;\n    sum2 = result2 << (result1 & 0xff);\n    result1 = sum1 + sum2;\n    shiftedInput4 = shiftedInput4 + CARRY4(shiftAmount2,input3) + ((int)result2 >> (shiftResult2 & 0xff)) +\n            (uint)CARRY4(sum1,sum2);\n  }\n  else {\n    temp1 = result2 << (-shiftResult2 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp1 = temp1 | 2;\n    }\n    result2 = (int)result2 >> (shiftResult2 - 0x20 & 0xff);\n    result1 = shiftAmount2 + result2;\n    shiftedInput4 = shiftedInput4 + ((int)result2 >> 0x1f) + (uint)CARRY4(shiftAmount2,result2);\n  }\n  input2 = shiftedInput4 & 0x80000000;\n  shiftResult2 = shiftedInput4;\n  if ((int)shiftedInput4 < 0) {\n    temp3 = temp1 == 0;\n    temp1 = -temp1;\n    shiftResult2 = -result1;\n    result1 = -(uint)!temp3 - result1;\n    shiftResult2 = -(uint)(temp3 <= shiftResult2) - shiftedInput4;\n  }\n  if (0xfffff < shiftResult2) {\n    shiftAmount2 = shiftResult1 - 1;\n    if (0x1fffff < shiftResult2) {\n      shiftAmount2 = shiftResult2 & 1;\n      shiftResult2 = shiftResult2 >> 1;\n      carry = (byte)result1;\n      result1 = (uint)(shiftAmount2 != 0) << 0x1f | result1 >> 1;\n      temp1 = (uint)(carry & 1) << 0x1f | temp1 >> 1;\n      shiftAmount2 = shiftResult1;\n      if (0xffbfffff < shiftResult1 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    temp3 = 0x7fffffff < temp1;\n    if (temp1 == 0x80000000) {\n      temp3 = (result1 & 1) != 0;\n    }\n    return CONCAT44(shiftResult2 + shiftAmount2 * 0x100000 + (uint)CARRY4(result1,(uint)temp3) | input2,\n                    result1 + temp3);\n  }\n  temp2 = (temp1 & 0x80000000) != 0;\n  temp1 = temp1 << 1;\n  shiftAmount2 = result1 * 2;\n  temp3 = CARRY4(result1,result1);\n  result1 = result1 * 2 + (uint)temp2;\n  shiftResult2 = shiftResult2 * 2 + (uint)(temp3 || CARRY4(shiftAmount2,(uint)temp2));\n  shiftAmount2 = shiftResult1 - 2;\n  if ((shiftResult2 & 0x100000) != 0) goto LAB_08000268;\n  result2 = result1;\n  shiftResult1 = shiftResult2;\n  if (shiftResult2 == 0) {\n    result2 = 0;\n    shiftResult1 = result1;\n  }\n  shiftAmount1 = LZCOUNT(shiftResult1);\n  if (shiftResult2 == 0) {\n    shiftAmount1 = shiftAmount1 + 0x20;\n  }\n  shiftResult2 = shiftAmount1 - 0xb;\n  temp4 = SBORROW4(shiftResult2,0x20);\n  result1 = shiftAmount1 - 0x2b;\n  temp3 = (int)result1 < 0;\n  temp2 = result1 == 0;\n  if ((int)shiftResult2 < 0x20) {\n    temp4 = SCARRY4(result1,0xc);\n    shiftAmount1 = shiftAmount1 + -0x1f;\n    temp3 = shiftAmount1 < 0;\n    temp2 = shiftAmount1 == 0;\n    result1 = shiftResult2;\n    if (!temp2 && temp3 == temp4) {\n      result2 = shiftResult1 << (shiftResult2 & 0xff);\n      shiftResult1 = shiftResult1 >> (0xcU - shiftAmount1 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (temp2 || temp3 != temp4) {\n    temp1 = 0x20 - result1;\n  }\n  shiftResult1 = shiftResult1 << (result1 & 0xff);\n  if (temp2 || temp3 != temp4) {\n    shiftResult1 = shiftResult1 | result2 >> (temp1 & 0xff);\n  }\n  if (temp2 || temp3 != temp4) {\n    result2 = result2 << (result1 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shiftResult2 <= (int)shiftAmount2) {\n    return CONCAT44(shiftResult1 + (shiftAmount2 - shiftResult2) * 0x100000 | input2,result2);\n  }\n  result1 = ~(shiftAmount2 - shiftResult2);\n  if ((int)result1 < 0x1f) {\n    shiftAmount1 = result1 - 0x13;\n    if (shiftAmount1 != 0 && shiftAmount1 < 0 == SCARRY4(result1 - 0x1f,0xc)) {\n      return CONCAT44(shiftedInput4,result2 >> (0x20 - (0xcU - shiftAmount1) & 0xff) | shiftResult1 << (0xcU - shiftAmount1 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    result1 = result1 + 1;\n    return CONCAT44(input2 | shiftResult1 >> (result1 & 0xff),\n                    result2 >> (result1 & 0xff) | shiftResult1 << (0x20 - result1 & 0xff));\n  }\n  return CONCAT44(shiftedInput4,shiftResult1 >> (result1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000158": "calculate_concatenation_08000158",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftedInput2",
                "bVar2": "carry",
                "uVar3": "sum1",
                "uVar4": "shiftedInput4",
                "uVar5": "sum2",
                "uVar6": "result1",
                "uVar7": "result2",
                "iVar8": "shiftAmount1",
                "uVar9": "shiftResult1",
                "uVar10": "shiftAmount2",
                "uVar11": "shiftResult2",
                "uVar12": "temp1",
                "bVar13": "temp2",
                "bVar14": "temp3",
                "bVar15": "temp4"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800015c": {
            "entrypoint": "0x0800015c",
            "current_name": "calculate_integer_0800015c",
            "code": "\nulonglong calculate_integer_0800015c(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  int shift_2;\n  byte carry;\n  uint temp1;\n  uint temp2;\n  uint uVar5;\n  int shift_4;\n  uint shifted_param_2;\n  uint shifted_param_4;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool is_equal;\n  bool is_zero;\n  bool is_negative;\n  \n  shifted_param_2 = input_2 << 1;\n  uVar9 = input_4 << 1;\n  is_equal = ((input_2 ^ input_4) & 0x7fffffff) == 0;\n  is_zero = is_equal && input_1 == input_3;\n  if (!is_equal || input_1 != input_3) {\n    is_zero = (shifted_param_2 | input_1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = (uVar9 | input_3) == 0;\n  }\n  shift_4 = (int)shifted_param_2 >> 0x15;\n  if (!is_zero) {\n    is_zero = shift_4 == -1;\n  }\n  shift_2 = (int)uVar9 >> 0x15;\n  if (!is_zero) {\n    is_zero = shift_2 == -1;\n  }\n  if (is_zero) {\n    if (shift_4 == -1 || shift_2 == -1) {\n      uVar9 = input_4;\n      shifted_param_2 = input_3;\n      if (shift_4 == -1) {\n        uVar9 = input_2;\n        shifted_param_2 = input_1;\n      }\n      if (shift_4 != -1 || shift_2 != -1) {\n        input_3 = shifted_param_2;\n        input_4 = uVar9;\n      }\n      is_zero = (shifted_param_2 | uVar9 << 0xc) == 0;\n      if (is_zero) {\n        is_zero = (input_3 | input_4 << 0xc) == 0;\n      }\n      if (is_zero) {\n        is_zero = uVar9 == input_4;\n      }\n      if (!is_zero) {\n        uVar9 = uVar9 | 0x80000;\n      }\n      return CONCAT44(uVar9,shifted_param_2);\n    }\n    if (((input_2 ^ input_4) & 0x7fffffff) != 0 || input_1 != input_3) {\n      if ((shifted_param_2 | input_1) == 0) {\n        input_1 = input_3;\n        input_2 = input_4;\n      }\n      return CONCAT44(input_2,input_1);\n    }\n    if (input_2 != input_4) {\n      return 0;\n    }\n    if (shifted_param_2 >> 0x15 == 0) {\n      is_zero = (input_1 & 0x80000000) != 0;\n      uVar9 = input_2 * 2 + (uint)is_zero;\n      if (CARRY4(input_2,input_2) || CARRY4(input_2 * 2,(uint)is_zero)) {\n        uVar9 = uVar9 | 0x80000000;\n      }\n      return CONCAT44(uVar9,input_1 << 1);\n    }\n    if (shifted_param_2 < 0xffc00000) {\n      return CONCAT44(input_2 + 0x100000,input_1);\n    }\n    input_2 = input_2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input_2 | 0x7ff00000) << 0x20;\n  }\n  shifted_param_2 = shifted_param_2 >> 0x15;\n  uVar9 = uVar9 >> 0x15;\n  uVar10 = uVar9 - shifted_param_2;\n  is_zero = uVar10 != 0;\n  if (uVar9 < shifted_param_2) {\n    uVar10 = -uVar10;\n  }\n  shifted_param_4 = input_1;\n  uVar5 = input_2;\n  if (is_zero && shifted_param_2 <= uVar9) {\n    shifted_param_2 = shifted_param_2 + uVar10;\n    shifted_param_4 = input_3;\n    uVar5 = input_4;\n    input_3 = input_1;\n    input_4 = input_2;\n  }\n  if (0x36 < uVar10) {\n    return CONCAT44(uVar5,shifted_param_4);\n  }\n  uVar9 = uVar5 & 0xfffff | 0x100000;\n  if ((uVar5 & 0x80000000) != 0) {\n    is_zero = shifted_param_4 != 0;\n    shifted_param_4 = -shifted_param_4;\n    uVar9 = -uVar9 - (uint)is_zero;\n  }\n  uVar5 = input_4 & 0xfffff | 0x100000;\n  if ((input_4 & 0x80000000) != 0) {\n    is_zero = input_3 != 0;\n    input_3 = -input_3;\n    uVar5 = -uVar5 - (uint)is_zero;\n  }\n  if (shifted_param_2 == uVar10) {\n    uVar5 = uVar5 ^ 0x100000;\n    if (shifted_param_2 == 0) {\n      uVar9 = uVar9 ^ 0x100000;\n      shifted_param_2 = 1;\n    }\n    else {\n      uVar10 = uVar10 - 1;\n    }\n  }\n  uVar12 = -uVar10 + 0x20;\n  if ((int)uVar10 < 0x21) {\n    uVar11 = input_3 << (uVar12 & 0xff);\n    input_3 = input_3 >> (uVar10 & 0xff);\n    temp1 = shifted_param_4 + input_3;\n    temp2 = uVar5 << (uVar12 & 0xff);\n    uVar12 = temp1 + temp2;\n    uVar9 = uVar9 + CARRY4(shifted_param_4,input_3) + ((int)uVar5 >> (uVar10 & 0xff)) +\n            (uint)CARRY4(temp1,temp2);\n  }\n  else {\n    uVar11 = uVar5 << (-uVar10 + 0x40 & 0xff);\n    if (input_3 != 0) {\n      uVar11 = uVar11 | 2;\n    }\n    uVar5 = (int)uVar5 >> (uVar10 - 0x20 & 0xff);\n    uVar12 = shifted_param_4 + uVar5;\n    uVar9 = uVar9 + ((int)uVar5 >> 0x1f) + (uint)CARRY4(shifted_param_4,uVar5);\n  }\n  input_2 = uVar9 & 0x80000000;\n  uVar10 = uVar9;\n  if ((int)uVar9 < 0) {\n    is_zero = uVar11 == 0;\n    uVar11 = -uVar11;\n    uVar10 = -uVar12;\n    uVar12 = -(uint)!is_zero - uVar12;\n    uVar10 = -(uint)(is_zero <= uVar10) - uVar9;\n  }\n  if (0xfffff < uVar10) {\n    shifted_param_4 = shifted_param_2 - 1;\n    if (0x1fffff < uVar10) {\n      uVar9 = uVar10 & 1;\n      uVar10 = uVar10 >> 1;\n      carry = (byte)uVar12;\n      uVar12 = (uint)(uVar9 != 0) << 0x1f | uVar12 >> 1;\n      uVar11 = (uint)(carry & 1) << 0x1f | uVar11 >> 1;\n      shifted_param_4 = shifted_param_2;\n      if (0xffbfffff < shifted_param_2 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    is_zero = 0x7fffffff < uVar11;\n    if (uVar11 == 0x80000000) {\n      is_zero = (uVar12 & 1) != 0;\n    }\n    return CONCAT44(uVar10 + shifted_param_4 * 0x100000 + (uint)CARRY4(uVar12,(uint)is_zero) | input_2,\n                    uVar12 + is_zero);\n  }\n  is_equal = (uVar11 & 0x80000000) != 0;\n  uVar11 = uVar11 << 1;\n  shifted_param_4 = uVar12 * 2;\n  is_zero = CARRY4(uVar12,uVar12);\n  uVar12 = uVar12 * 2 + (uint)is_equal;\n  uVar10 = uVar10 * 2 + (uint)(is_zero || CARRY4(shifted_param_4,(uint)is_equal));\n  shifted_param_4 = shifted_param_2 - 2;\n  if ((uVar10 & 0x100000) != 0) goto LAB_08000268;\n  uVar5 = uVar12;\n  shifted_param_2 = uVar10;\n  if (uVar10 == 0) {\n    uVar5 = 0;\n    shifted_param_2 = uVar12;\n  }\n  shift_4 = LZCOUNT(shifted_param_2);\n  if (uVar10 == 0) {\n    shift_4 = shift_4 + 0x20;\n  }\n  uVar12 = shift_4 - 0xb;\n  is_negative = SBORROW4(uVar12,0x20);\n  uVar10 = shift_4 - 0x2b;\n  is_zero = (int)uVar10 < 0;\n  is_equal = uVar10 == 0;\n  if ((int)uVar12 < 0x20) {\n    is_negative = SCARRY4(uVar10,0xc);\n    shift_4 = shift_4 + -0x1f;\n    is_zero = shift_4 < 0;\n    is_equal = shift_4 == 0;\n    uVar10 = uVar12;\n    if (!is_equal && is_zero == is_negative) {\n      uVar5 = shifted_param_2 << (uVar12 & 0xff);\n      shifted_param_2 = shifted_param_2 >> (0xcU - shift_4 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_equal || is_zero != is_negative) {\n    uVar11 = 0x20 - uVar10;\n  }\n  shifted_param_2 = shifted_param_2 << (uVar10 & 0xff);\n  if (is_equal || is_zero != is_negative) {\n    shifted_param_2 = shifted_param_2 | uVar5 >> (uVar11 & 0xff);\n  }\n  if (is_equal || is_zero != is_negative) {\n    uVar5 = uVar5 << (uVar10 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)uVar12 <= (int)shifted_param_4) {\n    return CONCAT44(shifted_param_2 + (shifted_param_4 - uVar12) * 0x100000 | input_2,uVar5);\n  }\n  uVar10 = ~(shifted_param_4 - uVar12);\n  if ((int)uVar10 < 0x1f) {\n    shift_4 = uVar10 - 0x13;\n    if (shift_4 != 0 && shift_4 < 0 == SCARRY4(uVar10 - 0x1f,0xc)) {\n      return CONCAT44(uVar9,uVar5 >> (0x20 - (0xcU - shift_4) & 0xff) | shifted_param_2 << (0xcU - shift_4 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uVar10 = uVar10 + 1;\n    return CONCAT44(input_2 | shifted_param_2 >> (uVar10 & 0xff),\n                    uVar5 >> (uVar10 & 0xff) | shifted_param_2 << (0x20 - uVar10 & 0xff));\n  }\n  return CONCAT44(uVar9,shifted_param_2 >> (uVar10 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800015c": "calculate_integer_0800015c",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "shift_2",
                "bVar2": "carry",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "iVar6": "shift_4",
                "uVar7": "shifted_param_2",
                "uVar8": "shifted_param_4",
                "bVar13": "is_equal",
                "bVar14": "is_zero",
                "bVar15": "is_negative"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003d4": {
            "entrypoint": "0x080003d4",
            "current_name": "reverse_bits_080003d4",
            "code": "\nulonglong reverseBits_080003d4(uint num)\n\n{\n  uint result;\n  uint shift;\n  int bitCount;\n  uint maxShift;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool isOverflow;\n  \n  if (num == 0) {\n    return 0;\n  }\n  result = 0;\n  bitCount = LZCOUNT(num);\n  maxShift = bitCount + 0x15;\n  isOverflow = SBORROW4(maxShift,0x20);\n  shift = bitCount - 0xb;\n  isNegative = (int)shift < 0;\n  isZero = shift == 0;\n  if (maxShift < 0x20) {\n    isOverflow = SCARRY4(shift,0xc);\n    isNegative = false;\n    isZero = bitCount + 1 == 0;\n    shift = maxShift;\n    if (!isZero && isOverflow == false) {\n      result = num << maxShift;\n      num = num >> (0xcU - (bitCount + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isZero || isNegative != isOverflow) {\n    remainingBits = 0x20 - shift;\n  }\n  num = num << (shift & 0xff);\n  if (isZero || isNegative != isOverflow) {\n    num = num | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isNegative != isOverflow) {\n    result = 0 << (shift & 0xff);\n  }\nLAB_080002e0:\n  if (maxShift < 0x433) {\n    return CONCAT44(num + (0x432 - maxShift) * 0x100000,result);\n  }\n  shift = ~(0x432 - maxShift);\n  if (0x1e < (int)shift) {\n    return (ulonglong)(num >> (shift - 0x1f & 0xff));\n  }\n  bitCount = shift - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(shift - 0x1f,0xc)) {\n    shift = shift + 1;\n    return CONCAT44(num >> (shift & 0xff),\n                    result >> (shift & 0xff) | num << (0x20 - shift & 0xff));\n  }\n  return (ulonglong)(result >> (0x20 - (0xcU - bitCount) & 0xff) | num << (0xcU - bitCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003d4": "reverse_bits_080003d4",
                "param_1": "num",
                "uVar1": "result",
                "uVar2": "shift",
                "iVar3": "bitCount",
                "uVar4": "maxShift",
                "in_r12": "remainingBits",
                "bVar5": "isNegative",
                "bVar6": "isZero",
                "bVar7": "isOverflow"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003f4": {
            "entrypoint": "0x080003f4",
            "current_name": "reverse_bits_080003f4",
            "code": "\nulonglong reverseBits_080003f4(uint input)\n\n{\n  uint bitCount;\n  uint absInput;\n  uint shiftAmount;\n  int leadingZeros;\n  uint adjustedShift;\n  uint signBit;\n  uint temp;\n  bool isNegative;\n  bool isZero;\n  bool carryFlag;\n  \n  if (input == 0) {\n    return 0;\n  }\n  signBit = input & 0x80000000;\n  absInput = input;\n  if ((int)signBit < 0) {\n    absInput = -input;\n  }\n  bitCount = 0;\n  leadingZeros = countLeadingZeros(absInput);\n  adjustedShift = leadingZeros + 0x15;\n  carryFlag = isSignedSubtractionOverflow(adjustedShift,0x20);\n  shiftAmount = leadingZeros - 0xb;\n  isNegative = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if (adjustedShift < 0x20) {\n    carryFlag = isSubtractionCarry(shiftAmount,0xc);\n    isNegative = false;\n    isZero = leadingZeros + 1 == 0;\n    shiftAmount = adjustedShift;\n    if (!isZero && carryFlag == false) {\n      bitCount = absInput << adjustedShift;\n      absInput = absInput >> (0xcU - (leadingZeros + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isZero || isNegative != carryFlag) {\n    temp = 0x20 - shiftAmount;\n  }\n  absInput = absInput << (shiftAmount & 0xff);\n  if (isZero || isNegative != carryFlag) {\n    absInput = absInput | 0U >> (temp & 0xff);\n  }\n  if (isZero || isNegative != carryFlag) {\n    bitCount = 0 << (shiftAmount & 0xff);\n  }\nLAB_080002e0:\n  if (adjustedShift < 0x433) {\n    return CONCAT44(absInput + (0x432 - adjustedShift) * 0x100000 | signBit,bitCount);\n  }\n  shiftAmount = ~(0x432 - adjustedShift);\n  if (0x1e < (int)shiftAmount) {\n    return CONCAT44(input,absInput >> (shiftAmount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leadingZeros = shiftAmount - 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != isSubtractionCarry(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(signBit | absInput >> (shiftAmount & 0xff),\n                    bitCount >> (shiftAmount & 0xff) | absInput << (0x20 - shiftAmount & 0xff));\n  }\n  return CONCAT44(input,bitCount >> (0x20 - (0xcU - leadingZeros) & 0xff) | absInput << (0xcU - leadingZeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080003f4": "reverse_bits_080003f4",
                "param_1": "input",
                "uVar1": "bitCount",
                "uVar2": "absInput",
                "uVar3": "shiftAmount",
                "iVar4": "leadingZeros",
                "uVar5": "adjustedShift",
                "uVar6": "signBit",
                "in_r12": "temp",
                "bVar7": "isNegative",
                "bVar8": "isZero",
                "bVar9": "carryFlag",
                "LZCOUNT": "countLeadingZeros",
                "SBORROW4": "isSignedSubtractionOverflow",
                "SCARRY4": "isSubtractionCarry"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000418": {
            "entrypoint": "0x08000418",
            "current_name": "decode_and_concatenate_08000418",
            "code": "\nulonglong decode_and_concatenate_08000418(uint input_value,undefined4 param_2,undefined4 param_3,uint param_4)\n\n{\n  uint high_bit_shifted;\n  uint shifted_input;\n  uint combined_value;\n  uint shifted_value;\n  uint input_value_shifted;\n  int shift_offset;\n  uint shift_difference;\n  uint constant;\n  bool is_less_than_zero;\n  bool is_zero;\n  bool is_greater_than_zero;\n  \n  input_value_shifted = input_value << 1;\n  is_zero = input_value_shifted == 0;\n  high_bit_shifted = (uint)((input_value & 0x80000000) != 0) << 0x1f;\n  shifted_value = (uint)((int)input_value_shifted >> 3) >> 1;\n  combined_value = high_bit_shifted | shifted_value;\n  input_value = input_value << 0x1d;\n  if (!is_zero) {\n    param_4 = input_value_shifted & 0xff000000;\n    is_zero = param_4 == 0;\n  }\n  if (!is_zero) {\n    is_zero = param_4 == 0xff000000;\n  }\n  if (!is_zero) {\n    return CONCAT44(combined_value,input_value) ^ 0x3800000000000000;\n  }\n  if ((input_value_shifted & 0xffffff) == 0) {\n    return CONCAT44(combined_value,input_value);\n  }\n  if (param_4 == 0xff000000) {\n    return CONCAT44(combined_value,input_value) | 0x8000000000000;\n  }\n  shifted_input = input_value;\n  input_value_shifted = shifted_value;\n  if (shifted_value == 0) {\n    shifted_input = 0;\n    input_value_shifted = input_value;\n  }\n  shift_offset = LZCOUNT(input_value_shifted);\n  if (shifted_value == 0) {\n    shift_offset = shift_offset + 0x20;\n  }\n  shift_difference = shift_offset - 0xb;\n  is_greater_than_zero = SBORROW4(shift_difference,0x20);\n  shifted_value = shift_offset - 0x2b;\n  is_zero = (int)shifted_value < 0;\n  is_less_than_zero = shifted_value == 0;\n  if ((int)shift_difference < 0x20) {\n    is_greater_than_zero = SCARRY4(shifted_value,0xc);\n    shift_offset = shift_offset + -0x1f;\n    is_zero = shift_offset < 0;\n    is_less_than_zero = shift_offset == 0;\n    shifted_value = shift_difference;\n    if (!is_less_than_zero && is_zero == is_greater_than_zero) {\n      shifted_input = input_value_shifted << (shift_difference & 0xff);\n      input_value_shifted = input_value_shifted >> (0xcU - shift_offset & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_less_than_zero || is_zero != is_greater_than_zero) {\n    constant = 0x20 - shifted_value;\n  }\n  input_value_shifted = input_value_shifted << (shifted_value & 0xff);\n  if (is_less_than_zero || is_zero != is_greater_than_zero) {\n    input_value_shifted = input_value_shifted | shifted_input >> (constant & 0xff);\n  }\n  if (is_less_than_zero || is_zero != is_greater_than_zero) {\n    shifted_input = shifted_input << (shifted_value & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shift_difference < 0x381) {\n    return CONCAT44(input_value_shifted + (0x380 - shift_difference) * 0x100000 | high_bit_shifted,shifted_input);\n  }\n  shifted_value = ~(0x380 - shift_difference);\n  if (0x1e < (int)shifted_value) {\n    return CONCAT44(combined_value,input_value_shifted >> (shifted_value - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  shift_offset = shifted_value - 0x13;\n  if (shift_offset == 0 || shift_offset < 0 != SCARRY4(shifted_value - 0x1f,0xc)) {\n    shifted_value = shifted_value + 1;\n    return CONCAT44(high_bit_shifted | input_value_shifted >> (shifted_value & 0xff),\n                    shifted_input >> (shifted_value & 0xff) | input_value_shifted << (0x20 - shifted_value & 0xff));\n  }\n  return CONCAT44(combined_value,shifted_input >> (0x20 - (0xcU - shift_offset) & 0xff) | input_value_shifted << (0xcU - shift_offset & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000418": "decode_and_concatenate_08000418",
                "param_1": "input_value",
                "uVar1": "high_bit_shifted",
                "uVar2": "shifted_input",
                "uVar3": "combined_value",
                "uVar4": "shifted_value",
                "uVar5": "input_value_shifted",
                "uVar7": "shift_difference",
                "in_r12": "constant",
                "bVar8": "is_less_than_zero",
                "bVar9": "is_zero",
                "bVar10": "is_greater_than_zero",
                "iVar6": "shift_offset"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004c8": {
            "entrypoint": "0x080004c8",
            "current_name": "calculate_result_080004c8",
            "code": "\nulonglong calculateResult_080004c8(undefined4 value1,uint value2,uint value3,uint value4)\n\n{\n  ulonglong result;\n  longlong temp;\n  uint value1High;\n  uint value2High;\n  int sum;\n  uint temp1;\n  uint value4High;\n  uint temp2;\n  uint temp3;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  ulonglong valueConcatenated;\n  \n  valueConcatenated = CONCAT44(value2,value1);\n  temp2 = 0x7ff;\n  value2High = value2 >> 0x14 & 0x7ff;\n  condition1 = value2High == 0;\n  if (!condition1) {\n    value4High = value4 >> 0x14 & 0x7ff;\n    condition1 = value4High == 0;\n  }\n  if (!condition1) {\n    condition1 = value2High == 0x7ff;\n  }\n  if (!condition1) {\n    condition1 = value4High == 0x7ff;\n  }\n  if (condition1) {\n    valueConcatenated = extract_bit_range_080006a4();\n  }\n  value1High = (uint)(valueConcatenated >> 0x20);\n  sum = value2High + value4High;\n  value2High = value1High ^ value4;\n  value1High = value1High & ~(temp2 << 0x15);\n  value4 = value4 & ~(temp2 << 0x15);\n  condition1 = ((uint)valueConcatenated | value1High << 0xc) == 0;\n  if (!condition1) {\n    condition1 = (value3 | value4 << 0xc) == 0;\n  }\n  value1High = value1High | 0x100000;\n  value4 = value4 | 0x100000;\n  if (condition1) {\n    value3 = (uint)valueConcatenated | value3;\n    value4 = (value2High & 0x80000000 | value1High) ^ value4;\n    value2High = temp2 >> 1;\n    condition3 = SBORROW4(sum,value2High);\n    temp1 = sum - value2High;\n    condition1 = temp1 == 0;\n    value1High = temp1;\n    if (!condition1 && (int)value2High <= sum) {\n      condition3 = SBORROW4(temp2,temp1);\n      value1High = temp2 - temp1;\n      condition1 = temp2 == temp1;\n    }\n    if (!condition1 && (int)value1High < 0 == condition3) {\n      value4 = value4 | temp1 * 0x100000;\n    }\n    if (!condition1 && (int)value1High < 0 == condition3) {\n      return CONCAT44(value4,value3);\n    }\n    value4 = value4 | 0x100000;\n    temp2 = 0;\n    condition3 = SBORROW4(temp1,1);\n    temp1 = temp1 - 1;\n    condition1 = temp1 == 0;\n    value2High = temp1;\n  }\n  else {\n    result = (valueConcatenated & 0xffffffff) * (ulonglong)value3;\n    valueConcatenated = (valueConcatenated & 0xffffffff) * (ulonglong)value4 +\n             (ulonglong)value1High * (ulonglong)value3 + (result >> 0x20);\n    temp3 = (uint)valueConcatenated;\n    temp = (ulonglong)value1High * (ulonglong)value4 + (valueConcatenated >> 0x20);\n    temp2 = (uint)temp;\n    value1High = (uint)((ulonglong)temp >> 0x20);\n    if ((int)result != 0) {\n      temp3 = temp3 | 1;\n    }\n    temp1 = (sum + -0x3ff) - (uint)(value1High < 0x200);\n    if (value1High < 0x200) {\n      condition1 = (temp3 & 0x80000000) != 0;\n      temp3 = temp3 << 1;\n      temp = CONCAT44(value1High * 2 + (uint)(CARRY4(temp2,temp2) || CARRY4(temp2 * 2,(uint)condition1)),\n                       temp2 * 2 + (uint)condition1);\n    }\n    value4 = value2High & 0x80000000 | (int)((ulonglong)temp >> 0x20) << 0xb | (uint)temp >> 0x15;\n    value3 = (uint)temp << 0xb | temp3 >> 0x15;\n    temp2 = temp3 * 0x800;\n    condition2 = 0xfc < temp1;\n    condition3 = SBORROW4(temp1,0xfd);\n    value1High = temp1 - 0xfd;\n    condition1 = value1High == 0;\n    value2High = value1High;\n    if (condition2 && !condition1) {\n      condition2 = 0x6ff < value1High;\n      condition3 = SBORROW4(value1High,0x700);\n      value2High = temp1 - 0x7fd;\n      condition1 = value1High == 0x700;\n    }\n    if (!condition2 || condition1) {\n      condition1 = 0x7fffffff < temp2;\n      if (temp2 == 0x80000000) {\n        condition1 = (temp3 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(value4 + temp1 * 0x100000 + (uint)CARRY4(value3,(uint)condition1),value3 + condition1\n                     );\n    }\n  }\n  if (!condition1 && (int)value2High < 0 == condition3) {\n    return (ulonglong)(value4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  condition2 = SCARRY4(temp1,0x36);\n  condition1 = (int)(temp1 + 0x36) < 0;\n  condition3 = temp1 == 0xffffffca;\n  if (condition3 || condition1 != condition2) {\n    value3 = 0;\n  }\n  if (condition3 || condition1 != condition2) {\n    value4 = value4 & 0x80000000;\n  }\n  if (condition3 || condition1 != condition2) {\n    return CONCAT44(value4,value3);\n  }\n  value2High = -temp1;\n  value1High = value2High - 0x20;\n  if (0x1f < (int)value2High) {\n    temp1 = value3 >> (value1High & 0xff) | value4 << (0x20 - value1High & 0xff);\n    value2High = (value4 >> (value1High & 0xff) & ~((value4 & 0x80000000) >> (value1High & 0xff))) -\n            ((int)temp1 >> 0x1f);\n    if ((temp2 | value3 << (0x20 - value1High & 0xff) | temp1 << 1) == 0) {\n      value2High = value2High & ~(temp1 >> 0x1f);\n    }\n    return CONCAT44(value4,value2High) & 0x80000000ffffffff;\n  }\n  sum = value2High - 0x14;\n  if (sum == 0 || sum < 0 != SCARRY4(value1High,0xc)) {\n    temp3 = value3 << (temp1 + 0x20 & 0xff);\n    value1High = value3 >> (value2High & 0xff) | value4 << (temp1 + 0x20 & 0xff);\n    temp1 = value1High + -((int)temp3 >> 0x1f);\n    if ((temp2 | temp3 << 1) == 0) {\n      temp1 = temp1 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44((value4 & 0x80000000) +\n                    ((value4 & 0x7fffffff) >> (value2High & 0xff)) +\n                    (uint)CARRY4(value1High,-((int)temp3 >> 0x1f)),temp1);\n  }\n  value2High = 0xc - sum;\n  temp1 = value3 << (value2High & 0xff);\n  value2High = value3 >> (0x20 - value2High & 0xff) | value4 << (value2High & 0xff);\n  value1High = value2High + -((int)temp1 >> 0x1f);\n  if ((temp2 | temp1 << 1) == 0) {\n    value1High = value1High & ~(temp1 >> 0x1f);\n  }\n  return CONCAT44((value4 & 0x80000000) + (uint)CARRY4(value2High,-((int)temp1 >> 0x1f)),value1High);\n}\n\n",
            "renaming": {
                "FUN_080004c8": "calculate_result_080004c8",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "lVar2": "temp",
                "uVar3": "value1High",
                "uVar4": "value2High",
                "iVar5": "sum",
                "uVar6": "temp1",
                "unaff_r5": "value4High",
                "uVar7": "temp2",
                "uVar8": "temp3",
                "bVar9": "condition1",
                "bVar10": "condition2",
                "bVar11": "condition3",
                "uVar12": "valueConcatenated"
            },
            "calling": [
                "frexp",
                "atan",
                "_dtoa_r",
                "mpu6050_calc_pitch",
                "_svfprintf_r",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [
                "FUN_080006a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006a4": {
            "entrypoint": "0x080006a4",
            "current_name": "extract_bit_range_080006a4",
            "code": "\nulonglong extract_bit_range_080006a4(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint bit1;\n  uint bit2;\n  uint bit3;\n  uint bit4;\n  uint bit5;\n  bool isZero;\n  \n  bit3 = bit5 & value4 >> 0x14;\n  if (bit2 != bit5 && bit3 != bit5) {\n    isZero = (value1 | value2 << 1) == 0;\n    if (!isZero) {\n      isZero = (value3 | value4 << 1) == 0;\n    }\n    if (isZero) {\n      return (ulonglong)((value2 ^ value4) & 0x80000000) << 0x20;\n    }\n    if (bit2 == 0) {\n      bit4 = value2 & 0x80000000;\n      do {\n        bit1 = value1 & 0x80000000;\n        value1 = value1 << 1;\n        value2 = value2 * 2 + (uint)(bit1 != 0);\n      } while ((value2 & 0x100000) == 0);\n      value2 = value2 | bit4;\n      if (bit3 != 0) {\n        return CONCAT44(value2,value1);\n      }\n    }\n    do {\n      bit3 = value3 & 0x80000000;\n      value3 = value3 << 1;\n      value4 = value4 * 2 + (uint)(bit3 != 0);\n    } while ((value4 & 0x100000) == 0);\n    return CONCAT44(value2,value1);\n  }\n  isZero = (value1 | value2 << 1) == 0;\n  if (isZero) {\n    value2 = value4;\n    value1 = value3;\n  }\n  if (!isZero) {\n    isZero = (value3 | value4 << 1) == 0;\n  }\n  bit4 = value2;\n  if (((!isZero) && ((bit2 != bit5 || ((value1 | value2 << 0xc) == 0)))) &&\n     ((bit3 != bit5 || (value1 = value3, bit4 = value4, (value3 | value4 << 0xc) == 0)))) {\n    return (ulonglong)((value2 ^ value4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(bit4,value1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006a4": "extract_bit_range_080006a4",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "bit1",
                "unaff_r4": "bit2",
                "uVar2": "bit3",
                "uVar3": "bit4",
                "in_r12": "bit5",
                "bVar4": "isZero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800071c": {
            "entrypoint": "0x0800071c",
            "current_name": "calculate_floating_point_0800071c",
            "code": "\nulonglong calculateFloatingPoint_0800071c(undefined4 value1,uint value2,uint value3,uint value4)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  int temp8;\n  uint temp9;\n  uint temp10;\n  uint temp11;\n  uint temp12;\n  uint temp13;\n  uint temp14;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  undefined8 reversedBits;\n  \n  reversedBits = CONCAT44(value2,value1);\n  temp14 = 0x7ff;\n  temp7 = value2 >> 0x14 & 0x7ff;\n  flag1 = temp7 == 0;\n  if (!flag1) {\n    temp10 = value4 >> 0x14 & 0x7ff;\n    flag1 = temp10 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp7 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp10 == 0x7ff;\n  }\n  if (flag1) {\n    reversedBits = reverse_bits_0800088a();\n  }\n  temp9 = (uint)((ulonglong)reversedBits >> 0x20);\n  temp12 = (uint)reversedBits;\n  temp8 = temp7 - temp10;\n  if ((value3 | value4 << 0xc) == 0) {\n    temp7 = (temp9 ^ value4) & 0x80000000 | temp9 & 0xfffff;\n    flag3 = SCARRY4(temp8,temp14 >> 1);\n    temp9 = temp8 + (temp14 >> 1);\n    flag1 = (int)temp9 < 0;\n    flag2 = temp9 == 0;\n    if (!flag2 && flag1 == flag3) {\n      flag3 = SBORROW4(temp14,temp9);\n      flag1 = (int)(temp14 - temp9) < 0;\n      flag2 = temp14 == temp9;\n    }\n    if (!flag2 && flag1 == flag3) {\n      temp7 = temp7 | temp9 * 0x100000;\n    }\n    if (!flag2 && flag1 == flag3) {\n      return CONCAT44(temp7,temp12);\n    }\n    temp7 = temp7 | 0x100000;\n    temp14 = 0;\n    flag2 = SBORROW4(temp9,1);\n    temp9 = temp9 - 1;\n    flag1 = temp9 == 0;\n    temp3 = temp9;\n  }\n  else {\n    temp3 = (value4 << 0xc) >> 4 | 0x10000000 | value3 >> 0x18;\n    temp14 = value3 << 8;\n    temp11 = (temp9 << 0xc) >> 4 | 0x10000000 | temp12 >> 0x18;\n    temp12 = temp12 * 0x100;\n    temp7 = (temp9 ^ value4) & 0x80000000;\n    flag1 = temp3 <= temp11;\n    if (temp11 == temp3) {\n      flag1 = temp14 <= temp12;\n    }\n    temp8 = temp8 + (uint)flag1;\n    temp9 = temp8 + 0x3fd;\n    if (flag1 == false) {\n      temp3 = temp3 >> 1;\n      temp14 = (uint)((value3 >> 0x18 & 1) != 0) << 0x1f | temp14 >> 1;\n    }\n    temp13 = temp12 - temp14;\n    temp11 = (temp11 - temp3) - (uint)(temp12 < temp14);\n    temp4 = temp3 >> 1;\n    temp1 = (uint)((temp3 & 1) != 0) << 0x1f | temp14 >> 1;\n    temp12 = 0x100000;\n    temp3 = 0x80000;\n    while( true ) {\n      flag1 = temp1 <= temp13;\n      if (temp4 < temp11 || temp11 - temp4 < (uint)flag1) {\n        temp13 = temp13 - temp1;\n        temp12 = temp12 | temp3;\n        temp11 = (temp11 - temp4) - (uint)!flag1;\n      }\n      temp5 = temp4 >> 1;\n      temp1 = (uint)((temp4 & 1) != 0) << 0x1f | temp1 >> 1;\n      flag2 = temp1 <= temp13;\n      flag1 = temp11 - temp5 < (uint)flag2;\n      temp14 = temp11;\n      if (temp5 < temp11 || flag1) {\n        temp13 = temp13 - temp1;\n        temp14 = (temp11 - temp5) - (uint)!flag2;\n      }\n      if (temp5 < temp11 || flag1) {\n        temp12 = temp12 | temp3 >> 1;\n      }\n      temp11 = temp4 >> 2;\n      temp2 = (uint)((temp5 & 1) != 0) << 0x1f | temp1 >> 1;\n      flag2 = temp2 <= temp13;\n      flag1 = temp14 - temp11 < (uint)flag2;\n      temp5 = temp14;\n      if (temp11 < temp14 || flag1) {\n        temp13 = temp13 - temp2;\n        temp5 = (temp14 - temp11) - (uint)!flag2;\n      }\n      if (temp11 < temp14 || flag1) {\n        temp12 = temp12 | temp3 >> 2;\n      }\n      temp6 = temp4 >> 3;\n      temp1 = (uint)((temp11 & 1) != 0) << 0x1f | temp2 >> 1;\n      flag2 = temp1 <= temp13;\n      flag1 = temp5 - temp6 < (uint)flag2;\n      temp11 = temp5;\n      if (temp6 < temp5 || flag1) {\n        temp13 = temp13 - temp1;\n        temp11 = (temp5 - temp6) - (uint)!flag2;\n      }\n      if (temp6 < temp5 || flag1) {\n        temp12 = temp12 | temp3 >> 3;\n      }\n      temp14 = temp11 | temp13;\n      if (temp14 == 0) break;\n      temp11 = temp11 << 4 | temp13 >> 0x1c;\n      temp13 = temp13 << 4;\n      temp4 = temp4 & 0xfffffff8 | temp1 >> 0x1d;\n      temp1 = (temp2 >> 1) << 3;\n      temp3 = temp3 >> 4;\n      if (temp3 == 0) {\n        temp6 = temp4;\n        if ((temp7 & 0x100000) != 0) goto LAB_0800083a;\n        temp7 = temp7 | temp12;\n        temp12 = 0;\n        temp3 = 0x80000000;\n      }\n    }\n    if ((temp7 & 0x100000) == 0) {\n      temp7 = temp7 | temp12;\n      temp12 = 0;\n    }\nLAB_0800083a:\n    flag3 = 0xfc < temp9;\n    flag2 = SBORROW4(temp9,0xfd);\n    temp4 = temp8 + 0x300;\n    flag1 = temp4 == 0;\n    temp3 = temp4;\n    if (flag3 && !flag1) {\n      flag3 = 0x6ff < temp4;\n      flag2 = SBORROW4(temp4,0x700);\n      temp3 = temp8 - 0x400;\n      flag1 = temp4 == 0x700;\n    }\n    if (!flag3 || flag1) {\n      flag1 = temp6 <= temp11;\n      if (temp11 == temp6) {\n        flag1 = temp1 <= temp13;\n      }\n      if (temp11 == temp6 && temp13 == temp1) {\n        flag1 = (temp12 & 1) != 0;\n      }\n      return CONCAT44(temp7 + temp9 * 0x100000 + (uint)CARRY4(temp12,(uint)flag1),temp12 + flag1);\n    }\n  }\n  if (!flag1 && (int)temp3 < 0 == flag2) {\n    return (ulonglong)(temp7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag3 = SCARRY4(temp9,0x36);\n  flag1 = (int)(temp9 + 0x36) < 0;\n  flag2 = temp9 == 0xffffffca;\n  if (flag2 || flag1 != flag3) {\n    temp12 = 0;\n  }\n  if (flag2 || flag1 != flag3) {\n    temp7 = temp7 & 0x80000000;\n  }\n  if (flag2 || flag1 != flag3) {\n    return CONCAT44(temp7,temp12);\n  }\n  temp3 = -temp9;\n  temp11 = temp3 - 0x20;\n  if (0x1f < (int)temp3) {\n    temp3 = temp12 >> (temp11 & 0xff) | temp7 << (0x20 - temp11 & 0xff);\n    temp9 = (temp7 >> (temp11 & 0xff) & ~((temp7 & 0x80000000) >> (temp11 & 0xff))) -\n            ((int)temp3 >> 0x1f);\n    if ((temp14 | temp12 << (0x20 - temp11 & 0xff) | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44(temp7,temp9) & 0x80000000ffffffff;\n  }\n  temp8 = temp3 - 0x14;\n  if (temp8 != 0 && temp8 < 0 == SCARRY4(temp11,0xc)) {\n    temp9 = 0xc - temp8;\n    temp3 = temp12 << (temp9 & 0xff);\n    temp12 = temp12 >> (0x20 - temp9 & 0xff) | temp7 << (temp9 & 0xff);\n    temp9 = temp12 + -((int)temp3 >> 0x1f);\n    if ((temp14 | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44((temp7 & 0x80000000) + (uint)CARRY4(temp12,-((int)temp3 >> 0x1f)),temp9);\n  }\n  temp11 = temp12 << (temp9 + 0x20 & 0xff);\n  temp12 = temp12 >> (temp3 & 0xff) | temp7 << (temp9 + 0x20 & 0xff);\n  temp9 = temp12 + -((int)temp11 >> 0x1f);\n  if ((temp14 | temp11 << 1) == 0) {\n    temp9 = temp9 & ~(temp11 >> 0x1f);\n  }\n  return CONCAT44((temp7 & 0x80000000) +\n                  ((temp7 & 0x7fffffff) >> (temp3 & 0xff)) +\n                  (uint)CARRY4(temp12,-((int)temp11 >> 0x1f)),temp9);\n}\n\n",
            "renaming": {
                "FUN_0800071c": "calculate_floating_point_0800071c",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "temp7",
                "iVar8": "temp8",
                "uVar9": "temp9",
                "unaff_r5": "temp10",
                "uVar10": "temp11",
                "uVar11": "temp12",
                "uVar12": "temp13",
                "uVar13": "temp14",
                "bVar14": "flag1",
                "bVar15": "flag2",
                "bVar16": "flag3",
                "uVar17": "reversedBits"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [
                "FUN_0800088a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800088a": {
            "entrypoint": "0x0800088a",
            "current_name": "reverse_bits_0800088a",
            "code": "\nulonglong reverseBits_0800088a(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bit1;\n  uint bit2;\n  uint bit3;\n  uint bit4;\n  uint bit5;\n  bool isZero;\n  \n  bit3 = bit5 & input4 >> 0x14;\n  bit4 = input2;\n  if (bit2 != bit5 || bit3 != bit5) {\n    if (bit2 == bit5) {\n      if (((input1 | input2 << 0xc) == 0) && (input1 = input3, bit4 = input4, bit3 != bit5)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bit3 == bit5) {\n      input1 = input3;\n      bit4 = input4;\n      if ((input3 | input4 << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      isZero = (input1 | input2 << 1) == 0;\n      if (!isZero) {\n        isZero = (input3 | input4 << 1) == 0;\n      }\n      if (!isZero) {\n        if (bit2 == 0) {\n          bit4 = input2 & 0x80000000;\n          do {\n            bit1 = input1 & 0x80000000;\n            input1 = input1 << 1;\n            input2 = input2 * 2 + (uint)(bit1 != 0);\n          } while ((input2 & 0x100000) == 0);\n          input2 = input2 | bit4;\n          if (bit3 != 0) {\n            return CONCAT44(input2,input1);\n          }\n        }\n        do {\n          bit4 = input3 & 0x80000000;\n          input3 = input3 << 1;\n          input4 = input4 * 2 + (uint)(bit4 != 0);\n        } while ((input4 & 0x100000) == 0);\n        return CONCAT44(input2,input1);\n      }\n      if ((input1 | input2 << 1) != 0) goto LAB_080006fc;\n      if ((input3 | input4 << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(bit4,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800088a": "reverse_bits_0800088a",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bit1",
                "unaff_r4": "bit2",
                "uVar2": "bit3",
                "uVar3": "bit4",
                "in_r12": "bit5",
                "bVar4": "isZero"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_equality_080008fc",
            "code": "\nuint checkEquality_080008fc(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool isEqual1;\n  bool isEqual2;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isEqual1 = (value1 | value2 << 1) == 0;\n  if (isEqual1) {\n    isEqual1 = (value3 | value4 << 1) == 0;\n  }\n  if (!isEqual1) {\n    isEqual1 = value2 == value4;\n  }\n  if (isEqual1) {\n    isEqual1 = value1 == value3;\n  }\n  if (!isEqual1) {\n    result = value2 ^ value4;\n    isEqual1 = result == 0;\n    if (-1 < (int)result) {\n      isEqual1 = value2 == value4;\n    }\n    isEqual2 = -1 < (int)result && value4 <= value2;\n    if (isEqual1) {\n      isEqual2 = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isEqual2) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_equality_080008fc",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "isEqual1",
                "bVar3": "isEqual2"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000978": {
            "entrypoint": "0x08000978",
            "current_name": "compare_floats_08000978",
            "code": "\nvoid compareFloats_08000978(undefined4 result,undefined4 comparison,undefined4 float1,undefined4 float2)\n\n{\n  __aeabi_cdcmpeq(float1,float2,result,comparison);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000978": "compare_floats_08000978",
                "param_1": "result",
                "param_2": "comparison",
                "param_3": "float1",
                "param_4": "float2"
            },
            "calling": [
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000988": {
            "entrypoint": "0x08000988",
            "current_name": "convert_float_to_double_08000988",
            "code": "\nundefined4 convert_float_to_double_08000988(undefined4 input_float)\n\n{\n  convert_float_to_double_08000988_helper();\n  return input_float;\n}\n\n",
            "renaming": {
                "FUN_08000988": "convert_float_to_double_08000988",
                "param_1": "input_float",
                "__nedf2": "convert_float_to_double_helper"
            },
            "calling": [
                "__aeabi_dcmple",
                "__aeabi_dcmpeq",
                "__aeabi_dcmplt",
                "__aeabi_cdrcmple"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "check_neq_zero_08000998",
            "code": "\nbool check_neq_zero_08000998(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdcmpeq();\n  return input_character != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000998": "check_neq_zero_08000998",
                "in_ZR": "input_character"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009ac": {
            "entrypoint": "0x080009ac",
            "current_name": "check_if_null_byte_080009ac",
            "code": "\nbool check_if_null_byte_080009ac(void)\n\n{\n  char input_char;\n  \n  __aeabi_cdcmpeq();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009ac": "check_if_null_byte_080009ac",
                "in_CY": "input_char"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c0": {
            "entrypoint": "0x080009c0",
            "current_name": "check_condition_080009c0",
            "code": "\nbool check_condition_080009c0(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_set;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)is_carry_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009c0": "check_condition_080009c0",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_set"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009d4": {
            "entrypoint": "0x080009d4",
            "current_name": "is_zr_or_cy_zero_080009d4",
            "code": "\nbool is_zr_or_cy_zero_080009d4(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_zero;\n  \n  __aeabi_cdrcmple();\n  return !(bool)is_carry_zero || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009d4": "is_zr_or_cy_zero_080009d4",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_zero"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009e8": {
            "entrypoint": "0x080009e8",
            "current_name": "check_if_empty_080009e8",
            "code": "\nbool checkIfEmpty_080009e8(void)\n\n{\n  char inputChar;\n  \n  __aeabi_cdrcmple();\n  return inputChar == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009e8": "check_if_empty_080009e8",
                "in_CY": "inputChar"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009fc": {
            "entrypoint": "0x080009fc",
            "current_name": "convert_to_float_080009fc",
            "code": "\nuint convertToFloat_080009fc(uint input,uint mask)\n\n{\n  uint result;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  bool flag1;\n  bool flag2;\n  \n  temp1 = mask * 2;\n  flag2 = temp1 < 0x70000000;\n  temp2 = temp1 + 0x90000000;\n  result = temp2;\n  if (!flag2) {\n    temp3 = temp1 + 0x8fe00000;\n    result = temp3;\n  }\n  flag1 = result == 0;\n  if (!flag2 && temp2 >= 0x200000) {\n    flag1 = temp3 == 0x1fc00000;\n  }\n  if (((flag2 || temp2 < 0x200000) || 0x1fc00000 < temp3) || flag1) {\n    if ((mask & 0x40000000) != 0) {\n      if (((int)temp1 >> 0x15 == -1) && ((input | mask << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return mask & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(temp1 + 0x92e00000) < 0 != SCARRY4(temp2,0x2e00000)) {\n      return mask & 0x80000000;\n    }\n    temp1 = 0x18 - (temp1 + 0x92e00000 >> 0x15);\n    result = input >> (temp1 & 0xff);\n    if (input << (0x20 - temp1 & 0xff) != 0) {\n      result = result | 1;\n    }\n    temp2 = mask & 0x1fffff | 0x100000;\n    input = result | temp2 << (0x20 - temp1 & 0xff);\n    temp2 = (temp2 >> (temp1 & 0xff)) << 1;\n  }\n  result = (mask & 0x80000000 | input >> 0x1d) + temp2 * 4 + (uint)(0x7fffffff < input * 8);\n  if (input * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080009fc": "convert_to_float_080009fc",
                "param_1": "input",
                "param_2": "mask",
                "uVar1": "result",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "in_r12": "temp3",
                "bVar4": "flag1",
                "bVar5": "flag2"
            },
            "calling": [
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa4": {
            "entrypoint": "0x08000aa4",
            "current_name": "calculate_significant_bit_08000aa4",
            "code": "\nuint calculate_significant_bit_08000aa4(uint input_value,uint mask_value,undefined4 param_3,uint comparison_value)\n\n{\n  int shifted_input_value;\n  int shifted_mask_value;\n  uint changed_mask_value;\n  uint temporary_value;\n  uint shifted_input_value2;\n  uint updated_input_value;\n  uint difference;\n  bool is_equal;\n  \n  changed_mask_value = mask_value ^ 0x80000000;\n  shifted_input_value2 = input_value << 1;\n  is_equal = shifted_input_value2 == 0;\n  if (!is_equal) {\n    comparison_value = mask_value << 1;\n    is_equal = comparison_value == 0;\n  }\n  if (!is_equal) {\n    is_equal = shifted_input_value2 == comparison_value;\n  }\n  shifted_input_value = (int)shifted_input_value2 >> 0x18;\n  if (!is_equal) {\n    is_equal = shifted_input_value == -1;\n  }\n  if (!is_equal) {\n    is_equal = (int)comparison_value >> 0x18 == -1;\n  }\n  if (is_equal) {\n    shifted_mask_value = (int)(mask_value << 1) >> 0x18;\n    if (shifted_input_value == -1 || shifted_mask_value == -1) {\n      shifted_input_value2 = changed_mask_value;\n      if (shifted_input_value == -1) {\n        shifted_input_value2 = input_value;\n      }\n      if (shifted_input_value != -1 || shifted_mask_value != -1) {\n        changed_mask_value = shifted_input_value2;\n      }\n      is_equal = (shifted_input_value2 & 0x7fffff) == 0;\n      if (is_equal) {\n        is_equal = (changed_mask_value & 0x7fffff) == 0;\n      }\n      if (is_equal) {\n        is_equal = shifted_input_value2 == changed_mask_value;\n      }\n      if (!is_equal) {\n        shifted_input_value2 = shifted_input_value2 | 0x400000;\n      }\n      return shifted_input_value2;\n    }\n    if (((input_value ^ changed_mask_value) & 0x7fffffff) != 0) {\n      if (shifted_input_value2 == 0) {\n        input_value = changed_mask_value;\n      }\n      return input_value;\n    }\n    if (input_value != changed_mask_value) {\n      return 0;\n    }\n    if ((shifted_input_value2 & 0xff000000) == 0) {\n      changed_mask_value = input_value << 1;\n      if ((input_value & 0x80000000) != 0) {\n        changed_mask_value = changed_mask_value | 0x80000000;\n      }\n      return changed_mask_value;\n    }\n    if (shifted_input_value2 < 0xfe000000) {\n      return input_value + 0x800000;\n    }\n    input_value = input_value & 0x80000000;\nLAB_08000bde:\n    return input_value | 0x7f800000;\n  }\n  shifted_input_value2 = shifted_input_value2 >> 0x18;\n  comparison_value = comparison_value >> 0x18;\n  difference = comparison_value - shifted_input_value2;\n  is_equal = difference != 0;\n  updated_input_value = shifted_input_value2;\n  if (is_equal && shifted_input_value2 <= comparison_value) {\n    updated_input_value = shifted_input_value2 + difference;\n  }\n  if (is_equal && shifted_input_value2 <= comparison_value) {\n    changed_mask_value = changed_mask_value ^ input_value;\n  }\n  if (is_equal && shifted_input_value2 <= comparison_value) {\n    input_value = input_value ^ changed_mask_value;\n  }\n  if (is_equal && shifted_input_value2 <= comparison_value) {\n    changed_mask_value = changed_mask_value ^ input_value;\n  }\n  if (comparison_value < shifted_input_value2) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input_value;\n  }\n  shifted_input_value2 = input_value & 0xffffff | 0x800000;\n  if ((input_value & 0x80000000) != 0) {\n    shifted_input_value2 = -shifted_input_value2;\n  }\n  temporary_value = changed_mask_value & 0xffffff | 0x800000;\n  if ((changed_mask_value & 0x80000000) != 0) {\n    temporary_value = -temporary_value;\n  }\n  if (updated_input_value == difference) {\n    temporary_value = temporary_value ^ 0x800000;\n    if (updated_input_value == 0) {\n      shifted_input_value2 = shifted_input_value2 ^ 0x800000;\n      updated_input_value = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  shifted_input_value2 = shifted_input_value2 + ((int)temporary_value >> (difference & 0xff));\n  temporary_value = temporary_value << (0x20 - difference & 0xff);\n  input_value = shifted_input_value2 & 0x80000000;\n  if ((int)shifted_input_value2 < 0) {\n    is_equal = temporary_value != 0;\n    temporary_value = -temporary_value;\n    shifted_input_value2 = -shifted_input_value2 - (uint)is_equal;\n  }\n  if (shifted_input_value2 < 0x800000) {\n    changed_mask_value = temporary_value & 0x80000000;\n    temporary_value = temporary_value << 1;\n    shifted_input_value2 = shifted_input_value2 * 2 + (uint)(changed_mask_value != 0);\n    changed_mask_value = updated_input_value - 2;\n    if ((shifted_input_value2 & 0x800000) == 0) {\n      difference = LZCOUNT(shifted_input_value2) - 8;\n      shifted_input_value2 = shifted_input_value2 << (difference & 0xff);\n      if ((int)changed_mask_value < (int)difference) {\n        shifted_input_value2 = shifted_input_value2 >> (-(changed_mask_value - difference) & 0xff);\n      }\n      else {\n        shifted_input_value2 = shifted_input_value2 + (changed_mask_value - difference) * 0x800000;\n      }\n      return shifted_input_value2 | input_value;\n    }\n  }\n  else {\n    changed_mask_value = updated_input_value - 1;\n    if (0xffffff < shifted_input_value2) {\n      changed_mask_value = shifted_input_value2 & 1;\n      shifted_input_value2 = shifted_input_value2 >> 1;\n      temporary_value = (uint)(changed_mask_value != 0) << 0x1f | temporary_value >> 1;\n      changed_mask_value = updated_input_value;\n      if (0xfd < updated_input_value) goto LAB_08000bde;\n    }\n  }\n  shifted_input_value2 = shifted_input_value2 + changed_mask_value * 0x800000 + (uint)(0x7fffffff < temporary_value);\n  if (temporary_value == 0x80000000) {\n    shifted_input_value2 = shifted_input_value2 & 0xfffffffe;\n  }\n  return shifted_input_value2 | input_value;\n}\n\n",
            "renaming": {
                "FUN_08000aa4": "calculate_significant_bit_08000aa4",
                "param_1": "input_value",
                "param_2": "mask_value",
                "param_4": "comparison_value",
                "iVar1": "shifted_input_value",
                "iVar2": "shifted_mask_value",
                "uVar3": "changed_mask_value",
                "uVar4": "temporary_value",
                "uVar5": "shifted_input_value2",
                "uVar6": "updated_input_value",
                "uVar7": "difference",
                "bVar8": "is_equal"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_float_08000aa8",
            "code": "\nuint calculateFloat_08000aa8(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  int shiftedInput1;\n  int shiftedInput2;\n  uint floatPartInput1;\n  uint floatPartInput2;\n  uint shiftCount;\n  uint difference;\n  bool isZero;\n  \n  floatPartInput2 = input1 << 1;\n  isZero = floatPartInput2 == 0;\n  if (!isZero) {\n    input4 = input2 << 1;\n    isZero = input4 == 0;\n  }\n  if (!isZero) {\n    isZero = floatPartInput2 == input4;\n  }\n  shiftedInput1 = (int)floatPartInput2 >> 0x18;\n  if (!isZero) {\n    isZero = shiftedInput1 == -1;\n  }\n  if (!isZero) {\n    isZero = (int)input4 >> 0x18 == -1;\n  }\n  if (isZero) {\n    shiftedInput2 = (int)(input2 << 1) >> 0x18;\n    if (shiftedInput1 == -1 || shiftedInput2 == -1) {\n      floatPartInput2 = input2;\n      if (shiftedInput1 == -1) {\n        floatPartInput2 = input1;\n      }\n      if (shiftedInput1 != -1 || shiftedInput2 != -1) {\n        input2 = floatPartInput2;\n      }\n      isZero = (floatPartInput2 & 0x7fffff) == 0;\n      if (isZero) {\n        isZero = (input2 & 0x7fffff) == 0;\n      }\n      if (isZero) {\n        isZero = floatPartInput2 == input2;\n      }\n      if (!isZero) {\n        floatPartInput2 = floatPartInput2 | 0x400000;\n      }\n      return floatPartInput2;\n    }\n    if (((input1 ^ input2) & 0x7fffffff) != 0) {\n      if (floatPartInput2 == 0) {\n        input1 = input2;\n      }\n      return input1;\n    }\n    if (input1 != input2) {\n      return 0;\n    }\n    if ((floatPartInput2 & 0xff000000) == 0) {\n      floatPartInput2 = input1 << 1;\n      if ((input1 & 0x80000000) != 0) {\n        floatPartInput2 = floatPartInput2 | 0x80000000;\n      }\n      return floatPartInput2;\n    }\n    if (floatPartInput2 < 0xfe000000) {\n      return input1 + 0x800000;\n    }\n    input1 = input1 & 0x80000000;\nLAB_08000bde:\n    return input1 | 0x7f800000;\n  }\n  floatPartInput2 = floatPartInput2 >> 0x18;\n  input4 = input4 >> 0x18;\n  difference = input4 - floatPartInput2;\n  isZero = difference != 0;\n  shiftCount = floatPartInput2;\n  if (isZero && floatPartInput2 <= input4) {\n    shiftCount = floatPartInput2 + difference;\n  }\n  if (isZero && floatPartInput2 <= input4) {\n    input2 = input2 ^ input1;\n  }\n  if (isZero && floatPartInput2 <= input4) {\n    input1 = input1 ^ input2;\n  }\n  if (isZero && floatPartInput2 <= input4) {\n    input2 = input2 ^ input1;\n  }\n  if (input4 < floatPartInput2) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input1;\n  }\n  floatPartInput2 = input1 & 0xffffff | 0x800000;\n  if ((input1 & 0x80000000) != 0) {\n    floatPartInput2 = -floatPartInput2;\n  }\n  floatPartInput1 = input2 & 0xffffff | 0x800000;\n  if ((input2 & 0x80000000) != 0) {\n    floatPartInput1 = -floatPartInput1;\n  }\n  if (shiftCount == difference) {\n    floatPartInput1 = floatPartInput1 ^ 0x800000;\n    if (shiftCount == 0) {\n      floatPartInput2 = floatPartInput2 ^ 0x800000;\n      shiftCount = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  floatPartInput2 = floatPartInput2 + ((int)floatPartInput1 >> (difference & 0xff));\n  floatPartInput1 = floatPartInput1 << (0x20 - difference & 0xff);\n  input1 = floatPartInput2 & 0x80000000;\n  if ((int)floatPartInput2 < 0) {\n    isZero = floatPartInput1 != 0;\n    floatPartInput1 = -floatPartInput1;\n    floatPartInput2 = -floatPartInput2 - (uint)isZero;\n  }\n  if (floatPartInput2 < 0x800000) {\n    difference = floatPartInput1 & 0x80000000;\n    floatPartInput1 = floatPartInput1 << 1;\n    floatPartInput2 = floatPartInput2 * 2 + (uint)(difference != 0);\n    difference = shiftCount - 2;\n    if ((floatPartInput2 & 0x800000) == 0) {\n      shiftCount = leadingZerosCount(floatPartInput2) - 8;\n      floatPartInput2 = floatPartInput2 << (shiftCount & 0xff);\n      if ((int)difference < (int)shiftCount) {\n        floatPartInput2 = floatPartInput2 >> (-(difference - shiftCount) & 0xff);\n      }\n      else {\n        floatPartInput2 = floatPartInput2 + (difference - shiftCount) * 0x800000;\n      }\n      return floatPartInput2 | input1;\n    }\n  }\n  else {\n    difference = shiftCount - 1;\n    if (0xffffff < floatPartInput2) {\n      difference = floatPartInput2 & 1;\n      floatPartInput2 = floatPartInput2 >> 1;\n      floatPartInput1 = (uint)(difference != 0) << 0x1f | floatPartInput1 >> 1;\n      difference = shiftCount;\n      if (0xfd < shiftCount) goto LAB_08000bde;\n    }\n  }\n  floatPartInput2 = floatPartInput2 + difference * 0x800000 + (uint)(0x7fffffff < floatPartInput1);\n  if (floatPartInput1 == 0x80000000) {\n    floatPartInput2 = floatPartInput2 & 0xfffffffe;\n  }\n  return floatPartInput2 | input1;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_float_08000aa8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftedInput1",
                "iVar2": "shiftedInput2",
                "uVar3": "floatPartInput1",
                "uVar4": "floatPartInput2",
                "uVar5": "shiftCount",
                "uVar6": "difference",
                "bVar7": "isZero",
                "LZCOUNT": "leadingZerosCount"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calibrate"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c08": {
            "entrypoint": "0x08000c08",
            "current_name": "calculate_unsigned_value_08000c08",
            "code": "\nuint calculateUnsignedValue_08000c08(uint inputValue)\n\n{\n  uint leadingZeros;\n  uint shiftValue;\n  int constantValue;\n  uint maskedValue;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeros = LZCOUNT(inputValue);\n  shiftValue = leadingZeros - 8;\n  constantValue = shiftValue * -0x800000 + 0x4a800000;\n  if (7 < leadingZeros) {\n    maskedValue = 0 << (shiftValue & 0xff);\n    leadingZeros = constantValue + (inputValue << (shiftValue & 0xff)) +\n            (0U >> (0x20 - shiftValue & 0xff)) + (uint)(0x7fffffff < maskedValue);\n    if (maskedValue == 0x80000000) {\n      leadingZeros = leadingZeros & 0xfffffffe;\n    }\n    return leadingZeros;\n  }\n  shiftValue = inputValue << leadingZeros + 0x18;\n  leadingZeros = constantValue + ((inputValue >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftValue >> 0x1f));\n  if ((shiftValue & 0x7fffffff) == 0) {\n    leadingZeros = leadingZeros & ~(shiftValue >> 0x1f);\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_08000c08": "calculate_unsigned_value_08000c08",
                "param_1": "inputValue",
                "uVar1": "leadingZeros",
                "uVar2": "shiftValue",
                "iVar3": "constantValue",
                "uVar4": "maskedValue"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c10": {
            "entrypoint": "0x08000c10",
            "current_name": "decode_and_shift_08000c10",
            "code": "\nuint decode_and_shift_08000c10(uint input_number)\n\n{\n  uint leading_zero_count;\n  uint shift_amount;\n  uint sign_bit;\n  int result;\n  \n  sign_bit = input_number & 0x80000000;\n  if ((int)sign_bit < 0) {\n    input_number = -input_number;\n  }\n  if (input_number == 0) {\n    return 0;\n  }\n  leading_zero_count = count_leading_zeros(input_number);\n  shift_amount = leading_zero_count - 8;\n  result = ((sign_bit | 0x4b000000) - 0x800000) + shift_amount * -0x800000;\n  if (7 < leading_zero_count) {\n    leading_zero_count = 0 << (shift_amount & 0xff);\n    sign_bit = result + (input_number << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < leading_zero_count);\n    if (leading_zero_count == 0x80000000) {\n      sign_bit = sign_bit & 0xfffffffe;\n    }\n    return sign_bit;\n  }\n  shift_amount = input_number << leading_zero_count + 0x18;\n  sign_bit = result + ((input_number >> (0x20 - (leading_zero_count + 0x18) & 0xff)) - ((int)shift_amount >> 0x1f));\n  if ((shift_amount & 0x7fffffff) == 0) {\n    sign_bit = sign_bit & ~(shift_amount >> 0x1f);\n  }\n  return sign_bit;\n}\n\n",
            "renaming": {
                "FUN_08000c10": "decode_and_shift_08000c10",
                "param_1": "input_number",
                "uVar1": "leading_zero_count",
                "uVar2": "shift_amount",
                "uVar3": "sign_bit",
                "iVar4": "result",
                "LZCOUNT": "count_leading_zeros"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_update",
                "mpu6050_calibrate"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cb8": {
            "entrypoint": "0x08000cb8",
            "current_name": "perform_floating_point_operation_08000cb8",
            "code": "\nuint performFloatingPointOperation_08000cb8(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  longlong tmp1;\n  uint result;\n  uint tmp2;\n  int tmp3;\n  int tmp4;\n  uint tmp5;\n  int tmp6;\n  uint tmp7;\n  bool tmpFlag1;\n  bool tmpFlag2;\n  \n  tmp2 = input1 >> 0x17 & 0xff;\n  tmpFlag1 = tmp2 == 0;\n  if (!tmpFlag1) {\n    input4 = input2 >> 0x17 & 0xff;\n    tmpFlag1 = input4 == 0;\n  }\n  if (!tmpFlag1) {\n    tmpFlag1 = tmp2 == 0xff;\n  }\n  if (!tmpFlag1) {\n    tmpFlag1 = input4 == 0xff;\n  }\n  if (tmpFlag1) {\n    input4 = input2 >> 0x17 & 0xff;\n    if (tmp2 == 0xff || input4 == 0xff) {\n      tmpFlag1 = input1 == 0 || input1 == 0x80000000;\n      result = input2;\n      if (input1 != 0 && input1 != 0x80000000) {\n        tmpFlag1 = input2 == 0;\n        result = input1;\n      }\n      if (!tmpFlag1) {\n        tmpFlag1 = input2 == 0x80000000;\n      }\n      tmp7 = result;\n      if (((tmpFlag1) || ((tmp2 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((input4 == 0xff && (tmp7 = input2, (input2 & 0x7fffff) != 0)))) {\n        return tmp7 | 0x7fc00000;\n      }\n      result = result ^ input2;\n      goto LAB_08000e08;\n    }\n    tmpFlag1 = (input1 & 0x7fffffff) == 0;\n    if (!tmpFlag1) {\n      tmpFlag1 = (input2 & 0x7fffffff) == 0;\n    }\n    if (tmpFlag1) {\n      return (input1 ^ input2) & 0x80000000;\n    }\n    tmpFlag1 = tmp2 == 0;\n    result = input1 & 0x80000000;\n    while( true ) {\n      if (tmpFlag1) {\n        input1 = input1 << 1;\n        tmpFlag1 = (input1 & 0x800000) == 0;\n      }\n      if (!tmpFlag1) break;\n      tmp2 = tmp2 - 1;\n    }\n    input1 = input1 | result;\n    tmpFlag1 = input4 == 0;\n    result = input2 & 0x80000000;\n    while( true ) {\n      if (tmpFlag1) {\n        input2 = input2 << 1;\n        tmpFlag1 = (input2 & 0x800000) == 0;\n      }\n      if (!tmpFlag1) break;\n      input4 = input4 - 1;\n    }\n    input2 = input2 | result;\n  }\n  tmp3 = tmp2 + input4;\n  tmp7 = input1 ^ input2;\n  tmp2 = input1 << 9;\n  tmpFlag1 = tmp2 == 0;\n  if (!tmpFlag1) {\n    input2 = input2 << 9;\n    tmpFlag1 = input2 == 0;\n  }\n  if (tmpFlag1) {\n    if (tmp2 == 0) {\n      input2 = input2 << 9;\n    }\n    result = tmp7 & 0x80000000 | input1 & 0x7fffff | input2 >> 9;\n    tmpFlag2 = SBORROW4(tmp3,0x7f);\n    tmp4 = tmp3 + -0x7f;\n    tmpFlag1 = tmp4 == 0;\n    tmp6 = tmp4;\n    if (!tmpFlag1 && 0x7e < tmp3) {\n      tmpFlag2 = SBORROW4(0xff,tmp4);\n      tmp6 = 0xff - tmp4;\n      tmpFlag1 = tmp4 == 0xff;\n    }\n    if (!tmpFlag1 && tmp6 < 0 == tmpFlag2) {\n      result = result | tmp4 * 0x800000;\n    }\n    if (!tmpFlag1 && tmp6 < 0 == tmpFlag2) {\n      return result;\n    }\n    result = result | 0x800000;\n    tmp5 = 0;\n    tmpFlag2 = SBORROW4(tmp4,1);\n    tmp7 = tmp3 - 0x80;\n    tmpFlag1 = tmp7 == 0;\n    tmp2 = tmp7;\n  }\n  else {\n    tmp1 = (ulonglong)(tmp2 >> 5 | 0x8000000) * (ulonglong)(input2 >> 5 | 0x8000000);\n    tmp5 = (uint)tmp1;\n    result = (uint)((ulonglong)tmp1 >> 0x20);\n    tmpFlag1 = result < 0x800000;\n    if (tmpFlag1) {\n      result = result << 1;\n    }\n    if (tmpFlag1) {\n      result = result | tmp5 >> 0x1f;\n      tmp5 = tmp5 << 1;\n    }\n    result = tmp7 & 0x80000000 | result;\n    tmp7 = (tmp3 + -0x7f) - (uint)tmpFlag1;\n    tmpFlag2 = SBORROW4(tmp7,0xfd);\n    tmpFlag1 = tmp7 == 0xfd;\n    tmp2 = tmp7 - 0xfd;\n    if (tmp7 < 0xfe) {\n      result = result + tmp7 * 0x800000 + (uint)(0x7fffffff < tmp5);\n      if (tmp5 == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (tmpFlag1 || (int)tmp2 < 0 != tmpFlag2) {\n    tmpFlag1 = (int)(tmp7 + 0x19) < 0;\n    if (tmp7 == 0xffffffe7 || tmpFlag1 != SCARRY4(tmp7,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (tmp7 != 0xffffffe7 && tmpFlag1 == SCARRY4(tmp7,0x19)) {\n      tmp2 = (result << 1) >> (-tmp7 & 0xff);\n      tmp7 = result << (tmp7 + 0x20 & 0xff);\n      tmp2 = ((uint)((result & 0x80000000) != 0) << 0x1f | tmp2 >> 1) + (uint)((byte)tmp2 & 1);\n      if ((tmp5 | tmp7 << 1) == 0) {\n        tmp2 = tmp2 & ~(tmp7 >> 0x1f);\n      }\n      return tmp2;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cb8": "perform_floating_point_operation_08000cb8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "lVar1": "tmp1",
                "uVar2": "result",
                "uVar3": "tmp2",
                "iVar4": "tmp3",
                "iVar5": "tmp4",
                "uVar6": "tmp5",
                "iVar7": "tmp6",
                "uVar8": "tmp7",
                "bVar9": "tmpFlag1",
                "bVar10": "tmpFlag2"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e20": {
            "entrypoint": "0x08000e20",
            "current_name": "floating_point_addition_08000e20",
            "code": "\nuint floatingPointAddition_08000e20(uint value1,uint value2,undefined4 undefinedVal,uint flag)\n\n{\n  uint significand1;\n  uint exponent1;\n  int exponentDiff;\n  uint exponent2;\n  int adjustedExponent;\n  uint result;\n  bool condition;\n  bool comparison;\n  bool carry;\n  \n  exponent1 = value1 >> 0x17 & 0xff;\n  condition = exponent1 == 0;\n  if (!condition) {\n    flag = value2 >> 0x17 & 0xff;\n    condition = flag == 0;\n  }\n  if (!condition) {\n    condition = exponent1 == 0xff;\n  }\n  if (!condition) {\n    condition = flag == 0xff;\n  }\n  if (condition) {\n    flag = value2 >> 0x17 & 0xff;\n    result = value1;\n    if (exponent1 == 0xff) {\n      if (((value1 & 0x7fffff) != 0) || (result = value2, flag == 0xff)) {\nLAB_08000e16:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (flag == 0xff) {\n        result = value2;\n        if ((value2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (value1 ^ value2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      condition = (value1 & 0x7fffffff) == 0;\n      if (!condition) {\n        condition = (value2 & 0x7fffffff) == 0;\n      }\n      if (!condition) {\n        condition = exponent1 == 0;\n        result = value1 & 0x80000000;\n        while( true ) {\n          if (condition) {\n            value1 = value1 << 1;\n            condition = (value1 & 0x800000) == 0;\n          }\n          if (!condition) break;\n          exponent1 = exponent1 - 1;\n        }\n        value1 = value1 | result;\n        condition = flag == 0;\n        result = value2 & 0x80000000;\n        while( true ) {\n          if (condition) {\n            value2 = value2 << 1;\n            condition = (value2 & 0x800000) == 0;\n          }\n          if (!condition) break;\n          flag = flag - 1;\n        }\n        value2 = value2 | result;\n        goto LAB_08000e38;\n      }\n      if ((value1 & 0x7fffffff) == 0) {\n        if ((value2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    value1 = value1 ^ value2;\n  }\n  else {\nLAB_08000e38:\n    exponentDiff = exponent1 - flag;\n    if (value2 << 9 == 0) {\n      value1 = (value1 ^ value2) & 0x80000000 | value1 & 0x7fffff;\n      carry = SCARRY4(exponentDiff,0x7f);\n      adjustedExponent = exponentDiff + 0x7f;\n      condition = adjustedExponent < 0;\n      comparison = adjustedExponent == 0;\n      if (!comparison && condition == carry) {\n        carry = SBORROW4(0xff,adjustedExponent);\n        condition = 0xff - adjustedExponent < 0;\n        comparison = adjustedExponent == 0xff;\n      }\n      if (!comparison && condition == carry) {\n        value1 = value1 | adjustedExponent * 0x800000;\n      }\n      if (!comparison && condition == carry) {\n        return value1;\n      }\n      value1 = value1 | 0x800000;\n      exponent1 = 0;\n      comparison = SBORROW4(adjustedExponent,1);\n      exponent2 = exponentDiff + 0x7e;\n      condition = exponent2 == 0;\n      result = exponent2;\n    }\n    else {\n      significand1 = (value2 << 9) >> 4 | 0x10000000;\n      exponent1 = (value1 << 9) >> 4 | 0x10000000;\n      value1 = (value1 ^ value2) & 0x80000000;\n      condition = significand1 <= exponent1;\n      if (!condition) {\n        exponent1 = exponent1 << 1;\n      }\n      exponent2 = exponentDiff + 0x7d + (uint)condition;\n      result = 0x800000;\n      do {\n        if (significand1 <= exponent1) {\n          exponent1 = exponent1 - significand1;\n          value1 = value1 | result;\n        }\n        condition = significand1 >> 1 <= exponent1;\n        if (condition) {\n          exponent1 = exponent1 - (significand1 >> 1);\n        }\n        if (condition) {\n          value1 = value1 | result >> 1;\n        }\n        condition = significand1 >> 2 <= exponent1;\n        if (condition) {\n          exponent1 = exponent1 - (significand1 >> 2);\n        }\n        if (condition) {\n          value1 = value1 | result >> 2;\n        }\n        condition = significand1 >> 3 <= exponent1;\n        if (condition) {\n          exponent1 = exponent1 - (significand1 >> 3);\n        }\n        if (condition) {\n          value1 = value1 | result >> 3;\n        }\n        exponent1 = exponent1 * 0x10;\n        condition = exponent1 == 0;\n        if (!condition) {\n          result = result >> 4;\n          condition = result == 0;\n        }\n      } while (!condition);\n      comparison = SBORROW4(exponent2,0xfd);\n      condition = exponent2 == 0xfd;\n      result = exponent2 - 0xfd;\n      if (exponent2 < 0xfe) {\n        value1 = value1 + exponent2 * 0x800000 + (uint)(significand1 <= exponent1);\n        if (exponent1 - significand1 == 0) {\n          value1 = value1 & 0xfffffffe;\n        }\n        return value1;\n      }\n    }\n    if (condition || (int)result < 0 != comparison) {\n      condition = (int)(exponent2 + 0x19) < 0;\n      if (exponent2 == 0xffffffe7 || condition != SCARRY4(exponent2,0x19)) {\n        value1 = value1 & 0x80000000;\n      }\n      if (exponent2 == 0xffffffe7 || condition != SCARRY4(exponent2,0x19)) {\n        return value1;\n      }\n      result = (value1 << 1) >> (-exponent2 & 0xff);\n      exponent2 = value1 << (exponent2 + 0x20 & 0xff);\n      result = ((uint)((value1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((exponent1 | exponent2 << 1) == 0) {\n        result = result & ~(exponent2 >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return value1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e20": "floating_point_addition_08000e20",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "undefinedVal",
                "param_4": "flag",
                "uVar1": "significand1",
                "uVar2": "exponent1",
                "iVar3": "exponentDiff",
                "uVar4": "exponent2",
                "iVar5": "adjustedExponent",
                "uVar6": "result",
                "bVar7": "condition",
                "bVar8": "comparison",
                "bVar9": "carry"
            },
            "calling": [
                "mpu6050_calibrate",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f68": {
            "entrypoint": "0x08000f68",
            "current_name": "check_overflow_08000f68",
            "code": "\nuint check_overflow_08000f68(uint result,uint result)\n\n{\n  bool is_negative;\n  uint double_input1;\n  uint double_input2;\n  uint combined_inputs;\n  bool is_zero;\n  \n  double_input1 = result * 2;\n  double_input2 = result * 2;\n  if (((int)double_input1 >> 0x18 == -1 || (int)double_input2 >> 0x18 == -1) &&\n     ((((int)double_input1 >> 0x18 == -1 && ((result & 0x7fffff) != 0)) ||\n      (((int)double_input2 >> 0x18 == -1 && ((result & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_inputs = double_input1 | result & 0x7fffffff;\n  is_zero = combined_inputs == 0;\n  if (!is_zero) {\n    combined_inputs = result ^ result;\n    is_zero = combined_inputs == 0;\n  }\n  is_negative = -1 < (int)combined_inputs;\n  if (is_negative) {\n    result = double_input1 + result * -2;\n    is_zero = result == 0;\n  }\n  if ((is_negative && double_input2 <= double_input1) && !is_zero) {\n    result = (int)result >> 0x1f;\n  }\n  if (!is_negative || double_input2 > double_input1) {\n    result = ~((int)result >> 0x1f);\n  }\n  if (!is_zero) {\n    result = result | 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08000f68": "check_overflow_08000f68",
                "param_1": "result",
                "param_2": "result",
                "uVar2": "double_input1",
                "uVar3": "double_input2",
                "uVar4": "combined_inputs",
                "bVar1": "is_negative",
                "bVar5": "is_zero"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fc8": {
            "entrypoint": "0x08000fc8",
            "current_name": "compare_floats_08000fc8",
            "code": "\nvoid compareFloats_08000fc8(undefined4 float1,undefined4 float2)\n\n{\n  __aeabi_cfcmpeq(float2,float1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fc8": "compare_floats_08000fc8",
                "param_1": "float1",
                "param_2": "float2"
            },
            "calling": [
                "__aeabi_fcmpgt"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fd0": {
            "entrypoint": "0x08000fd0",
            "current_name": "concatenate_params_08000fd0",
            "code": "\nundefined8 concatenateParams_08000fd0(undefined4 firstParam,undefined4 secondParam)\n\n{\n  __cmpsf2();\n  return CONCAT44(secondParam,firstParam);\n}\n\n",
            "renaming": {
                "FUN_08000fd0": "concatenate_params_08000fd0",
                "param_1": "firstParam",
                "param_2": "secondParam"
            },
            "calling": [
                "__aeabi_cfrcmple",
                "__aeabi_fcmplt"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ff4": {
            "entrypoint": "0x08000ff4",
            "current_name": "check_if_char_is_null_08000ff4",
            "code": "\nbool check_if_char_is_null_08000ff4(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfcmpeq();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000ff4": "check_if_char_is_null_08000ff4",
                "in_CY": "input_character"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001030": {
            "entrypoint": "0x08001030",
            "current_name": "is_null_character_08001030",
            "code": "\nbool is_null_character_08001030(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfrcmple();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001030": "is_null_character_08001030",
                "in_CY": "input_char"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001044": {
            "entrypoint": "0x08001044",
            "current_name": "reverse_bits_08001044",
            "code": "\nuint reverseBits_08001044(uint input)\n\n{\n  uint shiftAmount;\n  \n  if (((input & 0x80000000) != 0) || (input << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shiftAmount = 0x9e - ((input << 1) >> 0x18);\n  if (-1 < (int)shiftAmount) {\n    return (input << 8 | 0x80000000) >> (shiftAmount & 0xff);\n  }\n  if ((shiftAmount == 0xffffff9f) && ((input & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08001044": "reverse_bits_08001044",
                "param_1": "input",
                "uVar1": "shiftAmount"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001084": {
            "entrypoint": "0x08001084",
            "current_name": "copy_memory_08001084",
            "code": "\nundefined4 * copyMemory_08001084(undefined4 *destination,undefined4 *source,uint length)\n\n{\n  undefined4 *destPtrAligned;\n  undefined4 *destPtrAligned;\n  undefined4 *srcPtr;\n  uint remainingLength;\n  uint loopCounter;\n  bool isLooping;\n  \n  destPtrAligned = destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (length < 8) {\n      loopCounter = length - 4;\n      if (3 < length) {\n        do {\n          destPtrAligned = source;\n          srcPtr = destPtrAligned;\n          isLooping = loopCounter != 0;\n          loopCounter = loopCounter - 1;\n          *(undefined *)srcPtr = *(undefined *)destPtrAligned;\n          destPtrAligned = (undefined4 *)((int)srcPtr + 1);\n          source = (undefined4 *)((int)destPtrAligned + 1);\n        } while (isLooping);\n        *(undefined *)(undefined4 *)((int)srcPtr + 1) =\n             *(undefined *)(undefined4 *)((int)destPtrAligned + 1);\n        *(undefined *)((int)srcPtr + 2) = *(undefined *)((int)destPtrAligned + 2);\n        *(undefined *)((int)srcPtr + 3) = *(undefined *)((int)destPtrAligned + 3);\n        return destination;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      loopCounter = 4 - ((uint)destination & 3);\n      length = length - loopCounter;\n      destPtrAligned = destination;\n      srcPtr = source;\n      if (((uint)destination & 1) != 0) {\n        srcPtr = (undefined4 *)((int)source + 1);\n        destPtrAligned = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *(undefined *)source;\n      }\n      destPtrAligned = destPtrAligned;\n      source = srcPtr;\n      if ((loopCounter & 2) != 0) {\n        source = (undefined4 *)((int)srcPtr + 2);\n        destPtrAligned = (undefined4 *)((int)destPtrAligned + 2);\n        *(undefined2 *)destPtrAligned = *(undefined2 *)srcPtr;\n      }\n    }\n  }\n  while (0x3f < length) {\n    *destPtrAligned = *source;\n    destPtrAligned[1] = source[1];\n    destPtrAligned[2] = source[2];\n    destPtrAligned[3] = source[3];\n    destPtrAligned[4] = source[4];\n    destPtrAligned[5] = source[5];\n    destPtrAligned[6] = source[6];\n    destPtrAligned[7] = source[7];\n    destPtrAligned[8] = source[8];\n    destPtrAligned[9] = source[9];\n    destPtrAligned[10] = source[10];\n    destPtrAligned[0x0b] = source[0xb];\n    destPtrAligned[0x0c] = source[0xc];\n    destPtrAligned[0x0d] = source[0xd];\n    destPtrAligned[0x0e] = source[0xe];\n    destPtrAligned[0x0f] = source[0xf];\n    destPtrAligned = destPtrAligned + 0x10;\n    source = source + 0x10;\n    length = length - 0x40;\n  }\n  remainingLength = length - 0x10;\n  if (0xffffffcf < length - 0x40) {\n    do {\n      *destPtrAligned = *source;\n      destPtrAligned[1] = source[1];\n      destPtrAligned[2] = source[2];\n      destPtrAligned[3] = source[3];\n      destPtrAligned = destPtrAligned + 4;\n      source = source + 4;\n      isLooping = 0xf < remainingLength;\n      remainingLength = remainingLength - 0x10;\n    } while (isLooping);\n  }\n  loopCounter = remainingLength + 0xc;\n  srcPtr = destPtrAligned;\n  destPtrAligned = source;\n  if (0xfffffff3 < remainingLength) {\n    do {\n      source = destPtrAligned + 1;\n      *srcPtr = *destPtrAligned;\n      isLooping = 3 < loopCounter;\n      loopCounter = loopCounter - 4;\n      destPtrAligned = srcPtr + 1;\n      srcPtr = srcPtr + 1;\n      destPtrAligned = source;\n    } while (isLooping);\n  }\nLAB_08001108:\n  if (loopCounter + 4 != 0) {\n    destPtrAligned = destPtrAligned;\n    srcPtr = source;\n    if ((loopCounter & 1) != 0) {\n      srcPtr = (undefined4 *)((int)source + 1);\n      destPtrAligned = (undefined4 *)((int)destPtrAligned + 1);\n      *(undefined *)destPtrAligned = *(undefined *)source;\n    }\n    if ((loopCounter + 4 & 2) != 0) {\n      *(undefined2 *)destPtrAligned = *(undefined2 *)srcPtr;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "length",
                "puVar1": "destPtrAligned",
                "puVar2": "destPtrAligned",
                "puVar3": "srcPtr",
                "uVar4": "remainingLength",
                "uVar5": "loopCounter",
                "bVar6": "isLooping",
                "puVar2[1]": "destPtrAligned[1]",
                "puVar2[2]": "destPtrAligned[2]",
                "puVar2[3]": "destPtrAligned[3]",
                "puVar2[4]": "destPtrAligned[4]",
                "puVar2[5]": "destPtrAligned[5]",
                "puVar2[6]": "destPtrAligned[6]",
                "puVar2[7]": "destPtrAligned[7]",
                "puVar2[8]": "destPtrAligned[8]",
                "puVar2[9]": "destPtrAligned[9]",
                "puVar2[10]": "destPtrAligned[10]",
                "puVar2[0xb]": "destPtrAligned[0x0b]",
                "puVar2[0xc]": "destPtrAligned[0x0c]",
                "puVar2[0xd]": "destPtrAligned[0x0d]",
                "puVar2[0xe]": "destPtrAligned[0x0e]",
                "puVar2[0xf]": "destPtrAligned[0x0f]"
            },
            "calling": [
                "_dtoa_r",
                "__ssprint_r",
                "__multadd"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "check_params_08001170",
            "code": "\nundefined4 check_params_08001170(uint param1,int param2,uint param3,int param4)\n\n{\n  if ((((param2 << 1) >> 0x15 != -1) || ((param1 | param2 << 0xc) == 0)) &&\n     (((param4 << 1) >> 0x15 != -1 || ((param3 | param4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001170": "check_params_08001170",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800119c": {
            "entrypoint": "0x0800119c",
            "current_name": "calculate_result_0800119c",
            "code": "\nuint calculate_result_0800119c(uint input_value1,uint filtered_input2)\n\n{\n  uint result;\n  int shifted_offset;\n  uint condition_limit;\n  \n  shifted_offset = filtered_input2 * 2 + 0x200000;\n  if (filtered_input2 * 2 < 0xffe00000) {\n    if (-1 < shifted_offset) {\n      return 0;\n    }\n    result = shifted_offset >> 0x15;\n    condition_limit = -result - 0x3e1;\n    if (result < 0xfffffc20 && condition_limit != 0) {\n      result = (filtered_input2 << 0xb | 0x80000000 | input_value1 >> 0x15) >> (condition_limit & 0xff);\n      if ((filtered_input2 & 0x80000000) != 0) {\n        result = -result;\n      }\n      return result;\n    }\n  }\n  else if ((input_value1 | filtered_input2 << 0xc) != 0) {\n    return 0;\n  }\n  filtered_input2 = filtered_input2 & 0x80000000;\n  if (filtered_input2 == 0) {\n    filtered_input2 = 0x7fffffff;\n  }\n  return filtered_input2;\n}\n\n",
            "renaming": {
                "FUN_0800119c": "calculate_result_0800119c",
                "param_1": "input_value1",
                "param_2": "filtered_input2",
                "uVar1": "result",
                "iVar2": "shifted_offset",
                "uVar3": "condition_limit"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011ec": {
            "entrypoint": "0x080011ec",
            "current_name": "calculate_division_or_set_negative_values_080011ec",
            "code": "\nundefined8 calculateDivisionOrSetNegativeValues_080011ec(int numerator,int denominator,int variable1,int variable2)\n\n{\n  undefined8 result;\n  \n  if ((variable2 == 0) && (variable1 == 0)) {\n    if (denominator != 0 || numerator != 0) {\n      denominator = -1;\n      numerator = -1;\n    }\n    return CONCAT44(denominator,numerator);\n  }\n  result = __udivmoddi4();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080011ec": "calculate_division_or_set_negative_values_080011ec",
                "param_1": "numerator",
                "param_2": "denominator",
                "param_3": "variable1",
                "param_4": "variable2",
                "uVar1": "result"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800121c": {
            "entrypoint": "0x0800121c",
            "current_name": "calculate_quotient_remainder_0800121c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 calculate_quotient_remainder_0800121c(uint dividend,uint dividend_upper,uint divisor,uint divisor_upper,uint *result)\n\n{\n  code *func_table;\n  ulonglong mul_result;\n  uint quotient;\n  uint temp_quotient;\n  uint quotient_upper;\n  int shift_value;\n  uint temp;\n  uint temp2;\n  uint remainder;\n  uint *puVar9;\n  uint quotient1;\n  uint temp_quotient1;\n  uint quotient_upper1;\n  bool carry_flag;\n  undefined8 result_value;\n  \n  if (divisor_upper == 0) {\n    if (dividend_upper < divisor) {\n      shift_value = LZCOUNT(divisor);\n      temp2 = divisor;\n      if (shift_value != 0) {\n        temp2 = divisor << shift_value;\n        dividend_upper = dividend >> (0x20U - shift_value & 0xff) | dividend_upper << shift_value;\n        dividend = dividend << shift_value;\n      }\n      temp_quotient1 = temp2 >> 0x10;\n      remainder = dividend_upper / temp_quotient1;\n      quotient1 = remainder * (temp2 & 0xffff);\n      temp = dividend >> 0x10 | (dividend_upper - temp_quotient1 * remainder) * 0x10000;\n      temp_quotient = remainder;\n      if (temp <= quotient1 && quotient1 - temp != 0) {\n        carry_flag = CARRY4(temp2,temp);\n        temp = temp2 + temp;\n        temp_quotient = remainder - 1;\n        if ((carry_flag == false) && (temp <= quotient1 && quotient1 - temp != 0)) {\n          temp_quotient = remainder - 2;\n          temp = temp + temp2;\n        }\n      }\n      quotient = (temp - quotient1) / temp_quotient1;\n      quotient_upper = quotient * (temp2 & 0xffff);\n      remainder = dividend & 0xffff | ((temp - quotient1) - temp_quotient1 * quotient) * 0x10000;\n      temp = quotient;\n      if (remainder <= quotient_upper && quotient_upper - remainder != 0) {\n        carry_flag = CARRY4(temp2,remainder);\n        remainder = temp2 + remainder;\n        temp = quotient - 1;\n        if ((carry_flag == false) && (remainder <= quotient_upper && quotient_upper - remainder != 0)) {\n          temp = quotient - 2;\n          remainder = remainder + temp2;\n        }\n      }\n      temp = temp | temp_quotient << 0x10;\n      puVar9 = (uint *)0x0;\n      remainder = remainder - quotient_upper;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        func_table = (code *)software_udf(0xff,0x8001302);\n        result_value = (*func_table)();\n        return result_value;\n      }\n      shift_value = LZCOUNT(divisor);\n      if (shift_value == 0) {\n        puVar9 = (uint *)0x1;\n        dividend_upper = dividend_upper - divisor;\n        temp_quotient1 = divisor >> 0x10;\n        quotient = divisor & 0xffff;\n        temp2 = divisor;\n      }\n      else {\n        temp2 = divisor << shift_value;\n        temp = dividend_upper >> (0x20U - shift_value & 0xff);\n        temp_quotient1 = temp2 >> 0x10;\n        quotient1 = temp / temp_quotient1;\n        quotient = temp2 & 0xffff;\n        quotient_upper = quotient1 * quotient;\n        remainder = dividend >> (0x20U - shift_value & 0xff) | dividend_upper << shift_value;\n        temp_quotient = remainder >> 0x10 | (temp - temp_quotient1 * quotient1) * 0x10000;\n        dividend = dividend << shift_value;\n        temp = quotient1;\n        if (temp_quotient <= quotient_upper && quotient_upper - temp_quotient != 0) {\n          carry_flag = CARRY4(temp2,temp_quotient);\n          temp_quotient = temp2 + temp_quotient;\n          temp = quotient1 - 1;\n          if ((carry_flag == false) && (temp_quotient <= quotient_upper && quotient_upper - temp_quotient != 0)) {\n            temp = quotient1 - 2;\n            temp_quotient = temp_quotient + temp2;\n          }\n        }\n        quotient1 = (temp_quotient - quotient_upper) / temp_quotient1;\n        quotient_upper1 = quotient1 * quotient;\n        dividend_upper = remainder & 0xffff | ((temp_quotient - quotient_upper) - temp_quotient1 * quotient1) * 0x10000;\n        temp_quotient = quotient1;\n        if (dividend_upper <= quotient_upper1 && quotient_upper1 - dividend_upper != 0) {\n          carry_flag = CARRY4(temp2,dividend_upper);\n          dividend_upper = temp2 + dividend_upper;\n          temp_quotient = quotient1 - 1;\n          if ((carry_flag == false) && (dividend_upper <= quotient_upper1 && quotient_upper1 - dividend_upper != 0)) {\n            temp_quotient = quotient1 - 2;\n            dividend_upper = dividend_upper + temp2;\n          }\n        }\n        dividend_upper = dividend_upper - quotient_upper1;\n        puVar9 = (uint *)(temp_quotient | temp << 0x10);\n      }\n      quotient1 = dividend_upper / temp_quotient1;\n      temp = quotient * quotient1;\n      remainder = dividend >> 0x10 | (dividend_upper - temp_quotient1 * quotient1) * 0x10000;\n      temp_quotient = quotient1;\n      if (remainder <= temp && temp - remainder != 0) {\n        carry_flag = CARRY4(temp2,remainder);\n        remainder = temp2 + remainder;\n        temp_quotient = quotient1 - 1;\n        if ((carry_flag == false) && (remainder <= temp && temp - remainder != 0)) {\n          temp_quotient = quotient1 - 2;\n          remainder = remainder + temp2;\n        }\n      }\n      quotient1 = (remainder - temp) / temp_quotient1;\n      quotient = quotient * quotient1;\n      remainder = dividend & 0xffff | ((remainder - temp) - temp_quotient1 * quotient1) * 0x10000;\n      temp = quotient1;\n      if (remainder <= quotient && quotient - remainder != 0) {\n        carry_flag = CARRY4(temp2,remainder);\n        remainder = temp2 + remainder;\n        temp = quotient1 - 1;\n        if ((carry_flag == false) && (remainder <= quotient && quotient - remainder != 0)) {\n          temp = quotient1 - 2;\n          remainder = remainder + temp2;\n        }\n      }\n      remainder = remainder - quotient;\n      temp = temp | temp_quotient << 0x10;\n    }\n    if (result != (uint *)0x0) {\n      *result = remainder >> LZCOUNT(divisor);\n      result[1] = 0;\n    }\n  }\n  else {\n    puVar9 = result;\n    if (dividend_upper < divisor_upper) {\n      if (result != (uint *)0x0) {\n        *result = dividend;\n        result[1] = dividend_upper;\n        return 0;\n      }\n      temp = 0;\n    }\n    else {\n      shift_value = LZCOUNT(divisor_upper);\n      if (shift_value == 0) {\n        if ((divisor_upper < dividend_upper) || (divisor <= dividend)) {\n          carry_flag = dividend < divisor;\n          dividend = dividend - divisor;\n          dividend_upper = (dividend_upper - divisor_upper) - (uint)carry_flag;\n          temp = 1;\n        }\n        else {\n          temp = 0;\n        }\n        puVar9 = (uint *)0x0;\n        if (result != (uint *)0x0) {\n          *result = dividend;\n          result[1] = dividend_upper;\n        }\n      }\n      else {\n        remainder = 0x20 - shift_value;\n        quotient = divisor >> (remainder & 0xff) | divisor_upper << shift_value;\n        temp2 = dividend_upper >> (remainder & 0xff);\n        quotient_upper = quotient >> 0x10;\n        quotient1 = temp2 / quotient_upper;\n        temp_quotient1 = quotient1 * (quotient & 0xffff);\n        temp = dividend_upper << shift_value | dividend >> (remainder & 0xff);\n        temp_quotient = temp >> 0x10 | (temp2 - quotient_upper * quotient1) * 0x10000;\n        dividend = dividend << shift_value;\n        temp2 = quotient1;\n        if (temp_quotient <= temp_quotient1 && temp_quotient1 - temp_quotient != 0) {\n          carry_flag = CARRY4(quotient,temp_quotient);\n          temp_quotient = quotient + temp_quotient;\n          temp2 = quotient1 - 1;\n          if ((carry_flag == false) && (temp_quotient <= temp_quotient1 && temp_quotient1 - temp_quotient != 0)) {\n            temp2 = quotient1 - 2;\n            temp_quotient = temp_quotient + quotient;\n          }\n        }\n        quotient1 = (temp_quotient - temp_quotient1) / quotient_upper;\n        quotient_upper1 = quotient1 * (quotient & 0xffff);\n        temp_quotient = temp & 0xffff | ((temp_quotient - temp_quotient1) - quotient_upper * quotient1) * 0x10000;\n        temp = quotient1;\n        if (temp_quotient <= quotient_upper1 && quotient_upper1 - temp_quotient != 0) {\n          carry_flag = CARRY4(quotient,temp_quotient);\n          temp_quotient = quotient + temp_quotient;\n          temp = quotient1 - 1;\n          if ((carry_flag == false) && (temp_quotient <= quotient_upper1 && quotient_upper1 - temp_quotient != 0)) {\n            temp = quotient1 - 2;\n            temp_quotient = temp_quotient + quotient;\n          }\n        }\n        temp = temp | temp2 << 0x10;\n        mul_result = (ulonglong)temp * (ulonglong)(divisor << shift_value);\n        if (CONCAT44(temp_quotient - quotient_upper1,dividend) < mul_result) {\n          temp = temp - 1;\n          mul_result = mul_result - CONCAT44(quotient,divisor << shift_value);\n        }\n        if (result != (uint *)0x0) {\n          temp2 = ((temp_quotient - quotient_upper1) - (int)(mul_result >> 0x20)) - (uint)(dividend < (uint)mul_result);\n          *result = temp2 << (remainder & 0xff) | dividend - (uint)mul_result >> shift_value;\n          result[1] = temp2 >> shift_value;\n          puVar9 = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(puVar9,temp);\n}\n\n",
            "renaming": {
                "FUN_0800121c": "calculate_quotient_remainder_0800121c",
                "param_1": "dividend",
                "param_2": "dividend_upper",
                "param_3": "divisor",
                "param_4": "divisor_upper",
                "param_5": "result",
                "UNRECOVERED_JUMPTABLE": "func_table",
                "uVar1": "mul_result",
                "uVar2": "quotient",
                "uVar3": "temp_quotient",
                "uVar4": "quotient_upper",
                "iVar5": "shift_value",
                "uVar6": "temp",
                "uVar7": "temp2",
                "uVar8": "remainder",
                "uVar10": "quotient1",
                "uVar11": "temp_quotient1",
                "uVar12": "quotient_upper1",
                "bVar13": "carry_flag",
                "uVar14": "result_value"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014f0": {
            "entrypoint": "0x080014f0",
            "current_name": "initialize_hardware_080014f0",
            "code": "\n\n\nundefined4 initializeHardware_080014f0(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setInterruptPriorityGrouping(3);\n  initializeTick(0xf);\n  initializeHardware_080014f0Specific();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080014f0": "initialize_hardware_080014f0",
                "HAL_NVIC_SetPriorityGrouping": "setInterruptPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializeHardwareSpecific"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800151c": {
            "entrypoint": "0x0800151c",
            "current_name": "configure_sys_tick_0800151c",
            "code": "\nundefined4 configureSysTick_0800151c(uint priorityLevel)\n\n{\n  int configResult;\n  undefined4 returnValue;\n  \n  configResult = HAL_SYSTICK_Config((int)((ulonglong)DAT_20000018 / (1000 / (ulonglong)DAT_20000004)));\n  if (configResult == 0) {\n    if (priorityLevel < 0x10) {\n      HAL_NVIC_SetPriority(0xffffffff,priorityLevel,0);\n      returnValue = 0;\n      DAT_20000000 = priorityLevel;\n    }\n    else {\n      returnValue = 1;\n    }\n  }\n  else {\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800151c": "configure_sys_tick_0800151c",
                "param_1": "priorityLevel",
                "iVar1": "configResult",
                "uVar2": "returnValue"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "update_data_value_0800157c",
            "code": "\nvoid updateDataValue_0800157c(void)\n\n{\n  DAT_20000a48 = DAT_20000a48 + (uint)DAT_20000004;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "update_data_value_0800157c"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015a0": {
            "entrypoint": "0x080015a0",
            "current_name": "get_global_value_080015a0",
            "code": "\nundefined4 getGlobalValue_080015a0(void)\n\n{\n  return DAT_20000a48;\n}\n\n",
            "renaming": {
                "FUN_080015a0": "get_global_value_080015a0"
            },
            "calling": [
                "_get_ms_tick",
                "HAL_I2C_Mem_Read",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "HAL_RCC_ClockConfig",
                "I2C_RequestMemoryRead",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_WaitOnBTFFlagUntilTimeout",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_UART_Transmit",
                "HAL_RCC_OscConfig",
                "I2C_RequestMemoryWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b4": {
            "entrypoint": "0x080015b4",
            "current_name": "configure_control_register_080015b4",
            "code": "\n\n\nvoid configureControlRegister_080015b4(uint configData)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (configData & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b4": "configure_control_register_080015b4",
                "param_1": "configData"
            },
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015fc": {
            "entrypoint": "0x080015fc",
            "current_name": "get_shifted_and_masked_value_080015fc",
            "code": "\n\n\nuint get_shifted_and_masked_value_080015fc(void)\n\n{\n  return _DAT_e000ed0c >> 8 bitwise_and 7;\n}\n\n",
            "renaming": {
                "FUN_080015fc": "get_shifted_and_masked_value_080015fc",
                "&": "bitwise_and"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001618": {
            "entrypoint": "0x08001618",
            "current_name": "write_byte_to_memory_08001618",
            "code": "\nvoid writeByteToMemory_08001618(byte byteIndex,uint byteValue)\n\n{\n  if ((char)byteIndex < '\\0') {\n    *(char *)((byteIndex & 0xf) + 0xe000ed14) = (char)((byteValue & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)byteIndex + -0x1fff1c00) = (char)((byteValue & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001618": "write_byte_to_memory_08001618",
                "param_1": "byteIndex",
                "param_2": "byteValue"
            },
            "calling": [
                "HAL_NVIC_SetPriority",
                "SysTick_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800166c": {
            "entrypoint": "0x0800166c",
            "current_name": "apply_bit_mask_0800166c",
            "code": "\nuint applyBitMask_0800166c(uint inputBits,uint maskBits,uint value)\n\n{\n  uint shiftAmount;\n  \n  inputBits = inputBits & 7;\n  shiftAmount = 7 - inputBits;\n  if (3 < shiftAmount) {\n    shiftAmount = 4;\n  }\n  if (inputBits + 4 < 7) {\n    inputBits = 0;\n  }\n  else {\n    inputBits = inputBits - 3;\n  }\n  return value & ~(-1 << (inputBits & 0xff)) |\n         (~(-1 << (shiftAmount & 0xff)) & maskBits) << (inputBits & 0xff);\n}\n\n",
            "renaming": {
                "FUN_0800166c": "apply_bit_mask_0800166c",
                "param_1": "inputBits",
                "param_2": "maskBits",
                "param_3": "value",
                "uVar1": "shiftAmount"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016d0": {
            "entrypoint": "0x080016d0",
            "current_name": "check_and_set_priority_080016d0",
            "code": "\n\n\nbool checkAndSetPriority_080016d0(int value)\n\n{\n  bool isLessThanMax;\n  \n  isLessThanMax = value - 1U < 0x1000000;\n  if (isLessThanMax) {\n    _DAT_e000e014 = value + -1;\n    setPriority(0xffffffff,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return !isLessThanMax;\n}\n\n",
            "renaming": {
                "FUN_080016d0": "check_and_set_priority_080016d0",
                "param_1": "value",
                "bVar1": "isLessThanMax",
                "NVIC_SetPriority": "setPriority"
            },
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001714": {
            "entrypoint": "0x08001714",
            "current_name": "set_priority_grouping_08001714",
            "code": "\nvoid setPriorityGrouping_08001714(undefined4 priorityGroup)\n\n{\n  setPriorityGrouping_08001714(priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001714": "set_priority_grouping_08001714",
                "param_1": "priorityGroup",
                "NVIC_SetPriorityGrouping": "setPriorityGrouping"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800172a": {
            "entrypoint": "0x0800172a",
            "current_name": "set_interrupt_priority_0800172a",
            "code": "\nvoid setInterruptPriority_0800172a(char interruptHandler,undefined4 grouping,undefined4 subPriority)\n\n{\n  undefined4 priorityGrouping;\n  \n  priorityGrouping = getPriorityGrouping();\n  priorityGrouping = encodePriority(priorityGrouping,grouping,subPriority);\n  setPriority((int)interruptHandler,priorityGrouping);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800172a": "set_interrupt_priority_0800172a",
                "param_1": "interruptHandler",
                "param_2": "grouping",
                "param_3": "subPriority",
                "uVar1": "priorityGrouping",
                "NVIC_GetPriorityGrouping": "getPriorityGrouping",
                "NVIC_EncodePriority": "encodePriority",
                "NVIC_SetPriority": "setPriority"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "NVIC_SetPriority",
                "NVIC_GetPriorityGrouping",
                "NVIC_EncodePriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001762": {
            "entrypoint": "0x08001762",
            "current_name": "initialize_sys_tick_08001762",
            "code": "\nundefined4 initializeSysTick_08001762(undefined4 configValue)\n\n{\n  undefined4 systickConfigStatus;\n  \n  systickConfigStatus = SysTick_Config(configValue);\n  return systickConfigStatus;\n}\n\n",
            "renaming": {
                "FUN_08001762": "initialize_sys_tick_08001762",
                "param_1": "configValue",
                "uVar1": "systickConfigStatus"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "SysTick_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800177c": {
            "entrypoint": "0x0800177c",
            "current_name": "set_flag_0800177c",
            "code": "\n\n\nvoid setFlag_0800177c(int flagValue)\n\n{\n  if (flagValue == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800177c": "set_flag_0800177c",
                "param_1": "flagValue"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017b4": {
            "entrypoint": "0x080017b4",
            "current_name": "handle_timer_interrupt_080017b4",
            "code": "\nvoid handle_timer_interrupt_080017b4(void)\n\n{\n  HAL_TIM_PeriodElapsedCallback(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080017b4": "handle_timer_interrupt_080017b4"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017c4": {
            "entrypoint": "0x080017c4",
            "current_name": "update_bit_pattern_080017c4",
            "code": "\n\n\nvoid updateBitPattern_080017c4(uint *target,uint *source)\n\n{\n  uint bitMask;\n  uint bitCheck;\n  uint instruction;\n  uint *resultPtr;\n  int index;\n  uint value;\n  uint bitIndex;\n  \n  value = 0;\n  bitIndex = 0;\n  do {\n    if (0xf < bitIndex) {\n      return;\n    }\n    bitMask = 1 << (bitIndex & 0xff);\n    bitCheck = *source & bitMask;\n    if (bitCheck == bitMask) {\n      instruction = source[1];\n      if (instruction == 0x12) {\n        value = source[3] + 0xc;\n      }\n      else if (instruction < 0x13) {\n        if (instruction == 2) {\n          value = source[3] + 8;\n        }\n        else if (instruction < 3) {\n          if (instruction == 0) goto LAB_08001882;\n          if (instruction == 1) {\n            value = source[3];\n          }\n        }\n        else if (instruction == 3) {\n          value = 0;\n        }\n        else if (instruction == 0x11) {\n          value = source[3] + 4;\n        }\n      }\n      else if (instruction == 0x10210000) {\nLAB_08001882:\n        if (source[2] == 0) {\n          value = 4;\n        }\n        else if (source[2] == 1) {\n          value = 8;\n          target[4] = bitMask;\n        }\n        else {\n          value = 8;\n          target[5] = bitMask;\n        }\n      }\n      else if (instruction < 0x10210001) {\n        if ((instruction == 0x10110000) || (instruction == 0x10120000)) goto LAB_08001882;\n      }\n      else if (((instruction == 0x10310000) || (instruction == 0x10320000)) || (instruction == 0x10220000))\n      goto LAB_08001882;\n      if (bitCheck < 0x100) {\n        bitMask = bitIndex << 2;\n        resultPtr = target;\n      }\n      else {\n        resultPtr = target + 1;\n        bitMask = (bitIndex - 8) * 4;\n      }\n      *resultPtr = *resultPtr & ~(0xf << (bitMask & 0xff)) | value << (bitMask & 0xff);\n      if ((source[1] & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        if (target == (uint *)0x40010800) {\n          index = 0;\n        }\n        else if (target == (uint *)0x40010c00) {\n          index = 1;\n        }\n        else if (target == (uint *)0x40011000) {\n          index = 2;\n        }\n        else if (target == (uint *)0x40011400) {\n          index = 3;\n        }\n        else {\n          index = 4;\n        }\n        *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000) =\n             index << ((bitIndex & 3) << 2) |\n             ~(0xf << ((bitIndex & 3) << 2)) & *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000);\n        if ((source[1] & 0x10000) == 0) {\n          _DAT_40010400 = ~bitCheck & _DAT_40010400;\n        }\n        else {\n          _DAT_40010400 = bitCheck | _DAT_40010400;\n        }\n        if ((source[1] & 0x20000) == 0) {\n          _DAT_40010404 = ~bitCheck & _DAT_40010404;\n        }\n        else {\n          _DAT_40010404 = bitCheck | _DAT_40010404;\n        }\n        if ((source[1] & 0x100000) == 0) {\n          _DAT_40010408 = ~bitCheck & _DAT_40010408;\n        }\n        else {\n          _DAT_40010408 = bitCheck | _DAT_40010408;\n        }\n        if ((source[1] & 0x200000) == 0) {\n          _DAT_4001040c = ~bitCheck & _DAT_4001040c;\n        }\n        else {\n          _DAT_4001040c = bitCheck | _DAT_4001040c;\n        }\n      }\n    }\n    bitIndex = bitIndex + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080017c4": "update_bit_pattern_080017c4",
                "param_1": "target",
                "param_2": "source",
                "uVar1": "bitMask",
                "uVar2": "bitCheck",
                "uVar3": "instruction",
                "puVar4": "resultPtr",
                "iVar5": "index",
                "local_10": "value",
                "local_c": "bitIndex"
            },
            "calling": [
                "MX_GPIO_Init",
                "HAL_TIM_MspPostInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a80": {
            "entrypoint": "0x08001a80",
            "current_name": "store_parameter_in_memory_08001a80",
            "code": "\nvoid storeParameterInMemory_08001a80(int memoryAddress,ushort valueToStore,char flag)\n\n{\n  if (flag == '\\0') {\n    *(uint *)(memoryAddress + 0x10) = (uint)valueToStore << 0x10;\n  }\n  else {\n    *(uint *)(memoryAddress + 0x10) = (uint)valueToStore;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a80": "store_parameter_in_memory_08001a80",
                "param_1": "memoryAddress",
                "param_2": "valueToStore",
                "param_3": "flag"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "MX_GPIO_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_i2_c_08001ab0",
            "code": "\nundefined4 initializeI2C_08001ab0(uint **i2cConfig)\n\n{\n  uint pclk1Freq;\n  char isFreqValid;\n  undefined4 result;\n  uint uVar4;\n  bool isZero;\n  \n  if (i2cConfig == (uint **)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)i2cConfig + 0x3d) == '\\0') {\n      *(undefined *)(i2cConfig + 0xf) = 0;\n      initializationHandler(i2cConfig);\n    }\n    *(undefined *)((int)i2cConfig + 0x3d) = 0x24;\n    **i2cConfig = **i2cConfig & 0xfffffffe;\n    pclk1Freq = HAL_RCC_GetPCLK1Freq();\n    if (i2cConfig[1] < (uint *)0x186a1) {\n      uVar4 = pclk1Freq;\n      if (pclk1Freq < 2000000) {\n        uVar4 = 1;\n      }\n      isFreqValid = (char)uVar4;\n      if (1999999 < pclk1Freq) {\n        isFreqValid = '\\0';\n      }\n    }\n    else {\n      uVar4 = pclk1Freq;\n      if (pclk1Freq < 4000000) {\n        uVar4 = 1;\n      }\n      isFreqValid = (char)uVar4;\n      if (3999999 < pclk1Freq) {\n        isFreqValid = '\\0';\n      }\n    }\n    if (isFreqValid == '\\0') {\n      uVar4 = pclk1Freq / 1000000;\n      (*i2cConfig)[1] = uVar4;\n      if ((uint *)0x186a0 < i2cConfig[1]) {\n        uVar4 = (uVar4 * 300) / 1000;\n      }\n      (*i2cConfig)[8] = uVar4 + 1;\n      if (i2cConfig[1] < (uint *)0x186a1) {\n        pclk1Freq = (pclk1Freq - 1) / (uint)((int)i2cConfig[1] << 1) + 1 & 0xfff;\n        if (pclk1Freq < 4) {\n          pclk1Freq = 4;\n        }\n      }\n      else {\n        if (i2cConfig[2] == (uint *)0x0) {\n          uVar4 = (pclk1Freq - 1) / (uint)((int)i2cConfig[1] * 3) + 1 & 0xfff;\n          isZero = uVar4 == 0;\n          if (isZero) {\n            uVar4 = 1;\n          }\n          isFreqValid = (char)uVar4;\n          if (!isZero) {\n            isFreqValid = '\\0';\n          }\n        }\n        else {\n          uVar4 = (pclk1Freq - 1) / (uint)((int)i2cConfig[1] * 0x19) + 1 & 0xfff;\n          isZero = uVar4 == 0;\n          if (isZero) {\n            uVar4 = 1;\n          }\n          isFreqValid = (char)uVar4;\n          if (!isZero) {\n            isFreqValid = '\\0';\n          }\n        }\n        if (isFreqValid == '\\0') {\n          if (i2cConfig[2] == (uint *)0x0) {\n            pclk1Freq = (pclk1Freq - 1) / (uint)((int)i2cConfig[1] * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            pclk1Freq = (pclk1Freq - 1) / (uint)((int)i2cConfig[1] * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          pclk1Freq = 1;\n        }\n      }\n      (*i2cConfig)[7] = pclk1Freq;\n      **i2cConfig = (uint)i2cConfig[8] | (uint)i2cConfig[7];\n      (*i2cConfig)[2] = (uint)i2cConfig[3] | (uint)i2cConfig[4];\n      (*i2cConfig)[3] = (uint)i2cConfig[6] | (uint)i2cConfig[5];\n      **i2cConfig = **i2cConfig | 1;\n      i2cConfig[0x10] = (uint *)0x0;\n      *(undefined *)((int)i2cConfig + 0x3d) = 0x20;\n      i2cConfig[0xc] = (uint *)0x0;\n      *(undefined *)((int)i2cConfig + 0x3e) = 0;\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "initialize_i2_c_08001ab0",
                "param_1": "i2cConfig",
                "uVar1": "pclk1Freq",
                "cVar2": "isFreqValid",
                "uVar3": "result",
                "bVar5": "isZero",
                "HAL_I2C_MspInit": "initializationHandler"
            },
            "calling": [
                "MX_I2C1_Init"
            ],
            "called": [
                "HAL_I2C_MspInit",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cb8": {
            "entrypoint": "0x08001cb8",
            "current_name": "FUNC_08001cb8",
            "code": "\nvoid FUNC_08001cb8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cb8": "FUNC_08001cb8"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ccc": {
            "entrypoint": "0x08001ccc",
            "current_name": "perform_memory_write_08001ccc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001d5e) */\n/* WARNING: Removing unreachable block (ram,0x08001d70) */\n/* WARNING: Removing unreachable block (ram,0x08001d72) */\n/* WARNING: Removing unreachable block (ram,0x08001d74) */\n\nundefined4\nperformMemoryWrite_08001ccc(uint **memoryData,undefined2 address1,undefined2 address2,undefined2 address3,uint *data,\n            undefined2 param2,undefined4 param3)\n\n{\n  int currentTime;\n  int elapsedTime;\n  undefined4 result;\n  uint *byteData;\n  \n  currentTime = HAL_GetTick();\n  if (*(char *)((int)memoryData + 0x3d) == ' ') {\n    do {\n      if ((~(*memoryData)[6] & 2) != 0) {\n        elapsedTime = 0;\n        goto LAB_08001d9c;\n      }\n      elapsedTime = HAL_GetTick();\n    } while ((uint)(elapsedTime - currentTime) < 0x1a);\n    memoryData[0xc] = (uint *)0x0;\n    *(undefined *)((int)memoryData + 0x3d) = 0x20;\n    *(undefined *)((int)memoryData + 0x3e) = 0;\n    *(undefined *)(memoryData + 0xf) = 0;\n    elapsedTime = 3;\nLAB_08001d9c:\n    if (elapsedTime == 0) {\n      if (*(char *)(memoryData + 0xf) == '\\x01') {\n        result = 2;\n      }\n      else {\n        *(undefined *)(memoryData + 0xf) = 1;\n        if ((**memoryData & 1) != 1) {\n          **memoryData = **memoryData | 1;\n        }\n        **memoryData = **memoryData & 0xfffff7ff;\n        *(undefined *)((int)memoryData + 0x3d) = 0x21;\n        *(undefined *)((int)memoryData + 0x3e) = 0x40;\n        memoryData[0x10] = (uint *)0x0;\n        memoryData[9] = data;\n        *(undefined2 *)((int)memoryData + 0x2a) = param2;\n        memoryData[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(memoryData + 10) = *(undefined2 *)((int)memoryData + 0x2a);\n        elapsedTime = I2C_RequestMemoryWrite(memoryData,address1,address2,address3,param3,currentTime);\n        if (elapsedTime == 0) {\n          while (*(short *)(memoryData + 10) != 0) {\n            elapsedTime = I2C_WaitOnTXEFlagUntilTimeout(memoryData,param3,currentTime);\n            if (elapsedTime != 0) {\n              if (memoryData[0x10] == (uint *)0x4) {\n                **memoryData = **memoryData | 0x200;\n                return 1;\n              }\n              return 3;\n            }\n            byteData = memoryData[9];\n            memoryData[9] = (uint *)((int)byteData + 1);\n            (*memoryData)[4] = (uint)*(byte *)byteData;\n            *(short *)(memoryData + 10) = *(short *)(memoryData + 10) + -1;\n            *(short *)((int)memoryData + 0x2a) = *(short *)((int)memoryData + 0x2a) + -1;\n            if ((((*memoryData)[5] & 4) == 4) && (*(short *)(memoryData + 10) != 0)) {\n              byteData = memoryData[9];\n              memoryData[9] = (uint *)((int)byteData + 1);\n              (*memoryData)[4] = (uint)*(byte *)byteData;\n              *(short *)(memoryData + 10) = *(short *)(memoryData + 10) + -1;\n              *(short *)((int)memoryData + 0x2a) = *(short *)((int)memoryData + 0x2a) + -1;\n            }\n          }\n          currentTime = I2C_WaitOnBTFFlagUntilTimeout(memoryData,param3,currentTime);\n          if (currentTime == 0) {\n            **memoryData = **memoryData | 0x200;\n            *(undefined *)((int)memoryData + 0x3d) = 0x20;\n            *(undefined *)((int)memoryData + 0x3e) = 0;\n            *(undefined *)(memoryData + 0xf) = 0;\n            result = 0;\n          }\n          else if (memoryData[0x10] == (uint *)0x4) {\n            **memoryData = **memoryData | 0x200;\n            result = 1;\n          }\n          else {\n            result = 3;\n          }\n        }\n        else if (memoryData[0x10] == (uint *)0x4) {\n          *(undefined *)(memoryData + 0xf) = 0;\n          result = 1;\n        }\n        else {\n          *(undefined *)(memoryData + 0xf) = 0;\n          result = 3;\n        }\n      }\n    }\n    else {\n      result = 2;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001ccc": "perform_memory_write_08001ccc",
                "param_1": "memoryData",
                "param_2": "address1",
                "param_3": "address2",
                "param_4": "address3",
                "param_5": "data",
                "param_6": "param2",
                "param_7": "param3",
                "iVar1": "currentTime",
                "iVar2": "elapsedTime",
                "uVar3": "result",
                "puVar4": "byteData"
            },
            "calling": [
                "_i2c_write_reg"
            ],
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_WaitOnBTFFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_RequestMemoryWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f6c": {
            "entrypoint": "0x08001f6c",
            "current_name": "perform_i2_c_transfer_08001f6c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080024e6) */\n/* WARNING: Removing unreachable block (ram,0x080024f8) */\n/* WARNING: Removing unreachable block (ram,0x080024fa) */\n/* WARNING: Removing unreachable block (ram,0x080024fc) */\n/* WARNING: Removing unreachable block (ram,0x08002000) */\n/* WARNING: Removing unreachable block (ram,0x08002012) */\n/* WARNING: Removing unreachable block (ram,0x08002014) */\n/* WARNING: Removing unreachable block (ram,0x08002016) */\n/* WARNING: Removing unreachable block (ram,0x080023f4) */\n/* WARNING: Removing unreachable block (ram,0x08002406) */\n/* WARNING: Removing unreachable block (ram,0x08002408) */\n/* WARNING: Removing unreachable block (ram,0x0800240a) */\n/* WARNING: Removing unreachable block (ram,0x080022d6) */\n/* WARNING: Removing unreachable block (ram,0x080022e8) */\n/* WARNING: Removing unreachable block (ram,0x080022ea) */\n/* WARNING: Removing unreachable block (ram,0x080022ec) */\n\nundefined4\nperformI2CTransfer_08001f6c(uint **i2cTransferData,undefined2 param2,undefined2 param3,undefined2 param4,uint *buffer,\n            undefined2 param6,uint timeout)\n\n{\n  int startTick;\n  uint value;\n  int elapsedTime;\n  undefined4 returnValue;\n  uint *dataPtr;\n  \n  startTick = HAL_GetTick();\n  if (*(char *)((int)i2cTransferData + 0x3d) == ' ') {\n    do {\n      if ((~(*i2cTransferData)[6] & 2) != 0) {\n        elapsedTime = 0;\n        goto LAB_08002040;\n      }\n      elapsedTime = HAL_GetTick();\n    } while ((uint)(elapsedTime - startTick) < 0x1a);\n    i2cTransferData[0xc] = (uint *)0x0;\n    *(undefined *)((int)i2cTransferData + 0x3d) = 0x20;\n    *(undefined *)((int)i2cTransferData + 0x3e) = 0;\n    *(undefined *)(i2cTransferData + 0xf) = 0;\n    elapsedTime = 3;\nLAB_08002040:\n    if (elapsedTime == 0) {\n      if (*(char *)(i2cTransferData + 0xf) == '\\x01') {\n        returnValue = 2;\n      }\n      else {\n        *(undefined *)(i2cTransferData + 0xf) = 1;\n        if ((**i2cTransferData & 1) != 1) {\n          **i2cTransferData = **i2cTransferData | 1;\n        }\n        **i2cTransferData = **i2cTransferData & 0xfffff7ff;\n        *(undefined *)((int)i2cTransferData + 0x3d) = 0x22;\n        *(undefined *)((int)i2cTransferData + 0x3e) = 0x40;\n        i2cTransferData[0x10] = (uint *)0x0;\n        i2cTransferData[9] = buffer;\n        *(undefined2 *)((int)i2cTransferData + 0x2a) = param6;\n        i2cTransferData[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(i2cTransferData + 10) = *(undefined2 *)((int)i2cTransferData + 0x2a);\n        elapsedTime = I2C_RequestMemoryRead(i2cTransferData,param2,param3,param4,timeout,startTick);\n        if (elapsedTime == 0) {\n          if (*(short *)(i2cTransferData + 10) == 0) {\n            **i2cTransferData = **i2cTransferData | 0x200;\n          }\n          else if (*(short *)(i2cTransferData + 10) == 1) {\n            **i2cTransferData = **i2cTransferData & 0xfffffbff;\n            disableIRQinterrupts();\n            **i2cTransferData = **i2cTransferData | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (*(short *)(i2cTransferData + 10) == 2) {\n            **i2cTransferData = **i2cTransferData | 0x800;\n            disableIRQinterrupts();\n            **i2cTransferData = **i2cTransferData & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            **i2cTransferData = **i2cTransferData | 0x400;\n          }\n          while (*(short *)(i2cTransferData + 10) != 0) {\n            if (*(ushort *)(i2cTransferData + 10) < 4) {\n              if (*(short *)(i2cTransferData + 10) == 1) {\n                elapsedTime = I2C_WaitOnRXNEFlagUntilTimeout(i2cTransferData,timeout,startTick);\n                if (elapsedTime != 0) {\n                  if (i2cTransferData[0x10] == (uint *)0x20) {\n                    return 3;\n                  }\n                  return 1;\n                }\n                value = (*i2cTransferData)[4];\n                dataPtr = i2cTransferData[9];\n                i2cTransferData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)value;\n                *(short *)(i2cTransferData + 10) = *(short *)(i2cTransferData + 10) + -1;\n                *(short *)((int)i2cTransferData + 0x2a) = *(short *)((int)i2cTransferData + 0x2a) + -1;\n              }\n              else if (*(short *)(i2cTransferData + 10) == 2) {\n                do {\n                  if ((~(*i2cTransferData)[5] & 4) == 0) {\n                    elapsedTime = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (elapsedTime = HAL_GetTick(), (uint)(elapsedTime - startTick) <= timeout))\n                        ));\n                i2cTransferData[0xc] = (uint *)0x0;\n                *(undefined *)((int)i2cTransferData + 0x3d) = 0x20;\n                *(undefined *)((int)i2cTransferData + 0x3e) = 0;\n                *(undefined *)(i2cTransferData + 0xf) = 0;\n                elapsedTime = 3;\nLAB_080022fa:\n                if (elapsedTime != 0) {\n                  return 3;\n                }\n                disableIRQinterrupts();\n                **i2cTransferData = **i2cTransferData | 0x200;\n                value = (*i2cTransferData)[4];\n                dataPtr = i2cTransferData[9];\n                i2cTransferData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)value;\n                *(short *)(i2cTransferData + 10) = *(short *)(i2cTransferData + 10) + -1;\n                *(short *)((int)i2cTransferData + 0x2a) = *(short *)((int)i2cTransferData + 0x2a) + -1;\n                enableIRQinterrupts();\n                value = (*i2cTransferData)[4];\n                dataPtr = i2cTransferData[9];\n                i2cTransferData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)value;\n                *(short *)(i2cTransferData + 10) = *(short *)(i2cTransferData + 10) + -1;\n                *(short *)((int)i2cTransferData + 0x2a) = *(short *)((int)i2cTransferData + 0x2a) + -1;\n              }\n              else {\n                do {\n                  if ((~(*i2cTransferData)[5] & 4) == 0) {\n                    elapsedTime = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (elapsedTime = HAL_GetTick(), (uint)(elapsedTime - startTick) <= timeout))\n                        ));\n                i2cTransferData[0xc] = (uint *)0x0;\n                *(undefined *)((int)i2cTransferData + 0x3d) = 0x20;\n                *(undefined *)((int)i2cTransferData + 0x3e) = 0;\n                *(undefined *)(i2cTransferData + 0xf) = 0;\n                elapsedTime = 3;\nLAB_08002418:\n                if (elapsedTime != 0) {\n                  return 3;\n                }\n                **i2cTransferData = **i2cTransferData & 0xfffffbff;\n                disableIRQinterrupts();\n                value = (*i2cTransferData)[4];\n                dataPtr = i2cTransferData[9];\n                i2cTransferData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)value;\n                *(short *)(i2cTransferData + 10) = *(short *)(i2cTransferData + 10) + -1;\n                *(short *)((int)i2cTransferData + 0x2a) = *(short *)((int)i2cTransferData + 0x2a) + -1;\n                do {\n                  if ((~(*i2cTransferData)[5] & 4) == 0) {\n                    elapsedTime = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (elapsedTime = HAL_GetTick(), (uint)(elapsedTime - startTick) <= timeout))\n                        ));\n                i2cTransferData[0xc] = (uint *)0x0;\n                *(undefined *)((int)i2cTransferData + 0x3d) = 0x20;\n                *(undefined *)((int)i2cTransferData + 0x3e) = 0;\n                *(undefined *)(i2cTransferData + 0xf) = 0;\n                elapsedTime = 3;\nLAB_0800250a:\n                if (elapsedTime != 0) {\n                  return 3;\n                }\n                **i2cTransferData = **i2cTransferData | 0x200;\n                value = (*i2cTransferData)[4];\n                dataPtr = i2cTransferData[9];\n                i2cTransferData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)value;\n                *(short *)(i2cTransferData + 10) = *(short *)(i2cTransferData + 10) + -1;\n                *(short *)((int)i2cTransferData + 0x2a) = *(short *)((int)i2cTransferData + 0x2a) + -1;\n                enableIRQinterrupts();\n                value = (*i2cTransferData)[4];\n                dataPtr = i2cTransferData[9];\n                i2cTransferData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)value;\n                *(short *)(i2cTransferData + 10) = *(short *)(i2cTransferData + 10) + -1;\n                *(short *)((int)i2cTransferData + 0x2a) = *(short *)((int)i2cTransferData + 0x2a) + -1;\n              }\n            }\n            else {\n              elapsedTime = I2C_WaitOnRXNEFlagUntilTimeout(i2cTransferData,timeout,startTick);\n              if (elapsedTime != 0) {\n                if (i2cTransferData[0x10] == (uint *)0x20) {\n                  return 3;\n                }\n                return 1;\n              }\n              value = (*i2cTransferData)[4];\n              dataPtr = i2cTransferData[9];\n              i2cTransferData[9] = (uint *)((int)dataPtr + 1);\n              *(char *)dataPtr = (char)value;\n              *(short *)(i2cTransferData + 10) = *(short *)(i2cTransferData + 10) + -1;\n              *(short *)((int)i2cTransferData + 0x2a) = *(short *)((int)i2cTransferData + 0x2a) + -1;\n              if (((*i2cTransferData)[5] & 4) == 4) {\n                value = (*i2cTransferData)[4];\n                dataPtr = i2cTransferData[9];\n                i2cTransferData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)value;\n                *(short *)(i2cTransferData + 10) = *(short *)(i2cTransferData + 10) + -1;\n                *(short *)((int)i2cTransferData + 0x2a) = *(short *)((int)i2cTransferData + 0x2a) + -1;\n              }\n            }\n          }\n          *(undefined *)((int)i2cTransferData + 0x3d) = 0x20;\n          *(undefined *)((int)i2cTransferData + 0x3e) = 0;\n          *(undefined *)(i2cTransferData + 0xf) = 0;\n          returnValue = 0;\n        }\n        else if (i2cTransferData[0x10] == (uint *)0x4) {\n          *(undefined *)(i2cTransferData + 0xf) = 0;\n          returnValue = 1;\n        }\n        else {\n          *(undefined *)(i2cTransferData + 0xf) = 0;\n          returnValue = 3;\n        }\n      }\n    }\n    else {\n      returnValue = 2;\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08001f6c": "perform_i2_c_transfer_08001f6c",
                "param_1": "i2cTransferData",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "buffer",
                "param_6": "param6",
                "param_7": "timeout",
                "iVar1": "startTick",
                "uVar2": "value",
                "iVar3": "elapsedTime",
                "uVar4": "returnValue",
                "puVar5": "dataPtr"
            },
            "calling": [
                "_i2c_read_reg"
            ],
            "called": [
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_RequestMemoryRead",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002640": {
            "entrypoint": "0x08002640",
            "current_name": "perform_i2_c_transfer_08002640",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nundefined4\nperformI2CTransfer_08002640(uint **data,byte controlByte,undefined2 memoryAddress,short dataLength,uint timeout,int startTime)\n\n{\n  int errorCode;\n  undefined4 result;\n  \n  **data = **data | 0x100;\n  do {\n    if ((~(*data)[5] & 1) == 0) {\n      errorCode = 0;\n      goto LAB_0800270a;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (errorCode = HAL_GetTick(), (uint)(errorCode - startTime) <= timeout))));\n  data[0xc] = (uint *)0x0;\n  *(undefined *)((int)data + 0x3d) = 0x20;\n  *(undefined *)((int)data + 0x3e) = 0;\n  *(undefined *)(data + 0xf) = 0;\n  errorCode = 3;\nLAB_0800270a:\n  if (errorCode == 0) {\n    (*data)[4] = controlByte & 0xfe;\n    errorCode = I2C_WaitOnMasterAddressFlagUntilTimeout(data,0x10002,timeout,startTime);\n    if (errorCode == 0) {\n      errorCode = I2C_WaitOnTXEFlagUntilTimeout(data,timeout,startTime,(*data)[6]);\n      if (errorCode == 0) {\n        if (dataLength == 1) {\n          (*data)[4] = (uint)(byte)memoryAddress;\n        }\n        else {\n          (*data)[4] = (uint)(byte)((ushort)memoryAddress >> 8);\n          errorCode = I2C_WaitOnTXEFlagUntilTimeout(data,timeout,startTime);\n          if (errorCode != 0) {\n            if (data[0x10] == (uint *)0x4) {\n              **data = **data | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*data)[4] = (uint)(byte)memoryAddress;\n        }\n        result = 0;\n      }\n      else if (data[0x10] == (uint *)0x4) {\n        **data = **data | 0x200;\n        result = 1;\n      }\n      else {\n        result = 3;\n      }\n    }\n    else if (data[0x10] == (uint *)0x4) {\n      result = 1;\n    }\n    else {\n      result = 3;\n    }\n  }\n  else {\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002640": "perform_i2_c_transfer_08002640",
                "param_1": "data",
                "param_2": "controlByte",
                "param_3": "memoryAddress",
                "param_4": "dataLength",
                "param_5": "timeout",
                "param_6": "startTime",
                "iVar1": "errorCode",
                "uVar2": "result"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f4": {
            "entrypoint": "0x080027f4",
            "current_name": "perform_i2_c_transmission_080027f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nundefined4\nperformI2CTransmission_080027f4(uint **i2cPtr,byte address,undefined2 data,short dataSize,uint timeout,int startTime)\n\n{\n  int status;\n  undefined4 result;\n  \n  **i2cPtr = **i2cPtr | 0x400;\n  **i2cPtr = **i2cPtr | 0x100;\n  do {\n    if ((~(*i2cPtr)[5] & 1) == 0) {\n      status = 0;\n      goto LAB_080028d2;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (status = HAL_GetTick(), (uint)(status - startTime) <= timeout))));\n  i2cPtr[0xc] = (uint *)0x0;\n  *(undefined *)((int)i2cPtr + 0x3d) = 0x20;\n  *(undefined *)((int)i2cPtr + 0x3e) = 0;\n  *(undefined *)(i2cPtr + 0xf) = 0;\n  status = 3;\nLAB_080028d2:\n  if (status == 0) {\n    (*i2cPtr)[4] = address & 0xfe;\n    status = I2C_WaitOnMasterAddressFlagUntilTimeout(i2cPtr,0x10002,timeout,startTime);\n    if (status == 0) {\n      status = I2C_WaitOnTXEFlagUntilTimeout(i2cPtr,timeout,startTime,(*i2cPtr)[6]);\n      if (status == 0) {\n        if (dataSize == 1) {\n          (*i2cPtr)[4] = (uint)(byte)data;\n        }\n        else {\n          (*i2cPtr)[4] = (uint)(byte)((ushort)data >> 8);\n          status = I2C_WaitOnTXEFlagUntilTimeout(i2cPtr,timeout,startTime);\n          if (status != 0) {\n            if (i2cPtr[0x10] == (uint *)0x4) {\n              **i2cPtr = **i2cPtr | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*i2cPtr)[4] = (uint)(byte)data;\n        }\n        status = I2C_WaitOnTXEFlagUntilTimeout(i2cPtr,timeout,startTime);\n        if (status == 0) {\n          **i2cPtr = **i2cPtr | 0x100;\n          do {\n            if ((~(*i2cPtr)[5] & 1) == 0) {\n              status = 0;\n              goto LAB_08002a90;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (status = HAL_GetTick(), (uint)(status - startTime) <= timeout))));\n          i2cPtr[0xc] = (uint *)0x0;\n          *(undefined *)((int)i2cPtr + 0x3d) = 0x20;\n          *(undefined *)((int)i2cPtr + 0x3e) = 0;\n          *(undefined *)(i2cPtr + 0xf) = 0;\n          status = 3;\nLAB_08002a90:\n          if (status == 0) {\n            (*i2cPtr)[4] = (uint)(address | 1);\n            status = I2C_WaitOnMasterAddressFlagUntilTimeout(i2cPtr,0x10002,timeout,startTime);\n            if (status == 0) {\n              result = 0;\n            }\n            else if (i2cPtr[0x10] == (uint *)0x4) {\n              result = 1;\n            }\n            else {\n              result = 3;\n            }\n          }\n          else {\n            result = 3;\n          }\n        }\n        else if (i2cPtr[0x10] == (uint *)0x4) {\n          **i2cPtr = **i2cPtr | 0x200;\n          result = 1;\n        }\n        else {\n          result = 3;\n        }\n      }\n      else if (i2cPtr[0x10] == (uint *)0x4) {\n        **i2cPtr = **i2cPtr | 0x200;\n        result = 1;\n      }\n      else {\n        result = 3;\n      }\n    }\n    else if (i2cPtr[0x10] == (uint *)0x4) {\n      result = 1;\n    }\n    else {\n      result = 3;\n    }\n  }\n  else {\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080027f4": "perform_i2_c_transmission_080027f4",
                "param_1": "i2cPtr",
                "param_2": "address",
                "param_3": "data",
                "param_4": "dataSize",
                "param_5": "timeout",
                "param_6": "startTime",
                "iVar1": "status",
                "uVar2": "result"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "check_and_modify_parameters_08002ad8",
            "code": "\nundefined4 checkAndModifyParameters_08002ad8(uint **parameterArray,uint value1,uint value2,int value3)\n\n{\n  int tickDifference;\n  char updatedValue;\n  uint tempValue;\n  bool isNonZero;\n  \n  do {\n    if ((value1 >> 0x10 & 0xff) == 1) {\n      tempValue = value1 & ~(*parameterArray)[5] & 0xffff;\n      isNonZero = tempValue != 0;\n      if (isNonZero) {\n        tempValue = 1;\n      }\n      updatedValue = (char)tempValue;\n      if (!isNonZero) {\n        updatedValue = '\\0';\n      }\n    }\n    else {\n      tempValue = value1 & ~(*parameterArray)[6] & 0xffff;\n      isNonZero = tempValue != 0;\n      if (isNonZero) {\n        tempValue = 1;\n      }\n      updatedValue = (char)tempValue;\n      if (!isNonZero) {\n        updatedValue = '\\0';\n      }\n    }\n    if (updatedValue == '\\0') {\n      return 0;\n    }\n    if (((*parameterArray)[5] & 0x400) == 0x400) {\n      **parameterArray = **parameterArray | 0x200;\n      (*parameterArray)[5] = 0xfffffbff;\n      updatedParameter1 = (uint *)0x4;\n      updatedParameter2 = (uint *)0x0;\n      *(undefined *)((int)parameterArray + 0x3d) = 0x20;\n      *(undefined *)(parameterArray + 0xf) = 0;\n      return 1;\n    }\n  } while ((value2 == 0xffffffff) ||\n          ((value2 != 0 && (tickDifference = HAL_GetTick(), (uint)(tickDifference - value3) <= value2))));\n  updatedParameter2 = (uint *)0x0;\n  *(undefined *)((int)parameterArray + 0x3d) = 0x20;\n  *(undefined *)(parameterArray + 0xf) = 0;\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "check_and_modify_parameters_08002ad8",
                "param_1": "parameterArray",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3",
                "iVar1": "tickDifference",
                "cVar2": "updatedValue",
                "uVar3": "tempValue",
                "bVar4": "isNonZero",
                "param_1[0x10]": "updatedParameter1",
                "param_1[0xc]": "updatedParameter2"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bb4": {
            "entrypoint": "0x08002bb4",
            "current_name": "check_i2_c_availability_08002bb4",
            "code": "\nundefined4 checkI2CAvailability_08002bb4(int *i2cData,uint timeout,int startTime)\n\n{\n  int isAcknowledgeFailed;\n  \n  while( true ) {\n    if ((*(uint *)(*i2cData + 0x14) & 0x80) == 0x80) {\n      return 0;\n    }\n    isAcknowledgeFailed = I2C_IsAcknowledgeFailed(i2cData);\n    if (isAcknowledgeFailed != 0) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (isAcknowledgeFailed = HAL_GetTick(), timeout < (uint)(isAcknowledgeFailed - startTime))))) {\n      i2cData[0x10] = i2cData[0x10] | 0x20;\n      i2cData[0xc] = 0;\n      *(undefined *)((int)i2cData + 0x3d) = 0x20;\n      *(undefined *)(i2cData + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002bb4": "check_i2_c_availability_08002bb4",
                "param_1": "i2cData",
                "param_2": "timeout",
                "param_3": "startTime",
                "iVar1": "isAcknowledgeFailed"
            },
            "calling": [
                "HAL_I2C_Mem_Write",
                "I2C_RequestMemoryRead",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "I2C_IsAcknowledgeFailed",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2e": {
            "entrypoint": "0x08002c2e",
            "current_name": "check_i2_c_state_08002c2e",
            "code": "\nundefined4 checkI2CState_08002c2e(int *dataPtr,uint timeout,int startTime)\n\n{\n  int acknowledgeFailed;\n  \n  while( true ) {\n    if ((*(uint *)(*dataPtr + 0x14) & 4) == 4) {\n      return 0;\n    }\n    acknowledgeFailed = isAcknowledgeFailed(dataPtr);\n    if (acknowledgeFailed != 0) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (acknowledgeFailed = getCurrentTick(), timeout < (uint)(acknowledgeFailed - startTime))))) {\n      dataPtr[0x10] = dataPtr[0x10] | 0x20;\n      dataPtr[0xc] = 0;\n      *(undefined *)((int)dataPtr + 0x3d) = 0x20;\n      *(undefined *)(dataPtr + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002c2e": "check_i2_c_state_08002c2e",
                "param_1": "dataPtr",
                "param_2": "timeout",
                "param_3": "startTime",
                "iVar1": "acknowledgeFailed",
                "I2C_IsAcknowledgeFailed": "isAcknowledgeFailed",
                "HAL_GetTick": "getCurrentTick"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "I2C_IsAcknowledgeFailed",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca8": {
            "entrypoint": "0x08002ca8",
            "current_name": "check_time_and_status_08002ca8",
            "code": "\nundefined4 checkTimeAndStatus_08002ca8(int *ptrParam,uint paramValue,int currentTime)\n\n{\n  int tickValue;\n  \n  while( true ) {\n    if ((*(uint *)(*ptrParam + 0x14) & 0x40) == 0x40) {\n      return 0;\n    }\n    if ((*(uint *)(*ptrParam + 0x14) & 0x10) == 0x10) break;\n    if ((paramValue == 0) || (tickValue = HAL_GetTick(), paramValue < (uint)(tickValue - currentTime))) {\n      ptrParam[0x10] = ptrParam[0x10] | 0x20;\n      *(undefined *)((int)ptrParam + 0x3d) = 0x20;\n      *(undefined *)(ptrParam + 0xf) = 0;\n      return 3;\n    }\n  }\n  *(undefined4 *)(*ptrParam + 0x14) = 0xffffffef;\n  ptrParam[0x10] = 0;\n  ptrParam[0xc] = 0;\n  *(undefined *)((int)ptrParam + 0x3d) = 0x20;\n  *(undefined *)(ptrParam + 0xf) = 0;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002ca8": "check_time_and_status_08002ca8",
                "param_1": "ptrParam",
                "param_2": "paramValue",
                "param_3": "currentTime",
                "iVar1": "tickValue"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d3c": {
            "entrypoint": "0x08002d3c",
            "current_name": "validate_flag_08002d3c",
            "code": "\nbool validateFlag_08002d3c(int *flagPtr)\n\n{\n  bool isFlagSet;\n  \n  isFlagSet = (*(uint *)(*flagPtr + 0x14) & 0x400) == 0x400;\n  if (isFlagSet) {\n    *(undefined4 *)(*flagPtr + 0x14) = 0xfffffbff;\n    flagPtr[0x10] = 4;\n    flagPtr[0xc] = 0;\n    *(undefined *)((int)flagPtr + 0x3d) = 0x20;\n    *(undefined *)(flagPtr + 0xf) = 0;\n  }\n  return isFlagSet;\n}\n\n",
            "renaming": {
                "FUN_08002d3c": "validate_flag_08002d3c",
                "param_1": "flagPtr",
                "bVar1": "isFlagSet"
            },
            "calling": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_WaitOnBTFFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d8a": {
            "entrypoint": "0x08002d8a",
            "current_name": "FUNC_08002d8a",
            "code": "\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d98": {
            "entrypoint": "0x08002d98",
            "current_name": "check_configuration_08002d98",
            "code": "\n\n\nundefined4 checkConfiguration_08002d98(uint *config)\n\n{\n  int startTime;\n  int currentTime;\n  undefined4 result;\n  bool isFlagSet;\n  \n  if ((*config & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0x10000)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (config[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      if (config[1] == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (config[1] == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (config[1] == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (config[1] == 0) {\n        startTime = getCurrentTime();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTime = getCurrentTime();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        startTime = getCurrentTime();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTime = getCurrentTime();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*config & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (config[4] != 1)) {\n        return 1;\n      }\n      _DAT_40021000 = config[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n    else if (config[4] == 0) {\n      _DAT_42420000 = 0;\n      startTime = getCurrentTime();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTime = getCurrentTime();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTime = getCurrentTime();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTime = getCurrentTime();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n      _DAT_40021000 = config[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n  }\n  if ((*config & 8) != 0) {\n    if (config[6] == 0) {\n      _DAT_42420480 = 0;\n      startTime = getCurrentTime();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTime = getCurrentTime();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTime = getCurrentTime();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTime = getCurrentTime();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n      delay(1);\n    }\n  }\n  if ((*config & 4) != 0) {\n    isFlagSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isFlagSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = getCurrentTime();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = getCurrentTime();\n        if (100 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (config[3] == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (config[3] == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (config[3] == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (config[3] == 0) {\n      startTime = getCurrentTime();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTime = getCurrentTime();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      startTime = getCurrentTime();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTime = getCurrentTime();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (isFlagSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if (config[7] == 0) {\nLAB_0800324a:\n    result = 0;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    result = 1;\n  }\n  else if (config[7] == 2) {\n    _DAT_42420060 = 0;\n    startTime = getCurrentTime();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if (config[8] == 0x10000) {\n          _DAT_40021004 = config[2] | _DAT_40021004 & 0xfffdffff;\n        }\n        _DAT_40021004 = config[9] | config[8] | _DAT_40021004 & 0xffc2ffff;\n        _DAT_42420060 = 1;\n        startTime = getCurrentTime();\n        while ((_DAT_40021000 & 0x2000000) == 0) {\n          currentTime = getCurrentTime();\n          if (2 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      currentTime = getCurrentTime();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTime = getCurrentTime();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) goto LAB_0800324a;\n      currentTime = getCurrentTime();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002d98": "check_configuration_08002d98",
                "param_1": "config",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "result",
                "bVar4": "isFlagSet",
                "HAL_GetTick": "getCurrentTime",
                "RCC_Delay": "delay"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003260": {
            "entrypoint": "0x08003260",
            "current_name": "initialize_system_08003260",
            "code": "\n\n\nundefined4 initializeSystem_08003260(uint *systemConfig,uint configSize)\n\n{\n  int startTime;\n  int currentTime;\n  uint sysClockFreq;\n  undefined4 status;\n  \n  if (((_DAT_40022000 & 7) < configSize) &&\n     (_DAT_40022000 = configSize | _DAT_40022000 & 0xfffffff8, configSize != (configSize & 7))) {\n    status = 1;\n  }\n  else {\n    if ((*systemConfig & 2) != 0) {\n      _DAT_40021004 = systemConfig[2] | _DAT_40021004 & 0xffffff0f;\n    }\n    if ((*systemConfig & 1) == 0) {\nLAB_08003394:\n      if ((configSize < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = configSize | _DAT_40022000 & 0xfffffff8, configSize != (configSize & 7))) {\n        status = 1;\n      }\n      else {\n        if ((*systemConfig & 4) != 0) {\n          _DAT_40021004 = systemConfig[3] | _DAT_40021004 & 0xfffff8ff;\n        }\n        if ((*systemConfig & 8) != 0) {\n          _DAT_40021004 = systemConfig[4] << 3 | _DAT_40021004 & 0xffffc7ff;\n        }\n        sysClockFreq = HAL_RCC_GetSysClockFreq();\n        DAT_20000018 = sysClockFreq >> (&DAT_08009eb0)[_DAT_40021004 >> 4 & 0xf];\n        HAL_InitTick(0xf);\n        status = 0;\n      }\n    }\n    else {\n      if (systemConfig[1] == 1) {\n        if ((_DAT_40021000 & 0x20000) == 0) {\n          return 1;\n        }\n      }\n      else if ((systemConfig[1] != 2) && ((_DAT_40021000 & 2) == 0)) {\n        return 1;\n      }\n      _DAT_40021004 = systemConfig[1] | _DAT_40021004 & 0xfffffffc;\n      startTime = HAL_GetTick();\n      if (systemConfig[1] == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_08003394;\n          currentTime = HAL_GetTick();\n        } while ((uint)(currentTime - startTime) < 0x1389);\n        status = 3;\n      }\n      else if (systemConfig[1] == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_08003394;\n          currentTime = HAL_GetTick();\n        } while ((uint)(currentTime - startTime) < 0x1389);\n        status = 3;\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_08003394;\n          currentTime = HAL_GetTick();\n        } while ((uint)(currentTime - startTime) < 0x1389);\n        status = 3;\n      }\n    }\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003260": "initialize_system_08003260",
                "param_1": "systemConfig",
                "param_2": "configSize",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "sysClockFreq",
                "uVar4": "status"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003440": {
            "entrypoint": "0x08003440",
            "current_name": "calculate_processing_time_08003440",
            "code": "\n\n\nuint calculateProcessingTime_08003440(void)\n\n{\n  undefined2 inputValue;\n  undefined4 constant1;\n  undefined4 constant2;\n  undefined4 constant3;\n  undefined4 constant4;\n  uint processingTime1;\n  undefined4 processingTime2;\n  uint local_14;\n  uint result;\n  uint temp;\n  \n  constant1 = 0x5040302;\n  constant2 = 0x9080706;\n  constant3 = 0xd0c0b0a;\n  constant4 = 0x10100f0e;\n  inputValue = 0x201;\n  processingTime2 = 0;\n  temp = 0;\n  processingTime1 = 0;\n  result = 0;\n  local_14 = _DAT_40021004;\n  if ((_DAT_40021004 & 0xc) == 4) {\n    result = 8000000;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    processingTime1 = (uint)*(byte *)((int)&constant1 + (_DAT_40021004 >> 0x12 & 0xf));\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      temp = processingTime1 * 4000000;\n    }\n    else {\n      temp = (processingTime1 * 8000000) / (uint)*(byte *)((int)&inputValue + (_DAT_40021004 >> 0x11 & 1))\n      ;\n    }\n    result = temp;\n  }\n  else {\n    result = 8000000;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003440": "calculate_processing_time_08003440",
                "local_30": "inputValue",
                "local_2c": "constant1",
                "uStack_28": "constant2",
                "uStack_24": "constant3",
                "uStack_20": "constant4",
                "local_1c": "processingTime1",
                "local_18": "processingTime2",
                "local_10": "result",
                "local_c": "temp"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003504": {
            "entrypoint": "0x08003504",
            "current_name": "get_data_08003504",
            "code": "\nundefined4 get_data_08003504(void)\n\n{\n  return DAT_20000018;\n}\n\n",
            "renaming": {
                "FUN_08003504": "get_data_08003504"
            },
            "calling": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003518": {
            "entrypoint": "0x08003518",
            "current_name": "get_adjusted_hclk_freq_08003518",
            "code": "\n\n\nuint getAdjustedHCLKFreq_08003518(void)\n\n{\n  uint hclkFreq;\n  \n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  return hclkFreq >> *(adjustment *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 8 & 7));\n}\n\n",
            "renaming": {
                "FUN_08003518": "get_adjusted_hclk_freq_08003518",
                "uVar1": "hclkFreq",
                "sbyte": "adjustment"
            },
            "calling": [
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003540": {
            "entrypoint": "0x08003540",
            "current_name": "get_hclk_freq_08003540",
            "code": "\n\n\nuint getHCLKFreq_08003540(void)\n\n{\n  uint hclkFreq;\n  \n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  return hclkFreq >> *(sbyte *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 0xb & 7));\n}\n\n",
            "renaming": {
                "FUN_08003540": "get_hclk_freq_08003540",
                "uVar1": "hclkFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003568": {
            "entrypoint": "0x08003568",
            "current_name": "delay_function_08003568",
            "code": "\nvoid delayFunction_08003568(int delayTime)\n\n{\n  bool isNotZero;\n  int remainingIterations;\n  \n  remainingIterations = delayTime * (DAT_20000018 / 8000);\n  do {\n    isNotZero = remainingIterations != 0;\n    remainingIterations = remainingIterations + -1;\n  } while (isNotZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003568": "delay_function_08003568",
                "param_1": "delayTime",
                "local_c": "remainingIterations",
                "bVar1": "isNotZero"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035a4": {
            "entrypoint": "0x080035a4",
            "current_name": "initialize_timer_080035a4",
            "code": "\nundefined4 initializeTimer_080035a4(undefined4 *timerData)\n\n{\n  undefined4 result;\n  \n  if (timerData == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)timerData + 0x3d) == '\\0') {\n      *(undefined *)(timerData + 0xf) = 0;\n      initializeTimer_080035a4Hardware(timerData);\n    }\n    *(undefined *)((int)timerData + 0x3d) = 2;\n    setTimerConfig(*timerData,timerData + 1);\n    *(undefined *)((int)timerData + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080035a4": "initialize_timer_080035a4",
                "param_1": "timerData",
                "uVar1": "result",
                "HAL_TIM_Base_MspInit": "initializeTimerHardware",
                "TIM_Base_SetConfig": "setTimerConfig"
            },
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "called": [
                "HAL_TIM_Base_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fa": {
            "entrypoint": "0x080035fa",
            "current_name": "FUNC_080035fa",
            "code": "\nvoid FUNC_080035fa(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fa": "FUNC_080035fa"
            },
            "calling": [
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800360c": {
            "entrypoint": "0x0800360c",
            "current_name": "set_flags_0800360c",
            "code": "\nundefined4 setFlags_0800360c(uint **flags)\n\n{\n  (*flags)[3] = (*flags)[3] | 1;\n  **flags = **flags | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800360c": "set_flags_0800360c",
                "param_1": "flags"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003640": {
            "entrypoint": "0x08003640",
            "current_name": "initialize_pwm_controller_08003640",
            "code": "\nundefined4 initializePWMController_08003640(undefined4 *controllerPtr)\n\n{\n  undefined4 result;\n  \n  if (controllerPtr == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)controllerPtr + 0x3d) == '\\0') {\n      *(undefined *)(controllerPtr + 0xf) = 0;\n      initializePWM(controllerPtr);\n    }\n    *(undefined *)((int)controllerPtr + 0x3d) = 2;\n    setTimerBaseConfig(*controllerPtr,controllerPtr + 1);\n    *(undefined *)((int)controllerPtr + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003640": "initialize_pwm_controller_08003640",
                "param_1": "controllerPtr",
                "uVar1": "result",
                "HAL_TIM_PWM_MspInit": "initializePWM",
                "TIM_Base_SetConfig": "setTimerBaseConfig"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003696": {
            "entrypoint": "0x08003696",
            "current_name": "FUNC_08003696",
            "code": "\nvoid FUNC_08003696(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003696": "FUNC_08003696"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080036a8": {
            "entrypoint": "0x080036a8",
            "current_name": "configure_and_enable_channel_080036a8",
            "code": "\nundefined4 configureAndEnableChannel_080036a8(uint **channelPointer,undefined4 channelConfiguration)\n\n{\n  TIM_CCxChannelCmd(*channelPointer,channelConfiguration,1);\n  if (*channelPointer == (uint *)0x40012c00) {\n    (*channelPointer)[0x11] = (*channelPointer)[0x11] | 0x8000;\n  }\n  **channelPointer = **channelPointer | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080036a8": "configure_and_enable_channel_080036a8",
                "param_1": "channelPointer",
                "param_2": "channelConfiguration"
            },
            "calling": [
                "main"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f8": {
            "entrypoint": "0x080036f8",
            "current_name": "handle_timer_interrupt_080036f8",
            "code": "\nvoid handleTimerInterrupt_080036f8(int *timerData)\n\n{\n  if (((*(uint *)(*timerData + 0x10) & 2) == 2) && ((*(uint *)(*timerData + 0xc) & 2) == 2)) {\n    *(undefined4 *)(*timerData + 0x10) = 0xfffffffd;\n    *(undefined *)(timerData + 7) = 1;\n    if ((*(uint *)(*timerData + 0x18) & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerData);\n      HAL_TIM_PWM_PulseFinishedCallback(timerData);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerData);\n    }\n    *(undefined *)(timerData + 7) = 0;\n  }\n  if (((*(uint *)(*timerData + 0x10) & 4) == 4) && ((*(uint *)(*timerData + 0xc) & 4) == 4)) {\n    *(undefined4 *)(*timerData + 0x10) = 0xfffffffb;\n    *(undefined *)(timerData + 7) = 2;\n    if ((*(uint *)(*timerData + 0x18) & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerData);\n      HAL_TIM_PWM_PulseFinishedCallback(timerData);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerData);\n    }\n    *(undefined *)(timerData + 7) = 0;\n  }\n  if (((*(uint *)(*timerData + 0x10) & 8) == 8) && ((*(uint *)(*timerData + 0xc) & 8) == 8)) {\n    *(undefined4 *)(*timerData + 0x10) = 0xfffffff7;\n    *(undefined *)(timerData + 7) = 4;\n    if ((*(uint *)(*timerData + 0x1c) & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerData);\n      HAL_TIM_PWM_PulseFinishedCallback(timerData);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerData);\n    }\n    *(undefined *)(timerData + 7) = 0;\n  }\n  if (((*(uint *)(*timerData + 0x10) & 0x10) == 0x10) && ((*(uint *)(*timerData + 0xc) & 0x10) == 0x10))\n  {\n    *(undefined4 *)(*timerData + 0x10) = 0xffffffef;\n    *(undefined *)(timerData + 7) = 8;\n    if ((*(uint *)(*timerData + 0x1c) & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerData);\n      HAL_TIM_PWM_PulseFinishedCallback(timerData);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerData);\n    }\n    *(undefined *)(timerData + 7) = 0;\n  }\n  if (((*(uint *)(*timerData + 0x10) & 1) == 1) && ((*(uint *)(*timerData + 0xc) & 1) == 1)) {\n    *(undefined4 *)(*timerData + 0x10) = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(timerData);\n  }\n  if (((*(uint *)(*timerData + 0x10) & 0x80) == 0x80) && ((*(uint *)(*timerData + 0xc) & 0x80) == 0x80))\n  {\n    *(undefined4 *)(*timerData + 0x10) = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(timerData);\n  }\n  if (((*(uint *)(*timerData + 0x10) & 0x40) == 0x40) && ((*(uint *)(*timerData + 0xc) & 0x40) == 0x40))\n  {\n    *(undefined4 *)(*timerData + 0x10) = 0xffffffbf;\n    HAL_TIM_TriggerCallback(timerData);\n  }\n  if (((*(uint *)(*timerData + 0x10) & 0x20) == 0x20) && ((*(uint *)(*timerData + 0xc) & 0x20) == 0x20))\n  {\n    *(undefined4 *)(*timerData + 0x10) = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(timerData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036f8": "handle_timer_interrupt_080036f8",
                "param_1": "timerData"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PWM_PulseFinishedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003908": {
            "entrypoint": "0x08003908",
            "current_name": "configure_timer_output_08003908",
            "code": "\nundefined4 configureTimerOutput_08003908(int *timer,int config,undefined4 outputChannel)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(timer + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(timer + 0xf) = 1;\n    *(undefined *)((int)timer + 0x3d) = 2;\n    switch(outputChannel) {\n    case 0:\n      setTimerOutputChannel1Config(*timer,config);\n      *(uint *)(*timer + 0x18) = *(uint *)(*timer + 0x18) | 8;\n      *(uint *)(*timer + 0x18) = *(uint *)(*timer + 0x18) & 0xfffffffb;\n      *(uint *)(*timer + 0x18) = *(uint *)(config + 0x10) | *(uint *)(*timer + 0x18);\n      break;\n    case 4:\n      setTimerOutputChannel2Config(*timer,config);\n      *(uint *)(*timer + 0x18) = *(uint *)(*timer + 0x18) | 0x800;\n      *(uint *)(*timer + 0x18) = *(uint *)(*timer + 0x18) & 0xfffffbff;\n      *(uint *)(*timer + 0x18) = *(int *)(config + 0x10) << 8 | *(uint *)(*timer + 0x18);\n      break;\n    case 8:\n      setTimerOutputChannel3Config(*timer,config);\n      *(uint *)(*timer + 0x1c) = *(uint *)(*timer + 0x1c) | 8;\n      *(uint *)(*timer + 0x1c) = *(uint *)(*timer + 0x1c) & 0xfffffffb;\n      *(uint *)(*timer + 0x1c) = *(uint *)(config + 0x10) | *(uint *)(*timer + 0x1c);\n      break;\n    case 0xc:\n      setTimerOutputChannel4Config(*timer,config);\n      *(uint *)(*timer + 0x1c) = *(uint *)(*timer + 0x1c) | 0x800;\n      *(uint *)(*timer + 0x1c) = *(uint *)(*timer + 0x1c) & 0xfffffbff;\n      *(uint *)(*timer + 0x1c) = *(int *)(config + 0x10) << 8 | *(uint *)(*timer + 0x1c);\n    }\n    *(undefined *)((int)timer + 0x3d) = 1;\n    *(undefined *)(timer + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003908": "configure_timer_output_08003908",
                "param_1": "timer",
                "param_2": "config",
                "param_3": "outputChannel",
                "uVar1": "result",
                "TIM_OC1_SetConfig": "setTimerOutputChannel1Config",
                "TIM_OC2_SetConfig": "setTimerOutputChannel2Config",
                "TIM_OC3_SetConfig": "setTimerOutputChannel3Config",
                "TIM_OC4_SetConfig": "setTimerOutputChannel4Config"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "TIM_OC2_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC3_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a94": {
            "entrypoint": "0x08003a94",
            "current_name": "configure_timer_08003a94",
            "code": "\nundefined4 configureTimer_08003a94(int *timerParams,uint *configParams)\n\n{\n  undefined4 returnValue;\n  uint configValue;\n  \n  if (*(char *)(timerParams + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(timerParams + 0xf) = 1;\n    *(undefined *)((int)timerParams + 0x3d) = 2;\n    *(uint *)(*timerParams + 8) = *(uint *)(*timerParams + 8) & 0xffff0088;\n    configValue = *configParams;\n    if (configValue == 0x40) {\n      TIM_TI1_ConfigInputStage(*timerParams,configParams[1],configParams[3]);\n      TIM_ITRx_SetConfig(*timerParams,0x40);\n    }\n    else if (configValue < 0x41) {\n      if (configValue == 0x10) {\n        TIM_ITRx_SetConfig(*timerParams,0x10);\n      }\n      else if (configValue < 0x11) {\n        if (configValue == 0) {\n          TIM_ITRx_SetConfig(*timerParams,0);\n        }\n      }\n      else if (configValue == 0x20) {\n        TIM_ITRx_SetConfig(*timerParams,0x20);\n      }\n      else if (configValue == 0x30) {\n        TIM_ITRx_SetConfig(*timerParams,0x30);\n      }\n    }\n    else if (configValue == 0x70) {\n      TIM_ETR_SetConfig(*timerParams,configParams[2],configParams[1],configParams[3]);\n      *(uint *)(*timerParams + 8) = *(uint *)(*timerParams + 8) & 0xffffff88 | 0x77;\n    }\n    else if (configValue < 0x71) {\n      if (configValue == 0x50) {\n        TIM_TI1_ConfigInputStage(*timerParams,configParams[1],configParams[3]);\n        TIM_ITRx_SetConfig(*timerParams,0x50);\n      }\n      else if (configValue == 0x60) {\n        TIM_TI2_ConfigInputStage(*timerParams,configParams[1],configParams[3]);\n        TIM_ITRx_SetConfig(*timerParams,0x60);\n      }\n    }\n    else if (configValue == 0x1000) {\n      *(uint *)(*timerParams + 8) = *(uint *)(*timerParams + 8) & 0xfffffff8;\n    }\n    else if (configValue == 0x2000) {\n      TIM_ETR_SetConfig(*timerParams,configParams[2],configParams[1],configParams[3]);\n      *(uint *)(*timerParams + 8) = *(uint *)(*timerParams + 8) | 0x4000;\n    }\n    *(undefined *)((int)timerParams + 0x3d) = 1;\n    *(undefined *)(timerParams + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08003a94": "configure_timer_08003a94",
                "param_1": "timerParams",
                "param_2": "configParams",
                "uVar1": "returnValue",
                "uVar2": "configValue"
            },
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "called": [
                "TIM_ITRx_SetConfig",
                "TIM_TI1_ConfigInputStage",
                "TIM_TI2_ConfigInputStage",
                "TIM_ETR_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c4a": {
            "entrypoint": "0x08003c4a",
            "current_name": "FUNC_08003c4a",
            "code": "\nvoid FUNC_08003c4a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c4a": "FUNC_08003c4a"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c5c": {
            "entrypoint": "0x08003c5c",
            "current_name": "FUNC_08003c5c",
            "code": "\nvoid FUNC_08003c5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c5c": "FUNC_08003c5c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c6e": {
            "entrypoint": "0x08003c6e",
            "current_name": "FUNC_08003c6e",
            "code": "\nvoid FUNC_08003c6e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c6e": "FUNC_08003c6e"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c80": {
            "entrypoint": "0x08003c80",
            "current_name": "FUNC_08003c80",
            "code": "\nvoid FUNC_08003c80(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c80": "FUNC_08003c80"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c94": {
            "entrypoint": "0x08003c94",
            "current_name": "update_memory_08003c94",
            "code": "\nvoid updateMemory_08003c94(uint *memoryAddress,uint *data)\n\n{\n  uint originalValue;\n  \n  originalValue = *memoryAddress;\n  if ((((memoryAddress == (uint *)0x40012c00) || (memoryAddress == (uint *)0x40000000)) ||\n      (memoryAddress == (uint *)0x40000400)) || (memoryAddress == (uint *)0x40000800)) {\n    originalValue = data[1] | originalValue & 0xffffff8f;\n  }\n  if (((memoryAddress == (uint *)0x40012c00) || (memoryAddress == (uint *)0x40000000)) ||\n     ((memoryAddress == (uint *)0x40000400 || (memoryAddress == (uint *)0x40000800)))) {\n    originalValue = data[3] | originalValue & 0xfffffcff;\n  }\n  *memoryAddress = data[5] | originalValue & 0xffffff7f;\n  memoryAddress[0xb] = data[2];\n  memoryAddress[10] = *data;\n  if (memoryAddress == (uint *)0x40012c00) {\n    specialValue = data[4];\n  }\n  memoryAddress[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c94": "update_memory_08003c94",
                "param_1": "memoryAddress",
                "param_2": "data",
                "local_c": "originalValue",
                "uRam40012c30": "specialValue"
            },
            "calling": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d60": {
            "entrypoint": "0x08003d60",
            "current_name": "update_parameters_08003d60",
            "code": "\nvoid updateParameters_08003d60(int baseAddress,uint *parameters)\n\n{\n  uint value1;\n  uint value2;\n  uint tempValue;\n  \n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xfffffffe;\n  tempValue = *(uint *)(baseAddress + 4);\n  value1 = *parameters;\n  value2 = parameters[2] | *(uint *)(baseAddress + 0x20) & 0xfffffffd;\n  if (baseAddress == 0x40012c00) {\n    value2 = (parameters[3] | value2 & 0xfffffff7) & 0xfffffffb;\n    tempValue = parameters[6] | parameters[5] | tempValue & 0xfffffcff;\n  }\n  *(uint *)(baseAddress + 4) = tempValue;\n  *(uint *)(baseAddress + 0x18) = value1 | *(uint *)(baseAddress + 0x18) & 0xffffff8c;\n  *(uint *)(baseAddress + 0x34) = parameters[1];\n  *(uint *)(baseAddress + 0x20) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003d60": "update_parameters_08003d60",
                "param_1": "baseAddress",
                "param_2": "parameters",
                "uVar1": "value1",
                "uVar2": "value2",
                "local_10": "tempValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e38": {
            "entrypoint": "0x08003e38",
            "current_name": "update_data_08003e38",
            "code": "\nvoid updateData_08003e38(int dataAddress,int *paramList)\n\n{\n  int tempVar1;\n  uint tempVar2;\n  uint tempVar3;\n  \n  *(uint *)(dataAddress + 0x20) = *(uint *)(dataAddress + 0x20) & 0xffffffef;\n  tempVar3 = *(uint *)(dataAddress + 4);\n  tempVar1 = *paramList;\n  tempVar2 = paramList[2] << 4 | *(uint *)(dataAddress + 0x20) & 0xffffffdf;\n  if (dataAddress == 0x40012c00) {\n    tempVar2 = (paramList[3] << 4 | tempVar2 & 0xffffff7f) & 0xffffffbf;\n    tempVar3 = paramList[6] << 2 | paramList[5] << 2 | tempVar3 & 0xfffff3ff;\n  }\n  *(uint *)(dataAddress + 4) = tempVar3;\n  *(uint *)(dataAddress + 0x18) = tempVar1 << 8 | *(uint *)(dataAddress + 0x18) & 0xffff8cff;\n  *(int *)(dataAddress + 0x38) = paramList[1];\n  *(uint *)(dataAddress + 0x20) = tempVar2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e38": "update_data_08003e38",
                "param_1": "dataAddress",
                "param_2": "paramList",
                "iVar1": "tempVar1",
                "uVar2": "tempVar2",
                "local_10": "tempVar3"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "update_data_08003f18",
            "code": "\nvoid updateData_08003f18(int dataAddress,uint *dataArray)\n\n{\n  uint value1;\n  uint value2;\n  uint localValue;\n  \n  *(uint *)(dataAddress + 0x20) = *(uint *)(dataAddress + 0x20) & 0xfffffeff;\n  localValue = *(uint *)(dataAddress + 4);\n  value1 = *dataArray;\n  value2 = dataArray[2] << 8 | *(uint *)(dataAddress + 0x20) & 0xfffffdff;\n  if (dataAddress == 0x40012c00) {\n    value2 = (dataArray[3] << 8 | value2 & 0xfffff7ff) & 0xfffffbff;\n    localValue = dataArray[6] << 4 | dataArray[5] << 4 | localValue & 0xffffcfff;\n  }\n  *(uint *)(dataAddress + 4) = localValue;\n  *(uint *)(dataAddress + 0x1c) = value1 | *(uint *)(dataAddress + 0x1c) & 0xffffff8c;\n  *(uint *)(dataAddress + 0x3c) = dataArray[1];\n  *(uint *)(dataAddress + 0x20) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "update_data_08003f18",
                "param_1": "dataAddress",
                "param_2": "dataArray",
                "uVar1": "value1",
                "uVar2": "value2",
                "local_10": "localValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff8": {
            "entrypoint": "0x08003ff8",
            "current_name": "update_parameters_08003ff8",
            "code": "\nvoid updateParameters_08003ff8(int functionAddress,int *parameters)\n\n{\n  int param1Value;\n  int param2Value;\n  uint localVariable;\n  \n  *(uint *)(functionAddress + 0x20) = *(uint *)(functionAddress + 0x20) & 0xffffefff;\n  localVariable = *(uint *)(functionAddress + 4);\n  param1Value = *parameters;\n  param2Value = parameters[2];\n  if (functionAddress == 0x40012c00) {\n    localVariable = parameters[5] << 6 | localVariable & 0xffffbfff;\n  }\n  *(uint *)(functionAddress + 4) = localVariable;\n  *(uint *)(functionAddress + 0x1c) = param1Value << 8 | *(uint *)(functionAddress + 0x1c) & 0xffff8cff;\n  *(int *)(functionAddress + 0x40) = parameters[1];\n  *(uint *)(functionAddress + 0x20) = param2Value << 0xc | *(uint *)(functionAddress + 0x20) & 0xffffdfff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff8": "update_parameters_08003ff8",
                "param_1": "functionAddress",
                "param_2": "parameters",
                "iVar1": "param1Value",
                "iVar2": "param2Value",
                "local_c": "localVariable"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040a0": {
            "entrypoint": "0x080040a0",
            "current_name": "update_parameters_080040a0",
            "code": "\nvoid updateParameters_080040a0(int address,uint flags,int value)\n\n{\n  uint oldFlags;\n  \n  oldFlags = *(uint *)(address + 0x20);\n  *(uint *)(address + 0x20) = *(uint *)(address + 0x20) & 0xfffffffe;\n  *(uint *)(address + 0x18) = value << 4 | *(uint *)(address + 0x18) & 0xffffff0f;\n  *(uint *)(address + 0x20) = flags | oldFlags & 0xfffffff5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040a0": "update_parameters_080040a0",
                "param_1": "address",
                "param_2": "flags",
                "param_3": "value",
                "uVar1": "oldFlags"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004104": {
            "entrypoint": "0x08004104",
            "current_name": "update_flags_and_values_08004104",
            "code": "\nvoid updateFlagsAndValues_08004104(int dataPointer,int value1,int value2)\n\n{\n  *(uint *)(dataPointer + 0x20) = *(uint *)(dataPointer + 0x20) & 0xffffffef;\n  *(uint *)(dataPointer + 0x18) = value2 << 0xc | *(uint *)(dataPointer + 0x18) & 0xffff0fff;\n  *(uint *)(dataPointer + 0x20) = value1 << 4 | *(uint *)(dataPointer + 0x20) & 0xffffff5f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004104": "update_flags_and_values_08004104",
                "param_1": "dataPointer",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800416a": {
            "entrypoint": "0x0800416a",
            "current_name": "update_param_0800416a",
            "code": "\nvoid updateParam_0800416a(int ptrToData,ushort newParamValue)\n\n{\n  *(uint *)(ptrToData + 8) = *(uint *)(ptrToData + 8) & 0xffffff8f | (uint)(newParamValue | 7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800416a": "update_param_0800416a",
                "param_1": "ptrToData",
                "param_2": "newParamValue"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a8": {
            "entrypoint": "0x080041a8",
            "current_name": "update_value_080041a8",
            "code": "\nvoid updateValue_080041a8(int baseAddress,uint value1,uint value2,int value3)\n\n{\n  *(uint *)(baseAddress + 8) = value1 | value3 << 8 | value2 | *(uint *)(baseAddress + 8) & 0xffff00ff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a8": "update_value_080041a8",
                "param_1": "baseAddress",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ea": {
            "entrypoint": "0x080041ea",
            "current_name": "update_bitwise_value_080041ea",
            "code": "\nvoid updateBitwiseValue_080041ea(int inputAddress,uint bitPosition,int newValue)\n\n{\n  *(uint *)(inputAddress + 0x20) = *(uint *)(inputAddress + 0x20) & ~(1 << (bitPosition & 0xff));\n  *(uint *)(inputAddress + 0x20) = *(uint *)(inputAddress + 0x20) | newValue << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041ea": "update_bitwise_value_080041ea",
                "param_1": "inputAddress",
                "param_2": "bitPosition",
                "param_3": "newValue"
            },
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800422e": {
            "entrypoint": "0x0800422e",
            "current_name": "update_flag_and_write_data_0800422e",
            "code": "\nundefined4 updateFlagAndWriteData_0800422e(int *dataPtr,uint *values)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(dataPtr + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(dataPtr + 0xf) = 1;\n    *(uint *)(*dataPtr + 0x44) =\n         values[6] |\n         (values[6] |\n         (values[5] |\n         (values[4] |\n         (*values | (values[1] | (values[2] | values[3] & 0xfffffcff) & 0xfffffbff) & 0xfffff7ff\n         ) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    *(undefined *)(dataPtr + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800422e": "update_flag_and_write_data_0800422e",
                "param_1": "dataPtr",
                "param_2": "values",
                "uVar1": "result"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042de": {
            "entrypoint": "0x080042de",
            "current_name": "update_flags_and_values_080042de",
            "code": "\nundefined4 updateFlagsAndValues_080042de(int *array,uint *values)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(array + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(array + 0xf) = 1;\n    *(undefined *)((int)array + 0x3d) = 2;\n    *(uint *)(*array + 4) = *(uint *)(*array + 4) & 0xffffff8f;\n    *(uint *)(*array + 4) = *values | *(uint *)(*array + 4);\n    *(uint *)(*array + 8) = *(uint *)(*array + 8) & 0xffffff7f;\n    *(uint *)(*array + 8) = values[1] | *(uint *)(*array + 8);\n    *(undefined *)((int)array + 0x3d) = 1;\n    *(undefined *)(array + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080042de": "update_flags_and_values_080042de",
                "param_1": "array",
                "param_2": "values",
                "uVar1": "result"
            },
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004366": {
            "entrypoint": "0x08004366",
            "current_name": "FUNC_08004366",
            "code": "\nvoid FUNC_08004366(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004366": "FUNC_08004366"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004378": {
            "entrypoint": "0x08004378",
            "current_name": "FUNC_08004378",
            "code": "\nvoid FUNC_08004378(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004378": "FUNC_08004378"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800438a": {
            "entrypoint": "0x0800438a",
            "current_name": "initialize_uart_0800438a",
            "code": "\nundefined4 initializeUart_0800438a(int *uartDevice)\n\n{\n  undefined4 result;\n  \n  if (uartDevice == (int *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)uartDevice + 0x39) == '\\0') {\n      *(undefined *)(uartDevice + 0xe) = 0;\n      initializeUart_0800438aMsp(uartDevice);\n    }\n    *(undefined *)((int)uartDevice + 0x39) = 0x24;\n    *(uint *)(*uartDevice + 0xc) = *(uint *)(*uartDevice + 0xc) & 0xffffdfff;\n    setUartConfig(uartDevice);\n    *(uint *)(*uartDevice + 0x10) = *(uint *)(*uartDevice + 0x10) & 0xffffb7ff;\n    *(uint *)(*uartDevice + 0x14) = *(uint *)(*uartDevice + 0x14) & 0xffffffd5;\n    *(uint *)(*uartDevice + 0xc) = *(uint *)(*uartDevice + 0xc) | 0x2000;\n    uartDevice[0xf] = 0;\n    *(undefined *)((int)uartDevice + 0x39) = 0x20;\n    *(undefined *)((int)uartDevice + 0x3a) = 0x20;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800438a": "initialize_uart_0800438a",
                "param_1": "uartDevice",
                "uVar1": "result",
                "HAL_UART_MspInit": "initializeUartMsp",
                "UART_SetConfig": "setUartConfig"
            },
            "calling": [
                "MX_USART1_UART_Init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004424": {
            "entrypoint": "0x08004424",
            "current_name": "FUNC_08004424",
            "code": "\nvoid FUNC_08004424(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004424": "FUNC_08004424"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004436": {
            "entrypoint": "0x08004436",
            "current_name": "process_data_08004436",
            "code": "\nundefined4 processData_08004436(uint **data,ushort *input,short inputLength,uint timeout)\n\n{\n  int firstTick;\n  int currentTick;\n  undefined4 result;\n  ushort *currentInput;\n  \n  if (*(char *)((int)data + 0x39) == ' ') {\n    if ((input == (ushort *)0x0) || (inputLength == 0)) {\n      result = 1;\n    }\n    else if (*(char *)(data + 0xe) == '\\x01') {\n      result = 2;\n    }\n    else {\n      *(undefined *)(data + 0xe) = 1;\n      data[0xf] = (uint *)0x0;\n      *(undefined *)((int)data + 0x39) = 0x21;\n      firstTick = HAL_GetTick();\n      *(short *)(data + 9) = inputLength;\n      *(short *)((int)data + 0x26) = inputLength;\n      currentInput = input;\n      while (*(short *)((int)data + 0x26) != 0) {\n        *(short *)((int)data + 0x26) = *(short *)((int)data + 0x26) + -1;\n        if (data[2] == (uint *)0x1000) {\n          do {\n            if ((**data & 0x80) == 0x80) {\n              currentTick = 0;\n              goto LAB_0800454c;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (currentTick = HAL_GetTick(), (uint)(currentTick - firstTick) <= timeout))));\n          (*data)[3] = (*data)[3] & 0xfffffe5f;\n          (*data)[5] = (*data)[5] & 0xfffffffe;\n          *(undefined *)((int)data + 0x39) = 0x20;\n          *(undefined *)((int)data + 0x3a) = 0x20;\n          *(undefined *)(data + 0xe) = 0;\n          currentTick = 3;\nLAB_0800454c:\n          if (currentTick != 0) {\n            return 3;\n          }\n          (*data)[1] = *currentInput & 0x1ff;\n          if (data[4] == (uint *)0x0) {\n            currentInput = currentInput + 1;\n          }\n          else {\n            currentInput = (ushort *)((int)currentInput + 1);\n          }\n        }\n        else {\n          do {\n            if ((**data & 0x80) == 0x80) {\n              currentTick = 0;\n              goto LAB_08004614;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (currentTick = HAL_GetTick(), (uint)(currentTick - firstTick) <= timeout))));\n          (*data)[3] = (*data)[3] & 0xfffffe5f;\n          (*data)[5] = (*data)[5] & 0xfffffffe;\n          *(undefined *)((int)data + 0x39) = 0x20;\n          *(undefined *)((int)data + 0x3a) = 0x20;\n          *(undefined *)(data + 0xe) = 0;\n          currentTick = 3;\nLAB_08004614:\n          if (currentTick != 0) {\n            return 3;\n          }\n          (*data)[1] = (uint)*(byte *)currentInput;\n          currentInput = (ushort *)((int)currentInput + 1);\n        }\n      }\n      do {\n        if ((**data & 0x40) == 0x40) {\n          firstTick = 0;\n          goto LAB_080046c6;\n        }\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (currentTick = HAL_GetTick(), (uint)(currentTick - firstTick) <= timeout))));\n      (*data)[3] = (*data)[3] & 0xfffffe5f;\n      (*data)[5] = (*data)[5] & 0xfffffffe;\n      *(undefined *)((int)data + 0x39) = 0x20;\n      *(undefined *)((int)data + 0x3a) = 0x20;\n      *(undefined *)(data + 0xe) = 0;\n      firstTick = 3;\nLAB_080046c6:\n      if (firstTick == 0) {\n        *(undefined *)((int)data + 0x39) = 0x20;\n        *(undefined *)(data + 0xe) = 0;\n        result = 0;\n      }\n      else {\n        result = 3;\n      }\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004436": "process_data_08004436",
                "param_1": "data",
                "param_2": "input",
                "param_3": "inputLength",
                "param_4": "timeout",
                "iVar1": "firstTick",
                "iVar2": "currentTick",
                "uVar3": "result",
                "local_58": "currentInput"
            },
            "calling": [
                "uart_print"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046ec": {
            "entrypoint": "0x080046ec",
            "current_name": "calculate_clock_frequency_080046ec",
            "code": "\nvoid calculateClockFrequency_080046ec(int *clockConfiguration)\n\n{\n  ulonglong temp1;\n  int temp2;\n  int temp3;\n  uint temp4;\n  int temp5;\n  undefined8 pclkFreq;\n  \n  *(uint *)(*clockConfiguration + 0x10) = clockConfiguration[3] | *(uint *)(*clockConfiguration + 0x10) & 0xffffcfff;\n  *(uint *)(*clockConfiguration + 0xc) =\n       *(uint *)(*clockConfiguration + 0xc) & 0xffffe9f3 | clockConfiguration[5] | clockConfiguration[2] | clockConfiguration[4];\n  *(uint *)(*clockConfiguration + 0x14) = clockConfiguration[6] | *(uint *)(*clockConfiguration + 0x14) & 0xfffffcff;\n  if (*clockConfiguration == 0x40013800) {\n    pclkFreq = HAL_RCC_GetPCLK2Freq();\n    temp1 = (ulonglong)(uint)((int)pclkFreq * 0x19) / (ulonglong)(uint)(clockConfiguration[1] << 2);\n    temp2 = HAL_RCC_GetPCLK2Freq\n                      ((int)pclkFreq,(int)((ulonglong)pclkFreq >> 0x20),(int)(temp1 * 0x51eb851f));\n    temp3 = clockConfiguration[1];\n    pclkFreq = HAL_RCC_GetPCLK2Freq();\n    temp4 = ((uint)(temp2 * 0x19) / (uint)(temp3 << 2) +\n            (int)(((ulonglong)(uint)((int)pclkFreq * 0x19) / (ulonglong)(uint)(clockConfiguration[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    temp2 = HAL_RCC_GetPCLK2Freq((int)pclkFreq,(int)((ulonglong)pclkFreq >> 0x20),temp4 * 0x51eb851f);\n    temp5 = clockConfiguration[1];\n    temp3 = HAL_RCC_GetPCLK2Freq();\n    *(uint *)(*clockConfiguration + 8) =\n         ((((uint)(temp2 * 0x19) / (uint)(temp5 << 2) +\n           (int)(((ulonglong)(uint)(temp3 * 0x19) / (ulonglong)(uint)(clockConfiguration[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(temp1 / 100) * 0x10 + (temp4 / 100 & 0xf0);\n  }\n  else {\n    pclkFreq = HAL_RCC_GetPCLK1Freq();\n    temp1 = (ulonglong)(uint)((int)pclkFreq * 0x19) / (ulonglong)(uint)(clockConfiguration[1] << 2);\n    temp2 = HAL_RCC_GetPCLK1Freq\n                      ((int)pclkFreq,(int)((ulonglong)pclkFreq >> 0x20),(int)(temp1 * 0x51eb851f));\n    temp3 = clockConfiguration[1];\n    pclkFreq = HAL_RCC_GetPCLK1Freq();\n    temp4 = ((uint)(temp2 * 0x19) / (uint)(temp3 << 2) +\n            (int)(((ulonglong)(uint)((int)pclkFreq * 0x19) / (ulonglong)(uint)(clockConfiguration[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    temp2 = HAL_RCC_GetPCLK1Freq((int)pclkFreq,(int)((ulonglong)pclkFreq >> 0x20),temp4 * 0x51eb851f);\n    temp5 = clockConfiguration[1];\n    temp3 = HAL_RCC_GetPCLK1Freq();\n    *(uint *)(*clockConfiguration + 8) =\n         ((((uint)(temp2 * 0x19) / (uint)(temp5 << 2) +\n           (int)(((ulonglong)(uint)(temp3 * 0x19) / (ulonglong)(uint)(clockConfiguration[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(temp1 / 100) * 0x10 + (temp4 / 100 & 0xf0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046ec": "calculate_clock_frequency_080046ec",
                "param_1": "clockConfiguration",
                "uVar1": "temp1",
                "iVar2": "temp2",
                "iVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "temp5",
                "uVar6": "pclkFreq"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800491c": {
            "entrypoint": "0x0800491c",
            "current_name": "initialize_mpu6050_0800491c",
            "code": "\nvoid initializeMPU6050_0800491c(undefined4 *outputData)\n\n{\n  undefined temp1;\n  undefined temp2;\n  undefined tempArray [5];\n  \n  temp1 = 0;\n  (*DAT_20000a54)(0xd0,0x6b,&temp1,1);\n  temp2 = 0x10;\n  (*DAT_20000a54)(0xd0,0x1c,&temp2,1);\n  tempArray[0] = 8;\n  (*DAT_20000a54)(0xd0,0x1b,tempArray,1);\n  *outputData = 0;\n  outputData[1] = 0;\n  outputData[2] = 0;\n  outputData[3] = 0;\n  outputData[4] = 0;\n  outputData[5] = 0;\n  outputData[6] = 0;\n  outputData[7] = 0;\n  outputData[8] = 0;\n  outputData[9] = 0;\n  outputData[10] = 0;\n  mpu6050_calibrate(outputData);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800491c": "initialize_mpu6050_0800491c",
                "param_1": "outputData",
                "local_13": "temp1",
                "local_12": "temp2",
                "local_11": "tempArray"
            },
            "calling": [
                "main"
            ],
            "called": [
                "mpu6050_calibrate"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049cc": {
            "entrypoint": "0x080049cc",
            "current_name": "calculate_averages_080049cc",
            "code": "\nvoid calculateAverages_080049cc(int sensorData)\n\n{\n  undefined4 uVar1;\n  undefined4 sumPitch;\n  undefined4 sumRoll;\n  undefined4 getCurrentTime;\n  int numIterations;\n  int iterationCount;\n  undefined4 avgRoll;\n  undefined4 avgPitch;\n  undefined4 avgYaw;\n  undefined4 accX;\n  \n  numIterations = 1;\n  accX = 0;\n  avgYaw = 0;\n  avgPitch = 0;\n  avgRoll = 0;\n  getCurrentTime = (*DAT_20000a50)();\n  iterationCount = 0;\n  while( true ) {\n    if (numIterations <= iterationCount) break;\n    sumRoll = 0;\n    sumPitch = 0;\n    updateSensorData(sensorData);\n    calculatePitchAndRoll(sensorData,&sumRoll,&sumPitch);\n    avgPitch = addFloats(avgPitch,sumRoll);\n    avgRoll = addFloats(avgRoll,sumPitch);\n    accX = addFloats(accX,*(undefined4 *)(sensorData + 0x10));\n    avgYaw = addFloats(avgYaw,*(undefined4 *)(sensorData + 0x14));\n    getCurrentTime = (*DAT_20000a50)();\n    iterationCount = iterationCount + 1;\n  }\n  uVar1 = intToFloat(numIterations);\n  uVar1 = divideFloats(accX,uVar1);\n  *(undefined4 *)(sensorData + 0x1c) = uVar1;\n  uVar1 = intToFloat(numIterations);\n  uVar1 = divideFloats(avgYaw,uVar1);\n  *(undefined4 *)(sensorData + 0x20) = uVar1;\n  uVar1 = intToFloat(numIterations);\n  uVar1 = divideFloats(avgPitch,uVar1);\n  *(undefined4 *)(sensorData + 0x24) = uVar1;\n  uVar1 = intToFloat(numIterations);\n  uVar1 = divideFloats(avgRoll,uVar1);\n  *(undefined4 *)(sensorData + 0x28) = uVar1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049cc": "calculate_averages_080049cc",
                "param_1": "sensorData",
                "local_2c": "sumPitch",
                "local_28": "sumRoll",
                "local_24": "getCurrentTime",
                "local_20": "numIterations",
                "local_1c": "iterationCount",
                "local_18": "avgRoll",
                "local_14": "avgPitch",
                "local_10": "avgYaw",
                "local_c": "accX",
                "mpu6050_update": "updateSensorData",
                "mpu6050_calc_acc_pitch_roll": "calculatePitchAndRoll",
                "__addsf3": "addFloats",
                "__floatsisf": "intToFloat",
                "__aeabi_fdiv": "divideFloats"
            },
            "calling": [
                "mpu6050_init"
            ],
            "called": [
                "__aeabi_fdiv",
                "__addsf3",
                "mpu6050_update",
                "mpu6050_calc_acc_pitch_roll",
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ae0": {
            "entrypoint": "0x08004ae0",
            "current_name": "convert_integers_to_floats_08004ae0",
            "code": "\nvoid convertIntegersToFloats_08004ae0(undefined4 *outputValues)\n\n{\n  undefined4 uVar1;\n  undefined byte1;\n  undefined byte2;\n  undefined byte3;\n  undefined byte4;\n  undefined byte5;\n  undefined byte6;\n  undefined byte7;\n  undefined byte8;\n  undefined byte9;\n  undefined byte10;\n  undefined byte11;\n  undefined byte12;\n  undefined byte13;\n  undefined byte14;\n  short short1;\n  short short2;\n  short short3;\n  short short4;\n  short short5;\n  short short6;\n  \n  (*DAT_20000a4c)(0xd0,0x3b,&byte1,0xe);\n  short6 = CONCAT11(byte3,byte4);\n  short5 = CONCAT11(byte5,byte6);\n  short4 = CONCAT11(byte7,byte8);\n  short3 = CONCAT11(byte9,byte10);\n  short2 = CONCAT11(byte11,byte12);\n  short1 = CONCAT11(byte13,byte14);\n  uVar1 = __floatsisf((int)CONCAT11(byte1,byte2));\n  *outputValues = uVar1;\n  uVar1 = __floatsisf((int)short6);\n  outputValues[1] = uVar1;\n  uVar1 = __floatsisf((int)short5);\n  outputValues[2] = uVar1;\n  uVar1 = __floatsisf((int)short4);\n  outputValues[3] = uVar1;\n  uVar1 = __floatsisf((int)short3);\n  outputValues[4] = uVar1;\n  uVar1 = __floatsisf((int)short2);\n  outputValues[5] = uVar1;\n  uVar1 = __floatsisf((int)short1);\n  outputValues[6] = uVar1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ae0": "convert_integers_to_floats_08004ae0",
                "param_1": "outputValues",
                "local_2c": "byte1",
                "local_2b": "byte2",
                "local_2a": "byte3",
                "local_29": "byte4",
                "local_28": "byte5",
                "local_27": "byte6",
                "local_26": "byte7",
                "local_25": "byte8",
                "local_24": "byte9",
                "local_23": "byte10",
                "local_22": "byte11",
                "local_21": "byte12",
                "local_20": "byte13",
                "local_1f": "byte14",
                "local_1e": "short1",
                "local_1c": "short2",
                "local_1a": "short3",
                "local_18": "short4",
                "local_16": "short5",
                "local_14": "short6"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calibrate"
            ],
            "called": [
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bd8": {
            "entrypoint": "0x08004bd8",
            "current_name": "calculate_result_08004bd8",
            "code": "\nvoid calculate_result_08004bd8(int input_data,undefined4 *output_value)\n\n{\n  undefined4 difference;\n  undefined8 temp1;\n  undefined8 temp2;\n  \n  difference = __aeabi_fsub(*(undefined4 *)(input_data + 0x10),*(undefined4 *)(input_data + 0x1c));\n  temp1 = __aeabi_f2d(DAT_200009e4);\n  temp2 = __aeabi_f2d(difference);\n  temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x83f5c366,0x3f340215);\n  temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                       (int)((ulonglong)temp2 >> 0x20));\n  DAT_200009e4 = __truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  temp1 = __aeabi_f2d(*(undefined4 *)(input_data + 4));\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40b00000);\n  temp2 = __aeabi_f2d(*(undefined4 *)(input_data + 8));\n  temp2 = __divdf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0,0x40b00000);\n  temp1 = atan2((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40668000);\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x54442d18,0x400921fb);\n  temp2 = __aeabi_f2d(*(undefined4 *)(input_data + 0x24));\n  temp1 = __subdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                   (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40568000);\n  difference = __truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  if (DAT_20000005 == '\\0') {\n    temp1 = __aeabi_f2d(DAT_200009e4);\n    temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x9999999a,0x3fe99999);\n    temp2 = __aeabi_f2d(difference);\n    temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x9999999a,0x3fc99999);\n    temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                         (int)((ulonglong)temp2 >> 0x20));\n    DAT_200009e4 = __truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  }\n  else {\n    DAT_20000005 = '\\0';\n    DAT_200009e4 = difference;\n  }\n  *output_value = DAT_200009e4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bd8": "calculate_result_08004bd8",
                "param_1": "input_data",
                "param_2": "output_value",
                "uVar1": "difference",
                "uVar2": "temp1",
                "uVar3": "temp2"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_fsub",
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "__truncdfsf2",
                "atan2",
                "__subdf3",
                "__aeabi_f2d"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d78": {
            "entrypoint": "0x08004d78",
            "current_name": "calculate_angles_08004d78",
            "code": "\nvoid calculateAngles_08004d78(undefined4 *inputArray,undefined4 *angle1,undefined4 *angle2)\n\n{\n  undefined4 divided1;\n  undefined4 divided2;\n  undefined4 divided3;\n  undefined8 result1;\n  undefined8 result2;\n  \n  divided1 = __aeabi_fdiv(*inputArray,0x45800000);\n  divided2 = __aeabi_fdiv(inputArray[1],0x45800000);\n  divided3 = __aeabi_fdiv(inputArray[2],0x45800000);\n  result1 = __aeabi_f2d(divided2);\n  result2 = __aeabi_f2d(divided3);\n  result1 = atan2((int)result1,(int)((ulonglong)result1 >> 0x20),(int)result2,\n                (int)((ulonglong)result2 >> 0x20));\n  result1 = __muldf3((int)result1,(int)((ulonglong)result1 >> 0x20),0,0x40668000);\n  result1 = __divdf3((int)result1,(int)((ulonglong)result1 >> 0x20),0x54442d18,0x400921fb);\n  divided2 = __truncdfsf2((int)result1,(int)((ulonglong)result1 >> 0x20));\n  result1 = __aeabi_f2d(divided1);\n  result2 = __aeabi_f2d(divided3);\n  result1 = atan2((int)result1,(int)((ulonglong)result1 >> 0x20),(int)result2,\n                (int)((ulonglong)result2 >> 0x20));\n  result1 = __muldf3((int)result1,(int)((ulonglong)result1 >> 0x20),0,0x40668000);\n  result1 = __divdf3((int)result1,(int)((ulonglong)result1 >> 0x20),0x54442d18,0x400921fb);\n  divided1 = __truncdfsf2((int)result1,(int)((ulonglong)result1 >> 0x20));\n  *angle1 = divided2;\n  *angle2 = divided1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d78": "calculate_angles_08004d78",
                "param_1": "inputArray",
                "param_2": "angle1",
                "param_3": "angle2",
                "uVar1": "divided1",
                "uVar2": "divided2",
                "uVar3": "divided3",
                "uVar4": "result1",
                "uVar5": "result2"
            },
            "calling": [
                "mpu6050_calibrate"
            ],
            "called": [
                "__aeabi_fdiv",
                "__muldf3",
                "__divdf3",
                "__truncdfsf2",
                "atan2",
                "__aeabi_f2d"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e6c": {
            "entrypoint": "0x08004e6c",
            "current_name": "call_software_interrupt_08004e6c",
            "code": "\nvoid callSoftwareInterrupt_08004e6c(void)\n\n{\n  invokeInterrupt(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e6c": "call_software_interrupt_08004e6c",
                "software_interrupt": "invokeInterrupt"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "handle_afl_event_08004e74",
            "code": "\nundefined4 handleAflEvent_08004e74(undefined4 event)\n\n{\n  undefined4 returnValue;\n  \n  if (DAT_200009f0 == 0) {\n    returnValue = aflCall(1,event,0);\n  }\n  else {\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "handle_afl_event_08004e74",
                "param_1": "event",
                "uVar1": "returnValue"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ea4": {
            "entrypoint": "0x08004ea4",
            "current_name": "write_i2_c_memory_08004ea4",
            "code": "\nvoid writeI2CMemory_08004ea4(undefined deviceAddress,undefined memoryAddress,undefined4 data,undefined2 dataSize)\n\n{\n  HAL_I2C_Mem_Write(&DAT_20000a88,deviceAddress,memoryAddress,1,data,dataSize,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ea4": "write_i2_c_memory_08004ea4",
                "param_1": "deviceAddress",
                "param_2": "memoryAddress",
                "param_3": "data",
                "param_4": "dataSize"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "read_i2_c_memory_08004ee8",
            "code": "\nvoid readI2CMemory_08004ee8(undefined deviceAddress,undefined memoryAddress,undefined4 memoryAddressSize,undefined2 dataBuffer)\n\n{\n  HAL_I2C_Mem_Read(&DAT_20000a88,deviceAddress,memoryAddress,1,memoryAddressSize,dataBuffer,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "read_i2_c_memory_08004ee8",
                "param_1": "deviceAddress",
                "param_2": "memoryAddress",
                "param_3": "memoryAddressSize",
                "param_4": "dataBuffer"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "get_current_tick_08004f2c",
            "code": "\nundefined4 getCurrentTick_08004f2c(void)\n\n{\n  undefined4 currentTick;\n  \n  currentTick = HAL_GetTick();\n  return currentTick;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "get_current_tick_08004f2c",
                "uVar1": "currentTick"
            },
            "calling": [],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "transmit_data_08004f3c",
            "code": "\nvoid transmitData_08004f3c(undefined4 dataBuffer,undefined2 dataSize)\n\n{\n  uartTransmit(&DAT_20000adc,dataBuffer,dataSize,0x32);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "transmit_data_08004f3c",
                "param_1": "dataBuffer",
                "param_2": "dataSize",
                "HAL_UART_Transmit": "uartTransmit"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "initialize_data_08004f60",
            "code": "\nvoid initializeData_08004f60(void)\n\n{\n  memset(&DAT_20000ba8,0,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "initialize_data_08004f60"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f78": {
            "entrypoint": "0x08004f78",
            "current_name": "update_and_print_pitch_08004f78",
            "code": "\nvoid update_and_print_pitch_08004f78(void)\n\n{\n  undefined4 result;\n  int comparison;\n  undefined4 threshold;\n  uint mask;\n  undefined8 pitch;\n  byte converted_pitch;\n  \n  mpu6050_update(&DAT_20000a5c);\n  mpu6050_calc_pitch(&DAT_20000a5c,&DAT_20000ba0);\n  flush_strbuf();\n  pitch = __aeabi_f2d(DAT_20000ba0);\n  sprintf(&DAT_20000ba8,\"Pitch: %f\\n\",(int)pitch,(int)((ulonglong)pitch >> 0x20));\n  result = strlen(&DAT_20000ba8);\n  uart_print(&DAT_20000ba8,result);\n  DAT_200009f8 = __aeabi_fsub(DAT_20000014,DAT_20000ba0);\n  DAT_20000be8 = __aeabi_fmul(DAT_20000a00,DAT_200009f8);\n  result = __aeabi_fmul(DAT_20000a04,DAT_200009f8);\n  DAT_20000b5c = __addsf3(result,DAT_20000b5c);\n  result = __floatsisf(DAT_20000010);\n  comparison = __aeabi_fcmplt(result,DAT_20000b5c);\n  if (comparison == 0) {\n    result = __floatsisf(DAT_200009f4);\n    comparison = __aeabi_fcmpgt(result,DAT_20000b5c);\n    if (comparison != 0) {\n      DAT_20000b5c = __floatunsisf(DAT_200009f4);\n    }\n  }\n  else {\n    DAT_20000b5c = __floatunsisf(DAT_20000010);\n  }\n  mask = DAT_20000a08 ^ 0x80000000;\n  result = __aeabi_fsub(DAT_200009f8,DAT_200009fc);\n  DAT_20000a58 = __aeabi_fmul(mask,result);\n  result = __addsf3(DAT_20000be8,DAT_20000b5c);\n  result = __addsf3(result,DAT_20000a58);\n  threshold = __floatsisf(DAT_20000010);\n  comparison = __aeabi_fcmpgt(result,threshold);\n  if (comparison == 0) {\n    threshold = __floatsisf(DAT_200009f4);\n    comparison = __aeabi_fcmplt(result,threshold);\n    if (comparison == 0) {\n      converted_pitch = __fixunssfsi(result);\n    }\n    else {\n      converted_pitch = DAT_200009f4;\n    }\n  }\n  else {\n    converted_pitch = DAT_20000010;\n  }\n  DAT_200009fc = DAT_200009f8;\n  comparison = __aeabi_fcmpgt(DAT_200009f8,0);\n  HAL_GPIO_WritePin(0x40010800,2,comparison != 0);\n  comparison = __aeabi_fcmpgt(DAT_200009f8,0);\n  HAL_GPIO_WritePin(0x40010800,4,comparison == 0);\n  comparison = __aeabi_fcmpgt(DAT_200009f8,0);\n  HAL_GPIO_WritePin(0x40010800,8,comparison != 0);\n  comparison = __aeabi_fcmpgt(DAT_200009f8,0);\n  HAL_GPIO_WritePin(0x40010800,0x10,comparison == 0);\n  *(uint *)(DAT_20000b1c + 0x34) = (uint)converted_pitch;\n  *(uint *)(DAT_20000b1c + 0x40) = (uint)converted_pitch;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f78": "update_and_print_pitch_08004f78",
                "uVar1": "result",
                "iVar2": "comparison",
                "uVar3": "threshold",
                "uVar4": "mask",
                "uVar5": "pitch",
                "local_11": "converted_pitch"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler",
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "__aeabi_fsub",
                "__aeabi_fmul",
                "HAL_GPIO_WritePin",
                "__aeabi_fcmpgt",
                "__floatunsisf",
                "flush_strbuf",
                "mpu6050_calc_pitch",
                "__aeabi_f2d",
                "__fixunssfsi",
                "__aeabi_fcmplt",
                "sprintf",
                "__addsf3",
                "mpu6050_update",
                "strlen",
                "uart_print",
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005224": {
            "entrypoint": "0x08005224",
            "current_name": "initialize_system_08005224",
            "code": "\nvoid initializeSystem_08005224(void)\n\n{\n  initializeHAL();\n  configureSystemClock();\n  initializeGPIO();\n  initializeI2C1();\n  initializeUART1();\n  initializeTIM2();\n  initializeTIM1();\n  DAT_20000a54 = 0x8004ea5;\n  DAT_20000a4c = 0x8004ee9;\n  DAT_20000a50 = 0x8004f2d;\n  startTIMPWM(&DAT_20000b1c,0);\n  startTIMPWM(&DAT_20000b1c,0xc);\n  initializeMPU6050(&DAT_20000a5c);\n  startTIMBaseIT(&DAT_20000b60);\n  startForkServer(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005224": "initialize_system_08005224",
                "HAL_Init": "initializeHAL",
                "SystemClock_Config": "configureSystemClock",
                "MX_GPIO_Init": "initializeGPIO",
                "MX_I2C1_Init": "initializeI2C1",
                "MX_USART1_UART_Init": "initializeUART1",
                "MX_TIM2_Init": "initializeTIM2",
                "MX_TIM1_Init": "initializeTIM1",
                "HAL_TIM_PWM_Start": "startTIMPWM",
                "mpu6050_init": "initializeMPU6050",
                "HAL_TIM_Base_Start_IT": "startTIMBaseIT",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "startForkserver",
                "MX_USART1_UART_Init",
                "MX_TIM1_Init",
                "MX_GPIO_Init",
                "mpu6050_init",
                "HAL_TIM_Base_Start_IT",
                "MX_I2C1_Init",
                "HAL_Init",
                "HAL_TIM_PWM_Start",
                "MX_TIM2_Init",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052a0": {
            "entrypoint": "0x080052a0",
            "current_name": "initialize_system_080052a0",
            "code": "\nvoid initializeSystem_080052a0(void)\n\n{\n  int result;\n  undefined8 hclkFreq;\n  undefined4 oscillatorConfig;\n  undefined4 clockConfig;\n  undefined4 clockSourceConfig;\n  undefined4 priority;\n  undefined4 priority;\n  undefined4 pwrOscillatorConfig;\n  undefined4 flashLatency;\n  undefined4 voltageScale;\n  undefined4 sysclkSource;\n  undefined4 ahbPrescaler;\n  undefined4 apb1Prescaler;\n  undefined4 apb2Prescaler;\n  \n  pwrOscillatorConfig = 1;\n  flashLatency = 0x10000;\n  voltageScale = 0;\n  sysclkSource = 1;\n  ahbPrescaler = 2;\n  apb1Prescaler = 0x10000;\n  apb2Prescaler = 0x1c0000;\n  result = HAL_RCC_OscConfig(&pwrOscillatorConfig);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",0x151);\n  }\n  oscillatorConfig = 0xf;\n  clockConfig = 2;\n  clockSourceConfig = 0x80;\n  priority = 0;\n  priority = 0;\n  result = HAL_RCC_ClockConfig(&oscillatorConfig,2);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",0x15e);\n  }\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config((uint)hclkFreq / 1000,(int)((ulonglong)hclkFreq >> 0x20),(uint)hclkFreq * 0x10624dd3);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(0xffffffff,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052a0": "initialize_system_080052a0",
                "local_44": "oscillatorConfig",
                "local_40": "clockConfig",
                "local_3c": "clockSourceConfig",
                "local_38": "priority",
                "local_34": "priority",
                "local_30": "pwrOscillatorConfig",
                "local_2c": "flashLatency",
                "local_28": "voltageScale",
                "local_20": "sysclkSource",
                "local_14": "ahbPrescaler",
                "local_10": "apb1Prescaler",
                "local_c": "apb2Prescaler",
                "iVar1": "result",
                "uVar2": "hclkFreq"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq",
                "_Error_Handler",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_ClockConfig",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_SYSTICK_Config",
                "HAL_RCC_OscConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005348": {
            "entrypoint": "0x08005348",
            "current_name": "initialize_i2_c_08005348",
            "code": "\nvoid initializeI2C_08005348(void)\n\n{\n  int initStatus;\n  \n  DAT_20000a88 = 0x40005400;\n  DAT_20000a8c = 400000;\n  DAT_20000a90 = 0;\n  DAT_20000a94 = 0;\n  DAT_20000a98 = 0x4000;\n  DAT_20000a9c = 0;\n  DAT_20000aa0 = 0;\n  DAT_20000aa4 = 0;\n  DAT_20000aa8 = 0;\n  initStatus = HAL_I2C_Init(&DAT_20000a88);\n  if (initStatus != 0) {\n    _Error_Handler(\"../src/main.c\",0x17a);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005348": "initialize_i2_c_08005348",
                "iVar1": "initStatus"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_I2C_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053b0": {
            "entrypoint": "0x080053b0",
            "current_name": "initialize_timer_080053b0",
            "code": "\nvoid initializeTimer_080053b0(void)\n\n{\n  int initResult;\n  undefined4 breakDeadTime;\n  undefined4 unused1;\n  undefined4 unused2;\n  undefined4 unused3;\n  undefined4 unused4;\n  undefined4 deadTime;\n  undefined4 unused5;\n  undefined4 pwmConfig;\n  undefined4 unused6;\n  undefined4 unused7;\n  undefined4 unused8;\n  undefined4 unused9;\n  undefined4 unused10;\n  undefined4 unused11;\n  undefined4 synchronization;\n  undefined4 unused12;\n  undefined4 clockSource [4];\n  \n  DAT_20000b1c = 0x40012c00;\n  DAT_20000b20 = 0x708;\n  DAT_20000b24 = 0;\n  DAT_20000b28 = 100;\n  DAT_20000b2c = 0;\n  DAT_20000b30 = 0;\n  DAT_20000b34 = 0;\n  initResult = HAL_TIM_Base_Init(&DAT_20000b1c);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",399);\n  }\n  clockSource[0] = 0x1000;\n  initResult = HAL_TIM_ConfigClockSource(&DAT_20000b1c,clockSource);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x194);\n  }\n  initResult = HAL_TIM_PWM_Init(&DAT_20000b1c);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x198);\n  }\n  synchronization = 0;\n  unused12 = 0;\n  initResult = HAL_TIMEx_MasterConfigSynchronization(&DAT_20000b1c,&synchronization);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x19f);\n  }\n  pwmConfig = 0x60;\n  unused6 = 0;\n  unused7 = 0;\n  unused8 = 0;\n  unused9 = 0;\n  unused10 = 0;\n  unused11 = 0;\n  initResult = HAL_TIM_PWM_ConfigChannel(&DAT_20000b1c,&pwmConfig,0);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x1ab);\n  }\n  initResult = HAL_TIM_PWM_ConfigChannel(&DAT_20000b1c,&pwmConfig,0xc);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x1b0);\n  }\n  breakDeadTime = 0;\n  unused1 = 0;\n  unused2 = 0;\n  unused3 = 0;\n  unused4 = 0;\n  deadTime = 0x2000;\n  unused5 = 0;\n  initResult = HAL_TIMEx_ConfigBreakDeadTime(&DAT_20000b1c,&breakDeadTime);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x1bc);\n  }\n  HAL_TIM_MspPostInit(&DAT_20000b1c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053b0": "initialize_timer_080053b0",
                "iVar1": "initResult",
                "local_58": "breakDeadTime",
                "local_54": "unused1",
                "local_50": "unused2",
                "local_4c": "unused3",
                "local_48": "unused4",
                "local_44": "deadTime",
                "local_40": "unused5",
                "local_3c": "pwmConfig",
                "local_38": "unused6",
                "local_34": "unused7",
                "local_30": "unused8",
                "local_2c": "unused9",
                "local_28": "unused10",
                "local_24": "unused11",
                "local_20": "synchronization",
                "local_1c": "unused12",
                "local_18": "clockSource"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_ConfigClockSource",
                "_Error_Handler",
                "HAL_TIM_Base_Init",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_MspPostInit",
                "HAL_TIMEx_MasterConfigSynchronization"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005500": {
            "entrypoint": "0x08005500",
            "current_name": "initialize_timer_08005500",
            "code": "\nvoid initializeTimer_08005500(void)\n\n{\n  int initResult;\n  undefined4 prescalerValue;\n  undefined4 counterMode;\n  undefined4 clockConfiguration [4];\n  \n  DAT_20000b60 = 0x40000000;\n  DAT_20000b64 = 36000;\n  DAT_20000b68 = 0;\n  DAT_20000b6c = 0x14;\n  DAT_20000b70 = 0;\n  DAT_20000b78 = 0;\n  initResult = HAL_TIM_Base_Init(&DAT_20000b60);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x1d0);\n  }\n  clockConfiguration[0] = 0x1000;\n  initResult = HAL_TIM_ConfigClockSource(&DAT_20000b60,clockConfiguration);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x1d5);\n  }\n  prescalerValue = 0x20;\n  counterMode = 0;\n  initResult = HAL_TIMEx_MasterConfigSynchronization(&DAT_20000b60,&prescalerValue);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x1dc);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005500": "initialize_timer_08005500",
                "local_20": "prescalerValue",
                "local_1c": "counterMode",
                "local_18": "clockConfiguration",
                "iVar1": "initResult"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIM_ConfigClockSource",
                "_Error_Handler",
                "HAL_TIM_Base_Init",
                "HAL_TIMEx_MasterConfigSynchronization"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005598": {
            "entrypoint": "0x08005598",
            "current_name": "initialize_uart_08005598",
            "code": "\nvoid initializeUART_08005598(void)\n\n{\n  int initResult;\n  \n  DAT_20000adc = 0x40013800;\n  DAT_20000ae0 = 0x1c200;\n  DAT_20000ae4 = 0;\n  DAT_20000ae8 = 0;\n  DAT_20000aec = 0;\n  DAT_20000af0 = 0xc;\n  DAT_20000af4 = 0;\n  DAT_20000af8 = 0;\n  initResult = HAL_UART_Init(&DAT_20000adc);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x1ed);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005598": "initialize_uart_08005598",
                "iVar1": "initResult"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_UART_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055f4": {
            "entrypoint": "0x080055f4",
            "current_name": "initialize_gpio_080055f4",
            "code": "\n\n\nvoid initializeGPIO_080055f4(void)\n\n{\n  undefined4 pin;\n  undefined4 state;\n  undefined4 mode;\n  \n  _DAT_40021018 = _DAT_40021018 | 0x2c;\n  HAL_GPIO_WritePin(0x40010800,0x1e,0,_DAT_40021018 & 8);\n  pin = 0x1e;\n  state = 1;\n  mode = 2;\n  HAL_GPIO_Init(0x40010800,&pin);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055f4": "initialize_gpio_080055f4",
                "local_18": "pin",
                "local_14": "state",
                "local_c": "mode"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_GPIO_Init",
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005674": {
            "entrypoint": "0x08005674",
            "current_name": "run_infinite_loop_08005674",
            "code": "\nvoid RunInfiniteLoop_08005674(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005674": "run_infinite_loop_08005674"
            },
            "calling": [
                "MX_USART1_UART_Init",
                "MX_TIM1_Init",
                "MX_I2C1_Init",
                "SystemClock_Config",
                "MX_TIM2_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005680": {
            "entrypoint": "0x08005680",
            "current_name": "initialize_gpio_08005680",
            "code": "\nvoid initializeGPIO_08005680(int *gpioAddress)\n\n{\n  undefined4 modeRegister;\n  undefined4 outputPin;\n  undefined4 inputPin;\n  \n  if (*gpioAddress == 0x40012c00) {\n    modeRegister = 0x900;\n    outputPin = 2;\n    inputPin = 2;\n    HAL_GPIO_Init(0x40010800,&modeRegister);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005680": "initialize_gpio_08005680",
                "param_1": "gpioAddress",
                "local_18": "modeRegister",
                "local_14": "outputPin",
                "local_c": "inputPin"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005704": {
            "entrypoint": "0x08005704",
            "current_name": "update_system_tick_08005704",
            "code": "\nvoid updateSystemTick_08005704(void)\n\n{\n  incrementSystemTick();\n  handleSystemTickInterrupt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005704": "update_system_tick_08005704",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSystemTickInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "handle_tim_interrupt_08005714",
            "code": "\nvoid handle_TIM_interrupt_08005714(void)\n\n{\n  HAL_TIM_IRQHandler(&DAT_20000b60);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005714": "handle_tim_interrupt_08005714"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "allocate_memory_08005728",
            "code": "\nundefined * allocateMemory_08005728(int size)\n\n{\n  undefined4 *errorPtr;\n  undefined *allocatedMemory;\n  undefined stackBuffer [4];\n  int remainingSize;\n  undefined *currentPtr;\n  \n  if (DAT_20000a10 == (undefined *)0x0) {\n    DAT_20000a10 = &DAT_20000c18;\n  }\n  currentPtr = DAT_20000a10;\n  if (stackBuffer < DAT_20000a10 + size) {\n    remainingSize = size;\n    errorPtr = (undefined4 *)__errno();\n    *errorPtr = 0xc;\n    allocatedMemory = (undefined *)0xffffffff;\n  }\n  else {\n    allocatedMemory = DAT_20000a10;\n    DAT_20000a10 = DAT_20000a10 + size;\n  }\n  return allocatedMemory;\n}\n\n",
            "renaming": {
                "FUN_08005728": "allocate_memory_08005728",
                "param_1": "size",
                "puVar1": "errorPtr",
                "puVar2": "allocatedMemory",
                "auStack_18": "stackBuffer",
                "local_14": "remainingSize",
                "local_c": "currentPtr"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [
                "__errno"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005780": {
            "entrypoint": "0x08005780",
            "current_name": "initialize_peripheral_08005780",
            "code": "\n\n\nvoid initializePeripheral_08005780(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005780": "initialize_peripheral_08005780"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057e8": {
            "entrypoint": "0x080057e8",
            "current_name": "initialize_memory_080057e8",
            "code": "\nvoid initializeMemory_080057e8(void)\n\n{\n  int offset;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (offset = 0; (undefined4 *)(offset + 0x20000000) < &DAT_200009c8; offset = offset + 4) {\n    *(undefined4 *)(offset + 0x20000000) = *(undefined4 *)(offset + 0x800a1a4);\n  }\n  for (ptr = &DAT_200009c8; ptr < &DAT_20000c14; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x800581a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057e8": "initialize_memory_080057e8",
                "iVar1": "offset",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005834": {
            "entrypoint": "0x08005834",
            "current_name": "FUN_08005834",
            "code": "\nuint __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  undefined8 uVar6;\n  \n  uVar4 = param_4 & 0x7fffffff;\n  if ((0x7ff00000 < (uVar4 | (-param_3 | param_3) >> 0x1f)) ||\n     (uVar5 = param_2 & 0x7fffffff, 0x7ff00000 < (uVar5 | (-param_1 | param_1) >> 0x1f))) {\n    uVar4 = __aeabi_dadd(param_3,param_4,param_1,param_2);\n    return uVar4;\n  }\n  if ((param_4 + 0xc0100000 | param_3) == 0) {\n    uVar4 = atan();\n    return uVar4;\n  }\n  uVar3 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n  if ((uVar5 | param_1) == 0) {\n    if (uVar3 == 2) {\n      return 0x54442d18;\n    }\n    if (uVar3 != 3) {\n      return param_1;\n    }\n  }\n  else if ((uVar4 | param_3) != 0) {\n    if (uVar4 == 0x7ff00000) {\n      if (uVar5 == 0x7ff00000) {\n        if (uVar3 == 2) {\n          return 0x7f3321d2;\n        }\n        if (uVar3 == 3) {\n          return 0x7f3321d2;\n        }\n        if (uVar3 == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (uVar3 == 2) {\n        return 0x54442d18;\n      }\n      if (uVar3 != 3) {\n        if (uVar3 != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (uVar5 != 0x7ff00000) {\n      iVar1 = (int)(uVar5 - uVar4) >> 0x14;\n      if (iVar1 < 0x3d) {\n        if (((int)param_4 < 0) && (iVar1 + 0x3c < 0 != SCARRY4(iVar1,0x3c))) {\n          uVar6 = 0;\n        }\n        else {\n          __divdf3(param_1,param_2,param_3,param_4,param_4);\n          fabs();\n          uVar6 = atan();\n        }\n      }\n      else {\n        uVar6 = 0x3ff921fb54442d18;\n      }\n      uVar2 = (undefined4)((ulonglong)uVar6 >> 0x20);\n      uVar4 = (uint)uVar6;\n      if (uVar3 == 1) {\n        return uVar4;\n      }\n      if (uVar3 == 2) {\n        uVar6 = __subdf3(uVar4,uVar2,0x33145c07,0x3ca1a626);\n        uVar4 = __subdf3(0x54442d18,0x400921fb,(int)uVar6,(int)((ulonglong)uVar6 >> 0x20));\n        return uVar4;\n      }\n      if (uVar3 != 0) {\n        uVar6 = __subdf3(uVar4,uVar2,0x33145c07,0x3ca1a626);\n        uVar4 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),0x54442d18,0x400921fb);\n        return uVar4;\n      }\n      return uVar4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {},
            "calling": [
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005838": {
            "entrypoint": "0x08005838",
            "current_name": "calculate_arc_tan_08005838",
            "code": "\nuint calculateArcTan_08005838(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  int temp_var_1;\n  undefined4 temp_var_2;\n  uint temp_var_3;\n  uint temp_var_4;\n  uint temp_var_5;\n  undefined8 temp_var_6;\n  \n  temp_var_4 = input_4 & 0x7fffffff;\n  if ((0x7ff00000 < (temp_var_4 | (-input_3 | input_3) >> 0x1f)) ||\n     (temp_var_5 = input_2 & 0x7fffffff, 0x7ff00000 < (temp_var_5 | (-input_1 | input_1) >> 0x1f))) {\n    temp_var_4 = __aeabi_dadd(input_3,input_4,input_1,input_2);\n    return temp_var_4;\n  }\n  if ((input_4 + 0xc0100000 | input_3) == 0) {\n    temp_var_4 = atan();\n    return temp_var_4;\n  }\n  temp_var_3 = (int)input_4 >> 0x1e & 2U | input_2 >> 0x1f;\n  if ((temp_var_5 | input_1) == 0) {\n    if (temp_var_3 == 2) {\n      return 0x54442d18;\n    }\n    if (temp_var_3 != 3) {\n      return input_1;\n    }\n  }\n  else if ((temp_var_4 | input_3) != 0) {\n    if (temp_var_4 == 0x7ff00000) {\n      if (temp_var_5 == 0x7ff00000) {\n        if (temp_var_3 == 2) {\n          return 0x7f3321d2;\n        }\n        if (temp_var_3 == 3) {\n          return 0x7f3321d2;\n        }\n        if (temp_var_3 == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (temp_var_3 == 2) {\n        return 0x54442d18;\n      }\n      if (temp_var_3 != 3) {\n        if (temp_var_3 != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (temp_var_5 != 0x7ff00000) {\n      temp_var_1 = (int)(temp_var_5 - temp_var_4) >> 0x14;\n      if (temp_var_1 < 0x3d) {\n        if (((int)input_4 < 0) && (temp_var_1 + 0x3c < 0 != SCARRY4(temp_var_1,0x3c))) {\n          temp_var_6 = 0;\n        }\n        else {\n          __divdf3(input_1,input_2,input_3,input_4,input_4);\n          fabs();\n          temp_var_6 = atan();\n        }\n      }\n      else {\n        temp_var_6 = 0x3ff921fb54442d18;\n      }\n      temp_var_2 = (undefined4)((ulonglong)temp_var_6 >> 0x20);\n      temp_var_4 = (uint)temp_var_6;\n      if (temp_var_3 == 1) {\n        return temp_var_4;\n      }\n      if (temp_var_3 == 2) {\n        temp_var_6 = __subdf3(temp_var_4,temp_var_2,0x33145c07,0x3ca1a626);\n        temp_var_4 = __subdf3(0x54442d18,0x400921fb,(int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20));\n        return temp_var_4;\n      }\n      if (temp_var_3 != 0) {\n        temp_var_6 = __subdf3(temp_var_4,temp_var_2,0x33145c07,0x3ca1a626);\n        temp_var_4 = __subdf3((int)temp_var_6,(int)((ulonglong)temp_var_6 >> 0x20),0x54442d18,0x400921fb);\n        return temp_var_4;\n      }\n      return temp_var_4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "FUN_08005838": "calculate_arc_tan_08005838",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "temp_var_1",
                "uVar2": "temp_var_2",
                "uVar3": "temp_var_3",
                "uVar4": "temp_var_4",
                "uVar5": "temp_var_5",
                "uVar6": "temp_var_6"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "__aeabi_dadd",
                "atan",
                "__divdf3",
                "fabs",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f0": {
            "entrypoint": "0x080059f0",
            "current_name": "calculate_better_080059f0",
            "code": "\nundefined8 calculateBetter_080059f0(int input1,uint input2,undefined4 constant1,undefined4 constant2)\n\n{\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  undefined4 temp4;\n  undefined4 temp5;\n  undefined4 temp6;\n  uint temp7;\n  int index;\n  undefined8 result1;\n  undefined8 result2;\n  \n  result2 = CONCAT44(input2,input1);\n  temp7 = input2 & 0x7fffffff;\n  if (temp7 < 0x44100000) {\n    if (temp7 < 0x3fdc0000) {\n      if (temp7 < 0x3e200000) {\n        result1 = __aeabi_dadd(input1,input2,0x8800759c,0x7e37e43c,constant2);\n        index = __aeabi_dcmpgt((int)result1,(int)((ulonglong)result1 >> 0x20),0,0x3ff00000);\n        if (index != 0) {\n          return CONCAT44(input2,input1);\n        }\n      }\n      index = -1;\n    }\n    else {\n      result2 = fabs();\n      temp4 = (undefined4)((ulonglong)result2 >> 0x20);\n      temp1 = (undefined4)result2;\n      if (temp7 < 0x3ff30000) {\n        if (temp7 < 0x3fe60000) {\n          result2 = __aeabi_dadd(temp1,temp4,temp1,temp4);\n          result2 = __subdf3((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x3ff00000);\n          result1 = __aeabi_dadd(temp1,temp4,0,0x40000000);\n          result2 = __divdf3((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                            (int)((ulonglong)result1 >> 0x20));\n          index = 0;\n        }\n        else {\n          result2 = __subdf3(temp1,temp4,0,0x3ff00000);\n          result1 = __aeabi_dadd(temp1,temp4,0,0x3ff00000);\n          result2 = __divdf3((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                            (int)((ulonglong)result1 >> 0x20));\n          index = 1;\n        }\n      }\n      else if (temp7 < 0x40038000) {\n        result2 = __subdf3(temp1,temp4,0,0x3ff80000);\n        result1 = __muldf3(temp1,temp4,0,0x3ff80000);\n        result1 = __aeabi_dadd((int)result1,(int)((ulonglong)result1 >> 0x20),0,0x3ff00000);\n        result2 = __divdf3((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                          (int)((ulonglong)result1 >> 0x20));\n        index = 2;\n      }\n      else {\n        result2 = __divdf3(0,0xbff00000,temp1,temp4);\n        index = 3;\n      }\n    }\n    temp6 = (undefined4)((ulonglong)result2 >> 0x20);\n    temp5 = (undefined4)result2;\n    result2 = __muldf3(temp5,temp6,temp5,temp6);\n    temp2 = (undefined4)((ulonglong)result2 >> 0x20);\n    temp1 = (undefined4)result2;\n    result2 = __muldf3(temp1,temp2,temp1,temp2);\n    temp3 = (undefined4)((ulonglong)result2 >> 0x20);\n    temp4 = (undefined4)result2;\n    result2 = __muldf3(temp4,temp3,0xe322da11,0x3f90ad3a);\n    result2 = __aeabi_dadd((int)result2,(int)((ulonglong)result2 >> 0x20),0x24760deb,0x3fa97b4b);\n    result2 = __muldf3((int)result2,(int)((ulonglong)result2 >> 0x20),temp4,temp3);\n    result2 = __aeabi_dadd((int)result2,(int)((ulonglong)result2 >> 0x20),0xa0d03d51,0x3fb10d66);\n    result2 = __muldf3((int)result2,(int)((ulonglong)result2 >> 0x20),temp4,temp3);\n    result2 = __aeabi_dadd((int)result2,(int)((ulonglong)result2 >> 0x20),0xc54c206e,0x3fb745cd);\n    result2 = __muldf3((int)result2,(int)((ulonglong)result2 >> 0x20),temp4,temp3);\n    result2 = __aeabi_dadd((int)result2,(int)((ulonglong)result2 >> 0x20),0x920083ff,0x3fc24924);\n    result2 = __muldf3((int)result2,(int)((ulonglong)result2 >> 0x20),temp4,temp3);\n    result2 = __aeabi_dadd((int)result2,(int)((ulonglong)result2 >> 0x20),0x5555550d,0x3fd55555);\n    result2 = __muldf3((int)result2,(int)((ulonglong)result2 >> 0x20),temp1,temp2);\n    result1 = __muldf3(temp4,temp3,0x2c6a6c2f,0xbfa2b444);\n    result1 = __subdf3((int)result1,(int)((ulonglong)result1 >> 0x20),0x52defd9a,0x3fadde2d);\n    result1 = __muldf3((int)result1,(int)((ulonglong)result1 >> 0x20),temp4,temp3);\n    result1 = __subdf3((int)result1,(int)((ulonglong)result1 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    result1 = __muldf3((int)result1,(int)((ulonglong)result1 >> 0x20),temp4,temp3);\n    result1 = __subdf3((int)result1,(int)((ulonglong)result1 >> 0x20),0xfe231671,0x3fbc71c6);\n    result1 = __muldf3((int)result1,(int)((ulonglong)result1 >> 0x20),temp4,temp3);\n    result1 = __subdf3((int)result1,(int)((ulonglong)result1 >> 0x20),0x9998ebc4,0x3fc99999);\n    result1 = __muldf3((int)result1,(int)((ulonglong)result1 >> 0x20),temp4,temp3);\n    result2 = __aeabi_dadd((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                          (int)((ulonglong)result1 >> 0x20));\n    result2 = __muldf3((int)result2,(int)((ulonglong)result2 >> 0x20),temp5,temp6);\n    temp1 = (undefined4)((ulonglong)result2 >> 0x20);\n    if (index == -1) {\n      result2 = __subdf3(temp5,temp6,(int)result2,temp1);\n      return result2;\n    }\n    index = index * 8;\n    result2 = __subdf3((int)result2,temp1,*(undefined4 *)(&UNK_08009ee8 + index),\n                      *(undefined4 *)(&UNK_08009eec + index));\n    result2 = __subdf3((int)result2,(int)((ulonglong)result2 >> 0x20),temp5,temp6);\n    result2 = __subdf3(*(undefined4 *)(&UNK_08009ec8 + index),*(undefined4 *)(&UNK_08009ecc + index),\n                      (int)result2,(int)((ulonglong)result2 >> 0x20));\n    if ((int)input2 < 0) {\n      return CONCAT44((int)((ulonglong)result2 >> 0x20) + -0x80000000,(int)result2);\n    }\n  }\n  else {\n    if ((temp7 < 0x7ff00001) && ((temp7 != 0x7ff00000 || (input1 == 0)))) {\n      temp1 = 0xbff921fb;\n      if (0 < (int)input2) {\n        temp1 = 0x3ff921fb;\n      }\n      return CONCAT44(temp1,0x54442d18);\n    }\n    result2 = __aeabi_dadd(input1,input2,input1,input2,constant2);\n  }\n  return result2;\n}\n\n",
            "renaming": {
                "FUN_080059f0": "calculate_better_080059f0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "constant1",
                "param_4": "constant2",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "temp7",
                "iVar8": "index",
                "uVar9": "result1",
                "uVar10": "result2"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "fabs",
                "__subdf3",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d0c": {
            "entrypoint": "0x08005d0c",
            "current_name": "FUNC_08005d0c",
            "code": "\nvoid FUNC_08005d0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d0c": "FUNC_08005d0c"
            },
            "calling": [
                "atan",
                "__ieee754_atan2"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005d14": {
            "entrypoint": "0x08005d14",
            "current_name": "get_data_08005d14",
            "code": "\nundefined4 get_data_08005d14(void)\n\n{\n  return DAT_2000001c;\n}\n\n",
            "renaming": {
                "FUN_08005d14": "get_data_08005d14"
            },
            "calling": [
                "_sbrk"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d20": {
            "entrypoint": "0x08005d20",
            "current_name": "initialize_and_execute_08005d20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005d2c) */\n/* WARNING: Removing unreachable block (ram,0x08005d2e) */\n\nvoid initializeAndExecute_08005d20(void)\n\n{\n  int counter;\n  code **functionPointer;\n  \n  initialize();\n  counter = 0;\n  functionPointer = (code **)&DAT_0800a198;\n  do {\n    counter = counter + 1;\n    (**functionPointer)();\n    functionPointer = functionPointer + 1;\n  } while (counter != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d20": "initialize_and_execute_08005d20",
                "iVar1": "counter",
                "ppcVar2": "functionPointer",
                "_init": "initialize"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "register_fini",
                "frame_dummy",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d68": {
            "entrypoint": "0x08005d68",
            "current_name": "fill_memory_08005d68",
            "code": "\nvoid fillMemory_08005d68(undefined4 *dest,undefined value,uint size)\n\n{\n  undefined4 *destPtr1;\n  undefined4 *destPtr2;\n  uint remainingSize;\n  undefined4 fourByteValue;\n  bool isZeroSize;\n  \n  if (((uint)dest & 3) != 0) {\n    remainingSize = size - 1;\n    destPtr1 = dest;\n    if (size == 0) {\n      return;\n    }\n    while( true ) {\n      dest = (undefined4 *)((int)destPtr1 + 1);\n      *(undefined *)destPtr1 = value;\n      size = remainingSize;\n      if (((uint)dest & 3) == 0) break;\n      isZeroSize = remainingSize == 0;\n      remainingSize = remainingSize - 1;\n      destPtr1 = dest;\n      if (isZeroSize) {\n        return;\n      }\n    }\n  }\n  if (3 < size) {\n    fourByteValue = CONCAT22(CONCAT11(value,value),CONCAT11(value,value));\n    remainingSize = size;\n    destPtr1 = dest;\n    if (0xf < size) {\n      remainingSize = size - 0x10;\n      destPtr1 = dest + 4;\n      do {\n        destPtr1[-4] = fourByteValue;\n        destPtr1[-3] = fourByteValue;\n        destPtr1[-2] = fourByteValue;\n        destPtr1[-1] = fourByteValue;\n        destPtr1 = destPtr1 + 4;\n      } while (destPtr1 != (undefined4 *)((int)dest + (remainingSize & 0xfffffff0) + 0x20));\n      size = size & 0xf;\n      dest = dest + ((remainingSize >> 4) + 1) * 4;\n      remainingSize = size;\n      destPtr1 = dest;\n      if (size < 4) goto LAB_08005de4;\n    }\n    do {\n      size = size - 4;\n      *dest = fourByteValue;\n      dest = dest + 1;\n    } while (3 < size);\n    dest = (undefined4 *)((int)destPtr1 + (remainingSize - 4 & 0xfffffffc) + 4);\n    size = remainingSize & 3;\n  }\nLAB_08005de4:\n  if (size != 0) {\n    destPtr1 = dest;\n    do {\n      destPtr2 = (undefined4 *)((int)destPtr1 + 1);\n      *(undefined *)destPtr1 = value;\n      destPtr1 = destPtr2;\n    } while ((undefined4 *)(size + (int)dest) != destPtr2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d68": "fill_memory_08005d68",
                "param_1": "dest",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "destPtr1",
                "puVar2": "destPtr2",
                "uVar3": "remainingSize",
                "uVar4": "fourByteValue",
                "bVar5": "isZeroSize"
            },
            "calling": [
                "_calloc_r",
                "flush_strbuf"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dfc": {
            "entrypoint": "0x08005dfc",
            "current_name": "print_formatted_string_08005dfc",
            "code": "\nvoid printFormattedString_08005dfc(undefined *outputBuffer,undefined4 formatString,undefined4 arg1,undefined4 arg2)\n\n{\n  undefined *bufferArray [2];\n  undefined4 maxOutputLength;\n  undefined4 constValue;\n  undefined *currentBuffer;\n  undefined4 maxBufferLength;\n  undefined4 ptrArg1;\n  undefined4 ptrArg2;\n  \n  maxBufferLength = 0x7fffffff;\n  maxOutputLength = 0x7fffffff;\n  constValue = 0xffff0208;\n  bufferArray[0] = outputBuffer;\n  currentBuffer = outputBuffer;\n  ptrArg1 = arg1;\n  ptrArg2 = arg2;\n  _svfprintf_r(DAT_2000001c,bufferArray,formatString,&ptrArg1);\n  *bufferArray[0] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005dfc": "print_formatted_string_08005dfc",
                "param_1": "outputBuffer",
                "param_2": "formatString",
                "param_3": "arg1",
                "param_4": "arg2",
                "local_80": "bufferArray",
                "local_78": "maxOutputLength",
                "uStack_74": "constValue",
                "local_70": "currentBuffer",
                "local_6c": "maxBufferLength",
                "uStack_8": "ptrArg1",
                "uStack_4": "ptrArg2"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "_svfprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e40": {
            "entrypoint": "0x08005e40",
            "current_name": "calculate_lz_count_08005e40",
            "code": "\nint calculateLZCount_08005e40(uint inputValue)\n\n{\n  int extraBits;\n  uint *ptr;\n  uint value;\n  \n  ptr = (uint *)(inputValue & 0xfffffffc);\n  extraBits = -(inputValue & 3);\n  value = *ptr;\n  if ((inputValue & 3) != 0) {\n    value = value | 0xffffffffU >> ((extraBits + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    ptr = ptr + 1;\n    value = value + 0xfefefeff & ~value & 0x80808080;\n    if (value != 0) break;\n    value = *ptr;\n    extraBits = extraBits + 4;\n  }\n  return extraBits + (0x1fU - leadingZeroesCount(value & -value) >> 3);\n}\n\n",
            "renaming": {
                "FUN_08005e40": "calculate_lz_count_08005e40",
                "param_1": "inputValue",
                "iVar1": "extraBits",
                "puVar2": "ptr",
                "uVar3": "value",
                "LZCOUNT": "leadingZeroesCount"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e9c": {
            "entrypoint": "0x08005e9c",
            "current_name": "FUNC_08005e9c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  int iVar8;\n  int *piVar9;\n  undefined4 uVar10;\n  int **ppiVar11;\n  undefined uVar12;\n  ushort uVar13;\n  int **ppiVar14;\n  byte **ppbVar15;\n  int *piVar16;\n  int **ppiVar17;\n  char *pcVar18;\n  uint uVar19;\n  undefined *puVar20;\n  int *piVar21;\n  int *piVar22;\n  int *piVar23;\n  int *piVar24;\n  int *piVar25;\n  byte *pbVar26;\n  int *piVar27;\n  int *piVar28;\n  undefined4 *puVar29;\n  byte *pbVar30;\n  bool bVar31;\n  longlong lVar32;\n  undefined8 uVar33;\n  undefined8 uVar34;\n  undefined4 local_188;\n  int *piStack_184;\n  int **local_180;\n  undefined *puStack_17c;\n  int **local_178;\n  undefined4 *local_16c;\n  int *local_168;\n  byte *local_164;\n  int *local_160;\n  int *local_15c;\n  char *local_158;\n  int **local_154;\n  undefined8 local_150;\n  int *local_148;\n  int *local_144;\n  int *local_140;\n  int **local_13c;\n  int *local_138;\n  int *local_134;\n  int *local_130;\n  uint local_12c;\n  undefined4 local_128;\n  undefined4 local_124;\n  undefined4 local_120;\n  char *local_11c;\n  int *local_118;\n  int *local_114;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  int *local_100;\n  int *local_fc;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0;\n  undefined auStack_ec [4];\n  char local_e8;\n  undefined local_e7;\n  char local_e6 [6];\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int *local_d4;\n  int *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  local_16c = param_1;\n  local_160 = param_2;\n  local_154 = param_4;\n  ppiVar2 = (int **)_localeconv_r();\n  local_114 = *ppiVar2;\n  local_118 = (int *)strlen(local_114);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar3 = _malloc_r(local_16c,0x40);\n    *local_160 = iVar3;\n    local_160[4] = iVar3;\n    if (iVar3 == 0) {\n      *local_16c = 0xc;\n      return (byte *)0xffffffff;\n    }\n    local_160[5] = 0x40;\n  }\n  local_128 = 0;\n  local_138 = (int *)0x0;\n  local_12c = 0;\n  local_d4 = (int *)0x0;\n  local_d0 = (int *)0x0;\n  local_11c = (char *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  local_124 = 0;\n  local_120 = 0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = local_164 + (int)piVar27;\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    piVar25 = (int *)0x0;\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    puVar29 = local_16c;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    switch(piVar24) {\n    case (int *)0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (piVar24 == (int *)0x0) goto LAB_08006216;\n      piVar16 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_158 = (char *)0x1;\n      piVar23 = (int *)&local_8c;\n      piVar22 = piVar16;\n      local_8c = (char)piVar24;\n      goto LAB_08006298;\n    case (int *)0x23:\n      piVar25 = (int *)((uint)piVar25 | 1);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x27:\n      iVar3 = _localeconv_r(local_16c);\n      local_110 = *(int **)(iVar3 + 4);\n      piVar24 = (int *)strlen(local_110);\n      local_104 = piVar24;\n      iVar3 = _localeconv_r(puVar29);\n      local_108 = *(byte **)(iVar3 + 8);\n      if (piVar24 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 0x400);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2a:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2b:\n      local_f5 = 0x2b;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x2d:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\nLAB_08006602:\n      piVar25 = (int *)((uint)piVar25 | 4);\n      goto LAB_08005f4a;\n    case (int *)0x2e:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x2a) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (piVar24 + -0xc < (int *)0xa) {\n        piVar27 = (int *)((int)(piVar24 + -0xc) + (int)piVar27 * 10);\n        piVar24 = (int *)(uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case (int *)0x30:\n      piVar25 = (int *)((uint)piVar25 | 0x80);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x31:\n    case (int *)0x32:\n    case (int *)0x33:\n    case (int *)0x34:\n    case (int *)0x35:\n    case (int *)0x36:\n    case (int *)0x37:\n    case (int *)0x38:\n    case (int *)0x39:\n      goto switchD_08005f58_caseD_31;\n    case (int *)0x41:\n    case (int *)0x45:\n    case (int *)0x46:\n    case (int *)0x47:\n    case (int *)0x61:\n    case (int *)0x65:\n    case (int *)0x66:\n    case (int *)0x67:\n      puVar29 = (undefined4 *)((int)local_154 + 7U & 0xfffffff8);\n      uVar10 = *puVar29;\n      local_12c = puVar29[1];\n      local_168 = (int *)(local_12c & 0x7fffffff);\n      local_154 = (int **)(puVar29 + 2);\n      local_128 = uVar10;\n      iVar3 = __unorddf2(uVar10,local_168,0xffffffff,0x7fefffff);\n      if ((iVar3 == 0) &&\n         (iVar3 = __aeabi_dcmple(uVar10,local_168,0xffffffff,0x7fefffff), iVar3 == 0)) {\n        iVar3 = __aeabi_dcmplt(local_128,local_12c,local_124,local_120);\n        if (iVar3 == 0) {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        piVar23 = (int *)&UNK_08009f10;\n        piVar27 = (int *)&UNK_08009f0c;\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (piVar24 < (int *)0x48) {\n          piVar23 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar25 = (int *)((uint)piVar25 & 0xffffff7f);\n        local_158 = (char *)0x3;\n        local_13c = (int **)0x0;\n        piVar22 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      iVar3 = __unorddf2(local_128,local_12c,local_128,local_12c);\n      if (iVar3 != 0) {\n        if ((int)local_12c < 0) {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        piVar23 = (int *)&UNK_08009f18;\n        piVar27 = (int *)&UNK_08009f14;\n        goto LAB_08006524;\n      }\n      if (piVar24 == (int *)0x61) {\n        uVar12 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar12,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          piVar25 = (int *)((uint)piVar25 | 2);\n        }\n        else {\n          param_3 = (int *)_malloc_r(local_16c,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar13 = *(ushort *)(local_160 + 3) | 0x40;\n            *(ushort *)(local_160 + 3) = uVar13;\n            goto LAB_0800604e;\n          }\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          piVar25 = (int *)((uint)piVar25 | 2);\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = (int *)0x2d;\n          uVar19 = local_12c + 0x80000000;\n        }\n        else {\n          local_144 = (int *)0x0;\n          uVar19 = local_12c;\n        }\n        local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n        piVar22 = piVar27;\n        local_158 = (char *)local_128;\n        if (piVar24 == (int *)0x61) {\n          uVar33 = frexp(local_128,uVar19,&local_f0);\n          local_150 = __muldf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = __aeabi_dcmpeq((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                                 local_120);\n          if (iVar3 != 0) {\n            local_f0 = (int *)0x1;\n          }\n          local_158 = \"0123456789abcdef\";\n          local_13c = ppiVar2;\n          local_138 = piVar28;\n          local_134 = piVar24;\n          local_130 = piVar27;\n          local_100 = piVar25;\n          local_fc = param_3;\n          pcVar18 = local_158;\n          uVar33 = local_150;\n          goto LAB_080072ba;\n        }\n        if (piVar24 == (int *)0x41) {\n          uVar33 = frexp(local_128,uVar19,&local_f0);\n          local_150 = __muldf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = __aeabi_dcmpeq((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                                 local_120);\n          if (iVar3 == 0) {\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          else {\n            local_f0 = (int *)0x1;\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (piVar24 == (int *)0x41) {\n          uVar12 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = (int *)((uint)piVar25 | 0x100);\n        local_148 = (int *)0x0;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar27 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if (((uint)piVar24 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar27 = (int *)0x1;\n            local_148 = (int *)0x0;\n          }\n          goto LAB_0800724a;\n        }\n        if ((int)local_12c < 0) goto LAB_08007414;\n        local_144 = (int *)0x0;\n        uVar19 = local_12c;\n      }\n      local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n      piStack_184 = piVar27;\n      local_158 = (char *)local_128;\n      if (piVar24 == (int *)0x66) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)_dtoa_r(local_16c,local_180,local_128,uVar19);\n        piVar22 = (int *)((int)piVar23 + (int)piVar27);\n        local_150._0_4_ = piVar27;\nLAB_0800764c:\n        if ((*(byte *)piVar23 == 0x30) &&\n           (iVar3 = __aeabi_dcmpeq(local_158,uVar19,local_124,local_120), iVar3 == 0)) {\n          local_f0 = (int *)(1 - (int)(int *)local_150);\n        }\n        piVar22 = (int *)((int)piVar22 + (int)local_f0);\n      }\n      else if (piVar24 == (int *)0x46) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)_dtoa_r(local_16c,local_180,local_128,uVar19);\n        local_150._0_4_ = piVar27;\nLAB_08007760:\n        piVar22 = (int *)((int)piVar23 + (int)(int *)local_150);\n        if (piVar24 == (int *)0x46) goto LAB_0800764c;\n      }\n      else {\n        local_178 = &local_e0;\n        local_150._0_4_ = piVar27;\n        if (local_168 == (int *)0x45) {\n          local_150._0_4_ = (int *)((int)piVar27 + 1);\n        }\n        local_188 = 2;\n        piStack_184 = (int *)local_150;\n        local_180 = &local_f0;\n        puStack_17c = auStack_ec;\n        piVar23 = (int *)_dtoa_r(local_16c,local_180,local_128,uVar19);\n        piVar16 = local_e0;\n        if (piVar24 == (int *)0x67) {\n          if (((uint)piVar25 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (piVar24 == (int *)0x47) {\n          if (((uint)piVar25 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar22 = (int *)((int)(int *)local_150 + (int)piVar23);\n      }\n      iVar3 = __aeabi_dcmpeq(local_158,uVar19,local_124,local_120);\n      piVar16 = piVar22;\n      if (iVar3 == 0) {\n        for (; piVar16 = local_e0, local_e0 < piVar22; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)piVar16 - (int)piVar23);\n      goto LAB_08006cb0;\n    case (int *)0x43:\n    case (int *)0x63:\n      piVar16 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar22 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (char *)0x1;\n      local_8c = SUB41(piVar27,0);\n      piVar23 = (int *)&local_8c;\n      goto LAB_08006298;\n    case (int *)0x44:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_08006102;\n    case (int *)0x4c:\n      piVar25 = (int *)((uint)piVar25 | 8);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x4f:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n    case (int *)0x6f:\n      if (((uint)piVar25 & 0x20) == 0) {\n        ppiVar14 = local_154 + 1;\n        if (((uint)piVar25 & 0x10) == 0) {\n          if (((uint)piVar25 & 0x40) == 0) {\n            if (((uint)piVar25 & 0x200) == 0) goto LAB_08006be2;\n            piVar22 = (int *)(uint)*(byte *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n          else {\n            piVar22 = (int *)(uint)*(ushort *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar22 = *local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\n        ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar22 = *ppiVar14;\n        piVar16 = ppiVar14[1];\n        local_154 = ppiVar14 + 2;\n      }\n      iVar3 = 0;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n      break;\n    case (int *)0x53:\n    case (int *)0x73:\n      local_f5 = 0;\n      piVar23 = *local_154;\n      ppiVar14 = local_154 + 1;\n      if (piVar23 == (int *)0x0) {\n        if ((int *)0x5 < piVar27) {\n          piVar27 = (int *)0x6;\n        }\n        piVar23 = (int *)&UNK_08009f44;\n        piVar16 = (int *)0x0;\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar22 = (int *)0x0;\n        local_168 = piVar27;\n        local_158 = (char *)piVar27;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (piVar27 == (int *)0xffffffff) {\n          local_158 = (char *)strlen(piVar23);\n        }\n        else {\n          iVar3 = memchr(piVar23,0,piVar27);\n          if (iVar3 == 0) {\n            piVar16 = (int *)(uint)local_f5;\n            local_148 = (int *)0x0;\n            local_13c = (int **)0x0;\n            local_134 = (int *)0x0;\n            local_130 = (int *)0x0;\n            piVar22 = (int *)0x0;\n            local_168 = piVar27;\n            local_158 = (char *)piVar27;\n            local_154 = ppiVar14;\n            goto LAB_08006538;\n          }\n          local_158 = (char *)(iVar3 - (int)piVar23);\n        }\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar16 = (int *)(uint)local_f5;\n        piVar22 = (int *)0x0;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        local_154 = ppiVar14;\n      }\n      goto LAB_08006538;\n    case (int *)0x55:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      iVar3 = 1;\n      local_154 = ppiVar14 + 2;\n      break;\n    case (int *)0x58:\n      local_11c = \"0123456789ABCDEF\";\n      if (((uint)piVar25 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_080061be;\n    case (int *)0x64:\n    case (int *)0x69:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bcc:\n        piVar22 = *local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(int)*(short *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bcc;\n        piVar22 = (int *)(int)*(char *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\nLAB_08006102:\n      if ((int)piVar16 < 0) {\n        bVar31 = piVar22 != (int *)0x0;\n        piVar22 = (int *)-(int)piVar22;\n        piVar16 = (int *)(-(int)piVar16 - (uint)bVar31);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar3 = 1;\n        iVar8 = 1;\n        piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n        if (((uint)piVar22 | (uint)piVar16) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      piVar21 = piVar25;\n      if (piVar16 != (int *)0x0 || (int *)0x9 < piVar22) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case (int *)0x68:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x68) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar25 = (int *)((uint)piVar25 | 0x200);\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        piVar25 = (int *)((uint)piVar25 | 0x40);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x6a:\n    case (int *)0x71:\n      piVar25 = (int *)((uint)piVar25 | 0x20);\n    case (int *)0x74:\n    case (int *)0x7a:\nswitchD_08005f58_caseD_74:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case (int *)0x6e:\n      ppiVar14 = local_154 + 1;\n      ppbVar15 = (byte **)*local_154;\n      local_154 = ppiVar14;\n      if (((uint)piVar25 & 0x20) != 0) {\n        *ppbVar15 = local_164;\n        ppbVar15[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) != 0) {\n          *(short *)ppbVar15 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if (((uint)piVar25 & 0x200) != 0) {\n          *(char *)ppbVar15 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar15 = local_164;\n      goto LAB_0800620e;\n    case (int *)0x70:\n      local_f4 = 0x7830;\n      piVar22 = *local_154;\n      local_11c = \"0123456789abcdef\";\n      piVar25 = (int *)((uint)piVar25 | 2);\n      piVar16 = (int *)0x0;\n      iVar3 = 2;\n      piVar24 = (int *)0x78;\n      local_154 = local_154 + 1;\n      break;\n    case (int *)0x75:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bf2:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(uint)*(ushort *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bf2;\n        piVar22 = (int *)(uint)*(byte *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      break;\n    case (int *)0x78:\n      local_11c = \"0123456789abcdef\";\n      if (((uint)piVar25 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar14 = local_154 + 1;\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) == 0) {\n          if (((uint)piVar25 & 0x200) == 0) goto LAB_08006bbc;\n          piVar22 = (int *)(uint)*(byte *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n        else {\n          piVar22 = (int *)(uint)*(ushort *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        local_154 = ppiVar14;\n      }\nLAB_080061be:\n      if ((((uint)piVar25 & 1) != 0) && (((uint)piVar22 | (uint)piVar16) != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 2);\n        local_f4 = CONCAT11((char)piVar24,0x30);\n      }\n      iVar3 = 2;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      if (iVar3 != 1) goto LAB_08006136;\nLAB_08006980:\n      piVar21 = piVar25;\n      if (piVar16 == (int *)0x0 && piVar22 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar32 = CONCAT44(piVar16,piVar22);\n      piVar23 = (int *)(&bStack_2a + 2);\n      piVar22 = (int *)0x0;\n      pbVar26 = local_108;\n      local_168 = piVar23;\n      local_158 = (char *)ppiVar2;\n      local_150._0_4_ = piVar25;\n      local_148 = piVar24;\n      do {\n        iVar3 = (int)((ulonglong)lVar32 >> 0x20);\n        uVar19 = (uint)lVar32;\n        cVar6 = '\\n';\n        __aeabi_uldivmod(uVar19,iVar3,10,0);\n        *(byte *)((int)piVar23 + -1) = cVar6 + 0x30;\n        piVar22 = (int *)((int)piVar22 + 1);\n        piVar23 = (int *)((int)piVar23 + -1);\n        if ((((((uint)piVar25 & 0x400) != 0) && (piVar22 == (int *)(uint)*pbVar26)) &&\n            (piVar22 != (int *)0xff)) && (iVar3 != 0 || 9 < uVar19)) {\n          piVar23 = (int *)((int)piVar23 - (int)local_104);\n          strncpy(piVar23,local_110,local_104);\n          if (pbVar26[1] == 0) {\n            piVar22 = (int *)0x0;\n          }\n          else {\n            pbVar26 = pbVar26 + 1;\n            piVar22 = (int *)0x0;\n          }\n        }\n        lVar32 = __aeabi_uldivmod(uVar19,iVar3,10,0);\n      } while (lVar32 != 0);\n      piVar24 = local_148;\n      piVar25 = (int *)local_150;\n      ppiVar2 = (int **)local_158;\n      local_158 = (char *)((int)local_168 - (int)piVar23);\n      local_138 = piVar22;\n      local_108 = pbVar26;\n    }\n    else {\n      piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n      iVar8 = iVar3;\n      if (((uint)piVar22 | (uint)piVar16) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar3 == 0) {\n            local_158 = (char *)((uint)piVar25 & 1);\n            if ((int *)local_158 == (int *)0x0) {\n              piVar23 = (int *)(&bStack_2a + 2);\n              piVar25 = piVar21;\n            }\n            else {\n              piVar23 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n              piVar25 = piVar21;\n            }\n          }\n          else {\n            piVar23 = (int *)(&bStack_2a + 2);\n            piVar25 = piVar21;\n            local_158 = (char *)piVar27;\n          }\n        }\n        else {\n          piVar25 = piVar21;\n          if (iVar3 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar22 + '0';\n          piVar23 = (int *)(&bStack_2a + 1);\n          local_158 = (char *)0x1;\n          piVar25 = piVar21;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar3 = iVar8;\n        piVar25 = piVar21;\n        if (iVar8 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar3 == 2) {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = (int *)((uint)piVar22 >> 4 | (int)piVar16 << 0x1c);\n            piVar16 = (int *)((uint)piVar16 >> 4);\n            piVar23 = (int *)((int)piVar23 + -1);\n            *(char *)piVar23 = local_11c[(uint)piVar22 & 0xf];\n            piVar22 = piVar21;\n          } while (((uint)piVar21 | (uint)piVar16) != 0);\n        }\n        else {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = piVar23;\n            piVar9 = (int *)((uint)piVar22 >> 3 | (int)piVar16 << 0x1d);\n            piVar16 = (int *)((uint)piVar16 >> 3);\n            iVar3 = ((uint)piVar22 & 7) + 0x30;\n            *(byte *)((int)piVar21 + -1) = (byte)iVar3;\n            piVar23 = (int *)((int)piVar21 + -1);\n            piVar22 = piVar9;\n          } while (((uint)piVar9 | (uint)piVar16) != 0);\n          if ((((uint)piVar25 & 1) != 0) && (iVar3 != 0x30)) {\n            piVar23 = (int *)((int)piVar21 + -2);\n            *(byte *)((int)piVar21 + -2) = 0x30;\n            local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  piVar28 = local_160;\n  if (local_d0 == (int *)0x0) {\nLAB_0800604a:\n    uVar13 = *(ushort *)(local_160 + 3);\n  }\n  else {\n    __ssprint_r(local_16c,local_160,&local_d8);\n    uVar13 = *(ushort *)(piVar28 + 3);\n  }\nLAB_0800604e:\n  if ((uVar13 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (piVar24 == (int *)0x6c) {\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    piVar25 = (int *)((uint)piVar25 | 0x20);\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    piVar25 = (int *)((uint)piVar25 | 0x10);\n  }\n  goto LAB_08005f4a;\n  while( true ) {\n    iVar8 = __aeabi_dcmpeq((int)uVar33,uVar10,local_124,local_120);\n    if (iVar8 != 0) break;\nLAB_080072ba:\n    piVar16 = param_3;\n    piVar22 = (int *)((int)piVar22 + -1);\n    uVar33 = __muldf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x40300000);\n    iVar3 = __aeabi_d2iz();\n    uVar34 = __aeabi_i2d();\n    uVar33 = __subdf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar34,\n                      (int)((ulonglong)uVar34 >> 0x20));\n    uVar10 = (undefined4)((ulonglong)uVar33 >> 0x20);\n    param_3 = (int *)((int)piVar16 + 1);\n    *(char *)piVar16 = pcVar18[iVar3];\n    if (piVar22 == (int *)0xffffffff) break;\n  }\n  piVar23 = local_fc;\n  piVar25 = local_100;\n  piVar27 = local_130;\n  piVar24 = local_134;\n  piVar28 = local_138;\n  ppiVar2 = local_13c;\n  local_13c = (int **)piVar22;\n  local_134 = piVar16;\n  local_150 = uVar33;\n  iVar8 = __aeabi_dcmpgt((int)uVar33,uVar10,0,0x3fe00000);\n  if (iVar8 == 0) {\n    iVar8 = __aeabi_dcmpeq((int *)local_150,local_150._4_4_,0,0x3fe00000);\n    if ((iVar8 != 0) && (iVar3 << 0x1f < 0)) goto LAB_0800748a;\n    if (-1 < (int)local_13c) {\n      piVar16 = (int *)((byte *)((int)local_13c + 1) + (int)param_3);\n      piVar22 = param_3;\n      do {\n        param_3 = (int *)((int)piVar22 + 1);\n        *(byte *)piVar22 = 0x30;\n        piVar22 = param_3;\n      } while (piVar16 != param_3);\n    }\n  }\n  else {\nLAB_0800748a:\n    bVar1 = local_158[0xf];\n    bVar7 = *(byte *)piVar16;\n    piVar22 = param_3;\n    local_e0 = local_134;\n    while (bVar1 == bVar7) {\n      *(byte *)((int)piVar22 + -1) = 0x30;\n      bVar7 = *(byte *)((int)local_e0 + -1);\n      piVar22 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar7 == 0x39) {\n      bVar7 = local_158[10];\n    }\n    else {\n      bVar7 = bVar7 + 1;\n    }\n    *(byte *)((int)piVar22 + -1) = bVar7;\n  }\n  local_138 = (int *)((int)param_3 - (int)piVar23);\nLAB_08006cb0:\n  local_134 = local_f0;\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0 + 3) < 0 == SCARRY4((int)local_f0,3)) &&\n       ((int)local_f0 <= (int)piVar27)) {\n      if ((int)local_f0 < (int)local_138) {\n        local_158 = (char *)((int)local_138 + (int)local_118);\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (char *)((int)local_158 + (1 - (int)local_f0));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        piVar24 = (int *)0x67;\n      }\n      else {\n        if ((int)piVar25 << 0x1f < 0) {\n          local_158 = (char *)((int)local_f0 + (int)local_118);\n        }\n        else {\n          local_158 = (char *)local_f0;\n        }\n        if (-1 < (int)piVar25 << 0x15) {\n          piVar24 = (int *)0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074fc;\n        }\n        piVar24 = (int *)0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    piVar24 = (int *)((int)piVar24 + -2);\n    local_168 = (int *)((uint)piVar24 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8 = (char)piVar24;\n    if (local_168 == (int *)0x41) {\n      local_e8 = local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0 + -1);\n    if ((int)piVar27 < 0) {\n      local_e7 = 0x2d;\n      local_f0 = (int *)(1 - (int)local_f0);\n    }\n    else {\n      local_e7 = 0x2b;\n      local_f0 = piVar27;\n    }\n    if ((int)local_f0 < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e6[0] = 0x30;\n        pcVar18 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar18 = (char)local_f0 + '0';\n      pcVar18 = pcVar18 + 1;\n    }\n    else {\n      pbVar30 = abStack_dc + 3;\n      pbVar26 = pbVar30;\n      do {\n        pbVar5 = pbVar26;\n        piVar22 = (int *)((uint)local_f0 / 10);\n        pbVar5[-1] = (char)local_f0 + (char)piVar22 * -10 + 0x30;\n        pbVar26 = pbVar5 + -1;\n        local_f0 = piVar22;\n      } while ((int *)0x9 < piVar22);\n      uVar19 = (uint)(piVar22 + 0xc) & 0xff;\n      pbVar5[-2] = (byte)uVar19;\n      if (pbVar5 + -2 < pbVar30) {\n        pbVar5 = pbVar26;\n        puVar20 = (undefined *)((int)&local_e8 + 2);\n        while( true ) {\n          *puVar20 = (char)uVar19;\n          if (pbVar30 == pbVar5) break;\n          uVar19 = (uint)*pbVar5;\n          pbVar5 = pbVar5 + 1;\n          puVar20 = puVar20 + 1;\n        }\n        pcVar18 = (char *)(((int)&local_188 * 2 - (int)pbVar26) + 0x152);\n      }\n      else {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar18 + -(int)&local_e8);\n    local_158 = (char *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)piVar25 << 0x1f < 0)) {\n      local_158 = (char *)((int)local_158 + (int)local_118);\n    }\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    piVar25 = (int *)((uint)piVar25 & 0xfffffbff | 0x100);\n    local_f0 = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0 < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_168 = (int *)0x1;\n        local_158 = (char *)0x1;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_118 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      piVar25 = local_140;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)local_f0;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_f0 + (int)local_118) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)piVar25 << 0x15) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      uVar19 = (uint)*local_108;\n      while (uVar19 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar19) goto LAB_08007524;\n          uVar4 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar19);\n          if (uVar4 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = (int *)((int)local_130 + 1);\n          uVar19 = uVar4;\n          if (uVar4 == 0xff) goto LAB_08007524;\n        }\n        local_13c = (int **)((int)local_13c + 1);\n      }\nLAB_08007524:\n      local_158 = (char *)((int)local_158 + (int)local_104 * ((int)local_130 + (int)local_13c));\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      piVar25 = local_140;\n    }\n  }\n  if (local_144 == (int *)0x0) {\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = (int *)0x0;\nLAB_08006538:\n    if (piVar16 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar16 = (int *)0x2d;\n    piVar22 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n  }\nLAB_08006298:\n  piVar27 = local_160;\n  puVar29 = local_16c;\n  local_150._0_4_ = (int *)((uint)piVar25 & 2);\n  if ((int *)local_150 != (int *)0x0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  local_144 = (int *)((uint)piVar25 & 0x84);\n  if ((local_144 == (int *)0x0) &&\n     (piVar21 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar21)) {\n    if (0x10 < (int)piVar21) {\n      piVar16 = (int *)0x10;\n      local_100 = piVar24;\n      do {\n        piVar9 = piVar21;\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = piVar16;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n          piVar24 = local_100;\n        }\n        else {\n          local_140 = piVar16;\n          iVar3 = __ssprint_r(puVar29,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = local_140;\n          piVar24 = local_100;\n        }\n        piVar21 = piVar9 + -4;\n        local_100 = piVar24;\n      } while (0x10 < (int)piVar21);\n      piVar21 = piVar9 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar21);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar21;\n    if ((int)local_d4 < 8) {\n      piVar16 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar16 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar16 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 1);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((int *)local_150 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 2);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  if ((local_144 == (int *)0x80) &&\n     (piVar16 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar16)) {\n    if (0x10 < (int)piVar16) {\n      do {\n        while( true ) {\n          piVar21 = piVar16;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = __ssprint_r(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = piVar21 + -4;\n          if ((int)(piVar21 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar16 = piVar21 + -4;\n      } while (0x10 < (int)(piVar21 + -4));\nLAB_08006882:\n      piVar16 = piVar21 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar16);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar16;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  piVar22 = (int *)((int)piVar22 - (int)local_158);\n  if (0 < (int)piVar22) {\n    if (0x10 < (int)piVar22) {\n      do {\n        while( true ) {\n          piVar16 = piVar22;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = __ssprint_r(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar22 = piVar16 + -4;\n          if ((int)(piVar16 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar22 = piVar16 + -4;\n      } while (0x10 < (int)(piVar16 + -4));\nLAB_080063d2:\n      piVar22 = piVar16 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar22);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar22;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_d0;\n  if (((uint)piVar25 & 0x100) == 0) {\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)local_158);\n    *ppiVar2 = piVar23;\n    ppiVar2[1] = (int *)local_158;\n    if ((int)local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else if ((int)piVar24 < 0x66) {\n    local_158 = (char *)((int)local_d0 + 1);\n    piVar27 = (int *)((int)local_d4 + 1);\n    ppiVar14 = ppiVar2 + 2;\n    local_d0 = (int *)local_158;\n    if (((int)local_138 < 2) && (((uint)piVar25 & 1) == 0)) {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)piVar27 < 8) {\n        local_150._0_4_ = (int *)((int)local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = piVar27;\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        local_150._0_4_ = (int *)((int)local_d4 + 1);\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = piVar27;\n      if (7 < (int)piVar27) {\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n      }\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_158 = (char *)((int)local_158 + (int)local_118);\n      *ppiVar14 = local_114;\n      ppiVar14[1] = local_118;\n      local_d0 = (int *)local_158;\n      if ((int)local_d4 < 8) {\n        ppiVar17 = ppiVar14 + 2;\n      }\n      else {\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar17 = local_cc;\n      }\n      piVar24 = local_d4;\n      local_150._0_4_ = (int *)((int)local_d4 + 1);\n      piVar22 = (int *)((int)local_138 + -1);\n      ppiVar11 = ppiVar17 + 2;\n      local_158 = (char *)local_d0;\n      local_144 = (int *)local_150;\n      iVar3 = __aeabi_dcmpeq(local_128,local_12c,local_124,local_120);\n      piVar27 = local_160;\n      puVar29 = local_16c;\n      if (iVar3 == 0) {\n        local_158 = (char *)((int)local_158 + (int)piVar22);\n        *ppiVar17 = (int *)((int)piVar23 + 1);\n        ppiVar17[1] = piVar22;\n        local_d0 = (int *)local_158;\n        if ((int)(int *)local_150 < 8) {\n          local_150._0_4_ = (int *)((int)piVar24 + 2);\n          ppiVar14 = ppiVar11;\n          ppiVar2 = ppiVar17 + 4;\n        }\n        else {\nLAB_08006d9c:\n          local_158 = (char *)local_d0;\n          local_d4 = (int *)local_150;\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          local_150._0_4_ = (int *)((int)local_d4 + 1);\n          local_158 = (char *)local_d0;\n          ppiVar14 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar14 = ppiVar17;\n        ppiVar2 = ppiVar11;\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)local_158;\n          local_d4 = local_144;\n          if (0x10 < (int)piVar22) {\n            while( true ) {\n              local_d0 = local_d0 + 4;\n              *ppiVar17 = (int *)0x8009f60;\n              ppiVar17[1] = (int *)0x10;\n              if ((int)local_d4 < 8) {\n                ppiVar17 = ppiVar17 + 2;\n              }\n              else {\n                iVar3 = __ssprint_r(puVar29,piVar27,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar17 = local_cc;\n              }\n              piVar22 = piVar22 + -4;\n              if ((int)piVar22 < 0x11) break;\n              local_d4 = (int *)((int)local_d4 + 1);\n            }\n            local_150._0_4_ = (int *)((int)local_d4 + 1);\n            ppiVar11 = ppiVar17 + 2;\n            local_158 = (char *)local_d0;\n          }\n          *ppiVar17 = (int *)0x8009f60;\n          ppiVar17[1] = piVar22;\n          local_158 = (char *)((int)local_158 + (int)piVar22);\n          local_d0 = (int *)local_158;\n          if (7 < (int)(int *)local_150) goto LAB_08006d9c;\n          local_150._0_4_ = (int *)((int)(int *)local_150 + 1);\n          ppiVar2 = ppiVar11 + 2;\n          ppiVar14 = ppiVar11;\n        }\n      }\n    }\n    ppiVar14[1] = local_10c;\n    local_d0 = (int *)((int)local_158 + (int)local_10c);\n    local_d4 = (int *)local_150;\n    *ppiVar14 = (int *)&local_e8;\n    piVar27 = local_d0;\n    if (7 < (int)(int *)local_150) {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else {\n    iVar3 = __aeabi_dcmpeq(local_128,local_12c,local_124,local_120);\n    if (iVar3 == 0) {\n      if ((int)local_f0 < 1) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)piVar27 + 1);\n        *ppiVar2 = (int *)&DAT_08009f4c;\n        ppiVar2[1] = (int *)0x1;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0 != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)local_d0 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          puVar29 = local_16c;\n          if ((int)local_f0 < 0) {\n            piVar27 = (int *)-(int)local_f0;\n            if ((int)(local_f0 + 4) < 0 != SCARRY4((int)local_f0,0x10)) {\n              do {\n                local_d4 = (int *)((int)local_d4 + 1);\n                local_d0 = local_d0 + 4;\n                *ppiVar2 = (int *)0x8009f60;\n                ppiVar2[1] = (int *)0x10;\n                if ((int)local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar3 = __ssprint_r(puVar29,local_160,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)local_d0 + (int)piVar27);\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = piVar27;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = (int *)((int)local_d0 + (int)local_138);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar24 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar24 = local_138;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar24);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = piVar24;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        piVar22 = local_134;\n        if (-1 < (int)piVar24) {\n          piVar22 = (int *)((int)local_134 - (int)piVar24);\n        }\n        if (0 < (int)piVar22) {\n          for (; 0x10 < (int)piVar22; piVar22 = piVar22 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = piVar27 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          local_d4 = (int *)((int)local_d4 + 1);\n          piVar27 = (int *)((int)piVar27 + (int)piVar22);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar22;\n          local_d0 = piVar27;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar22 = local_104;\n        piVar24 = local_160;\n        puVar29 = local_16c;\n        piVar16 = (int *)((int)local_134 + (int)piVar23);\n        if (((uint)piVar25 & 0x400) != 0) {\n          local_158 = (char *)((int)piVar23 + (int)local_138);\n          pbVar26 = local_108;\n          local_150._0_4_ = piVar28;\n          local_144 = piVar25;\n          local_140 = piVar23;\n          if (local_130 == (int *)0x0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != (int **)0x0) goto LAB_0800717e;\n          pbVar26 = pbVar26 + -1;\n          local_130 = (int *)((int)local_130 + -1);\n          do {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)piVar27 + (int)piVar22);\n            *ppiVar2 = local_110;\n            ppiVar2[1] = piVar22;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = (int *)(uint)*pbVar26;\n            piVar28 = (int *)((int)local_158 - (int)piVar16);\n            if ((int)piVar27 <= (int)(int *)((int)local_158 - (int)piVar16)) {\n              piVar28 = piVar27;\n            }\n            if (0 < (int)piVar28) {\n              local_d0 = (int *)((int)local_d0 + (int)piVar28);\n              local_d4 = (int *)((int)local_d4 + 1);\n              *ppiVar2 = piVar16;\n              ppiVar2[1] = piVar28;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar27 = (int *)(uint)*pbVar26;\n              }\n            }\n            piVar25 = piVar27;\n            if (-1 < (int)piVar28) {\n              piVar25 = (int *)((int)piVar27 - (int)piVar28);\n            }\n            if (0 < (int)piVar25) {\n              for (; 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n                while( true ) {\n                  local_d4 = (int *)((int)local_d4 + 1);\n                  local_d0 = local_d0 + 4;\n                  *ppiVar2 = (int *)0x8009f60;\n                  ppiVar2[1] = (int *)0x10;\n                  if ((int)local_d4 < 8) break;\n                  iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  piVar25 = piVar25 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar25 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = (int *)((int)local_d4 + 1);\n              local_d0 = (int *)((int)local_d0 + (int)piVar25);\n              *ppiVar2 = (int *)0x8009f60;\n              ppiVar2[1] = piVar25;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = local_cc;\n              }\n            }\n            piVar16 = (int *)((int)piVar16 + (int)piVar27);\n            piVar27 = local_d0;\n            if (local_130 != (int *)0x0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == (int **)0x0) {\n              piVar23 = local_140;\n              piVar25 = local_144;\n              piVar28 = (int *)local_150;\n              local_108 = pbVar26;\n              if ((int *)((int)local_140 + (int)local_138) <= piVar16) {\n                piVar16 = (int *)((int)local_140 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = (int **)((int)local_13c + -1);\n          } while( true );\n        }\n        if (((int)local_f0 < (int)local_138) || (((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)piVar27 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar24 = (int *)((int)local_138 - (int)local_f0);\n        piVar22 = (int *)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16);\n        if ((int)piVar24 <= (int)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16)) {\n          piVar22 = piVar24;\n        }\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar22);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar16;\n          ppiVar2[1] = piVar22;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar24 = (int *)((int)local_138 - (int)local_f0);\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        if (-1 < (int)piVar22) {\n          piVar24 = (int *)((int)piVar24 - (int)piVar22);\n        }\n        if (0 < (int)piVar24) {\n          for (; local_d0 = piVar27, 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_d0 = (int *)((int)piVar27 + 1);\n      *ppiVar2 = (int *)&DAT_08009f4c;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0 < (int)local_138) || (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)local_118);\n        *ppiVar2 = local_114;\n        ppiVar2[1] = local_118;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar22 = local_160;\n        puVar29 = local_16c;\n        piVar24 = (int *)((int)local_138 + -1);\n        piVar27 = local_d0;\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar22,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\nLAB_08007014:\n          local_d0 = (int *)((int)local_d0 + (int)piVar24);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar24;\njoined_r0x08006a1c:\n          local_d4 = (int *)((int)local_d4 + 1);\n          if (7 < (int)local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  piVar24 = local_160;\n  puVar29 = local_16c;\n  if ((((uint)piVar25 & 4) != 0) &&\n     (piVar25 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar25)) {\n    for (; local_d0 = piVar27, 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n      while( true ) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if ((int)local_d4 < 8) break;\n        iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        piVar25 = piVar25 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar25 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar25);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar25;\n    piVar27 = local_d0;\n    if ((7 < (int)local_d4) &&\n       (iVar3 = __ssprint_r(local_16c,local_160,&local_d8), piVar27 = local_d0, iVar3 != 0))\n    goto LAB_0800603e;\n  }\n  piVar24 = local_15c;\n  if ((int)local_15c < (int)local_168) {\n    piVar24 = local_168;\n  }\n  local_164 = local_164 + (int)piVar24;\n  if ((piVar27 == (int *)0x0) || (iVar3 = __ssprint_r(local_16c,local_160,&local_d8), iVar3 == 0)) {\n    local_d4 = (int *)0x0;\n    if (local_148 != (int *)0x0) {\n      _free_r(local_16c,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    _free_r(local_16c,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  piVar16 = piVar24 + -0xc;\n  piVar22 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar22 + 1);\n    piVar24 = (int *)(uint)*(byte *)piVar22;\n    local_15c = (int *)((int)piVar16 + (int)local_15c * 10);\n    piVar16 = piVar24 + -0xc;\n    piVar22 = piVar28;\n  } while (piVar16 < (int *)0xa);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "calling": [
                "sprintf"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__ssprint_r",
                "__aeabi_dcmpgt",
                "__unorddf2",
                "__aeabi_dcmple",
                "__aeabi_dcmpeq",
                "memchr",
                "__muldf3",
                "frexp",
                "_dtoa_r",
                "__aeabi_i2d",
                "_malloc_r",
                "__aeabi_uldivmod",
                "__aeabi_d2iz",
                "__subdf3",
                "strncpy",
                "strlen",
                "_free_r",
                "_localeconv_r"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078a0": {
            "entrypoint": "0x080078a0",
            "current_name": "FUNC_080078a0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080078a4) */\n\nvoid FUNC_080078a0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078a0": "FUNC_080078a0"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078c0": {
            "entrypoint": "0x080078c0",
            "current_name": "calculate_division_080078c0",
            "code": "\nuint calculateDivision_080078c0(int numerator,int denominator)\n\n{\n  uint tempResult;\n  uint *numeratorPtr;\n  int carry;\n  int numeratorSize;\n  int index;\n  uint result;\n  uint *denominatorPtr;\n  uint *numerator;\n  uint *denominator;\n  uint tempResult0;\n  uint *denominatorTempPtr;\n  uint *denominatorNextPtr;\n  \n  numeratorSize = *(int *)(denominator + 0x10);\n  if (*(int *)(numerator + 0x10) < numeratorSize) {\n    return 0;\n  }\n  index = numeratorSize + -1;\n  denominatorPtr = (uint *)(denominator + 0x14);\n  numerator = (uint *)(numerator + 0x14);\n  result = numerator[index] / (denominatorPtr[index] + 1);\n  denominator = denominatorPtr + index;\n  if (result != 0) {\n    tempResult = 0;\n    carry = 0;\n    numeratorPtr = numerator;\n    denominatorTempPtr = denominatorPtr;\n    do {\n      denominatorNextPtr = denominatorTempPtr + 1;\n      tempResult = result * (*denominatorTempPtr & 0xffff) + tempResult;\n      tempResult0 = result * (*denominatorTempPtr >> 0x10) + (tempResult >> 0x10);\n      tempResult = (carry - (tempResult & 0xffff)) + (*numeratorPtr & 0xffff);\n      carry = ((*numeratorPtr >> 0x10) - (tempResult0 & 0xffff)) + ((int)tempResult >> 0x10);\n      *numeratorPtr = tempResult & 0xffff | carry * 0x10000;\n      carry = carry >> 0x10;\n      tempResult = tempResult0 >> 0x10;\n      numeratorPtr = numeratorPtr + 1;\n      denominatorTempPtr = denominatorNextPtr;\n    } while (denominatorNextPtr <= denominator);\n    if (numerator[index] == 0) {\n      if ((numerator < numerator + numeratorSize + -2) && (numerator[numeratorSize + -2] == 0)) {\n        numeratorPtr = numerator + numeratorSize + -3;\n        do {\n          index = index + -1;\n          if (numeratorPtr <= numerator) break;\n          tempResult = *numeratorPtr;\n          numeratorPtr = numeratorPtr + -1;\n        } while (tempResult == 0);\n      }\n      *(int *)(numerator + 0x10) = index;\n    }\n  }\n  numeratorSize = __mcmp();\n  if (-1 < numeratorSize) {\n    numeratorSize = 0;\n    result = result + 1;\n    numeratorPtr = numerator;\n    do {\n      denominatorTempPtr = denominatorPtr + 1;\n      tempResult = (numeratorSize - (*denominatorPtr & 0xffff)) + (*numeratorPtr & 0xffff);\n      numeratorSize = ((*numeratorPtr >> 0x10) - (*denominatorPtr >> 0x10)) + ((int)tempResult >> 0x10);\n      *numeratorPtr = tempResult & 0xffff | numeratorSize * 0x10000;\n      numeratorSize = numeratorSize >> 0x10;\n      numeratorPtr = numeratorPtr + 1;\n      denominatorPtr = denominatorTempPtr;\n    } while (denominatorTempPtr <= denominator);\n    if (numerator[index] == 0) {\n      if ((numerator < numerator + index + -1) && (numerator[index + -1] == 0)) {\n        denominatorPtr = numerator + index + -2;\n        do {\n          index = index + -1;\n          if (denominatorPtr <= numerator) break;\n          tempResult = *denominatorPtr;\n          denominatorPtr = denominatorPtr + -1;\n        } while (tempResult == 0);\n      }\n      *(int *)(numerator + 0x10) = index;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080078c0": "calculate_division_080078c0",
                "param_1": "numerator",
                "param_2": "denominator",
                "iVar3": "carry",
                "iVar4": "numeratorSize",
                "iVar5": "index",
                "uVar1": "tempResult",
                "uVar6": "result",
                "puVar2": "numeratorPtr",
                "puVar7": "denominatorPtr",
                "puVar8": "numerator",
                "puVar9": "denominator",
                "puVar11": "denominatorTempPtr",
                "puVar12": "denominatorNextPtr"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__mcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e8": {
            "entrypoint": "0x080079e8",
            "current_name": "format_floating_point_080079e8",
            "code": "\nchar * formatFloatingPoint_080079e8(int precision,undefined4 sign,uint mantissa_high,uint mantissa_low,uint exponent,\n                   uint digits,int *length,uint *is_negative,char **result)\n\n{\n  bool is_infinity_or_nan;\n  bool is_zero;\n  bool is_rounding_needed;\n  char digit;\n  byte is_negative_input;\n  undefined4 fractional_part;\n  int shift;\n  int comparison_result;\n  int comparison_result2;\n  char *pcVar10;\n  uint shifted_mantissa_high;\n  undefined4 uVar12;\n  undefined4 uVar13;\n  int temp1;\n  int temp2;\n  undefined4 uVar16;\n  uint shifted_mantissa_low;\n  uint converted_exponent;\n  int temp3;\n  char *pcVar20;\n  char *pcVar21;\n  undefined4 *puVar22;\n  undefined4 uVar23;\n  int digit_value;\n  bool is_zero5;\n  undefined8 uVar26;\n  undefined8 uVar27;\n  undefined8 uVar28;\n  uint normalized_fractional_part;\n  uint converted_exponent;\n  uint exponent_length;\n  int fractional_part_length;\n  uint initial_length;\n  int digits_shift;\n  int shifted_length;\n  uint leading_zeros;\n  uint sign_shifted_mantissa_low;\n  uint sign_shifted_mantissa_high;\n  uint adjusted_length;\n  uint temp5;\n  int temp6;\n  int temp7 [2];\n  \n  temp1 = *(int *)(precision + 0x40);\n  if (temp1 != 0) {\n    converted_exponent = *(uint *)(precision + 0x44);\n    *(uint *)(temp1 + 4) = converted_exponent;\n    *(int *)(temp1 + 8) = 1 << (converted_exponent & 0xff);\n    _Bfree(precision,temp1);\n    *(undefined4 *)(precision + 0x40) = 0;\n  }\n  is_zero5 = (int)mantissa_low < 0;\n  converted_exponent = mantissa_low;\n  if (is_zero5) {\n    converted_exponent = mantissa_low & 0x7fffffff;\n  }\n  *is_negative = (uint)is_zero5;\n  converted_exponent = mantissa_low;\n  if (is_zero5) {\n    converted_exponent = converted_exponent;\n  }\n  shifted_mantissa_low = converted_exponent;\n  if ((~converted_exponent & 0x7ff00000) == 0) {\n    *length = 9999;\n    if ((mantissa_high == 0) && ((converted_exponent & 0xfffff) == 0)) {\n      pcVar10 = \"Infinity\";\n      if (result == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    else {\n      pcVar10 = \"NaN\";\n      if (result == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    *result = pcVar21;\n    return pcVar10;\n  }\n  uVar26 = __aeabi_dcmpeq(mantissa_high,converted_exponent,0,0);\n  if ((int)uVar26 != 0) {\n    *length = 1;\n    if (result != (char **)0x0) {\n      *result = \"\";\n      return \"0\";\n    }\n    return \"0\";\n  }\n  fractional_part = __d2b(precision,(int)((ulonglong)uVar26 >> 0x20),mantissa_high,converted_exponent,temp7,&temp6);\n  temp1 = temp6;\n  if (converted_exponent >> 0x14 == 0) {\n    temp3 = temp7[0] + temp6;\n    temp2 = temp3 + 0x432;\n    if (temp2 < 0x21) {\n      converted_exponent = mantissa_high << (0x20U - temp2 & 0xff);\n    }\n    else {\n      converted_exponent = mantissa_high >> (temp3 + 0x412U & 0xff) | converted_exponent << (0x40U - temp2 & 0xff);\n    }\n    uVar26 = __floatunsidf(converted_exponent);\n    temp3 = temp3 + -1;\n    is_zero5 = true;\n    shifted_mantissa_high = (int)((ulonglong)uVar26 >> 0x20) + 0xfe100000;\n    converted_exponent = (uint)uVar26;\n  }\n  else {\n    temp3 = (converted_exponent >> 0x14) - 0x3ff;\n    shifted_mantissa_high = converted_exponent & 0xfffff | 0x3ff00000;\n    is_zero5 = false;\n    converted_exponent = mantissa_high;\n  }\n  uVar26 = __subdf3(converted_exponent,shifted_mantissa_high,0,0x3ff80000);\n  uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0x636f4361,0x3fd287a7);\n  uVar26 = __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0x8b60c8b3,0x3fc68a28);\n  uVar27 = __aeabi_i2d(temp3);\n  uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0x509f79fb,0x3fd34413);\n  uVar26 = __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar27,\n                        (int)((ulonglong)uVar27 >> 0x20));\n  uVar13 = (undefined4)((ulonglong)uVar26 >> 0x20);\n  exponent_length = __aeabi_d2iz();\n  temp2 = __aeabi_dcmplt((int)uVar26,uVar13,0,0);\n  if (temp2 != 0) {\n    uVar27 = __aeabi_i2d(exponent_length);\n    temp2 = __aeabi_dcmpeq((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,uVar13);\n    if (temp2 == 0) {\n      exponent_length = exponent_length - 1;\n    }\n  }\n  if (exponent_length < 0x17) {\n    temp2 = __aeabi_dcmpgt(*(undefined4 *)(&DAT_08009fa8 + exponent_length * 8),\n                            *(undefined4 *)(&DAT_08009fac + exponent_length * 8),mantissa_high,converted_exponent);\n    if (temp2 == 0) {\n      is_zero = false;\n    }\n    else {\n      exponent_length = exponent_length - 1;\n      is_zero = false;\n    }\n  }\n  else {\n    is_zero = true;\n  }\n  temp2 = (temp1 - temp3) + -1;\n  if (temp2 < 0) {\n    fractional_part_length = 1 - (temp1 - temp3);\n    temp2 = 0;\n  }\n  else {\n    fractional_part_length = 0;\n  }\n  if ((int)exponent_length < 0) {\n    leading_zeros = 0;\n    fractional_part_length = fractional_part_length - exponent_length;\n    shifted_length = -exponent_length;\n  }\n  else {\n    temp2 = temp2 + exponent_length;\n    leading_zeros = exponent_length;\n    shifted_length = 0;\n  }\n  if (9 < exponent) {\n    adjusted_length = 0xffffffff;\n    is_infinity_or_nan = true;\n    initial_length = 0xffffffff;\n    is_rounding_needed = true;\n    exponent = 0;\n    digits = 0;\n    goto LAB_08007c24;\n  }\n  is_infinity_or_nan = (int)exponent < 6;\n  if (!is_infinity_or_nan) {\n    exponent = exponent - 4;\n  }\n  switch(exponent) {\n  case 2:\n    is_rounding_needed = false;\n    break;\n  case 3:\n    is_rounding_needed = false;\n    goto LAB_08008300;\n  case 4:\n    is_rounding_needed = true;\n    break;\n  case 5:\n    is_rounding_needed = true;\nLAB_08008300:\n    adjusted_length = exponent_length + digits;\n    initial_length = adjusted_length + 1;\n    converted_exponent = initial_length;\n    if ((int)initial_length < 1) {\n      converted_exponent = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(precision + 0x44) = 0;\n    pcVar10 = (char *)_Balloc(precision,0);\n    adjusted_length = 0xffffffff;\n    initial_length = 0xffffffff;\n    digits = 0;\n    *(char **)(precision + 0x40) = pcVar10;\n    is_rounding_needed = true;\n    goto LAB_08007e36;\n  }\n  if ((int)digits < 1) {\n    adjusted_length = 1;\n    digits = 1;\n    initial_length = 1;\nLAB_08007c24:\n    *(undefined4 *)(precision + 0x44) = 0;\n    shifted_mantissa_high = adjusted_length;\n  }\n  else {\n    adjusted_length = digits;\n    initial_length = digits;\n    converted_exponent = digits;\nLAB_08008314:\n    *(undefined4 *)(precision + 0x44) = 0;\n    shifted_mantissa_high = initial_length;\n    if (0x17 < (int)converted_exponent) {\n      temp3 = 4;\n      temp1 = 1;\n      do {\n        shift = temp1;\n        temp3 = temp3 * 2;\n        temp1 = shift + 1;\n      } while (temp3 + 0x14U <= converted_exponent);\n      *(int *)(precision + 0x44) = shift;\n    }\n  }\n  pcVar10 = (char *)_Balloc(precision);\n  *(char **)(precision + 0x40) = pcVar10;\n  if ((shifted_mantissa_high < 0xf) && (is_infinity_or_nan)) {\n    if ((int)exponent_length < 1) {\n      if (exponent_length == 0) {\n        temp1 = 2;\n        normalized_fractional_part = mantissa_high;\n      }\n      else {\n        temp1 = (-exponent_length & 0xf) * 8;\n        uVar26 = __muldf3(mantissa_high,converted_exponent,*(undefined4 *)(&DAT_08009fa8 + temp1),\n                          *(undefined4 *)(&DAT_08009fac + temp1));\n        converted_exponent = (uint)((ulonglong)uVar26 >> 0x20);\n        normalized_fractional_part = (uint)uVar26;\n        temp3 = (int)-exponent_length >> 4;\n        if (temp3 == 0) {\n          temp1 = 2;\n        }\n        else {\n          is_infinity_or_nan = false;\n          temp1 = 2;\n          puVar22 = &DAT_08009f80;\n          do {\n            if (temp3 << 0x1f < 0) {\n              uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),*puVar22,puVar22[1]);\n              is_infinity_or_nan = true;\n              temp1 = temp1 + 1;\n            }\n            temp3 = temp3 >> 1;\n            puVar22 = puVar22 + 2;\n          } while (temp3 != 0);\n          if (is_infinity_or_nan) {\n            normalized_fractional_part = (uint)uVar26;\n            converted_exponent = (uint)((ulonglong)uVar26 >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      converted_exponent = (int)exponent_length >> 4;\n      uVar27 = *(undefined8 *)(&DAT_08009fa8 + (exponent_length & 0xf) * 8);\n      uVar26 = *(undefined8 *)(&DAT_08009fa8 + (exponent_length & 0xf) * 8);\n      if ((int)(converted_exponent << 0x1b) < 0) {\n        uVar28 = __divdf3(mantissa_high,converted_exponent,0x7f73bf3c,0x75154fdd);\n        sign_shifted_mantissa_high = (uint)((ulonglong)uVar28 >> 0x20);\n        sign_shifted_mantissa_low = (uint)uVar28;\n        temp1 = 3;\n        converted_exponent = converted_exponent & 0xf;\n      }\n      else {\n        temp1 = 2;\n        sign_shifted_mantissa_high = converted_exponent;\n        sign_shifted_mantissa_low = mantissa_high;\n      }\n      if (converted_exponent != 0) {\n        puVar22 = &DAT_08009f80;\n        do {\n          if ((int)(converted_exponent << 0x1f) < 0) {\n            uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),*puVar22,puVar22[1]);\n            temp1 = temp1 + 1;\n          }\n          converted_exponent = (int)converted_exponent >> 1;\n          puVar22 = puVar22 + 2;\n          uVar27 = uVar26;\n        } while (converted_exponent != 0);\n      }\n      converted_exponent = (uint)((ulonglong)uVar27 >> 0x20);\n      normalized_fractional_part = (uint)uVar27;\n      uVar26 = __divdf3(sign_shifted_mantissa_low,sign_shifted_mantissa_high,normalized_fractional_part,converted_exponent);\n      normalized_fractional_part = (uint)uVar26;\n      converted_exponent = (uint)((ulonglong)uVar26 >> 0x20);\n    }\n    uVar26 = CONCAT44(converted_exponent,normalized_fractional_part);\n    if ((is_zero) && (temp3 = __aeabi_dcmplt(normalized_fractional_part,converted_exponent,0,0x3ff00000), temp3 != 0)) {\n      if (initial_length == 0) {\n        uVar26 = __aeabi_i2d(temp1);\n        uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),normalized_fractional_part,converted_exponent);\n        uVar26 = __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x401c0000);\n        uVar13 = (undefined4)uVar26;\n        temp1 = (int)((ulonglong)uVar26 >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)adjusted_length) {\n        uVar26 = __muldf3(normalized_fractional_part,converted_exponent,0,0x40240000);\n        uVar27 = __aeabi_i2d(temp1 + 1);\n        uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                          (int)((ulonglong)uVar26 >> 0x20));\n        uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0,0x401c0000);\n        uVar13 = (undefined4)uVar27;\n        sign_shifted_mantissa_low = adjusted_length;\n        temp5 = exponent_length - 1;\n        temp1 = (int)((ulonglong)uVar27 >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    uVar27 = __aeabi_i2d(temp1);\n    uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),normalized_fractional_part,converted_exponent);\n    uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0,0x401c0000);\n    uVar13 = (undefined4)uVar27;\n    temp1 = (int)((ulonglong)uVar27 >> 0x20) + -0x3400000;\n    if (initial_length != 0) {\n      temp5 = exponent_length;\n      sign_shifted_mantissa_low = initial_length;\nLAB_08007cfa:\n      converted_exponent = (uint)((ulonglong)uVar26 >> 0x20);\n      normalized_fractional_part = (uint)uVar26;\n      digit = __aeabi_d2iz(normalized_fractional_part,converted_exponent);\n      digit = digit + '0';\n      uVar16 = (&DAT_08009fa0)[sign_shifted_mantissa_low * 2];\n      uVar12 = (&DAT_08009fa4)[sign_shifted_mantissa_low * 2];\n      uVar26 = __aeabi_i2d();\n      uVar26 = __subdf3(normalized_fractional_part,converted_exponent,(int)uVar26,(int)((ulonglong)uVar26 >> 0x20));\n      uVar23 = (undefined4)((ulonglong)uVar26 >> 0x20);\n      pcVar21 = pcVar10 + 1;\n      if (is_rounding_needed) {\n        uVar27 = __divdf3(0,0x3fe00000,uVar16,uVar12);\n        uVar27 = __subdf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar13,temp1);\n        uVar13 = (undefined4)((ulonglong)uVar27 >> 0x20);\n        *pcVar10 = digit;\n        temp1 = __aeabi_dcmpgt((int)uVar27,uVar13,(int)uVar26,uVar23);\n        if (temp1 != 0) {\nLAB_08008784:\n          exponent_length = temp5;\n          goto LAB_08008294;\n        }\n        uVar28 = __subdf3(0,0x3ff00000,(int)uVar26,uVar23);\n        temp1 = __aeabi_dcmpgt((int)uVar27,uVar13,(int)uVar28,(int)((ulonglong)uVar28 >> 0x20));\n        if (temp1 == 0) {\n          if (sign_shifted_mantissa_low != 1) {\n            pcVar20 = pcVar21;\n            do {\n              uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0,0x40240000);\n              uVar13 = (undefined4)((ulonglong)uVar27 >> 0x20);\n              uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x40240000);\n              digit = __aeabi_d2iz();\n              uVar28 = __aeabi_i2d();\n              uVar26 = __subdf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar28,\n                                (int)((ulonglong)uVar28 >> 0x20));\n              uVar16 = (undefined4)((ulonglong)uVar26 >> 0x20);\n              digit = digit + '0';\n              pcVar21 = pcVar20 + 1;\n              *pcVar20 = digit;\n              temp1 = __aeabi_dcmplt((int)uVar26,uVar16,(int)uVar27,uVar13);\n              if (temp1 != 0) {\n                exponent_length = temp5;\n                goto LAB_08008294;\n              }\n              uVar28 = __subdf3(0,0x3ff00000,(int)uVar26,uVar16);\n              temp1 = __aeabi_dcmplt((int)uVar28,(int)((ulonglong)uVar28 >> 0x20),(int)uVar27,\n                                      uVar13);\n              if (temp1 != 0) goto LAB_08008798;\n              pcVar20 = pcVar21;\n            } while (pcVar21 != pcVar10 + sign_shifted_mantissa_low);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        exponent_length = temp5;\n      }\n      else {\n        uVar27 = __muldf3(uVar13,temp1,uVar16,uVar12);\n        uVar13 = (undefined4)((ulonglong)uVar27 >> 0x20);\n        *pcVar10 = digit;\n        if (sign_shifted_mantissa_low != 1) {\n          pcVar20 = pcVar21;\n          do {\n            uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x40240000);\n            digit = __aeabi_d2iz();\n            uVar28 = __aeabi_i2d();\n            uVar26 = __subdf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar28,\n                              (int)((ulonglong)uVar28 >> 0x20));\n            pcVar21 = pcVar20 + 1;\n            *pcVar20 = digit + '0';\n            pcVar20 = pcVar21;\n          } while (pcVar21 != pcVar10 + sign_shifted_mantissa_low);\n        }\n        uVar16 = (undefined4)((ulonglong)uVar26 >> 0x20);\n        uVar28 = __aeabi_dadd((int)uVar27,uVar13,0,0x3fe00000);\n        temp1 = __aeabi_dcmplt((int)uVar28,(int)((ulonglong)uVar28 >> 0x20),(int)uVar26,uVar16);\n        if (temp1 == 0) {\n          uVar27 = __subdf3(0,0x3fe00000,(int)uVar27,uVar13);\n          temp1 = __aeabi_dcmpgt((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,uVar16);\n          pcVar20 = pcVar21;\n          if (temp1 == 0) goto LAB_08007e36;\n          do {\n            pcVar21 = pcVar20;\n            pcVar20 = pcVar21 + -1;\n          } while (pcVar21[-1] == '0');\n          goto LAB_08008784;\n        }\n        exponent_length = temp5;\n        digit = pcVar21[-1];\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    uVar26 = __subdf3(normalized_fractional_part,converted_exponent,0,0x40140000);\n    uVar16 = (undefined4)((ulonglong)uVar26 >> 0x20);\n    temp3 = __aeabi_dcmpgt((int)uVar26,uVar16,uVar13,temp1);\n    if (temp3 == 0) {\n      temp1 = __aeabi_dcmplt((int)uVar26,uVar16,uVar13,temp1 + -0x80000000);\n      if (temp1 == 0) goto LAB_08007e36;\n      temp3 = 0;\n      temp1 = 0;\n      pcVar21 = pcVar10;\n      goto LAB_080084f0;\n    }\n    temp2 = 0;\n    shift = 0;\nLAB_08008406:\n    *pcVar10 = '1';\n    exponent_length = exponent_length + 1;\n    pcVar21 = pcVar10 + 1;\n    temp3 = shift;\n    temp1 = temp2;\nLAB_08008416:\n    _Bfree(precision,temp1);\n    if (temp3 == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pcVar21 = pcVar10;\n    if ((-1 < temp7[0]) && ((int)exponent_length < 0xf)) {\n      uVar13 = *(undefined4 *)(&DAT_08009fa8 + exponent_length * 8);\n      uVar16 = *(undefined4 *)(&DAT_08009fac + exponent_length * 8);\n      if ((-1 < (int)digits) || (0 < (int)initial_length)) {\n        __divdf3(mantissa_high,shifted_mantissa_low,uVar13,uVar16);\n        is_negative_input = __aeabi_d2iz();\n        uVar26 = __aeabi_i2d();\n        uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),uVar13,uVar16);\n        uVar26 = __subdf3(mantissa_high,shifted_mantissa_low,(int)uVar26,(int)((ulonglong)uVar26 >> 0x20));\n        *pcVar10 = is_negative_input + 0x30;\n        pcVar21 = pcVar10 + 1;\n        if (initial_length != 1) {\n          uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x40240000);\n          temp1 = __aeabi_dcmpeq((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0);\n          while (temp1 == 0) {\n            uVar23 = (undefined4)((ulonglong)uVar26 >> 0x20);\n            __divdf3((int)uVar26,uVar23,uVar13,uVar16);\n            is_negative_input = __aeabi_d2iz();\n            uVar27 = __aeabi_i2d();\n            uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar13,uVar16);\n            uVar26 = __subdf3((int)uVar26,uVar23,(int)uVar27,(int)((ulonglong)uVar27 >> 0x20));\n            pcVar20 = pcVar21 + 1;\n            *pcVar21 = is_negative_input + 0x30;\n            pcVar21 = pcVar20;\n            if (initial_length == (int)pcVar20 - (int)pcVar10) goto LAB_08007f3a;\n            uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0x40240000);\n            temp1 = __aeabi_dcmpeq((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        uVar26 = __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 >> 0x20));\n        uVar23 = (undefined4)((ulonglong)uVar26 >> 0x20);\n        temp1 = __aeabi_dcmpgt((int)uVar26,uVar23,uVar13,uVar16);\n        if ((temp1 == 0) &&\n           ((temp1 = __aeabi_dcmpeq((int)uVar26,uVar23,uVar13,uVar16), temp1 == 0 ||\n            ((is_negative_input & 1) == 0)))) goto LAB_08008294;\n        digit = pcVar21[-1];\nLAB_08007f7c:\n        while (pcVar20 = pcVar21 + -1, digit == '9') {\n          if (pcVar10 == pcVar20) {\n            *pcVar10 = '0';\n            digit = pcVar21[-1];\n            exponent_length = exponent_length + 1;\n            pcVar20 = pcVar10;\n            break;\n          }\n          digit = pcVar21[-2];\n          pcVar21 = pcVar20;\n        }\n        *pcVar20 = digit + '\\x01';\n        goto LAB_08008294;\n      }\n      if (initial_length == 0) {\n        uVar26 = __muldf3(uVar13,uVar16,0,0x40140000);\n        comparison_result2 = __aeabi_dcmpge((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),mantissa_high,shifted_mantissa_low);\n        temp3 = 0;\n        temp2 = 0;\n        shift = 0;\n        temp1 = 0;\n        if (comparison_result2 == 0) goto LAB_08008406;\n      }\n      else {\n        temp3 = 0;\n        temp1 = 0;\n      }\nLAB_080084f0:\n      exponent_length = ~digits;\n      pcVar10 = pcVar21;\n      goto LAB_08008416;\n    }\n    temp1 = shifted_length;\n    if (is_rounding_needed) {\n      if ((int)exponent < 2) {\n        if (is_zero5) {\n          digits_shift = fractional_part_length;\n          fractional_part_length = fractional_part_length + temp7[0] + 0x433;\n          temp2 = temp2 + temp7[0] + 0x433;\n        }\n        else {\n          digits_shift = fractional_part_length;\n          fractional_part_length = fractional_part_length + (0x36 - temp6);\n          temp2 = temp2 + (0x36 - temp6);\n        }\n      }\n      else {\n        temp3 = initial_length - 1;\n        if (shifted_length < temp3) {\n          leading_zeros = leading_zeros + (temp3 - shifted_length);\n          temp1 = 0;\n          shifted_length = temp3;\n        }\n        else {\n          temp1 = shifted_length - temp3;\n        }\n        if ((int)initial_length < 0) {\n          digits_shift = fractional_part_length - initial_length;\n        }\n        else {\n          temp2 = temp2 + initial_length;\n          digits_shift = fractional_part_length;\n          fractional_part_length = fractional_part_length + initial_length;\n        }\n      }\n      temp3 = __i2b(precision,1);\n    }\n    else {\n      digits_shift = fractional_part_length;\n      temp3 = 0;\n    }\n    if ((0 < digits_shift) && (0 < temp2)) {\n      shift = digits_shift;\n      if (temp2 <= digits_shift) {\n        shift = temp2;\n      }\n      temp2 = temp2 - shift;\n      fractional_part_length = fractional_part_length - shift;\n      digits_shift = digits_shift - shift;\n    }\n    if (shifted_length != 0) {\n      if (is_rounding_needed) {\n        uVar13 = fractional_part;\n        if (temp1 != 0) {\n          temp3 = __pow5mult(precision,temp3,temp1);\n          uVar13 = __multiply(precision,temp3,fractional_part);\n          _Bfree(precision,fractional_part);\n          fractional_part = uVar13;\n          if (shifted_length - temp1 == 0) goto LAB_08008062;\n        }\n        fractional_part = __pow5mult(precision,uVar13,shifted_length - temp1);\n      }\n      else {\n        fractional_part = __pow5mult(precision,fractional_part,shifted_length);\n      }\n    }\nLAB_08008062:\n    temp1 = __i2b(precision,1);\n    if (leading_zeros == 0) {\n      if (((int)exponent < 2) && (mantissa_high == 0)) {\nLAB_0800835a:\n        if ((shifted_mantissa_low & 0xfffff) == 0) {\n          shifted_mantissa_low = shifted_mantissa_low & 0x7ff00000;\n          if (shifted_mantissa_low != 0) {\n            temp2 = temp2 + 1;\n            fractional_part_length = fractional_part_length + 1;\n            shifted_mantissa_low = 1;\n          }\n        }\n        else {\n          shifted_mantissa_low = 0;\n        }\n        is_zero5 = leading_zeros != 0;\n        converted_exponent = mantissa_high;\n        leading_zeros = shifted_mantissa_low;\n        if (is_zero5) goto LAB_080082d4;\n      }\n      shift = 1;\n    }\n    else {\n      uVar26 = __pow5mult(precision,temp1);\n      temp1 = (int)uVar26;\n      if (((int)exponent < 2) && (mantissa_high == 0)) goto LAB_0800835a;\n      leading_zeros = 0;\n      converted_exponent = (uint)((ulonglong)uVar26 >> 0x20);\nLAB_080082d4:\n      shift = __hi0bits(*(undefined4 *)(temp1 + *(int *)(temp1 + 0x10) * 4 + 0x10),converted_exponent);\n      shift = 0x20 - shift;\n    }\n    converted_exponent = shift + temp2 & 0x1f;\n    if (converted_exponent == 0) {\n      shift = 0x1c;\nLAB_08008096:\n      temp2 = temp2 + shift;\n      fractional_part_length = fractional_part_length + shift;\n      digits_shift = digits_shift + shift;\n    }\n    else {\n      if (4 < (int)(0x20 - converted_exponent)) {\n        shift = 0x1c - converted_exponent;\n        goto LAB_08008096;\n      }\n      if (0x20 - converted_exponent != 4) {\n        shift = 0x3c - converted_exponent;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < fractional_part_length) {\n      fractional_part = __lshift(precision,fractional_part,fractional_part_length);\n    }\n    if (0 < temp2) {\n      temp1 = __lshift(precision,temp1,temp2);\n    }\n    pcVar20 = pcVar10;\n    if ((is_zero) && (temp2 = __mcmp(fractional_part,temp1), temp2 < 0)) {\n      exponent_length = exponent_length - 1;\n      fractional_part = __multadd(precision,fractional_part,10,0);\n      if (is_rounding_needed) {\n        temp3 = __multadd(precision,temp3,10,0);\n        if ((0 < (int)adjusted_length) || ((int)exponent < 3)) {\n          initial_length = adjusted_length;\n          goto LAB_080080de;\n        }\n      }\n      else if ((0 < (int)adjusted_length) || ((int)exponent < 3)) {\n        initial_length = adjusted_length;\n        goto LAB_0800820a;\n      }\n      initial_length = adjusted_length;\nLAB_080084e8:\n      if (initial_length == 0) {\n        temp2 = __multadd(precision,temp1,5);\n        comparison_result2 = __mcmp(fractional_part,temp2);\n        shift = temp3;\n        temp1 = temp2;\n        if (0 < comparison_result2) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)initial_length < 1) && (2 < (int)exponent)) goto LAB_080084e8;\n    if (is_rounding_needed) {\nLAB_080080de:\n      normalized_fractional_part = temp3;\n      if (0 < digits_shift) {\n        normalized_fractional_part = __lshift(precision,temp3,digits_shift);\n      }\n      temp3 = normalized_fractional_part;\n      if (leading_zeros != 0) {\n        temp3 = _Balloc(precision,*(undefined4 *)(normalized_fractional_part + 4));\n        memcpy(temp3 + 0xc,normalized_fractional_part + 0xc,(*(int *)(normalized_fractional_part + 0x10) + 2) * 4);\n        temp3 = __lshift(precision,temp3,1);\n      }\nLAB_08008108:\n      temp2 = quorem(fractional_part,temp1);\n      shift = __mcmp(fractional_part,normalized_fractional_part);\n      comparison_result2 = __mdiff(precision,temp1,temp3);\n      digit_value = temp2 + 0x30;\n      if (*(int *)(comparison_result2 + 0xc) == 0) {\n        comparison_result = __mcmp(fractional_part);\n        _Bfree(precision,comparison_result2);\n        if ((comparison_result != 0) || (exponent != 0)) goto LAB_0800815a;\n        if ((mantissa_high & 1) != 0) {\n          comparison_result = 0;\n          goto LAB_0800815a;\n        }\n        if (digit_value != 0x39) {\n          if (0 < shift) goto LAB_0800874c;\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pcVar21 = pcVar20 + 1;\n        digit = '9';\n        *pcVar20 = '9';\n        goto LAB_08008268;\n      }\n      _Bfree(precision,comparison_result2);\n      comparison_result = 1;\nLAB_0800815a:\n      if ((shift < 0) || (((shift == 0 && (exponent == 0)) && ((mantissa_high & 1) == 0)))) {\n        if (0 < comparison_result) {\n          fractional_part = __lshift(precision,fractional_part,1);\n          shift = __mcmp(fractional_part,temp1);\n          if ((0 < shift) || ((shift == 0 && (temp2 << 0x1f < 0)))) {\n            if (digit_value == 0x39) goto LAB_08008752;\nLAB_0800874c:\n            digit_value = temp2 + 0x31;\n          }\n        }\nLAB_080085a4:\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)digit_value;\n        goto LAB_08008274;\n      }\n      pcVar21 = pcVar20 + 1;\n      if (0 < comparison_result) {\n        if (digit_value == 0x39) goto LAB_08008752;\n        *pcVar20 = (char)temp2 + '1';\n        goto LAB_08008274;\n      }\n      *pcVar20 = (char)digit_value;\n      if (pcVar10 + (initial_length - 1) != pcVar20) {\n        fractional_part = __multadd(precision,fractional_part,10,0);\n        pcVar20 = pcVar21;\n        if (normalized_fractional_part == temp3) {\n          normalized_fractional_part = __multadd(precision,normalized_fractional_part,10,0);\n          temp3 = normalized_fractional_part;\n        }\n        else {\n          normalized_fractional_part = __multadd(precision,normalized_fractional_part,10,0);\n          temp3 = __multadd(precision,temp3,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    else {\nLAB_0800820a:\n      while( true ) {\n        digit_value = quorem(fractional_part,temp1);\n        digit_value = digit_value + 0x30;\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)digit_value;\n        if ((int)initial_length <= (int)pcVar21 - (int)pcVar10) break;\n        fractional_part = __multadd(precision,fractional_part,10,0);\n        pcVar20 = pcVar21;\n      }\n      normalized_fractional_part = 0;\n    }\n    fractional_part = __lshift(precision,fractional_part,1);\n    temp2 = __mcmp(fractional_part,temp1);\n    digit = pcVar21[-1];\n    if ((0 < temp2) || ((temp2 == 0 && (digit_value << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pcVar20 = pcVar21 + -1;\n        if (digit != '9') goto code_r0x08008270;\n        if (pcVar10 == pcVar20) {\n          *pcVar10 = '1';\n          exponent_length = exponent_length + 1;\n          goto LAB_08008274;\n        }\n        digit = pcVar21[-2];\n        pcVar21 = pcVar20;\n      } while( true );\n    }\n    while (digit == '0') {\n      digit = pcVar21[-2];\n      pcVar21 = pcVar21 + -1;\n    }\nLAB_08008274:\n    _Bfree(precision,temp1);\n    if (temp3 == 0) goto LAB_08008294;\n    if ((normalized_fractional_part != 0) && (normalized_fractional_part != temp3)) {\n      _Bfree(precision);\n    }\n  }\n  _Bfree(precision,temp3);\nLAB_08008294:\n  _Bfree(precision,fractional_part);\n  *pcVar21 = '\\0';\n  *length = exponent_length + 1;\n  if (result == (char **)0x0) {\n    return pcVar10;\n  }\n  *result = pcVar21;\n  return pcVar10;\ncode_r0x08008270:\n  *pcVar20 = digit + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "renaming": {
                "FUN_080079e8": "format_floating_point_080079e8",
                "param_1": "precision",
                "param_2": "sign",
                "param_3": "mantissa_high",
                "param_4": "mantissa_low",
                "param_5": "exponent",
                "param_6": "digits",
                "param_7": "length",
                "param_8": "is_negative",
                "param_9": "result",
                "bVar1": "is_infinity_or_nan",
                "bVar2": "is_zero",
                "bVar3": "is_rounding_needed",
                "cVar4": "digit",
                "bVar5": "is_negative_input",
                "uVar6": "fractional_part",
                "iVar7": "shift",
                "iVar8": "comparison_result",
                "iVar9": "comparison_result2",
                "iVar14": "temp1",
                "iVar15": "temp2",
                "iVar19": "temp3",
                "iVar24": "digit_value",
                "uVar11": "shifted_mantissa_high",
                "uVar17": "shifted_mantissa_low",
                "uVar18": "converted_exponent",
                "local_80": "normalized_fractional_part",
                "local_7c": "converted_exponent",
                "local_74": "exponent_length",
                "local_70": "fractional_part_length",
                "local_68": "initial_length",
                "local_60": "digits_shift",
                "local_5c": "shifted_length",
                "local_58": "leading_zeros",
                "local_48": "sign_shifted_mantissa_low",
                "uStack_44": "sign_shifted_mantissa_high",
                "local_38": "adjusted_length",
                "local_34": "temp5",
                "local_30": "temp6",
                "local_2c": "temp7"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "_Bfree",
                "__floatunsidf",
                "memcpy",
                "quorem",
                "__aeabi_dcmplt",
                "__multiply",
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt",
                "_Balloc",
                "__pow5mult",
                "__i2b",
                "__mcmp",
                "__hi0bits",
                "__aeabi_dcmpeq",
                "__d2b",
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "__aeabi_i2d",
                "__aeabi_d2iz",
                "__subdf3",
                "__mdiff",
                "__multadd",
                "__lshift"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800884c": {
            "entrypoint": "0x0800884c",
            "current_name": "allocate_memory_0800884c",
            "code": "\nundefined4 allocateMemory_0800884c(undefined4 lock,int size)\n\n{\n  int result;\n  int adjustedAddr;\n  uint pageSize;\n  \n  __malloc_lock();\n  pageSize = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  adjustedAddr = ((0xfef - size) + pageSize & 0xfffff000) - 0x1000;\n  if (0xfff < adjustedAddr) {\n    result = _sbrk_r(lock,0);\n    if (result == DAT_20000454 + pageSize) {\n      result = _sbrk_r(lock,-adjustedAddr);\n      if (result != -1) {\n        DAT_20000a14 = DAT_20000a14 - adjustedAddr;\n        *(uint *)(DAT_20000454 + 4) = pageSize - adjustedAddr | 1;\n        __malloc_unlock(lock);\n        return 1;\n      }\n      adjustedAddr = _sbrk_r(lock,0);\n      if (0xf < adjustedAddr - DAT_20000454) {\n        DAT_20000a14 = adjustedAddr - DAT_20000854;\n        *(uint *)(DAT_20000454 + 4) = adjustedAddr - DAT_20000454 | 1;\n      }\n    }\n  }\n  __malloc_unlock(lock);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800884c": "allocate_memory_0800884c",
                "param_1": "lock",
                "param_2": "size",
                "iVar1": "result",
                "iVar2": "adjustedAddr",
                "uVar3": "pageSize"
            },
            "calling": [
                "_free_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088ec": {
            "entrypoint": "0x080088ec",
            "current_name": "deallocate_memory_080088ec",
            "code": "\nvoid deallocateMemory_080088ec(undefined4 lock,int ptr,undefined4 arg3,undefined4 arg4)\n\n{\n  int index;\n  uint *ptr1;\n  uint *ptr2;\n  undefined *ptr3;\n  uint size1;\n  uint size2;\n  undefined *ptr4;\n  undefined *ptr5;\n  undefined4 *ptr6;\n  int count;\n  uint flag1;\n  uint flag2;\n  \n  if (ptr == 0) {\n    return;\n  }\n  __malloc_lock();\n  flag1 = *(uint *)(ptr + -4);\n  ptr1 = (uint *)(ptr + -8);\n  size1 = flag1 & 0xfffffffe;\n  ptr2 = (uint *)((int)ptr1 + size1);\n  size2 = ptr2[1] & 0xfffffffc;\n  if (DAT_20000454 == ptr2) {\n    size1 = size1 + size2;\n    if ((flag1 & 1) == 0) {\n      ptr1 = (uint *)((int)ptr1 - *(int *)(ptr + -8));\n      size2 = ptr1[2];\n      flag1 = ptr1[3];\n      size1 = size1 + *(int *)(ptr + -8);\n      *(uint *)(size2 + 0xc) = flag1;\n      *(uint *)(flag1 + 8) = size2;\n    }\n    size2 = DAT_20000858;\n    ptr1[1] = size1 | 1;\n    DAT_20000454 = ptr1;\n    if (size2 <= size1) {\n      _malloc_trim_r(lock,DAT_20000a44);\n    }\nLAB_080089f0:\n    __malloc_unlock(lock);\n    return;\n  }\n  ptr2[1] = size2;\n  if ((flag1 & 1) == 0) {\n    ptr1 = (uint *)((int)ptr1 - *(int *)(ptr + -8));\n    ptr6 = (undefined4 *)ptr1[2];\n    size1 = size1 + *(int *)(ptr + -8);\n    flag1 = *(uint *)((int)ptr2 + size2 + 4) & 1;\n    if ((uint **)ptr6 == &DAT_20000454) {\n      if (flag1 == 0) {\n        flag1 = ptr2[2];\n        flag2 = ptr2[3];\n        size1 = size1 + size2;\n        *(uint *)(flag1 + 0xc) = flag2;\n        *(uint *)(flag2 + 8) = flag1;\n        ptr1[1] = size1 | 1;\n        *(uint *)((int)ptr1 + size1) = size1;\n      }\n      else {\n        ptr1[1] = size1 | 1;\n        *ptr2 = size1;\n      }\n      goto LAB_080089f0;\n    }\n    flag2 = ptr1[3];\n    ptr6[3] = flag2;\n    *(undefined4 **)(flag2 + 8) = ptr6;\n  }\n  else {\n    flag1 = *(uint *)((int)ptr2 + size2 + 4) & 1;\n  }\n  if (flag1 == 0) {\n    ptr6 = (undefined4 *)ptr2[2];\n    size1 = size1 + size2;\n    if ((uint **)ptr6 == &DAT_20000454) {\n      DAT_2000045c = ptr1;\n      DAT_20000460 = ptr1;\n      ptr1[2] = (uint)&DAT_20000454;\n      ptr1[3] = (uint)&DAT_20000454;\n      ptr1[1] = size1 | 1;\n      *(uint *)((int)ptr1 + size1) = size1;\n      goto LAB_080089f0;\n    }\n    size2 = ptr2[3];\n    ptr6[3] = size2;\n    *(undefined4 **)(size2 + 8) = ptr6;\n    ptr1[1] = size1 | 1;\n    *(uint *)((int)ptr1 + size1) = size1;\n  }\n  else {\n    ptr1[1] = size1 | 1;\n    *(uint *)((int)ptr1 + size1) = size1;\n  }\n  if (size1 < 0x200) {\n    count = (size1 >> 3) + 1;\n    size1 = 1 << ((int)(size1 >> 3) >> 2 & 0xffU) | (uint)DAT_20000450;\n    size2 = *(uint *)(&DAT_2000044c + count * 8);\n    ptr1[2] = size2;\n    ptr1[3] = (uint)(&DAT_20000444 + count * 8);\n    DAT_20000450 = (undefined *)size1;\n    *(uint **)(&DAT_2000044c + count * 8) = ptr1;\n    *(uint **)(size2 + 0xc) = ptr1;\n    __malloc_unlock(lock,ptr1,size1,arg4);\n    return;\n  }\n  size2 = size1 >> 9;\n  if (size2 < 5) {\n    count = ((size1 >> 6) + 0x39) * 8;\n    index = (size1 >> 6) + 0x38;\n  }\n  else if (size2 < 0x15) {\n    count = (size2 + 0x5c) * 8;\n    index = size2 + 0x5b;\n  }\n  else if (size2 < 0x55) {\n    count = ((size1 >> 0xc) + 0x6f) * 8;\n    index = (size1 >> 0xc) + 0x6e;\n  }\n  else if (size2 < 0x155) {\n    count = ((size1 >> 0xf) + 0x78) * 8;\n    index = (size1 >> 0xf) + 0x77;\n  }\n  else if (size2 < 0x555) {\n    count = ((size1 >> 0x12) + 0x7d) * 8;\n    index = (size1 >> 0x12) + 0x7c;\n  }\n  else {\n    count = 0x3f8;\n    index = 0x7e;\n  }\n  ptr3 = *(undefined **)(&DAT_2000044c + count);\n  ptr4 = &DAT_20000444 + count;\n  if (ptr4 == ptr3) {\n    ptr3 = (undefined *)(1 << (index >> 2 & 0xffU) | (uint)DAT_20000450);\n    ptr5 = ptr4;\n    DAT_20000450 = ptr3;\n  }\n  else {\n    do {\n      ptr5 = ptr3;\n      if ((*(uint *)(ptr3 + 4) & 0xfffffffc) <= size1) break;\n      ptr3 = *(undefined **)(ptr3 + 8);\n      ptr5 = ptr4;\n    } while (ptr4 != ptr3);\n    ptr4 = *(undefined **)(ptr5 + 0xc);\n  }\n  ptr1[2] = (uint)ptr5;\n  ptr1[3] = (uint)ptr4;\n  *(uint **)(ptr4 + 8) = ptr1;\n  *(uint **)(ptr5 + 0xc) = ptr1;\n  __malloc_unlock(lock,ptr1,ptr3,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088ec": "deallocate_memory_080088ec",
                "param_1": "lock",
                "param_2": "ptr",
                "param_3": "arg3",
                "param_4": "arg4",
                "iVar1": "index",
                "puVar2": "ptr1",
                "puVar3": "ptr2",
                "puVar4": "ptr3",
                "uVar5": "size1",
                "uVar6": "size2",
                "puVar7": "ptr4",
                "puVar8": "ptr5",
                "puVar9": "ptr6",
                "iVar10": "count",
                "uVar11": "flag1",
                "uVar12": "flag2"
            },
            "calling": [
                "_malloc_r",
                "__ssprint_r",
                "_svfprintf_r",
                "_realloc_r"
            ],
            "called": [
                "_malloc_trim_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ad4": {
            "entrypoint": "0x08008ad4",
            "current_name": "get_modified_value_08008ad4",
            "code": "\nint getModifiedValue_08008ad4(void)\n\n{\n  int originalValue;\n  \n  originalValue = *(int *)(DAT_2000001c + 0x34);\n  if (originalValue == 0) {\n    originalValue = 0x2000085c;\n  }\n  return originalValue + 0xf0;\n}\n\n",
            "renaming": {
                "FUN_08008ad4": "get_modified_value_08008ad4",
                "iVar1": "originalValue"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "FUNC_08008af0",
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_lock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af4": {
            "entrypoint": "0x08008af4",
            "current_name": "FUNC_08008af4",
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af8": {
            "entrypoint": "0x08008af8",
            "current_name": "allocate_memory_08008af8",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_memory_08008af8(undefined4 *param_lock,uint requested_size)\n\n{\n  undefined *var1;\n  uint var2;\n  uint var3;\n  int var4;\n  undefined *var5;\n  uint var6;\n  uint var7;\n  undefined4 *var8;\n  undefined *var9;\n  undefined *var10;\n  int *result;\n  uint adjusted_size;\n  uint aligned_size;\n  int temp_var;\n  undefined4 *new_block;\n  undefined4 *old_block;\n  \n  adjusted_size = requested_size + 0xb;\n  if (adjusted_size < 0x17) {\n    if (0x10 < requested_size) goto LAB_08008c7a;\n    __malloc_lock();\n    aligned_size = 0x10;\n    var4 = 0x18;\n    adjusted_size = 2;\nLAB_08008b18:\n    var10 = *(undefined **)((int)&DAT_20000450 + var4);\n    if ((var10 != &DAT_20000444 + var4) ||\n       (var10 = *(undefined **)((int)&DAT_20000458 + var4), &DAT_2000044c + var4 != var10)) {\n      var4 = *(int *)(var10 + 0xc);\n      var5 = var10 + (*(uint *)(var10 + 4) & 0xfffffffc);\n      adjusted_size = *(uint *)(var5 + 4);\nLAB_08008b34:\n      temp_var = *(int *)(var10 + 8);\n      *(int *)(temp_var + 0xc) = var4;\n      *(int *)(var4 + 8) = temp_var;\n      *(uint *)(var5 + 4) = adjusted_size | 1;\n      __malloc_unlock(param_lock);\n      return (int *)(var10 + 8);\n    }\n    adjusted_size = adjusted_size + 2;\n  }\n  else {\n    aligned_size = adjusted_size & 0xfffffff8;\n    if (((int)aligned_size < 0) || (aligned_size < requested_size)) {\nLAB_08008c7a:\n      *param_lock = 0xc;\n      return (int *)0x0;\n    }\n    __malloc_lock();\n    if (aligned_size < 0x1f8) {\n      adjusted_size = adjusted_size >> 3;\n      var4 = aligned_size + 8;\n      goto LAB_08008b18;\n    }\n    var2 = adjusted_size >> 9;\n    if (var2 == 0) {\n      var4 = 0x200;\n      var6 = 0x40;\n      var2 = 0x3f;\n    }\n    else if (var2 < 5) {\n      var6 = (adjusted_size >> 6) + 0x39;\n      var2 = (adjusted_size >> 6) + 0x38;\n      var4 = var6 * 8;\n    }\n    else if (var2 < 0x15) {\n      var6 = var2 + 0x5c;\n      var2 = var2 + 0x5b;\n      var4 = var6 * 8;\n    }\n    else if (var2 < 0x55) {\n      var6 = (adjusted_size >> 0xc) + 0x6f;\n      var2 = (adjusted_size >> 0xc) + 0x6e;\n      var4 = var6 * 8;\n    }\n    else if (var2 < 0x155) {\n      var6 = (adjusted_size >> 0xf) + 0x78;\n      var2 = (adjusted_size >> 0xf) + 0x77;\n      var4 = var6 * 8;\n    }\n    else if (var2 < 0x555) {\n      var6 = (adjusted_size >> 0x12) + 0x7d;\n      var2 = (adjusted_size >> 0x12) + 0x7c;\n      var4 = var6 * 8;\n    }\n    else {\n      var4 = 0x3f8;\n      var6 = 0x7f;\n      var2 = 0x7e;\n    }\n    for (var10 = *(undefined **)((int)&DAT_20000450 + var4); adjusted_size = var6,\n        &DAT_20000444 + var4 != var10; var10 = *(undefined **)(var10 + 0xc)) {\n      temp_var = (*(uint *)(var10 + 4) & 0xfffffffc) - aligned_size;\n      adjusted_size = var2;\n      if (0xf < temp_var) break;\n      if (-1 < temp_var) {\n        var5 = var10 + (*(uint *)(var10 + 4) & 0xfffffffc);\n        adjusted_size = *(uint *)(var5 + 4);\n        var4 = *(int *)(var10 + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  new_block = DAT_2000045c;\n  if ((undefined **)DAT_2000045c == &DAT_20000454) {\n    var6 = 1 << ((int)adjusted_size >> 2 & 0xffU);\n    var2 = DAT_20000450;\n    if (var6 <= DAT_20000450) goto LAB_08008c06;\n  }\n  else {\n    var6 = DAT_2000045c[1];\n    var7 = var6 & 0xfffffffc;\n    var2 = var7 - aligned_size;\n    if (0xf < (int)var2) {\n      old_block = (undefined4 *)(aligned_size + (int)DAT_2000045c);\n      DAT_2000045c[1] = aligned_size | 1;\n      DAT_2000045c = old_block;\n      DAT_20000460 = old_block;\n      old_block[2] = &DAT_20000454;\n      old_block[3] = &DAT_20000454;\n      old_block[1] = var2 | 1;\n      *(uint *)((int)new_block + var7) = var2;\n      __malloc_unlock(param_lock);\n      return new_block + 2;\n    }\n    DAT_2000045c = &DAT_20000454;\n    DAT_20000460 = &DAT_20000454;\n    if (-1 < (int)var2) {\n      *(uint *)((int)new_block + var7 + 4) = *(uint *)((int)new_block + var7 + 4) | 1;\n      __malloc_unlock(param_lock);\n      return new_block + 2;\n    }\n    if (var7 < 0x200) {\n      var4 = (var6 >> 3) + 1;\n      temp_var = *(int *)(&DAT_2000044c + var4 * 8);\n      var2 = 1 << ((int)(var6 >> 3) >> 2 & 0xffU) | DAT_20000450;\n      new_block[2] = temp_var;\n      new_block[3] = &DAT_20000444 + var4 * 8;\n      DAT_20000450 = var2;\n      *(undefined4 **)(&DAT_2000044c + var4 * 8) = new_block;\n      *(undefined4 **)(temp_var + 0xc) = new_block;\n    }\n    else {\n      var2 = var6 >> 9;\n      if (var2 < 5) {\n        var4 = ((var6 >> 6) + 0x39) * 8;\n        temp_var = (var6 >> 6) + 0x38;\n      }\n      else if (var2 < 0x15) {\n        var4 = (var2 + 0x5c) * 8;\n        temp_var = var2 + 0x5b;\n      }\n      else if (var2 < 0x55) {\n        var4 = ((var6 >> 0xc) + 0x6f) * 8;\n        temp_var = (var6 >> 0xc) + 0x6e;\n      }\n      else if (var2 < 0x155) {\n        var4 = ((var6 >> 0xf) + 0x78) * 8;\n        temp_var = (var6 >> 0xf) + 0x77;\n      }\n      else if (var2 < 0x555) {\n        var4 = ((var6 >> 0x12) + 0x7d) * 8;\n        temp_var = (var6 >> 0x12) + 0x7c;\n      }\n      else {\n        var4 = 0x3f8;\n        temp_var = 0x7e;\n      }\n      var10 = *(undefined **)(&DAT_2000044c + var4);\n      var5 = &DAT_20000444 + var4;\n      if (var5 == var10) {\n        DAT_20000450 = 1 << (temp_var >> 2 & 0xffU) | DAT_20000450;\n      }\n      else {\n        do {\n          if ((*(uint *)(var10 + 4) & 0xfffffffc) <= var7) break;\n          var10 = *(undefined **)(var10 + 8);\n        } while (var5 != var10);\n        var5 = *(undefined **)(var10 + 0xc);\n      }\n      var2 = DAT_20000450;\n      new_block[2] = var10;\n      new_block[3] = var5;\n      *(undefined4 **)(var5 + 8) = new_block;\n      *(undefined4 **)(var10 + 0xc) = new_block;\n    }\n    var6 = 1 << ((int)adjusted_size >> 2 & 0xffU);\n    if (var6 <= var2) {\nLAB_08008c06:\n      if ((var6 & var2) == 0) {\n        adjusted_size = adjusted_size & 0xfffffffc;\n        do {\n          var6 = var6 << 1;\n          adjusted_size = adjusted_size + 4;\n        } while ((var6 & var2) == 0);\n      }\n      do {\n        old_block = (undefined4 *)(&DAT_2000044c + adjusted_size * 8);\n        var2 = adjusted_size;\n        new_block = old_block;\n        do {\n          for (var8 = (undefined4 *)new_block[3]; new_block != var8;\n              var8 = (undefined4 *)var8[3]) {\n            var7 = var8[1] & 0xfffffffc;\n            var3 = var7 - aligned_size;\n            if (0xf < (int)var3) {\n              temp_var = var8[2];\n              var4 = var8[3];\n              new_block = (undefined4 *)(aligned_size + (int)var8);\n              var8[1] = aligned_size | 1;\n              *(int *)(temp_var + 0xc) = var4;\n              *(int *)(var4 + 8) = temp_var;\n              DAT_2000045c = new_block;\n              DAT_20000460 = new_block;\n              new_block[2] = &DAT_20000454;\n              new_block[3] = &DAT_20000454;\n              new_block[1] = var3 | 1;\n              *(uint *)((int)var8 + var7) = var3;\n              __malloc_unlock(param_lock);\n              return var8 + 2;\n            }\n            if (-1 < (int)var3) {\n              var4 = var8[3];\n              temp_var = var8[2];\n              *(uint *)((int)var8 + var7 + 4) = *(uint *)((int)var8 + var7 + 4) | 1;\n              *(int *)(temp_var + 0xc) = var4;\n              *(int *)(var4 + 8) = temp_var;\n              __malloc_unlock(param_lock);\n              return var8 + 2;\n            }\n          }\n          var2 = var2 + 1;\n          new_block = new_block + 2;\n        } while ((var2 & 3) != 0);\n        do {\n          var7 = adjusted_size & 3;\n          new_block = old_block + -2;\n          adjusted_size = adjusted_size - 1;\n          if (var7 == 0) {\n            DAT_20000450 = DAT_20000450 & ~var6;\n            break;\n          }\n          old_block = (undefined4 *)*old_block;\n        } while (old_block == new_block);\n        var6 = var6 * 2;\n        if ((DAT_20000450 <= var6 && var6 - DAT_20000450 != 0) || (adjusted_size = var2, var6 == 0))\n        break;\n        for (; (var6 & DAT_20000450) == 0; var6 = var6 << 1) {\n          adjusted_size = adjusted_size + 4;\n        }\n      } while( true );\n    }\n  }\n  var10 = DAT_20000454;\n  adjusted_size = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  if ((aligned_size <= adjusted_size) && (var2 = adjusted_size - aligned_size, 0xf < (int)var2)) goto LAB_08008dac;\n  if (DAT_20000854 == (undefined *)0xffffffff) {\n    var2 = aligned_size + DAT_20000a44 + 0x10;\n  }\n  else {\n    var2 = aligned_size + DAT_20000a44 + 0x100f & 0xfffff000;\n  }\n  var5 = (undefined *)_sbrk_r(param_lock,var2);\n  if (var5 == (undefined *)0xffffffff) {\nLAB_08008ed8:\n    adjusted_size = *(uint *)(DAT_20000454 + 4);\n  }\n  else {\n    var1 = var10 + adjusted_size;\n    if (var1 < var5 || var1 == var5) {\n      var9 = DAT_20000a14 + var2;\n      if ((var1 != var5) || (((uint)var1 & 0xfff) != 0)) goto LAB_08008d02;\n      DAT_20000a14 = var9;\n      *(uint *)(DAT_20000454 + 4) = adjusted_size + var2 | 1;\n    }\n    else {\n      if (var10 != &DAT_2000044c) goto LAB_08008ed8;\nLAB_08008d02:\n      DAT_20000a14 = DAT_20000a14 + var2;\n      var9 = var5;\n      if (DAT_20000854 != (undefined *)0xffffffff) {\n        DAT_20000a14 = DAT_20000a14 + ((int)var5 - (int)var1);\n        var9 = DAT_20000854;\n      }\n      DAT_20000854 = var9;\n      var6 = (uint)var5 & 7;\n      if (var6 == 0) {\n        var4 = 0x1000;\n      }\n      else {\n        var5 = var5 + (8 - var6);\n        var4 = 0x1008 - var6;\n      }\n      var4 = var4 - ((uint)(var5 + var2) & 0xfff);\n      temp_var = _sbrk_r(param_lock,var4);\n      if (temp_var == -1) {\n        var2 = 1;\n        var4 = 0;\n      }\n      else {\n        var2 = (temp_var - (int)var5) + var4 | 1;\n      }\n      var9 = DAT_20000a14 + var4;\n      DAT_20000454 = var5;\n      DAT_20000a14 = var9;\n      *(uint *)(var5 + 4) = var2;\n      if (var10 != &DAT_2000044c) {\n        if (adjusted_size < 0x10) {\n          *(undefined4 *)(var5 + 4) = 1;\n          goto LAB_08008eee;\n        }\n        adjusted_size = adjusted_size - 0xc & 0xfffffff8;\n        *(uint *)(var10 + 4) = *(uint *)(var10 + 4) & 1 | adjusted_size;\n        *(undefined4 *)(var10 + adjusted_size + 4) = 5;\n        *(undefined4 *)(var10 + adjusted_size + 8) = 5;\n        if (0xf < adjusted_size) {\n          _free_r(param_lock,var10 + 8);\n          var9 = DAT_20000a14;\n        }\n      }\n    }\n    if (DAT_20000a3c < var9) {\n      DAT_20000a3c = var9;\n    }\n    adjusted_size = *(uint *)(DAT_20000454 + 4);\n    if (DAT_20000a40 < var9) {\n      DAT_20000a40 = var9;\n    }\n  }\n  var2 = (adjusted_size & 0xfffffffc) - aligned_size;\n  if ((aligned_size <= (adjusted_size & 0xfffffffc)) && (0xf < (int)var2)) {\nLAB_08008dac:\n    var10 = DAT_20000454 + aligned_size;\n    *(uint *)(DAT_20000454 + 4) = aligned_size | 1;\n    result = (int *)(DAT_20000454 + 8);\n    DAT_20000454 = var10;\n    *(uint *)(var10 + 4) = var2 | 1;\n    __malloc_unlock(param_lock);\n    return result;\n  }\nLAB_08008eee:\n  __malloc_unlock(param_lock);\n  return (int *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08008af8": "allocate_memory_08008af8",
                "param_1": "param_lock",
                "param_2": "requested_size",
                "puVar1": "var1",
                "uVar2": "var2",
                "uVar3": "var3",
                "iVar4": "var4",
                "puVar5": "var5",
                "uVar6": "var6",
                "uVar7": "var7",
                "puVar8": "var8",
                "puVar9": "var9",
                "puVar10": "var10",
                "piVar11": "result",
                "uVar12": "adjusted_size",
                "uVar13": "aligned_size",
                "iVar14": "temp_var",
                "puVar15": "new_block",
                "puVar16": "old_block"
            },
            "calling": [
                "_calloc_r",
                "__ssprint_r",
                "_svfprintf_r",
                "_realloc_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "_free_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800901c": {
            "entrypoint": "0x0800901c",
            "current_name": "find_byte_sequence_0800901c",
            "code": "\nuint * find_byte_sequence_0800901c(uint *sequence,uint byte,uint length)\n\n{\n  uint xor_result;\n  uint shifted_byte;\n  uint *current_address;\n  uint masked_byte;\n  bool is_length_zero;\n  \n  masked_byte = byte & 0xff;\n  if (((uint)sequence & 3) == 0) {\nLAB_0800904a:\n    if (3 < length) {\n      shifted_byte = (byte & 0xff) << 8 | masked_byte;\n      current_address = sequence;\n      do {\n        xor_result = *current_address ^ (shifted_byte | shifted_byte << 0x10);\n        sequence = current_address + 1;\n        if ((xor_result + 0xfefefeff & ~xor_result & 0x80808080) != 0) goto LAB_08009050;\n        length = length - 4;\n        current_address = sequence;\n      } while (3 < length);\n    }\n    current_address = sequence;\n    if (length == 0) {\n      sequence = (uint *)0x0;\n    }\n    else {\nLAB_08009050:\n      sequence = current_address;\n      if (*(byte *)sequence != masked_byte) {\n        current_address = (uint *)(length + (int)sequence);\n        do {\n          sequence = (uint *)((int)sequence + 1);\n          if (current_address == sequence) goto LAB_0800906c;\n        } while (*(byte *)sequence != masked_byte);\n      }\n    }\n  }\n  else {\n    shifted_byte = length - 1;\n    if (length == 0) {\nLAB_0800906c:\n      sequence = (uint *)0x0;\n    }\n    else if (*(byte *)sequence != masked_byte) {\n      current_address = (uint *)((int)sequence + 1);\n      do {\n        sequence = current_address;\n        length = shifted_byte;\n        if (((uint)sequence & 3) == 0) goto LAB_0800904a;\n        is_length_zero = shifted_byte == 0;\n        shifted_byte = shifted_byte - 1;\n        if (is_length_zero) goto LAB_0800906c;\n        current_address = (uint *)((int)sequence + 1);\n      } while (*(byte *)sequence != masked_byte);\n    }\n  }\n  return sequence;\n}\n\n",
            "renaming": {
                "FUN_0800901c": "find_byte_sequence_0800901c",
                "param_1": "sequence",
                "param_2": "byte",
                "param_3": "length",
                "uVar1": "xor_result",
                "uVar2": "shifted_byte",
                "puVar3": "current_address",
                "uVar4": "masked_byte",
                "bVar5": "is_length_zero"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090a8": {
            "entrypoint": "0x080090a8",
            "current_name": "acquire_lock_080090a8",
            "code": "\nvoid acquireLock_080090a8(void)\n\n{\n  __retarget_lock_acquire_recursive(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090a8": "acquire_lock_080090a8"
            },
            "calling": [
                "_malloc_trim_r",
                "_malloc_r",
                "_free_r",
                "_realloc_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "release_recursive_lock_080090b4",
            "code": "\nvoid releaseRecursiveLock_080090b4(void)\n\n{\n  __retarget_lock_release_recursive(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "release_recursive_lock_080090b4"
            },
            "calling": [
                "_malloc_trim_r",
                "_malloc_r",
                "_realloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c0": {
            "entrypoint": "0x080090c0",
            "current_name": "allocate_or_update_array_080090c0",
            "code": "\nundefined4 * allocateOrUpdateArray_080090c0(int pointerToData,uint index)\n\n{\n  undefined4 *arrayElement;\n  int arrayPointer;\n  \n  arrayPointer = *(int *)(pointerToData + 0x4c);\n  if (arrayPointer == 0) {\n    arrayPointer = _calloc_r(pointerToData,4,0x21);\n    *(int *)(pointerToData + 0x4c) = arrayPointer;\n    if (arrayPointer == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  arrayElement = *(undefined4 **)(arrayPointer + index * 4);\n  if (arrayElement == (undefined4 *)0x0) {\n    arrayPointer = 1 << (index & 0xff);\n    arrayElement = (undefined4 *)_calloc_r(pointerToData,1,(arrayPointer + 5) * 4);\n    if (arrayElement == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    arrayElement[1] = index;\n    arrayElement[2] = arrayPointer;\n  }\n  else {\n    *(undefined4 *)(arrayPointer + index * 4) = *arrayElement;\n  }\n  arrayElement[3] = 0;\n  arrayElement[4] = 0;\n  return arrayElement;\n}\n\n",
            "renaming": {
                "FUN_080090c0": "allocate_or_update_array_080090c0",
                "param_1": "pointerToData",
                "param_2": "index",
                "puVar1": "arrayElement",
                "iVar2": "arrayPointer"
            },
            "calling": [
                "__d2b",
                "_dtoa_r",
                "__multiply",
                "__i2b",
                "__mdiff",
                "__pow5mult",
                "__multadd",
                "__lshift"
            ],
            "called": [
                "_calloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800910c": {
            "entrypoint": "0x0800910c",
            "current_name": "copy_value_to_pointer_0800910c",
            "code": "\nvoid copyValueToPointer_0800910c(int inputOffset,undefined4 *outputPointer)\n\n{\n  int dataBlockOffset;\n  \n  if (outputPointer != (undefined4 *)0x0) {\n    dataBlockOffset = *(int *)(inputOffset + 0x4c);\n    *outputPointer = *(undefined4 *)(dataBlockOffset + outputPointer[1] * 4);\n    *(undefined4 **)(dataBlockOffset + outputPointer[1] * 4) = outputPointer;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800910c": "copy_value_to_pointer_0800910c",
                "param_1": "inputOffset",
                "param_2": "outputPointer",
                "iVar1": "dataBlockOffset"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009120": {
            "entrypoint": "0x08009120",
            "current_name": "calculate_checksum_08009120",
            "code": "\nundefined4 * calculateChecksum_08009120(int size,undefined4 *data,int multiplier,uint checksum)\n\n{\n  undefined4 *result;\n  uint carry;\n  int numElements;\n  uint *currentElement;\n  int iteration;\n  \n  iteration = 0;\n  numElements = data[4];\n  currentElement = data + 5;\n  do {\n    iteration = iteration + 1;\n    checksum = multiplier * (*currentElement & 0xffff) + checksum;\n    carry = multiplier * (*currentElement >> 0x10) + (checksum >> 0x10);\n    *currentElement = (checksum & 0xffff) + carry * 0x10000;\n    checksum = carry >> 0x10;\n    currentElement = currentElement + 1;\n  } while (iteration < numElements);\n  result = data;\n  if (checksum != 0) {\n    if ((int)data[2] <= numElements) {\n      result = (undefined4 *)_Balloc(size,data[1] + 1);\n      memcpy(result + 3,data + 3,(data[4] + 2) * 4);\n      iteration = *(int *)(size + 0x4c);\n      *data = *(undefined4 *)(iteration + data[1] * 4);\n      *(undefined4 **)(iteration + data[1] * 4) = data;\n    }\n    result[numElements + 5] = checksum;\n    result[4] = numElements + 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009120": "calculate_checksum_08009120",
                "param_1": "size",
                "param_2": "data",
                "param_3": "multiplier",
                "param_4": "checksum",
                "puVar1": "result",
                "uVar2": "carry",
                "iVar3": "numElements",
                "puVar4": "currentElement",
                "iVar5": "iteration"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "memcpy",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a4": {
            "entrypoint": "0x080091a4",
            "current_name": "determine_bit_position_080091a4",
            "code": "\nint determineBitPosition_080091a4(uint inputValue)\n\n{\n  int bitPosition;\n  \n  if ((inputValue & 0xffff0000) == 0) {\n    inputValue = inputValue << 0x10;\n    bitPosition = 0x10;\n  }\n  else {\n    bitPosition = 0;\n  }\n  if ((inputValue & 0xff000000) == 0) {\n    inputValue = inputValue << 8;\n    bitPosition = bitPosition + 8;\n  }\n  if ((inputValue & 0xf0000000) == 0) {\n    inputValue = inputValue << 4;\n    bitPosition = bitPosition + 4;\n  }\n  if ((inputValue & 0xc0000000) == 0) {\n    inputValue = inputValue << 2;\n    bitPosition = bitPosition + 2;\n  }\n  if (-1 < (int)inputValue) {\n    if ((int)(inputValue << 1) < 0) {\n      return bitPosition + 1;\n    }\n    bitPosition = 0x20;\n  }\n  return bitPosition;\n}\n\n",
            "renaming": {
                "FUN_080091a4": "determine_bit_position_080091a4",
                "param_1": "inputValue",
                "iVar1": "bitPosition"
            },
            "calling": [
                "__d2b",
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091e4": {
            "entrypoint": "0x080091e4",
            "current_name": "count_leading_zeros_080091e4",
            "code": "\nint countLeadingZeros_080091e4(uint *value)\n\n{\n  int leadingZeros;\n  uint temp;\n  \n  temp = *value;\n  if ((temp & 7) == 0) {\n    if ((temp & 0xffff) == 0) {\n      temp = temp >> 0x10;\n      leadingZeros = 0x10;\n    }\n    else {\n      leadingZeros = 0;\n    }\n    if ((temp & 0xff) == 0) {\n      temp = temp >> 8;\n      leadingZeros = leadingZeros + 8;\n    }\n    if ((temp & 0xf) == 0) {\n      temp = temp >> 4;\n      leadingZeros = leadingZeros + 4;\n    }\n    if ((temp & 3) == 0) {\n      temp = temp >> 2;\n      leadingZeros = leadingZeros + 2;\n    }\n    if (-1 < (int)(temp << 0x1f)) {\n      temp = temp >> 1;\n      if (temp == 0) {\n        return 0x20;\n      }\n      leadingZeros = leadingZeros + 1;\n    }\n    *value = temp;\n    return leadingZeros;\n  }\n  if ((int)(temp << 0x1f) < 0) {\n    return 0;\n  }\n  if (-1 < (int)(temp << 0x1e)) {\n    *value = temp >> 2;\n    return 2;\n  }\n  *value = temp >> 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080091e4": "count_leading_zeros_080091e4",
                "param_1": "value",
                "iVar1": "leadingZeros",
                "uVar2": "temp"
            },
            "calling": [
                "__d2b"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009244": {
            "entrypoint": "0x08009244",
            "current_name": "initialize_data_structure_08009244",
            "code": "\nvoid initializeDataStructure_08009244(undefined4 size,undefined4 value)\n\n{\n  int allocatedMemory;\n  \n  allocatedMemory = _Balloc(size,1);\n  *(undefined4 *)(allocatedMemory + 0x10) = 1;\n  *(undefined4 *)(allocatedMemory + 0x14) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009244": "initialize_data_structure_08009244",
                "param_1": "size",
                "param_2": "value",
                "iVar1": "allocatedMemory"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009258": {
            "entrypoint": "0x08009258",
            "current_name": "calculate_hash_08009258",
            "code": "\nvoid calculateHash_08009258(undefined4 outputBuffer,int sourceBuffer1,int sourceBuffer2)\n\n{\n  uint *src1Ptr;\n  uint *src2Ptr;\n  int numElements;\n  uint temp;\n  uint *destPtr;\n  uint src1Start;\n  uint *src1End;\n  uint carry;\n  int source1Length;\n  int minLength;\n  uint src2End;\n  int source2Length;\n  int maxLength;\n  uint *destPtr;\n  uint *src1Ptr;\n  uint *src2Ptr;\n  uint *destEndPtr;\n  uint *destStartPtr;\n  \n  source2Length = *(int *)(sourceBuffer1 + 0x10);\n  source1Length = *(int *)(sourceBuffer2 + 0x10);\n  minLength = source1Length;\n  maxLength = sourceBuffer1;\n  if (source2Length < source1Length) {\n    minLength = source2Length;\n    source2Length = source1Length;\n    maxLength = sourceBuffer2;\n    sourceBuffer2 = sourceBuffer1;\n  }\n  source1Length = source2Length + minLength;\n  numElements = *(int *)(maxLength + 4);\n  if (*(int *)(maxLength + 8) < source1Length) {\n    numElements = numElements + 1;\n  }\n  numElements = _Balloc(outputBuffer,numElements);\n  destStartPtr = (uint *)(numElements + 0x14);\n  destEndPtr = destStartPtr + source1Length;\n  for (destPtr = destStartPtr; destPtr < destEndPtr; destPtr = destPtr + 1) {\n    *destPtr = 0;\n  }\n  src1Start = sourceBuffer2 + 0x14;\n  src2End = src1Start + minLength * 4;\n  destPtr = (uint *)(maxLength + 0x14);\n  if (src1Start < src2End) {\n    src1End = (uint *)(src1Start + ((src2End - sourceBuffer2) - 0x15 & 0xfffffffc));\n    src2Ptr = (uint *)(sourceBuffer2 + 0x10);\n    do {\n      while( true ) {\n        src2Ptr = src2Ptr + 1;\n        src1Start = *src2Ptr & 0xffff;\n        if (src1Start != 0) break;\n        src1Start = *src2Ptr >> 0x10;\n        if (src1Start == 0) goto LAB_080092d2;\nLAB_0800932c:\n        carry = *destStartPtr;\n        temp = 0;\n        src1Ptr = destPtr;\n        destPtr = destStartPtr;\n        src2End = carry;\n        do {\n          src1Ptr = destPtr;\n          temp = temp + src1Start * *(ushort *)src1Ptr + (src2End >> 0x10);\n          *src1Ptr = carry & 0xffff | temp * 0x10000;\n          src2Ptr = src1Ptr + 1;\n          src2End = src1Ptr[1];\n          carry = src1Start * (*src1Ptr >> 0x10) + (src2End & 0xffff) + (temp >> 0x10);\n          temp = carry >> 0x10;\n          src1Ptr = src2Ptr;\n          destPtr = src1Ptr + 1;\n        } while (src2Ptr < destPtr + source2Length);\n        src1Ptr[1] = carry;\n        destStartPtr = destStartPtr + 1;\n        if (src1End == src2Ptr) goto LAB_0800937a;\n      }\n      src2End = 0;\n      src1Ptr = destStartPtr;\n      destPtr = destPtr;\n      do {\n        src2Ptr = src1Ptr;\n        src1Ptr = destPtr + 1;\n        carry = src1Start * (*destPtr & 0xffff) + (*src2Ptr & 0xffff) + src2End;\n        temp = src1Start * (*destPtr >> 0x10) + (*src2Ptr >> 0x10) + (carry >> 0x10);\n        src2End = temp >> 0x10;\n        *src2Ptr = carry & 0xffff | temp * 0x10000;\n        src1Ptr = src2Ptr + 1;\n        destPtr = src1Ptr;\n      } while (src1Ptr < destPtr + source2Length);\n      src2Ptr[1] = src2End;\n      src1Start = *src2Ptr >> 0x10;\n      if (src1Start != 0) goto LAB_0800932c;\nLAB_080092d2:\n      destStartPtr = destStartPtr + 1;\n    } while (src1End != src2Ptr);\n  }\nLAB_0800937a:\n  if (0 < source1Length) {\n    src1Start = destEndPtr[-1];\n    destEndPtr = destEndPtr + -1;\n    while ((src1Start == 0 && (source1Length = source1Length + -1, source1Length != 0))) {\n      destEndPtr = destEndPtr + -1;\n      src1Start = *destEndPtr;\n    }\n  }\n  *(int *)(numElements + 0x10) = source1Length;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009258": "calculate_hash_08009258",
                "param_1": "outputBuffer",
                "param_2": "sourceBuffer1",
                "param_3": "sourceBuffer2",
                "puVar1": "src1Ptr",
                "puVar2": "src2Ptr",
                "iVar3": "numElements",
                "uVar4": "temp",
                "puVar5": "destPtr",
                "uVar6": "src1Start",
                "puVar7": "src1End",
                "puVar16": "src2Ptr",
                "uVar8": "carry",
                "iVar9": "source1Length",
                "iVar12": "source2Length",
                "iVar10": "minLength",
                "iVar13": "maxLength",
                "uVar11": "src2End",
                "puVar14": "destPtr",
                "puVar15": "src1Ptr",
                "puVar17": "destEndPtr",
                "puVar18": "destStartPtr"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080093a4": {
            "entrypoint": "0x080093a4",
            "current_name": "multiply_and_add_080093a4",
            "code": "\nundefined4 * multiplyAndAdd_080093a4(int value1,undefined4 *valueArray,uint arrayLength)\n\n{\n  int index;\n  int numIterations;\n  undefined4 *valuePtr1;\n  undefined4 *valuePtr2;\n  \n  if ((arrayLength & 3) != 0) {\n    valueArray = (undefined4 *)\n              multiplyAndAdd_080093a4Helper(value1,valueArray,*(undefined4 *)(&DAT_0800a070 + ((arrayLength & 3) - 1) * 4),0);\n  }\n  numIterations = (int)arrayLength >> 2;\n  if (numIterations != 0) {\n    valuePtr2 = *(undefined4 **)(value1 + 0x48);\n    if (valuePtr2 == (undefined4 *)0x0) {\n      valuePtr2 = (undefined4 *)_Balloc(value1,1);\n      valuePtr2[4] = 1;\n      valuePtr2[5] = 0x271;\n      *(undefined4 **)(value1 + 0x48) = valuePtr2;\n      *valuePtr2 = 0;\n    }\n    valuePtr1 = valueArray;\n    if (numIterations << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    numIterations = numIterations >> 1;\n    valuePtr1 = valuePtr2;\n    if (numIterations != 0) {\n      while( true ) {\n        valuePtr2 = (undefined4 *)*valuePtr1;\n        if (valuePtr2 == (undefined4 *)0x0) {\n          valuePtr2 = (undefined4 *)__multiply(value1,valuePtr1,valuePtr1);\n          *valuePtr1 = valuePtr2;\n          *valuePtr2 = 0;\n        }\n        valuePtr1 = valueArray;\n        if (-1 < numIterations << 0x1f) break;\nLAB_080093d2:\n        valueArray = (undefined4 *)__multiply(value1,valuePtr1,valuePtr2);\n        if (valuePtr1 == (undefined4 *)0x0) break;\n        index = *(int *)(value1 + 0x4c);\n        numIterations = numIterations >> 1;\n        *valuePtr1 = *(undefined4 *)(index + valuePtr1[1] * 4);\n        *(undefined4 **)(index + valuePtr1[1] * 4) = valuePtr1;\n        valuePtr1 = valuePtr2;\n        if (numIterations == 0) {\n          return valueArray;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return valueArray;\n}\n\n",
            "renaming": {
                "FUN_080093a4": "multiply_and_add_080093a4",
                "param_1": "value1",
                "param_2": "valueArray",
                "param_3": "arrayLength",
                "iVar1": "index",
                "iVar2": "numIterations",
                "puVar3": "valuePtr1",
                "puVar4": "valuePtr2",
                "__multadd": "multiplyAndAddHelper"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__multiply",
                "_Balloc",
                "__multadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009444": {
            "entrypoint": "0x08009444",
            "current_name": "decompress_data_08009444",
            "code": "\nvoid decompressData_08009444(int targetBuf,undefined4 *header,uint headerSize)\n\n{\n  int temp;\n  int temp1;\n  int temp2;\n  undefined4 temp3;\n  int dataOffset;\n  int temp4;\n  uint *destData;\n  uint *srcData;\n  uint *tempPtr2;\n  uint *tempPtr3;\n  int shiftAmount;\n  int temp5;\n  uint temp6;\n  uint *tempPtr1;\n  \n  dataOffset = header[4];\n  shiftAmount = (int)headerSize >> 5;\n  temp5 = shiftAmount + dataOffset + 1;\n  temp2 = header[1];\n  temp1 = header[2];\n  if ((int)header[2] < temp5) {\n    do {\n      temp4 = temp1 * 2;\n      temp = temp1 * -2;\n      temp2 = temp2 + 1;\n      temp1 = temp4;\n    } while (temp5 != temp4 && temp5 + temp < 0 == SBORROW4(temp5,temp4));\n  }\n  temp1 = _Balloc(targetBuf,temp2);\n  destData = (uint *)(temp1 + 0x14);\n  if (0 < shiftAmount) {\n    tempPtr3 = destData + shiftAmount;\n    srcData = destData;\n    do {\n      tempPtr1 = srcData + 1;\n      *srcData = 0;\n      destData = tempPtr3;\n      srcData = tempPtr1;\n    } while (tempPtr1 != tempPtr3);\n  }\n  temp2 = header[4];\n  srcData = header + 5;\n  headerSize = headerSize & 0x1f;\n  if (headerSize == 0) {\n    destData = destData + -1;\n    tempPtr3 = srcData;\n    do {\n      tempPtr1 = tempPtr3 + 1;\n      destData = destData + 1;\n      *destData = *tempPtr3;\n      tempPtr3 = tempPtr1;\n    } while (tempPtr1 < srcData + temp2);\n  }\n  else {\n    temp6 = 0;\n    tempPtr3 = srcData;\n    do {\n      tempPtr1 = destData;\n      *tempPtr1 = *tempPtr3 << headerSize | temp6;\n      tempPtr2 = tempPtr3 + 1;\n      temp6 = *tempPtr3 >> (0x20 - headerSize & 0xff);\n      destData = tempPtr1 + 1;\n      tempPtr3 = tempPtr2;\n    } while (tempPtr2 < srcData + temp2);\n    tempPtr1[1] = temp6;\n    if (temp6 != 0) {\n      temp5 = shiftAmount + dataOffset + 2;\n    }\n  }\n  dataOffset = *(int *)(targetBuf + 0x4c);\n  temp2 = header[1];\n  temp3 = *(undefined4 *)(dataOffset + temp2 * 4);\n  *(int *)(temp1 + 0x10) = temp5 + -1;\n  *header = temp3;\n  *(undefined4 **)(dataOffset + temp2 * 4) = header;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009444": "decompress_data_08009444",
                "param_1": "targetBuf",
                "param_2": "header",
                "param_3": "headerSize",
                "iVar1": "temp",
                "iVar2": "temp1",
                "iVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "dataOffset",
                "iVar6": "temp4",
                "puVar7": "destData",
                "puVar8": "srcData",
                "puVar9": "tempPtr1",
                "puVar10": "tempPtr2",
                "puVar11": "tempPtr3",
                "iVar12": "shiftAmount",
                "iVar13": "temp5",
                "uVar14": "temp6"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094f8": {
            "entrypoint": "0x080094f8",
            "current_name": "compare_arrays_080094f8",
            "code": "\nint compareArrays_080094f8(int array1,int array2)\n\n{\n  int difference;\n  uint *ptr2;\n  int offset;\n  uint *ptr1;\n  \n  offset = *(int *)(array2 + 0x10);\n  difference = *(int *)(array1 + 0x10) - offset;\n  if (difference == 0) {\n    ptr2 = (uint *)(array2 + 0x14 + offset * 4);\n    ptr1 = (uint *)(array1 + 0x14) + offset;\n    do {\n      ptr1 = ptr1 + -1;\n      ptr2 = ptr2 + -1;\n      if (*ptr1 != *ptr2) {\n        if (*ptr2 <= *ptr1) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1 + 0x14) < ptr1);\n  }\n  return difference;\n}\n\n",
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1",
                "param_2": "array2",
                "iVar1": "difference",
                "iVar3": "offset",
                "puVar2": "ptr2",
                "puVar4": "ptr1"
            },
            "calling": [
                "_dtoa_r",
                "quorem"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009530": {
            "entrypoint": "0x08009530",
            "current_name": "reverse_and_allocate_08009530",
            "code": "\nvoid reverseAndAllocate_08009530(undefined4 input_param,uint *source_array,uint *target_array,undefined4 unused_param)\n\n{\n  int allocation_result;\n  uint *source_ptr;\n  uint source_length;\n  uint current_value;\n  undefined4 is_equal;\n  uint *target_ptr;\n  uint *source_ptr_current;\n  uint *source_ptr_initial;\n  uint *target_ptr_current;\n  uint *target_ptr_end;\n  int carry_over;\n  uint *source_ptr_end;\n  uint target_length;\n  uint *source_ptr_temp;\n  \n  source_ptr = (uint *)target_array[4];\n  target_ptr_end = source_array + 5;\n  source_ptr_end = target_array + 5;\n  source_ptr_current = target_ptr_end;\n  source_ptr_initial = source_array;\n  if ((uint *)source_array[4] == source_ptr) {\n    target_ptr = target_ptr_end + (int)source_ptr;\n    source_ptr = source_ptr_end + (int)source_ptr;\n    while( true ) {\n      target_ptr = target_ptr + -1;\n      source_ptr = source_ptr + -1;\n      if (*target_ptr != *source_ptr) break;\n      if (target_ptr <= target_ptr_end) {\n        carry_over = _Balloc(input_param,0,target_ptr,source_ptr,unused_param);\n        *(undefined4 *)(carry_over + 0x10) = 1;\n        *(undefined4 *)(carry_over + 0x14) = 0;\n        return;\n      }\n    }\n    is_equal = 0;\n    if (*source_ptr <= *target_ptr) goto LAB_08009578;\n  }\n  else if (-1 < (int)(uint *)source_array[4] - (int)source_ptr) {\n    is_equal = 0;\n    target_ptr = target_array;\n    goto LAB_08009578;\n  }\n  is_equal = 1;\n  target_ptr = target_ptr_end;\n  source_ptr = source_array;\n  source_ptr_current = source_ptr_end;\n  source_ptr_initial = target_array;\n  target_array = source_array;\n  source_ptr_end = target_ptr_end;\nLAB_08009578:\n  allocation_result = _Balloc(input_param,source_ptr_initial[1],target_ptr,source_ptr,unused_param);\n  carry_over = 0;\n  target_length = source_ptr_initial[4];\n  source_length = target_array[4];\n  *(undefined4 *)(allocation_result + 0xc) = is_equal;\n  target_ptr_end = source_ptr_current + target_length;\n  source_ptr = (uint *)(allocation_result + 0x14);\n  source_ptr_initial = source_ptr_end;\n  do {\n    source_ptr_temp = source_ptr_current + 1;\n    target_ptr_current = source_ptr_initial + 1;\n    current_value = ((*source_ptr_current & 0xffff) + carry_over) - (*source_ptr_initial & 0xffff);\n    carry_over = ((*source_ptr_current >> 0x10) - (*source_ptr_initial >> 0x10)) + ((int)current_value >> 0x10);\n    current_value = current_value & 0xffff | carry_over * 0x10000;\n    target_ptr = source_ptr + 1;\n    *source_ptr = current_value;\n    carry_over = carry_over >> 0x10;\n    source_ptr = target_ptr;\n    source_ptr_current = source_ptr_temp;\n    source_ptr_initial = target_ptr_current;\n  } while (target_ptr_current < source_ptr_end + source_length);\n  source_ptr = source_ptr_temp;\n  source_ptr_current = target_ptr;\n  if (source_ptr_temp < target_ptr_end) {\n    do {\n      source_ptr_initial = source_ptr + 1;\n      source_length = (*source_ptr & 0xffff) + carry_over;\n      carry_over = ((int)source_length >> 0x10) + (*source_ptr >> 0x10);\n      current_value = source_length & 0xffff | carry_over * 0x10000;\n      *source_ptr_current = current_value;\n      carry_over = carry_over >> 0x10;\n      source_ptr = source_ptr_initial;\n      source_ptr_current = source_ptr_current + 1;\n    } while (source_ptr_initial < target_ptr_end);\n    target_ptr = (uint *)((int)target_ptr + ((int)target_ptr_end + ~(uint)source_ptr_temp & 0xfffffffc) + 4);\n  }\n  target_ptr = target_ptr + -1;\n  while (current_value == 0) {\n    target_ptr = target_ptr + -1;\n    target_length = target_length - 1;\n    current_value = *target_ptr;\n  }\n  *(uint *)(allocation_result + 0x10) = target_length;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009530": "reverse_and_allocate_08009530",
                "param_1": "input_param",
                "param_2": "source_array",
                "param_3": "target_array",
                "param_4": "unused_param",
                "iVar1": "allocation_result",
                "puVar2": "source_ptr",
                "uVar3": "source_length",
                "uVar4": "current_value",
                "uVar5": "is_equal",
                "uVar14": "target_length",
                "puVar6": "target_ptr",
                "puVar7": "source_ptr_current",
                "puVar8": "source_ptr_temp",
                "puVar9": "source_ptr_initial",
                "puVar10": "target_ptr_current",
                "puVar11": "target_ptr_end",
                "puVar13": "source_ptr_end",
                "iVar12": "carry_over"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009630": {
            "entrypoint": "0x08009630",
            "current_name": "process_data_08009630",
            "code": "\nint processData_08009630(undefined4 dataSize,undefined4 param2,uint value1,uint value2,int *result1,\n                int *result2)\n\n{\n  int buffer;\n  uint shift;\n  int temp1;\n  int temp2;\n  uint temp3;\n  uint temp4;\n  undefined8 temp5;\n  uint localValue1;\n  uint localValue2;\n  \n  buffer = _Balloc(dataSize,1);\n  temp4 = (value2 << 1) >> 0x15;\n  localValue2 = value2 & 0xfffff;\n  if (temp4 != 0) {\n    localValue2 = localValue2 | 0x100000;\n  }\n  if (value1 == 0) {\n    temp1 = __lo0bits(&localValue2);\n    temp2 = 1;\n    shift = temp1 + 0x20;\n    *(undefined4 *)(buffer + 0x10) = 1;\n    *(uint *)(buffer + 0x14) = localValue2;\n  }\n  else {\n    localValue1 = value1;\n    shift = __lo0bits(&localValue1);\n    if (shift == 0) {\n      *(uint *)(buffer + 0x14) = localValue1;\n    }\n    else {\n      temp3 = localValue2 << (0x20 - shift & 0xff);\n      localValue2 = localValue2 >> (shift & 0xff);\n      *(uint *)(buffer + 0x14) = temp3 | localValue1;\n    }\n    if (localValue2 == 0) {\n      temp2 = 1;\n    }\n    else {\n      temp2 = 2;\n    }\n    *(uint *)(buffer + 0x18) = localValue2;\n    *(int *)(buffer + 0x10) = temp2;\n  }\n  if (temp4 == 0) {\n    *result1 = shift - 0x432;\n    temp5 = __hi0bits(*(undefined4 *)(buffer + temp2 * 4 + 0x10));\n    *result2 = (int)((ulonglong)temp5 >> 0x20) * 0x20 - (int)temp5;\n    return buffer;\n  }\n  *result1 = (temp4 - 0x433) + shift;\n  *result2 = 0x35 - shift;\n  return buffer;\n}\n\n",
            "renaming": {
                "FUN_08009630": "process_data_08009630",
                "param_1": "dataSize",
                "param_2": "param2",
                "param_3": "value1",
                "param_4": "value2",
                "param_5": "result1",
                "param_6": "result2",
                "iVar1": "buffer",
                "uVar2": "shift",
                "iVar3": "temp1",
                "iVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "temp4",
                "uVar7": "temp5",
                "local_20": "localValue1",
                "local_1c": "localValue2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__lo0bits",
                "_Balloc",
                "__hi0bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e0": {
            "entrypoint": "0x080096e0",
            "current_name": "calculate_floating_point_080096e0",
            "code": "\nundefined8 calculateFloatingPoint_080096e0(uint number1,uint number2,int *resultExponent,undefined4 additionalParam)\n\n{\n  int counter;\n  uint normalizedNumber2;\n  undefined8 combinedNumbers;\n  \n  combinedNumbers = CONCAT44(number2,number1);\n  counter = 0;\n  normalizedNumber2 = number2 & 0x7fffffff;\n  *resultExponent = 0;\n  if ((normalizedNumber2 < 0x7ff00000) && ((normalizedNumber2 | number1) != 0)) {\n    if (normalizedNumber2 < 0x100000) {\n      combinedNumbers = __muldf3(number1,number2,0,0x43500000,additionalParam);\n      counter = -0x36;\n      normalizedNumber2 = (uint)((ulonglong)combinedNumbers >> 0x20) & 0x7fffffff;\n    }\n    number1 = (uint)combinedNumbers;\n    number2 = (uint)((ulonglong)combinedNumbers >> 0x20) & 0x800fffff | 0x3fe00000;\n    *resultExponent = ((int)normalizedNumber2 >> 0x14) + -0x3fe + counter;\n  }\n  return CONCAT44(number2,number1);\n}\n\n",
            "renaming": {
                "FUN_080096e0": "calculate_floating_point_080096e0",
                "param_1": "number1",
                "param_2": "number2",
                "param_3": "resultExponent",
                "param_4": "additionalParam",
                "iVar1": "counter",
                "uVar2": "normalizedNumber2",
                "uVar3": "combinedNumbers"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__muldf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009744": {
            "entrypoint": "0x08009744",
            "current_name": "initialize_memory_block_08009744",
            "code": "\nvoid initializeMemoryBlock_08009744(int *resultPointer,undefined4 allocationSize)\n\n{\n  int allocationResult;\n  \n  DAT_20000c10 = 0;\n  allocationResult = _sbrk(allocationSize);\n  if ((allocationResult == -1) && (DAT_20000c10 != 0)) {\n    *resultPointer = DAT_20000c10;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009744": "initialize_memory_block_08009744",
                "param_1": "resultPointer",
                "param_2": "allocationSize",
                "iVar1": "allocationResult"
            },
            "calling": [
                "_malloc_trim_r",
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009768": {
            "entrypoint": "0x08009768",
            "current_name": "copy_with_bounds_check_08009768",
            "code": "\nvoid copyWithBoundsCheck_08009768(uint *dest,uint *src,uint size)\n\n{\n  char currentChar;\n  uint *srcPtr;\n  uint *destPtr;\n  uint currentWord;\n  \n  if (((((uint)dest | (uint)src) & 3) == 0) &&\n     (destPtr = dest, srcPtr = src, 3 < size)) {\n    do {\n      src = srcPtr + 1;\n      currentWord = *srcPtr;\n      dest = destPtr;\n      if ((currentWord + 0xfefefeff & ~currentWord & 0x80808080) != 0) goto LAB_0800979c;\n      size = size - 4;\n      dest = destPtr + 1;\n      *destPtr = currentWord;\n      destPtr = dest;\n      srcPtr = src;\n    } while (3 < size);\n  }\n  srcPtr = src;\n  if (size != 0) {\nLAB_0800979c:\n    currentChar = *(char *)srcPtr;\n    *(char *)dest = currentChar;\n    while( true ) {\n      dest = (uint *)((int)dest + 1);\n      size = size - 1;\n      if (currentChar == '\\0') break;\n      if (size == 0) {\n        return;\n      }\n      srcPtr = (uint *)((int)srcPtr + 1);\n      currentChar = *(char *)srcPtr;\n      *(char *)dest = currentChar;\n    }\n    if (size != 0) {\n      srcPtr = dest;\n      do {\n        destPtr = (uint *)((int)srcPtr + 1);\n        *(char *)srcPtr = '\\0';\n        srcPtr = destPtr;\n      } while (destPtr != (uint *)(size + (int)dest));\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009768": "copy_with_bounds_check_08009768",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "cVar1": "currentChar",
                "puVar2": "srcPtr",
                "puVar3": "destPtr",
                "uVar4": "currentWord"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080097cc": {
            "entrypoint": "0x080097cc",
            "current_name": "copy_and_resize_buffer_080097cc",
            "code": "\nundefined4 copyAndResizeBuffer_080097cc(undefined4 *destBuffer,int *srcBuffer,int *lengths)\n\n{\n  int destBufferIndex;\n  uint srcBufferLength;\n  int newBuffer;\n  int sizeDifference;\n  uint newBufferSize;\n  uint copyLength;\n  undefined4 *nextElement;\n  undefined4 *currentElement;\n  undefined4 currentElementValue;\n  \n  if (lengths[2] != 0) {\n    destBufferIndex = *srcBuffer;\n    newBufferSize = srcBuffer[2];\n    currentElement = (undefined4 *)*lengths;\n    do {\n      do {\n        nextElement = currentElement + 2;\n        currentElementValue = *currentElement;\n        copyLength = currentElement[1];\n        currentElement = nextElement;\n      } while (copyLength == 0);\n      srcBufferLength = copyLength;\n      if ((newBufferSize <= copyLength) && (srcBufferLength = newBufferSize, (*(ushort *)(srcBuffer + 3) & 0x480) != 0)) {\n        sizeDifference = destBufferIndex - srcBuffer[4];\n        newBufferSize = (srcBuffer[5] * 3) / 2;\n        srcBufferLength = copyLength + 1 + sizeDifference;\n        if (newBufferSize < srcBufferLength) {\n          newBufferSize = srcBufferLength;\n        }\n        if ((int)((uint)*(ushort *)(srcBuffer + 3) << 0x15) < 0) {\n          newBuffer = _malloc_r(destBuffer,newBufferSize);\n          if (newBuffer == 0) {\nLAB_08009896:\n            *destBuffer = 0xc;\n            *(ushort *)(srcBuffer + 3) = *(ushort *)(srcBuffer + 3) | 0x40;\n            lengths[1] = 0;\n            lengths[2] = 0;\n            return 0xffffffff;\n          }\n          memcpy(newBuffer,srcBuffer[4],sizeDifference);\n          *(ushort *)(srcBuffer + 3) = *(ushort *)(srcBuffer + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          newBuffer = _realloc_r(destBuffer);\n          if (newBuffer == 0) {\n            _free_r(destBuffer,srcBuffer[4]);\n            goto LAB_08009896;\n          }\n        }\n        destBufferIndex = newBuffer + sizeDifference;\n        srcBuffer[5] = newBufferSize;\n        srcBuffer[4] = newBuffer;\n        *srcBuffer = destBufferIndex;\n        srcBuffer[2] = newBufferSize - sizeDifference;\n        srcBufferLength = copyLength;\n      }\n      memmove(destBufferIndex,currentElementValue,srcBufferLength);\n      sizeDifference = lengths[2];\n      newBufferSize = srcBuffer[2] - srcBufferLength;\n      destBufferIndex = *srcBuffer + srcBufferLength;\n      srcBuffer[2] = newBufferSize;\n      *srcBuffer = destBufferIndex;\n      lengths[2] = sizeDifference - copyLength;\n    } while (sizeDifference - copyLength != 0);\n  }\n  lengths[1] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080097cc": "copy_and_resize_buffer_080097cc",
                "param_1": "destBuffer",
                "param_2": "srcBuffer",
                "param_3": "lengths",
                "iVar1": "destBufferIndex",
                "uVar2": "srcBufferLength",
                "iVar3": "newBuffer",
                "iVar4": "sizeDifference",
                "uVar5": "newBufferSize",
                "uVar6": "copyLength",
                "puVar7": "nextElement",
                "puVar8": "currentElement",
                "uVar9": "currentElementValue"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "memcpy",
                "_malloc_r",
                "memmove",
                "_free_r",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098c0": {
            "entrypoint": "0x080098c0",
            "current_name": "update_data_entry_080098c0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009906) */\n/* WARNING: Removing unreachable block (ram,0x08009912) */\n\nundefined4 updateDataEntry_080098c0(int type,undefined4 data,undefined4 value1,undefined4 value2)\n\n{\n  undefined *dataEntry;\n  undefined4 returnValue;\n  uint bitMask;\n  uint entryIndex;\n  \n  __retarget_lock_acquire_recursive(DAT_20000448);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  dataEntry = DAT_20000168;\n  entryIndex = *(uint *)(DAT_20000168 + 4);\n  if ((int)entryIndex < 0x20) {\n    if (type != 0) {\n      *(undefined4 *)(DAT_20000168 + entryIndex * 4 + 0x88) = value1;\n      bitMask = 1 << (entryIndex & 0xff);\n      *(uint *)(dataEntry + 0x188) = *(uint *)(dataEntry + 0x188) | bitMask;\n      *(undefined4 *)(dataEntry + entryIndex * 4 + 0x108) = value2;\n      if (type == 2) {\n        *(uint *)(dataEntry + 0x18c) = bitMask | *(uint *)(dataEntry + 0x18c);\n      }\n    }\n    *(uint *)(dataEntry + 4) = entryIndex + 1;\n    returnValue = DAT_20000448;\n    *(undefined4 *)(dataEntry + (entryIndex + 2) * 4) = data;\n    __retarget_lock_release_recursive(returnValue);\n    returnValue = 0;\n  }\n  else {\n    __retarget_lock_release_recursive(DAT_20000448);\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080098c0": "update_data_entry_080098c0",
                "param_1": "type",
                "param_2": "data",
                "param_3": "value1",
                "param_4": "value2",
                "puVar1": "dataEntry",
                "uVar2": "returnValue",
                "uVar3": "bitMask",
                "uVar4": "entryIndex"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009980": {
            "entrypoint": "0x08009980",
            "current_name": "allocate_memory_08009980",
            "code": "\nundefined4 * allocate_memory_08009980(undefined4 size,int element_size,int num_elements)\n\n{\n  undefined4 *ptr;\n  uint header_size;\n  undefined4 *data_ptr;\n  \n  ptr = (undefined4 *)_malloc_r(size,num_elements * element_size);\n  if (ptr == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  header_size = (ptr[-1] & 0xfffffffc) - 4;\n  if (header_size < 0x25) {\n    data_ptr = ptr;\n    if (0x13 < header_size) {\n      *ptr = 0;\n      ptr[1] = 0;\n      if (0x1b < header_size) {\n        ptr[2] = 0;\n        ptr[3] = 0;\n        if (header_size == 0x24) {\n          ptr[4] = 0;\n          ptr[5] = 0;\n          data_ptr = ptr + 6;\n        }\n        else {\n          data_ptr = ptr + 4;\n        }\n        *data_ptr = 0;\n        data_ptr[1] = 0;\n        data_ptr[2] = 0;\n        return ptr;\n      }\n      data_ptr = ptr + 2;\n    }\n    *data_ptr = 0;\n    data_ptr[1] = 0;\n    data_ptr[2] = 0;\n    return ptr;\n  }\n  memset(ptr,0);\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08009980": "allocate_memory_08009980",
                "param_1": "size",
                "param_2": "element_size",
                "param_3": "num_elements",
                "puVar1": "ptr",
                "uVar2": "header_size",
                "puVar3": "data_ptr"
            },
            "calling": [
                "_Balloc"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a18": {
            "entrypoint": "0x08009a18",
            "current_name": "copy_memory_08009a18",
            "code": "\nvoid copyMemory_08009a18(undefined4 *source,undefined4 *destination,uint size)\n\n{\n  undefined4 *srcPtr;\n  undefined4 *dstPtr;\n  int numIterations;\n  undefined *srcEndPtr;\n  undefined4 *dstEndPtr;\n  uint remainingSize;\n  uint copySize;\n  \n  if ((destination < source) && (dstPtr = (undefined4 *)((int)destination + size), source < dstPtr)) {\n    srcEndPtr = (undefined *)((int)source + size);\n    if (size != 0) {\n      do {\n        dstPtr = (undefined4 *)((int)dstPtr + -1);\n        srcEndPtr = srcEndPtr + -1;\n        *srcEndPtr = *(undefined *)dstPtr;\n      } while (destination != dstPtr);\n    }\n  }\n  else {\n    copySize = size;\n    if (0xf < size) {\n      if ((((uint)source | (uint)destination) & 3) != 0) goto LAB_08009abc;\n      dstPtr = destination + 4;\n      srcPtr = source + 4;\n      do {\n        dstEndPtr = dstPtr + 4;\n        srcPtr[-4] = dstPtr[-4];\n        srcPtr[-3] = dstPtr[-3];\n        srcPtr[-2] = dstPtr[-2];\n        srcPtr[-1] = dstPtr[-1];\n        dstPtr = dstEndPtr;\n        srcPtr = srcPtr + 4;\n      } while (dstEndPtr != (undefined4 *)((int)destination + (size - 0x10 & 0xfffffff0) + 0x20));\n      numIterations = (size - 0x10 >> 4) + 1;\n      copySize = size & 0xf;\n      destination = destination + numIterations * 4;\n      source = source + numIterations * 4;\n      if (3 < copySize) {\n        dstPtr = source + -1;\n        remainingSize = copySize;\n        srcPtr = destination;\n        do {\n          remainingSize = remainingSize - 4;\n          dstPtr = dstPtr + 1;\n          *dstPtr = *srcPtr;\n          srcPtr = srcPtr + 1;\n        } while (3 < remainingSize);\n        numIterations = (copySize - 4 & 0xfffffffc) + 4;\n        source = (undefined4 *)((int)source + numIterations);\n        destination = (undefined4 *)((int)destination + numIterations);\n        copySize = size & 3;\n      }\n    }\n    size = copySize;\n    if (copySize != 0) {\nLAB_08009abc:\n      srcEndPtr = (undefined *)((int)source + -1);\n      dstPtr = destination;\n      do {\n        srcPtr = (undefined4 *)((int)dstPtr + 1);\n        srcEndPtr = srcEndPtr + 1;\n        *srcEndPtr = *(undefined *)dstPtr;\n        dstPtr = srcPtr;\n      } while (srcPtr != (undefined4 *)(size + (int)destination));\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009a18": "copy_memory_08009a18",
                "param_1": "source",
                "param_2": "destination",
                "param_3": "size",
                "puVar1": "srcPtr",
                "puVar2": "dstPtr",
                "iVar3": "numIterations",
                "puVar4": "srcEndPtr",
                "puVar5": "dstEndPtr",
                "uVar6": "remainingSize",
                "uVar7": "copySize"
            },
            "calling": [
                "__ssprint_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009adc": {
            "entrypoint": "0x08009adc",
            "current_name": "allocate_memory_08009adc",
            "code": "\nint * allocate_memory_08009adc(undefined4 *context,int *existing_memory,uint size)\n\n{\n  int *new_memory;\n  int offset;\n  int *block_header;\n  uint block_size;\n  int tmp;\n  uint header_size;\n  int *dst;\n  uint aligned_size;\n  uint requested_size;\n  uint new_size;\n  int ptr;\n  \n  if (existing_memory == (int *)0x0) {\n    block_header = (int *)_malloc_r(context,size);\n    return block_header;\n  }\n  __malloc_lock();\n  header_size = existing_memory[-1];\n  requested_size = header_size & 0xfffffffc;\n  block_header = existing_memory + -2;\n  if (size + 0xb < 0x17) {\n    aligned_size = 0x10;\n  }\n  else {\n    aligned_size = size + 0xb & 0xfffffff8;\n    if ((int)aligned_size < 0) goto LAB_08009b8e;\n  }\n  if (aligned_size < size) {\nLAB_08009b8e:\n    *context = 0xc;\n    return (int *)0x0;\n  }\n  ptr = (int)block_header + requested_size;\n  new_size = requested_size;\n  if ((int)requested_size < (int)aligned_size) {\n    if (DAT_20000454 == ptr) {\n      ptr = (*(uint *)(DAT_20000454 + 4) & 0xfffffffc) + requested_size;\n      if ((int)(aligned_size + 0x10) <= ptr) {\n        DAT_20000454 = (int)block_header + aligned_size;\n        *(uint *)(DAT_20000454 + 4) = ptr - aligned_size | 1;\n        existing_memory[-1] = aligned_size | existing_memory[-1] & 1U;\n        __malloc_unlock(context);\n        return existing_memory;\n      }\n      if (-1 < (int)(header_size << 0x1f)) {\n        new_memory = (int *)((int)block_header - existing_memory[-2]);\n        header_size = new_memory[1] & 0xfffffffc;\n        if ((int)(aligned_size + 0x10) <= (int)(ptr + header_size)) {\n          tmp = new_memory[3];\n          block_header = new_memory + 2;\n          offset = *block_header;\n          requested_size = requested_size - 4;\n          *(int *)(offset + 0xc) = tmp;\n          *(int *)(tmp + 8) = offset;\n          if (requested_size < 0x25) {\n            offset = *existing_memory;\n            dst = block_header;\n            if (0x13 < requested_size) {\n              new_memory[2] = offset;\n              new_memory[3] = existing_memory[1];\n              offset = existing_memory[2];\n              if (requested_size < 0x1c) {\n                existing_memory = existing_memory + 2;\n                dst = new_memory + 4;\n              }\n              else {\n                new_memory[4] = offset;\n                new_memory[5] = existing_memory[3];\n                offset = existing_memory[4];\n                if (requested_size == 0x24) {\n                  new_memory[6] = offset;\n                  new_memory[7] = existing_memory[5];\n                  offset = existing_memory[6];\n                  existing_memory = existing_memory + 6;\n                  dst = new_memory + 8;\n                }\n                else {\n                  existing_memory = existing_memory + 4;\n                  dst = new_memory + 6;\n                }\n              }\n            }\n            *dst = offset;\n            dst[1] = existing_memory[1];\n            dst[2] = existing_memory[2];\n          }\n          else {\n            memmove(block_header,existing_memory);\n          }\n          DAT_20000454 = (int)new_memory + aligned_size;\n          *(uint *)(DAT_20000454 + 4) = (ptr + header_size) - aligned_size | 1;\n          new_memory[1] = aligned_size | new_memory[1] & 1U;\n          __malloc_unlock(context);\n          return block_header;\n        }\nLAB_08009bb0:\n        new_size = requested_size + header_size;\n        if ((int)aligned_size <= (int)new_size) {\n          tmp = new_memory[3];\n          dst = new_memory + 2;\n          offset = *dst;\n          *(int *)(offset + 0xc) = tmp;\n          ptr = (int)new_memory + new_size;\n          *(int *)(tmp + 8) = offset;\n          block_header = new_memory;\n          if (requested_size - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          memmove(dst,existing_memory);\n          existing_memory = dst;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(ptr + 4) & 0xfffffffe) + ptr + 4) << 0x1f) {\n        block_size = *(uint *)(ptr + 4) & 0xfffffffc;\n        new_size = requested_size + block_size;\n        if ((int)new_size < (int)aligned_size) {\n          if ((int)(header_size << 0x1f) < 0) goto LAB_08009b36;\n          new_memory = (int *)((int)block_header - existing_memory[-2]);\n          header_size = new_memory[1] & 0xfffffffc;\n          new_size = block_size + header_size + requested_size;\n          if ((int)new_size < (int)aligned_size) goto LAB_08009bb0;\n          offset = *(int *)(ptr + 8);\n          ptr = *(int *)(ptr + 0xc);\n          *(int *)(offset + 0xc) = ptr;\n          *(int *)(ptr + 8) = offset;\n          dst = new_memory + 2;\n          offset = *dst;\n          tmp = new_memory[3];\n          *(int *)(offset + 0xc) = tmp;\n          ptr = (int)new_memory + new_size;\n          *(int *)(tmp + 8) = offset;\n          block_header = new_memory;\n          if (0x24 < requested_size - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          requested_size = requested_size - 4;\n          offset = *existing_memory;\n          new_memory = dst;\n          if (0x13 < requested_size) {\n            block_header[2] = offset;\n            block_header[3] = existing_memory[1];\n            offset = existing_memory[2];\n            if (requested_size < 0x1c) {\n              existing_memory = existing_memory + 2;\n              new_memory = block_header + 4;\n            }\n            else {\n              block_header[4] = offset;\n              block_header[5] = existing_memory[3];\n              offset = existing_memory[4];\n              if (requested_size == 0x24) {\n                block_header[6] = offset;\n                block_header[7] = existing_memory[5];\n                offset = existing_memory[6];\n                existing_memory = existing_memory + 6;\n                new_memory = block_header + 8;\n              }\n              else {\n                existing_memory = existing_memory + 4;\n                new_memory = block_header + 6;\n              }\n            }\n          }\n          *new_memory = offset;\n          new_memory[1] = existing_memory[1];\n          new_memory[2] = existing_memory[2];\n          existing_memory = dst;\n        }\n        else {\n          offset = *(int *)(ptr + 8);\n          tmp = *(int *)(ptr + 0xc);\n          *(int *)(offset + 0xc) = tmp;\n          ptr = (int)block_header + new_size;\n          *(int *)(tmp + 8) = offset;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(header_size << 0x1f)) {\n        new_memory = (int *)((int)block_header - existing_memory[-2]);\n        header_size = new_memory[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    new_memory = (int *)_malloc_r(context,size);\n    if (new_memory != (int *)0x0) {\n      if ((int *)((existing_memory[-1] & 0xfffffffeU) + (int)block_header) == new_memory + -2) {\n        new_size = requested_size + (new_memory[-1] & 0xfffffffcU);\n        ptr = (int)block_header + new_size;\n        goto LAB_08009c00;\n      }\n      requested_size = requested_size - 4;\n      if (requested_size < 0x25) {\n        ptr = *existing_memory;\n        block_header = existing_memory;\n        dst = new_memory;\n        if (0x13 < requested_size) {\n          *new_memory = ptr;\n          new_memory[1] = existing_memory[1];\n          if (requested_size < 0x1c) {\n            ptr = existing_memory[2];\n            block_header = existing_memory + 2;\n            dst = new_memory + 2;\n          }\n          else {\n            new_memory[2] = existing_memory[2];\n            new_memory[3] = existing_memory[3];\n            if (requested_size == 0x24) {\n              new_memory[4] = existing_memory[4];\n              new_memory[5] = existing_memory[5];\n              ptr = existing_memory[6];\n              block_header = existing_memory + 6;\n              dst = new_memory + 6;\n            }\n            else {\n              ptr = existing_memory[4];\n              block_header = existing_memory + 4;\n              dst = new_memory + 4;\n            }\n          }\n        }\n        *dst = ptr;\n        dst[1] = block_header[1];\n        dst[2] = block_header[2];\n      }\n      else {\n        memmove(new_memory,existing_memory);\n      }\n      _free_r(context,existing_memory);\n    }\n    __malloc_unlock(context);\n    existing_memory = new_memory;\n  }\n  else {\nLAB_08009c00:\n    if (new_size - aligned_size < 0x10) {\n      block_header[1] = block_header[1] & 1U | new_size;\n      *(uint *)(ptr + 4) = *(uint *)(ptr + 4) | 1;\n    }\n    else {\n      block_header[1] = block_header[1] & 1U | aligned_size;\n      *(uint *)((int)block_header + aligned_size + 4) = new_size - aligned_size | 1;\n      *(uint *)(ptr + 4) = *(uint *)(ptr + 4) | 1;\n      _free_r(context,(int)block_header + aligned_size + 8);\n    }\n    __malloc_unlock(context);\n  }\n  return existing_memory;\n}\n\n",
            "renaming": {
                "FUN_08009adc": "allocate_memory_08009adc",
                "param_1": "context",
                "param_2": "existing_memory",
                "param_3": "size",
                "piVar1": "new_memory",
                "iVar2": "offset",
                "piVar3": "block_header",
                "uVar4": "block_size",
                "iVar5": "tmp",
                "uVar6": "header_size",
                "piVar7": "dst",
                "uVar8": "aligned_size",
                "uVar9": "requested_size",
                "uVar10": "new_size",
                "iVar11": "ptr"
            },
            "calling": [
                "__ssprint_r"
            ],
            "called": [
                "_malloc_r",
                "memmove",
                "__malloc_unlock",
                "_free_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e68": {
            "entrypoint": "0x08009e68",
            "current_name": "FUNC_08009e68",
            "code": "\nvoid FUNC_08009e68(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e68": "FUNC_08009e68"
            },
            "calling": [
                "__libc_init_array",
                "frame_dummy",
                "__do_global_dtors_aux"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009e74": {
            "entrypoint": "0x08009e74",
            "current_name": "FUNC_08009e74",
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 147260,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000158",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_080003f4",
            "FUN_08000418",
            "FUN_080006a4",
            "FUN_0800088a",
            "FUN_080008fc",
            "FUN_08000978",
            "FUN_08000988",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_080009c0",
            "FUN_080009d4",
            "FUN_080009e8",
            "FUN_080009fc",
            "FUN_08000aa4",
            "FUN_08000aa8",
            "FUN_08000c08",
            "FUN_08000c10",
            "FUN_08000cb8",
            "FUN_08000e20",
            "FUN_08000f68",
            "FUN_08000fc8",
            "FUN_08000fd0",
            "FUN_08000ff4",
            "FUN_08001030",
            "FUN_08001044",
            "FUN_08001084",
            "FUN_08001170",
            "FUN_0800119c",
            "FUN_080011ec",
            "FUN_0800121c",
            "FUN_080014f0",
            "FUN_0800151c",
            "FUN_0800157c",
            "FUN_080015a0",
            "FUN_080015b4",
            "FUN_080015fc",
            "FUN_08001618",
            "FUN_0800166c",
            "FUN_080016d0",
            "FUN_08001714",
            "FUN_0800172a",
            "FUN_08001762",
            "FUN_0800177c",
            "FUN_080017b4",
            "FUN_080017c4",
            "FUN_08001a80",
            "FUN_08001ab0",
            "FUN_08001ccc",
            "FUN_08001f6c",
            "FUN_08002640",
            "FUN_080027f4",
            "FUN_08002ad8",
            "FUN_08002bb4",
            "FUN_08002c2e",
            "FUN_08002ca8",
            "FUN_08002d3c",
            "FUN_08002d98",
            "FUN_08003260",
            "FUN_08003440",
            "FUN_08003504",
            "FUN_08003518",
            "FUN_08003540",
            "FUN_08003568",
            "FUN_080035a4",
            "FUN_0800360c",
            "FUN_08003640",
            "FUN_080036a8",
            "FUN_080036f8",
            "FUN_08003908",
            "FUN_08003a94",
            "FUN_08003c94",
            "FUN_08003d60",
            "FUN_08003e38",
            "FUN_08003f18",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08004104",
            "FUN_0800416a",
            "FUN_080041a8",
            "FUN_080041ea",
            "FUN_0800422e",
            "FUN_080042de",
            "FUN_0800438a",
            "FUN_08004436",
            "FUN_080046ec",
            "FUN_0800491c",
            "FUN_080049cc",
            "FUN_08004ae0",
            "FUN_08004bd8",
            "FUN_08004d78",
            "FUN_08004e6c",
            "FUN_08004e74",
            "FUN_08004ea4",
            "FUN_08004ee8",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f60",
            "FUN_08004f78",
            "FUN_08005224",
            "FUN_080052a0",
            "FUN_08005348",
            "FUN_080053b0",
            "FUN_08005500",
            "FUN_08005598",
            "FUN_080055f4",
            "FUN_08005674",
            "FUN_08005680",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_08005728",
            "FUN_08005780",
            "FUN_080057e8",
            "FUN_08005838",
            "FUN_080059f0",
            "FUN_08005d14",
            "FUN_08005d20",
            "FUN_08005d68",
            "FUN_08005dfc",
            "FUN_08005e40",
            "FUN_080078c0",
            "FUN_080079e8",
            "FUN_0800884c",
            "FUN_080088ec",
            "FUN_08008ad4",
            "FUN_08008af8",
            "FUN_0800901c",
            "FUN_080090a8",
            "FUN_080090b4",
            "FUN_080090c0",
            "FUN_0800910c",
            "FUN_08009120",
            "FUN_080091a4",
            "FUN_080091e4",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_080093a4",
            "FUN_08009444",
            "FUN_080094f8",
            "FUN_08009530",
            "FUN_08009630",
            "FUN_080096e0",
            "FUN_08009744",
            "FUN_08009768",
            "FUN_080097cc",
            "FUN_080098c0",
            "FUN_08009980",
            "FUN_08009a18",
            "FUN_08009adc"
        ],
        [
            "FUN_080004c8",
            "FUN_0800071c"
        ]
    ],
    "locked_functions": []
}