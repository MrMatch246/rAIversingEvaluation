{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeFlag_08000110(undefined4 input)\n\n{\n  if ((char)DAT_200009c8 == '\\0') {\n    DAT_200009c8._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_flag_08000110",
                "param_1": "input"
            },
            "calling": [],
            "called": [
                "FUN_08009e68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_64bit_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_64bit_08000134(undefined4 input_1,undefined4 input_2)\n\n{\n  return CONCAT44(input_2,input_1);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_64bit_08000134",
                "param_1": "input_1",
                "param_2": "input_2"
            },
            "calling": [
                "FUN_08005d20"
            ],
            "called": [
                "FUN_08009e68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000158": {
            "entrypoint": "0x08000158",
            "current_name": "calculate_result_08000158",
            "code": "\nulonglong calculate_result_08000158(uint input_value_1,uint input_value_2,uint input_value_3,uint input_value_4)\n\n{\n  int temp_var_1;\n  byte temp_var_2;\n  uint temp_var_3;\n  uint temp_var_4;\n  uint temp_var_5;\n  uint temp_var_6;\n  uint temp_var_7;\n  int temp_var_8;\n  uint temp_var_9;\n  uint temp_var_10;\n  uint temp_var_11;\n  uint temp_var_12;\n  bool temp_var_13;\n  bool temp_var_14;\n  bool temp_var_15;\n  \n  temp_var_6 = input_value_4 ^ 0x80000000;\n  temp_var_9 = input_value_2 << 1;\n  input_value_4 = input_value_4 << 1;\n  temp_var_13 = ((input_value_2 ^ temp_var_6) & 0x7fffffff) == 0;\n  temp_var_14 = temp_var_13 && input_value_1 == input_value_3;\n  if (!temp_var_13 || input_value_1 != input_value_3) {\n    temp_var_14 = (temp_var_9 | input_value_1) == 0;\n  }\n  if (!temp_var_14) {\n    temp_var_14 = (input_value_4 | input_value_3) == 0;\n  }\n  temp_var_8 = (int)temp_var_9 >> 0x15;\n  if (!temp_var_14) {\n    temp_var_14 = temp_var_8 == -1;\n  }\n  temp_var_1 = (int)input_value_4 >> 0x15;\n  if (!temp_var_14) {\n    temp_var_14 = temp_var_1 == -1;\n  }\n  if (temp_var_14) {\n    if (temp_var_8 == -1 || temp_var_1 == -1) {\n      temp_var_9 = temp_var_6;\n      temp_var_11 = input_value_3;\n      if (temp_var_8 == -1) {\n        temp_var_9 = input_value_2;\n        temp_var_11 = input_value_1;\n      }\n      if (temp_var_8 != -1 || temp_var_1 != -1) {\n        input_value_3 = temp_var_11;\n        temp_var_6 = temp_var_9;\n      }\n      temp_var_14 = (temp_var_11 | temp_var_9 << 0xc) == 0;\n      if (temp_var_14) {\n        temp_var_14 = (input_value_3 | temp_var_6 << 0xc) == 0;\n      }\n      if (temp_var_14) {\n        temp_var_14 = temp_var_9 == temp_var_6;\n      }\n      if (!temp_var_14) {\n        temp_var_9 = temp_var_9 | 0x80000;\n      }\n      return CONCAT44(temp_var_9,temp_var_11);\n    }\n    if (((input_value_2 ^ temp_var_6) & 0x7fffffff) != 0 || input_value_1 != input_value_3) {\n      if ((temp_var_9 | input_value_1) == 0) {\n        input_value_1 = input_value_3;\n        input_value_2 = temp_var_6;\n      }\n      return CONCAT44(input_value_2,input_value_1);\n    }\n    if (input_value_2 != temp_var_6) {\n      return 0;\n    }\n    if (temp_var_9 >> 0x15 == 0) {\n      temp_var_14 = (input_value_1 & 0x80000000) != 0;\n      temp_var_6 = input_value_2 * 2 + (uint)temp_var_14;\n      if (CARRY4(input_value_2,input_value_2) || CARRY4(input_value_2 * 2,(uint)temp_var_14)) {\n        temp_var_6 = temp_var_6 | 0x80000000;\n      }\n      return CONCAT44(temp_var_6,input_value_1 << 1);\n    }\n    if (temp_var_9 < 0xffc00000) {\n      return CONCAT44(input_value_2 + 0x100000,input_value_1);\n    }\n    input_value_2 = input_value_2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input_value_2 | 0x7ff00000) << 0x20;\n  }\n  temp_var_9 = temp_var_9 >> 0x15;\n  input_value_4 = input_value_4 >> 0x15;\n  temp_var_11 = input_value_4 - temp_var_9;\n  temp_var_14 = temp_var_11 != 0;\n  if (input_value_4 < temp_var_9) {\n    temp_var_11 = -temp_var_11;\n  }\n  temp_var_10 = input_value_1;\n  temp_var_7 = input_value_2;\n  if (temp_var_14 && temp_var_9 <= input_value_4) {\n    temp_var_9 = temp_var_9 + temp_var_11;\n    temp_var_10 = input_value_3;\n    temp_var_7 = temp_var_6;\n    input_value_3 = input_value_1;\n    temp_var_6 = input_value_2;\n  }\n  if (0x36 < temp_var_11) {\n    return CONCAT44(temp_var_7,temp_var_10);\n  }\n  temp_var_4 = temp_var_7 & 0xfffff | 0x100000;\n  if ((temp_var_7 & 0x80000000) != 0) {\n    temp_var_14 = temp_var_10 != 0;\n    temp_var_10 = -temp_var_10;\n    temp_var_4 = -temp_var_4 - (uint)temp_var_14;\n  }\n  temp_var_7 = temp_var_6 & 0xfffff | 0x100000;\n  if ((temp_var_6 & 0x80000000) != 0) {\n    temp_var_14 = input_value_3 != 0;\n    input_value_3 = -input_value_3;\n    temp_var_7 = -temp_var_7 - (uint)temp_var_14;\n  }\n  if (temp_var_9 == temp_var_11) {\n    temp_var_7 = temp_var_7 ^ 0x100000;\n    if (temp_var_9 == 0) {\n      temp_var_4 = temp_var_4 ^ 0x100000;\n      temp_var_9 = 1;\n    }\n    else {\n      temp_var_11 = temp_var_11 - 1;\n    }\n  }\n  temp_var_6 = -temp_var_11 + 0x20;\n  if ((int)temp_var_11 < 0x21) {\n    temp_var_12 = input_value_3 << (temp_var_6 & 0xff);\n    input_value_3 = input_value_3 >> (temp_var_11 & 0xff);\n    temp_var_3 = temp_var_10 + input_value_3;\n    temp_var_5 = temp_var_7 << (temp_var_6 & 0xff);\n    temp_var_6 = temp_var_3 + temp_var_5;\n    temp_var_4 = temp_var_4 + CARRY4(temp_var_10,input_value_3) + ((int)temp_var_7 >> (temp_var_11 & 0xff)) +\n            (uint)CARRY4(temp_var_3,temp_var_5);\n  }\n  else {\n    temp_var_12 = temp_var_7 << (-temp_var_11 + 0x40 & 0xff);\n    if (input_value_3 != 0) {\n      temp_var_12 = temp_var_12 | 2;\n    }\n    temp_var_7 = (int)temp_var_7 >> (temp_var_11 - 0x20 & 0xff);\n    temp_var_6 = temp_var_10 + temp_var_7;\n    temp_var_4 = temp_var_4 + ((int)temp_var_7 >> 0x1f) + (uint)CARRY4(temp_var_10,temp_var_7);\n  }\n  input_value_2 = temp_var_4 & 0x80000000;\n  temp_var_11 = temp_var_4;\n  if ((int)temp_var_4 < 0) {\n    temp_var_14 = temp_var_12 == 0;\n    temp_var_12 = -temp_var_12;\n    temp_var_11 = -temp_var_6;\n    temp_var_6 = -(uint)!temp_var_14 - temp_var_6;\n    temp_var_11 = -(uint)(temp_var_14 <= temp_var_11) - temp_var_4;\n  }\n  if (0xfffff < temp_var_11) {\n    temp_var_10 = temp_var_9 - 1;\n    if (0x1fffff < temp_var_11) {\n      temp_var_10 = temp_var_11 & 1;\n      temp_var_11 = temp_var_11 >> 1;\n      temp_var_2 = (byte)temp_var_6;\n      temp_var_6 = (uint)(temp_var_10 != 0) << 0x1f | temp_var_6 >> 1;\n      temp_var_12 = (uint)(temp_var_2 & 1) << 0x1f | temp_var_12 >> 1;\n      temp_var_10 = temp_var_9;\n      if (0xffbfffff < temp_var_9 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    temp_var_14 = 0x7fffffff < temp_var_12;\n    if (temp_var_12 == 0x80000000) {\n      temp_var_14 = (temp_var_6 & 1) != 0;\n    }\n    return CONCAT44(temp_var_11 + temp_var_10 * 0x100000 + (uint)CARRY4(temp_var_6,(uint)temp_var_14) | input_value_2,\n                    temp_var_6 + temp_var_14);\n  }\n  temp_var_13 = (temp_var_12 & 0x80000000) != 0;\n  temp_var_12 = temp_var_12 << 1;\n  temp_var_10 = temp_var_6 * 2;\n  temp_var_14 = CARRY4(temp_var_6,temp_var_6);\n  temp_var_6 = temp_var_6 * 2 + (uint)temp_var_13;\n  temp_var_11 = temp_var_11 * 2 + (uint)(temp_var_14 || CARRY4(temp_var_10,(uint)temp_var_13));\n  temp_var_10 = temp_var_9 - 2;\n  if ((temp_var_11 & 0x100000) != 0) goto LAB_08000268;\n  temp_var_7 = temp_var_6;\n  temp_var_9 = temp_var_11;\n  if (temp_var_11 == 0) {\n    temp_var_7 = 0;\n    temp_var_9 = temp_var_6;\n  }\n  temp_var_8 = LZCOUNT(temp_var_9);\n  if (temp_var_11 == 0) {\n    temp_var_8 = temp_var_8 + 0x20;\n  }\n  temp_var_11 = temp_var_8 - 0xb;\n  temp_var_15 = SBORROW4(temp_var_11,0x20);\n  temp_var_6 = temp_var_8 - 0x2b;\n  temp_var_14 = (int)temp_var_6 < 0;\n  temp_var_13 = temp_var_6 == 0;\n  if ((int)temp_var_11 < 0x20) {\n    temp_var_15 = SCARRY4(temp_var_6,0xc);\n    temp_var_8 = temp_var_8 + -0x1f;\n    temp_var_14 = temp_var_8 < 0;\n    temp_var_13 = temp_var_8 == 0;\n    temp_var_6 = temp_var_11;\n    if (!temp_var_13 && temp_var_14 == temp_var_15) {\n      temp_var_7 = temp_var_9 << (temp_var_11 & 0xff);\n      temp_var_9 = temp_var_9 >> (0xcU - temp_var_8 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (temp_var_13 || temp_var_14 != temp_var_15) {\n    temp_var_12 = 0x20 - temp_var_6;\n  }\n  temp_var_9 = temp_var_9 << (temp_var_6 & 0xff);\n  if (temp_var_13 || temp_var_14 != temp_var_15) {\n    temp_var_9 = temp_var_9 | temp_var_7 >> (temp_var_12 & 0xff);\n  }\n  if (temp_var_13 || temp_var_14 != temp_var_15) {\n    temp_var_7 = temp_var_7 << (temp_var_6 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)temp_var_11 <= (int)temp_var_10) {\n    return CONCAT44(temp_var_9 + (temp_var_10 - temp_var_11) * 0x100000 | input_value_2,temp_var_7);\n  }\n  temp_var_6 = ~(temp_var_10 - temp_var_11);\n  if ((int)temp_var_6 < 0x1f) {\n    temp_var_8 = temp_var_6 - 0x13;\n    if (temp_var_8 != 0 && temp_var_8 < 0 == SCARRY4(temp_var_6 - 0x1f,0xc)) {\n      return CONCAT44(temp_var_4,temp_var_7 >> (0x20 - (0xcU - temp_var_8) & 0xff) | temp_var_9 << (0xcU - temp_var_8 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp_var_6 = temp_var_6 + 1;\n    return CONCAT44(input_value_2 | temp_var_9 >> (temp_var_6 & 0xff),\n                    temp_var_7 >> (temp_var_6 & 0xff) | temp_var_9 << (0x20 - temp_var_6 & 0xff));\n  }\n  return CONCAT44(temp_var_4,temp_var_9 >> (temp_var_6 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000158": "calculate_result_08000158",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "param_3": "input_value_3",
                "param_4": "input_value_4",
                "iVar1": "temp_var_1",
                "bVar2": "temp_var_2",
                "uVar3": "temp_var_3",
                "uVar4": "temp_var_4",
                "uVar5": "temp_var_5",
                "uVar6": "temp_var_6",
                "uVar7": "temp_var_7",
                "iVar8": "temp_var_8",
                "uVar9": "temp_var_9",
                "uVar10": "temp_var_10",
                "uVar11": "temp_var_11",
                "uVar12": "temp_var_12",
                "bVar13": "temp_var_13",
                "bVar14": "temp_var_14",
                "bVar15": "temp_var_15"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8",
                "FUN_08005838",
                "FUN_080059f0",
                "FUN_08004bd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800015c": {
            "entrypoint": "0x0800015c",
            "current_name": "perform_unsigned_division_0800015c",
            "code": "\nulonglong performUnsignedDivision_0800015c(uint dividend,uint divisor,uint quotient,uint remainder)\n\n{\n  int shift1;\n  byte carry1;\n  uint qShift;\n  uint rShift;\n  uint temp;\n  int shift2;\n  uint divisorShifted;\n  uint quotientShifted;\n  uint dividendShifted;\n  uint quotDiff;\n  uint qTemp;\n  uint rTemp;\n  bool isEqual;\n  bool isValid;\n  bool isShiftNegative;\n  \n  divisorShifted = divisor << 1;\n  dividendShifted = remainder << 1;\n  isEqual = ((divisor ^ remainder) & 0x7fffffff) == 0;\n  isValid = isEqual && dividend == quotient;\n  if (!isEqual || dividend != quotient) {\n    isValid = (divisorShifted | dividend) == 0;\n  }\n  if (!isValid) {\n    isValid = (dividendShifted | quotient) == 0;\n  }\n  shift2 = (int)divisorShifted >> 0x15;\n  if (!isValid) {\n    isValid = shift2 == -1;\n  }\n  shift1 = (int)dividendShifted >> 0x15;\n  if (!isValid) {\n    isValid = shift1 == -1;\n  }\n  if (isValid) {\n    if (shift2 == -1 || shift1 == -1) {\n      dividendShifted = remainder;\n      divisorShifted = quotient;\n      if (shift2 == -1) {\n        dividendShifted = divisor;\n        divisorShifted = dividend;\n      }\n      if (shift2 != -1 || shift1 != -1) {\n        quotient = divisorShifted;\n        remainder = dividendShifted;\n      }\n      isValid = (divisorShifted | dividendShifted << 0xc) == 0;\n      if (isValid) {\n        isValid = (quotient | remainder << 0xc) == 0;\n      }\n      if (isValid) {\n        isValid = dividendShifted == remainder;\n      }\n      if (!isValid) {\n        dividendShifted = dividendShifted | 0x80000;\n      }\n      return CONCAT44(dividendShifted,divisorShifted);\n    }\n    if (((divisor ^ remainder) & 0x7fffffff) != 0 || dividend != quotient) {\n      if ((divisorShifted | dividend) == 0) {\n        dividend = quotient;\n        divisor = remainder;\n      }\n      return CONCAT44(divisor,dividend);\n    }\n    if (divisor != remainder) {\n      return 0;\n    }\n    if (divisorShifted >> 0x15 == 0) {\n      isValid = (dividend & 0x80000000) != 0;\n      dividendShifted = divisor * 2 + (uint)isValid;\n      if (CARRY4(divisor,divisor) || CARRY4(divisor * 2,(uint)isValid)) {\n        dividendShifted = dividendShifted | 0x80000000;\n      }\n      return CONCAT44(dividendShifted,dividend << 1);\n    }\n    if (divisorShifted < 0xffc00000) {\n      return CONCAT44(divisor + 0x100000,dividend);\n    }\n    divisor = divisor & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(divisor | 0x7ff00000) << 0x20;\n  }\n  divisorShifted = divisorShifted >> 0x15;\n  dividendShifted = dividendShifted >> 0x15;\n  quotDiff = dividendShifted - divisorShifted;\n  isValid = quotDiff != 0;\n  if (dividendShifted < divisorShifted) {\n    quotDiff = -quotDiff;\n  }\n  quotientShifted = dividend;\n  temp = divisor;\n  if (isValid && divisorShifted <= dividendShifted) {\n    divisorShifted = divisorShifted + quotDiff;\n    quotientShifted = quotient;\n    temp = remainder;\n    quotient = dividend;\n    remainder = divisor;\n  }\n  if (0x36 < quotDiff) {\n    return CONCAT44(temp,quotientShifted);\n  }\n  dividendShifted = temp & 0xfffff | 0x100000;\n  if ((temp & 0x80000000) != 0) {\n    isValid = quotientShifted != 0;\n    quotientShifted = -quotientShifted;\n    dividendShifted = -dividendShifted - (uint)isValid;\n  }\n  temp = remainder & 0xfffff | 0x100000;\n  if ((remainder & 0x80000000) != 0) {\n    isValid = quotient != 0;\n    quotient = -quotient;\n    temp = -temp - (uint)isValid;\n  }\n  if (divisorShifted == quotDiff) {\n    temp = temp ^ 0x100000;\n    if (divisorShifted == 0) {\n      dividendShifted = dividendShifted ^ 0x100000;\n      divisorShifted = 1;\n    }\n    else {\n      quotDiff = quotDiff - 1;\n    }\n  }\n  rTemp = -quotDiff + 0x20;\n  if ((int)quotDiff < 0x21) {\n    qTemp = quotient << (rTemp & 0xff);\n    quotient = quotient >> (quotDiff & 0xff);\n    qShift = quotientShifted + quotient;\n    rShift = temp << (rTemp & 0xff);\n    rTemp = qShift + rShift;\n    dividendShifted = dividendShifted + CARRY4(quotientShifted,quotient) + ((int)temp >> (quotDiff & 0xff)) +\n            (uint)CARRY4(qShift,rShift);\n  }\n  else {\n    qTemp = temp << (-quotDiff + 0x40 & 0xff);\n    if (quotient != 0) {\n      qTemp = qTemp | 2;\n    }\n    temp = (int)temp >> (quotDiff - 0x20 & 0xff);\n    rTemp = quotientShifted + temp;\n    dividendShifted = dividendShifted + ((int)temp >> 0x1f) + (uint)CARRY4(quotientShifted,temp);\n  }\n  divisor = dividendShifted & 0x80000000;\n  quotDiff = dividendShifted;\n  if ((int)dividendShifted < 0) {\n    isValid = qTemp == 0;\n    qTemp = -qTemp;\n    quotDiff = -rTemp;\n    rTemp = -(uint)!isValid - rTemp;\n    quotDiff = -(uint)(isValid <= quotDiff) - dividendShifted;\n  }\n  if (0xfffff < quotDiff) {\n    quotientShifted = divisorShifted - 1;\n    if (0x1fffff < quotDiff) {\n      dividendShifted = quotDiff & 1;\n      quotDiff = quotDiff >> 1;\n      carry1 = (byte)rTemp;\n      rTemp = (uint)(dividendShifted != 0) << 0x1f | rTemp >> 1;\n      qTemp = (uint)(carry1 & 1) << 0x1f | qTemp >> 1;\n      quotientShifted = divisorShifted;\n      if (0xffbfffff < divisorShifted * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    isValid = 0x7fffffff < qTemp;\n    if (qTemp == 0x80000000) {\n      isValid = (rTemp & 1) != 0;\n    }\n    return CONCAT44(quotDiff + quotientShifted * 0x100000 + (uint)CARRY4(rTemp,(uint)isValid) | divisor,\n                    rTemp + isValid);\n  }\n  isEqual = (qTemp & 0x80000000) != 0;\n  qTemp = qTemp << 1;\n  quotientShifted = rTemp * 2;\n  isValid = CARRY4(rTemp,rTemp);\n  rTemp = rTemp * 2 + (uint)isEqual;\n  quotDiff = quotDiff * 2 + (uint)(isValid || CARRY4(quotientShifted,(uint)isEqual));\n  quotientShifted = divisorShifted - 2;\n  if ((quotDiff & 0x100000) != 0) goto LAB_08000268;\n  temp = rTemp;\n  divisorShifted = quotDiff;\n  if (quotDiff == 0) {\n    temp = 0;\n    divisorShifted = rTemp;\n  }\n  shift2 = LZCOUNT(divisorShifted);\n  if (quotDiff == 0) {\n    shift2 = shift2 + 0x20;\n  }\n  rTemp = shift2 - 0xb;\n  isShiftNegative = SBORROW4(rTemp,0x20);\n  quotDiff = shift2 - 0x2b;\n  isValid = (int)quotDiff < 0;\n  isEqual = quotDiff == 0;\n  if ((int)rTemp < 0x20) {\n    isShiftNegative = SCARRY4(quotDiff,0xc);\n    shift2 = shift2 + -0x1f;\n    isValid = shift2 < 0;\n    isEqual = shift2 == 0;\n    quotDiff = rTemp;\n    if (!isEqual && isValid == isShiftNegative) {\n      temp = divisorShifted << (rTemp & 0xff);\n      divisorShifted = divisorShifted >> (0xcU - shift2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isEqual || isValid != isShiftNegative) {\n    qTemp = 0x20 - quotDiff;\n  }\n  divisorShifted = divisorShifted << (quotDiff & 0xff);\n  if (isEqual || isValid != isShiftNegative) {\n    divisorShifted = divisorShifted | temp >> (qTemp & 0xff);\n  }\n  if (isEqual || isValid != isShiftNegative) {\n    temp = temp << (quotDiff & 0xff);\n  }\nLAB_080002e0:\n  if ((int)rTemp <= (int)quotientShifted) {\n    return CONCAT44(divisorShifted + (quotientShifted - rTemp) * 0x100000 | divisor,temp);\n  }\n  quotDiff = ~(quotientShifted - rTemp);\n  if ((int)quotDiff < 0x1f) {\n    shift2 = quotDiff - 0x13;\n    if (shift2 != 0 && shift2 < 0 == SCARRY4(quotDiff - 0x1f,0xc)) {\n      return CONCAT44(dividendShifted,temp >> (0x20 - (0xcU - shift2) & 0xff) | divisorShifted << (0xcU - shift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    quotDiff = quotDiff + 1;\n    return CONCAT44(divisor | divisorShifted >> (quotDiff & 0xff),\n                    temp >> (quotDiff & 0xff) | divisorShifted << (0x20 - quotDiff & 0xff));\n  }\n  return CONCAT44(dividendShifted,divisorShifted >> (quotDiff - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800015c": "perform_unsigned_division_0800015c",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "iVar1": "shift1",
                "bVar2": "carry1",
                "uVar3": "qShift",
                "uVar4": "rShift",
                "uVar5": "temp",
                "iVar6": "shift2",
                "uVar7": "divisorShifted",
                "uVar8": "quotientShifted",
                "uVar9": "dividendShifted",
                "uVar10": "quotDiff",
                "uVar11": "qTemp",
                "uVar12": "rTemp",
                "bVar13": "isEqual",
                "bVar14": "isValid",
                "bVar15": "isShiftNegative"
            },
            "calling": [
                "FUN_080079e8",
                "FUN_08005838",
                "FUN_080059f0",
                "FUN_08004bd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003d4": {
            "entrypoint": "0x080003d4",
            "current_name": "bitwise_shift_function_080003d4",
            "code": "\nulonglong bitwise_shift_function_080003d4(uint input_parameter)\n\n{\n  uint shifted_value;\n  uint shift_amount;\n  int lzcount_result;\n  uint temp_value;\n  uint complement_value;\n  bool is_negative;\n  bool is_zero;\n  bool is_borrow;\n  \n  if (input_parameter == 0) {\n    return 0;\n  }\n  shifted_value = 0;\n  lzcount_result = LZCOUNT(input_parameter);\n  temp_value = lzcount_result + 0x15;\n  is_borrow = SBORROW4(temp_value,0x20);\n  shift_amount = lzcount_result - 0xb;\n  is_negative = (int)shift_amount < 0;\n  is_zero = shift_amount == 0;\n  if (temp_value < 0x20) {\n    is_borrow = SCARRY4(shift_amount,0xc);\n    is_negative = false;\n    is_zero = lzcount_result + 1 == 0;\n    shift_amount = temp_value;\n    if (!is_zero && is_borrow == false) {\n      shifted_value = input_parameter << temp_value;\n      input_parameter = input_parameter >> (0xcU - (lzcount_result + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_zero || is_negative != is_borrow) {\n    complement_value = 0x20 - shift_amount;\n  }\n  input_parameter = input_parameter << (shift_amount & 0xff);\n  if (is_zero || is_negative != is_borrow) {\n    input_parameter = input_parameter | 0U >> (complement_value & 0xff);\n  }\n  if (is_zero || is_negative != is_borrow) {\n    shifted_value = 0 << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if (temp_value < 0x433) {\n    return CONCAT44(input_parameter + (0x432 - temp_value) * 0x100000,shifted_value);\n  }\n  shift_amount = ~(0x432 - temp_value);\n  if (0x1e < (int)shift_amount) {\n    return (ulonglong)(input_parameter >> (shift_amount - 0x1f & 0xff));\n  }\n  lzcount_result = shift_amount - 0x13;\n  if (lzcount_result == 0 || lzcount_result < 0 != SCARRY4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(input_parameter >> (shift_amount & 0xff),\n                    shifted_value >> (shift_amount & 0xff) | input_parameter << (0x20 - shift_amount & 0xff));\n  }\n  return (ulonglong)(shifted_value >> (0x20 - (0xcU - lzcount_result) & 0xff) | input_parameter << (0xcU - lzcount_result & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003d4": "bitwise_shift_function_080003d4",
                "param_1": "input_parameter",
                "uVar1": "shifted_value",
                "uVar2": "shift_amount",
                "iVar3": "lzcount_result",
                "uVar4": "temp_value",
                "in_r12": "complement_value",
                "bVar5": "is_negative",
                "bVar6": "is_zero",
                "bVar7": "is_borrow"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003f4": {
            "entrypoint": "0x080003f4",
            "current_name": "bit_shift_080003f4",
            "code": "\nulonglong bitShift_080003f4(uint input)\n\n{\n  uint shiftedBits;\n  uint absInput;\n  uint shiftAmount;\n  int leadingZeros;\n  uint adjustedShift;\n  uint signBit;\n  uint remainder;\n  bool isNegative;\n  bool isZero;\n  bool overflow;\n  \n  if (input == 0) {\n    return 0;\n  }\n  signBit = input bitwiseAnd 0x80000000;\n  absInput = input;\n  if ((int)signBit < 0) {\n    absInput = subtractinput;\n  }\n  shiftedBits = 0;\n  leadingZeros = countLeadingZeros(absInput);\n  adjustedShift = leadingZeros + 0x15;\n  overflow = subtractOverflow(adjustedShift,0x20);\n  shiftAmount = leadingZeros subtract 0xb;\n  isNegative = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if (adjustedShift < 0x20) {\n    overflow = addOverflow(shiftAmount,0xc);\n    isNegative = false;\n    isZero = leadingZeros + 1 == 0;\n    shiftAmount = adjustedShift;\n    if (!isZero bitwiseAndbitwiseAnd overflow == false) {\n      shiftedBits = absInput << adjustedShift;\n      absInput = absInput >> (constantG subtract (leadingZeros + 1) bitwiseAnd 0xff);\n      goto shiftComplete;\n    }\n  }\n  if (isZero || isNegative != overflow) {\n    remainder = 0x20 subtract shiftAmount;\n  }\n  absInput = absInput << (shiftAmount bitwiseAnd 0xff);\n  if (isZero || isNegative != overflow) {\n    absInput = absInput | 0U >> (remainder bitwiseAnd 0xff);\n  }\n  if (isZero || isNegative != overflow) {\n    shiftedBits = 0 << (shiftAmount bitwiseAnd 0xff);\n  }\nshiftComplete:\n  if (adjustedShift < 0x433) {\n    return concatenate(absInput + (0x432 subtract adjustedShift) * 0x100000 | signBit,shiftedBits);\n  }\n  shiftAmount = bitwiseNot(0x432 subtract adjustedShift);\n  if (0x1e < (int)shiftAmount) {\n    return concatenate(input,absInput >> (shiftAmount subtract 0x1f bitwiseAnd 0xff)) bitwiseAnd 0x80000000ffffffff;\n  }\n  leadingZeros = shiftAmount subtract 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != addOverflow(shiftAmount subtract 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return concatenate(signBit | absInput >> (shiftAmount bitwiseAnd 0xff),\n                    shiftedBits >> (shiftAmount bitwiseAnd 0xff) | absInput << (0x20 subtract shiftAmount bitwiseAnd 0xff));\n  }\n  return concatenate(input,shiftedBits >> (0x20 subtract (constantG subtract leadingZeros) bitwiseAnd 0xff) | absInput << (constantG subtract leadingZeros bitwiseAnd 0xff))\n         bitwiseAnd 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080003f4": "bit_shift_080003f4",
                "param_1": "input",
                "uVar1": "shiftedBits",
                "uVar2": "absInput",
                "uVar3": "shiftAmount",
                "iVar4": "leadingZeros",
                "uVar5": "adjustedShift",
                "uVar6": "signBit",
                "in_r12": "remainder",
                "bVar7": "isNegative",
                "bVar8": "isZero",
                "bVar9": "overflow",
                "LZCOUNT": "countLeadingZeros",
                "SBORROW4": "subtractOverflow",
                "SCARRY4": "addOverflow",
                "LAB_080002e0": "shiftComplete",
                "CONCAT44": "concatenate",
                "0xcU": "constantG",
                "&": "bitwiseAnd",
                "~": "bitwiseNot",
                "-": "subtract"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000418": {
            "entrypoint": "0x08000418",
            "current_name": "extract_bits_08000418",
            "code": "\nulonglong extractBits_08000418(uint input,undefined4 unknown1,undefined4 unknown2,uint unknown3)\n\n{\n  uint signBitShifted;\n  uint output;\n  uint mergedBits;\n  uint shiftedInput;\n  uint twiceInput;\n  int leadingZeros;\n  uint shiftedLeadingZeros;\n  uint temp;\n  bool isNegative;\n  bool isZero;\n  bool isShiftNegative;\n  \n  twiceInput = input << 1;\n  isZero = twiceInput == 0;\n  signBitShifted = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shiftedInput = (uint)((int)twiceInput >> 3) >> 1;\n  mergedBits = signBitShifted | shiftedInput;\n  input = input << 0x1d;\n  if (!isZero) {\n    unknown3 = twiceInput & 0xff000000;\n    isZero = unknown3 == 0;\n  }\n  if (!isZero) {\n    isZero = unknown3 == 0xff000000;\n  }\n  if (!isZero) {\n    return CONCAT44(mergedBits,input) ^ 0x3800000000000000;\n  }\n  if ((twiceInput & 0xffffff) == 0) {\n    return CONCAT44(mergedBits,input);\n  }\n  if (unknown3 == 0xff000000) {\n    return CONCAT44(mergedBits,input) | 0x8000000000000;\n  }\n  output = input;\n  twiceInput = shiftedInput;\n  if (shiftedInput == 0) {\n    output = 0;\n    twiceInput = input;\n  }\n  leadingZeros = LZCOUNT(twiceInput);\n  if (shiftedInput == 0) {\n    leadingZeros = leadingZeros + 0x20;\n  }\n  shiftedLeadingZeros = leadingZeros - 0xb;\n  isShiftNegative = SBORROW4(shiftedLeadingZeros,0x20);\n  shiftedInput = leadingZeros - 0x2b;\n  isZero = (int)shiftedInput < 0;\n  isNegative = shiftedInput == 0;\n  if ((int)shiftedLeadingZeros < 0x20) {\n    isShiftNegative = SCARRY4(shiftedInput,0xc);\n    leadingZeros = leadingZeros + -0x1f;\n    isZero = leadingZeros < 0;\n    isNegative = leadingZeros == 0;\n    shiftedInput = shiftedLeadingZeros;\n    if (!isNegative && isZero == isShiftNegative) {\n      output = twiceInput << (shiftedLeadingZeros & 0xff);\n      twiceInput = twiceInput >> (0xcU - leadingZeros & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isNegative || isZero != isShiftNegative) {\n    temp = 0x20 - shiftedInput;\n  }\n  twiceInput = twiceInput << (shiftedInput & 0xff);\n  if (isNegative || isZero != isShiftNegative) {\n    twiceInput = twiceInput | output >> (temp & 0xff);\n  }\n  if (isNegative || isZero != isShiftNegative) {\n    output = output << (shiftedInput & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shiftedLeadingZeros < 0x381) {\n    return CONCAT44(twiceInput + (0x380 - shiftedLeadingZeros) * 0x100000 | signBitShifted,output);\n  }\n  shiftedInput = ~(0x380 - shiftedLeadingZeros);\n  if (0x1e < (int)shiftedInput) {\n    return CONCAT44(mergedBits,twiceInput >> (shiftedInput - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leadingZeros = shiftedInput - 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != SCARRY4(shiftedInput - 0x1f,0xc)) {\n    shiftedInput = shiftedInput + 1;\n    return CONCAT44(signBitShifted | twiceInput >> (shiftedInput & 0xff),\n                    output >> (shiftedInput & 0xff) | twiceInput << (0x20 - shiftedInput & 0xff));\n  }\n  return CONCAT44(mergedBits,output >> (0x20 - (0xcU - leadingZeros) & 0xff) | twiceInput << (0xcU - leadingZeros & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000418": "extract_bits_08000418",
                "param_1": "input",
                "param_2": "unknown1",
                "param_3": "unknown2",
                "param_4": "unknown3",
                "uVar1": "signBitShifted",
                "uVar2": "output",
                "uVar3": "mergedBits",
                "uVar4": "shiftedInput",
                "uVar5": "twiceInput",
                "iVar6": "leadingZeros",
                "uVar7": "shiftedLeadingZeros",
                "in_r12": "temp",
                "bVar8": "isNegative",
                "bVar9": "isZero",
                "bVar10": "isShiftNegative"
            },
            "calling": [
                "FUN_08004d78",
                "FUN_08004f78",
                "FUN_08004bd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004c8": {
            "entrypoint": "0x080004c8",
            "current_name": "calculate_product_080004c8",
            "code": "\nulonglong calculateProduct_080004c8(undefined4 input1,uint input2,uint input3,uint input4)\n\n{\n  ulonglong resultLow;\n  longlong temp;\n  uint carry1;\n  uint carry2;\n  int sum;\n  uint carry3;\n  uint carry4;\n  uint temp1;\n  uint temp2;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  ulonglong product;\n  \n  product = CONCAT44(input2,input1);\n  temp1 = 0x7ff;\n  carry2 = input2 >> 0x14 & 0x7ff;\n  flag1 = carry2 == 0;\n  if (!flag1) {\n    carry4 = input4 >> 0x14 & 0x7ff;\n    flag1 = carry4 == 0;\n  }\n  if (!flag1) {\n    flag1 = carry2 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = carry4 == 0x7ff;\n  }\n  if (flag1) {\n    product = FUN_080006a4();\n  }\n  carry1 = (uint)(product >> 0x20);\n  sum = carry2 + carry4;\n  carry2 = carry1 ^ input4;\n  carry1 = carry1 & ~(temp1 << 0x15);\n  input4 = input4 & ~(temp1 << 0x15);\n  flag1 = ((uint)product | carry1 << 0xc) == 0;\n  if (!flag1) {\n    flag1 = (input3 | input4 << 0xc) == 0;\n  }\n  carry1 = carry1 | 0x100000;\n  input4 = input4 | 0x100000;\n  if (flag1) {\n    input3 = (uint)product | input3;\n    input4 = (carry2 & 0x80000000 | carry1) ^ input4;\n    carry2 = temp1 >> 1;\n    flag3 = SBORROW4(sum,carry2);\n    carry3 = sum - carry2;\n    flag1 = carry3 == 0;\n    carry1 = carry3;\n    if (!flag1 && (int)carry2 <= sum) {\n      flag3 = SBORROW4(temp1,carry3);\n      carry1 = temp1 - carry3;\n      flag1 = temp1 == carry3;\n    }\n    if (!flag1 && (int)carry1 < 0 == flag3) {\n      input4 = input4 | carry3 * 0x100000;\n    }\n    if (!flag1 && (int)carry1 < 0 == flag3) {\n      return CONCAT44(input4,input3);\n    }\n    input4 = input4 | 0x100000;\n    temp1 = 0;\n    flag3 = SBORROW4(carry3,1);\n    carry3 = carry3 - 1;\n    flag1 = carry3 == 0;\n    carry2 = carry3;\n  }\n  else {\n    resultLow = (product & 0xffffffff) * (ulonglong)input3;\n    product = (product & 0xffffffff) * (ulonglong)input4 +\n             (ulonglong)carry1 * (ulonglong)input3 + (resultLow >> 0x20);\n    temp2 = (uint)product;\n    temp = (ulonglong)carry1 * (ulonglong)input4 + (product >> 0x20);\n    temp1 = (uint)temp;\n    carry1 = (uint)((ulonglong)temp >> 0x20);\n    if ((int)resultLow != 0) {\n      temp2 = temp2 | 1;\n    }\n    carry3 = (sum + -0x3ff) - (uint)(carry1 < 0x200);\n    if (carry1 < 0x200) {\n      flag1 = (temp2 & 0x80000000) != 0;\n      temp2 = temp2 << 1;\n      temp = CONCAT44(carry1 * 2 + (uint)(CARRY4(temp1,temp1) || CARRY4(temp1 * 2,(uint)flag1)),\n                       temp1 * 2 + (uint)flag1);\n    }\n    input4 = carry2 & 0x80000000 | (int)((ulonglong)temp >> 0x20) << 0xb | (uint)temp >> 0x15;\n    input3 = (uint)temp << 0xb | temp2 >> 0x15;\n    temp1 = temp2 * 0x800;\n    flag2 = 0xfc < carry3;\n    flag3 = SBORROW4(carry3,0xfd);\n    carry1 = carry3 - 0xfd;\n    flag1 = carry1 == 0;\n    carry2 = carry1;\n    if (flag2 && !flag1) {\n      flag2 = 0x6ff < carry1;\n      flag3 = SBORROW4(carry1,0x700);\n      carry2 = carry3 - 0x7fd;\n      flag1 = carry1 == 0x700;\n    }\n    if (!flag2 || flag1) {\n      flag1 = 0x7fffffff < temp1;\n      if (temp1 == 0x80000000) {\n        flag1 = (temp2 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input4 + carry3 * 0x100000 + (uint)CARRY4(input3,(uint)flag1),input3 + flag1\n                     );\n    }\n  }\n  if (!flag1 && (int)carry2 < 0 == flag3) {\n    return (ulonglong)(input4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag2 = SCARRY4(carry3,0x36);\n  flag1 = (int)(carry3 + 0x36) < 0;\n  flag3 = carry3 == 0xffffffca;\n  if (flag3 || flag1 != flag2) {\n    input3 = 0;\n  }\n  if (flag3 || flag1 != flag2) {\n    input4 = input4 & 0x80000000;\n  }\n  if (flag3 || flag1 != flag2) {\n    return CONCAT44(input4,input3);\n  }\n  carry2 = -carry3;\n  carry1 = carry2 - 0x20;\n  if (0x1f < (int)carry2) {\n    carry3 = input3 >> (carry1 & 0xff) | input4 << (0x20 - carry1 & 0xff);\n    carry2 = (input4 >> (carry1 & 0xff) & ~((input4 & 0x80000000) >> (carry1 & 0xff))) -\n            ((int)carry3 >> 0x1f);\n    if ((temp1 | input3 << (0x20 - carry1 & 0xff) | carry3 << 1) == 0) {\n      carry2 = carry2 & ~(carry3 >> 0x1f);\n    }\n    return CONCAT44(input4,carry2) & 0x80000000ffffffff;\n  }\n  sum = carry2 - 0x14;\n  if (sum == 0 || sum < 0 != SCARRY4(carry1,0xc)) {\n    temp2 = input3 << (carry3 + 0x20 & 0xff);\n    carry1 = input3 >> (carry2 & 0xff) | input4 << (carry3 + 0x20 & 0xff);\n    carry3 = carry1 + -((int)temp2 >> 0x1f);\n    if ((temp1 | temp2 << 1) == 0) {\n      carry3 = carry3 & ~(temp2 >> 0x1f);\n    }\n    return CONCAT44((input4 & 0x80000000) +\n                    ((input4 & 0x7fffffff) >> (carry2 & 0xff)) +\n                    (uint)CARRY4(carry1,-((int)temp2 >> 0x1f)),carry3);\n  }\n  carry2 = 0xc - sum;\n  carry3 = input3 << (carry2 & 0xff);\n  carry2 = input3 >> (0x20 - carry2 & 0xff) | input4 << (carry2 & 0xff);\n  carry1 = carry2 + -((int)carry3 >> 0x1f);\n  if ((temp1 | carry3 << 1) == 0) {\n    carry1 = carry1 & ~(carry3 >> 0x1f);\n  }\n  return CONCAT44((input4 & 0x80000000) + (uint)CARRY4(carry2,-((int)carry3 >> 0x1f)),carry1);\n}\n\n",
            "renaming": {
                "FUN_080004c8": "calculate_product_080004c8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "resultLow",
                "lVar2": "temp",
                "uVar3": "carry1",
                "uVar4": "carry2",
                "iVar5": "sum",
                "uVar6": "carry3",
                "unaff_r5": "carry4",
                "uVar7": "temp1",
                "uVar8": "temp2",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3",
                "uVar12": "product"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8",
                "FUN_08004d78",
                "FUN_080059f0",
                "FUN_080096e0",
                "FUN_08004bd8"
            ],
            "called": [
                "FUN_080006a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006a4": {
            "entrypoint": "0x080006a4",
            "current_name": "calculate_shifted_value_080006a4",
            "code": "\nulonglong calculate_shifted_value_080006a4(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint shifted_input_1;\n  uint shifted_input_2;\n  uint shifted_in_r12;\n  uint shifted_result;\n  uint constant;\n  bool is_zero;\n  \n  shifted_in_r12 = constant & input_4 >> 0x14;\n  if (shifted_input_2 != constant && shifted_in_r12 != constant) {\n    is_zero = (input_1 | input_2 << 1) == 0;\n    if (!is_zero) {\n      is_zero = (input_3 | input_4 << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n    }\n    if (shifted_input_2 == 0) {\n      shifted_result = input_2 & 0x80000000;\n      do {\n        shifted_input_1 = input_1 & 0x80000000;\n        input_1 = input_1 << 1;\n        input_2 = input_2 * 2 + (uint)(shifted_input_1 != 0);\n      } while ((input_2 & 0x100000) == 0);\n      input_2 = input_2 | shifted_result;\n      if (shifted_in_r12 != 0) {\n        return CONCAT44(input_2,input_1);\n      }\n    }\n    do {\n      shifted_in_r12 = input_3 & 0x80000000;\n      input_3 = input_3 << 1;\n      input_4 = input_4 * 2 + (uint)(shifted_in_r12 != 0);\n    } while ((input_4 & 0x100000) == 0);\n    return CONCAT44(input_2,input_1);\n  }\n  is_zero = (input_1 | input_2 << 1) == 0;\n  if (is_zero) {\n    input_2 = input_4;\n    input_1 = input_3;\n  }\n  if (!is_zero) {\n    is_zero = (input_3 | input_4 << 1) == 0;\n  }\n  shifted_result = input_2;\n  if (((!is_zero) && ((shifted_input_2 != constant || ((input_1 | input_2 << 0xc) == 0)))) &&\n     ((shifted_in_r12 != constant || (input_1 = input_3, shifted_result = input_4, (input_3 | input_4 << 0xc) == 0)))) {\n    return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(shifted_result,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006a4": "calculate_shifted_value_080006a4",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "shifted_input_1",
                "unaff_r4": "shifted_input_2",
                "uVar2": "shifted_in_r12",
                "uVar3": "shifted_result",
                "in_r12": "constant",
                "bVar4": "is_zero"
            },
            "calling": [
                "FUN_080004c8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800071c": {
            "entrypoint": "0x0800071c",
            "current_name": "calculate_floating_point_0800071c",
            "code": "\nulonglong calculateFloatingPoint_0800071c(undefined4 sign,uint exponent,uint mantissa_high,uint mantissa_low)\n\n{\n  uint exponent_bits;\n  uint mantissa_high_bits;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  int exponent_diff;\n  uint exponent1;\n  uint exponent2;\n  uint fraction1;\n  uint fraction2;\n  uint residual;\n  uint overflow_bit;\n  bool is_zero_diff;\n  bool is_equal;\n  bool is_negative;\n  undefined8 exponent_bits7;\n  \n  exponent_bits7 = CONCAT44(exponent,sign);\n  overflow_bit = 0x7ff;\n  temp5 = exponent >> 0x14 & 0x7ff;\n  is_zero_diff = temp5 == 0;\n  if (!is_zero_diff) {\n    exponent2 = mantissa_low >> 0x14 & 0x7ff;\n    is_zero_diff = exponent2 == 0;\n  }\n  if (!is_zero_diff) {\n    is_zero_diff = temp5 == 0x7ff;\n  }\n  if (!is_zero_diff) {\n    is_zero_diff = exponent2 == 0x7ff;\n  }\n  if (is_zero_diff) {\n    exponent_bits7 = FUN_0800088a();\n  }\n  exponent1 = (uint)((ulonglong)exponent_bits7 >> 0x20);\n  fraction2 = (uint)exponent_bits7;\n  exponent_diff = temp5 - exponent2;\n  if ((mantissa_high | mantissa_low << 0xc) == 0) {\n    temp5 = (exponent1 ^ mantissa_low) & 0x80000000 | exponent1 & 0xfffff;\n    is_negative = SCARRY4(exponent_diff,overflow_bit >> 1);\n    exponent1 = exponent_diff + (overflow_bit >> 1);\n    is_zero_diff = (int)exponent1 < 0;\n    is_equal = exponent1 == 0;\n    if (!is_equal && is_zero_diff == is_negative) {\n      is_negative = SBORROW4(overflow_bit,exponent1);\n      is_zero_diff = (int)(overflow_bit - exponent1) < 0;\n      is_equal = overflow_bit == exponent1;\n    }\n    if (!is_equal && is_zero_diff == is_negative) {\n      temp5 = temp5 | exponent1 * 0x100000;\n    }\n    if (!is_equal && is_zero_diff == is_negative) {\n      return CONCAT44(temp5,fraction2);\n    }\n    temp5 = temp5 | 0x100000;\n    overflow_bit = 0;\n    is_equal = SBORROW4(exponent1,1);\n    exponent1 = exponent1 - 1;\n    is_zero_diff = exponent1 == 0;\n    temp1 = exponent1;\n  }\n  else {\n    temp1 = (mantissa_low << 0xc) >> 4 | 0x10000000 | mantissa_high >> 0x18;\n    overflow_bit = mantissa_high << 8;\n    fraction1 = (exponent1 << 0xc) >> 4 | 0x10000000 | fraction2 >> 0x18;\n    fraction2 = fraction2 * 0x100;\n    temp5 = (exponent1 ^ mantissa_low) & 0x80000000;\n    is_zero_diff = temp1 <= fraction1;\n    if (fraction1 == temp1) {\n      is_zero_diff = overflow_bit <= fraction2;\n    }\n    exponent_diff = exponent_diff + (uint)is_zero_diff;\n    exponent1 = exponent_diff + 0x3fd;\n    if (is_zero_diff == false) {\n      temp1 = temp1 >> 1;\n      overflow_bit = (uint)((mantissa_high >> 0x18 & 1) != 0) << 0x1f | overflow_bit >> 1;\n    }\n    residual = fraction2 - overflow_bit;\n    fraction1 = (fraction1 - temp1) - (uint)(fraction2 < overflow_bit);\n    temp2 = temp1 >> 1;\n    exponent_bits = (uint)((temp1 & 1) != 0) << 0x1f | overflow_bit >> 1;\n    fraction2 = 0x100000;\n    temp1 = 0x80000;\n    while( true ) {\n      is_zero_diff = exponent_bits <= residual;\n      if (temp2 < fraction1 || fraction1 - temp2 < (uint)is_zero_diff) {\n        residual = residual - exponent_bits;\n        fraction2 = fraction2 | temp1;\n        fraction1 = (fraction1 - temp2) - (uint)!is_zero_diff;\n      }\n      temp3 = temp2 >> 1;\n      exponent_bits = (uint)((temp2 & 1) != 0) << 0x1f | exponent_bits >> 1;\n      is_equal = exponent_bits <= residual;\n      is_zero_diff = fraction1 - temp3 < (uint)is_equal;\n      overflow_bit = fraction1;\n      if (temp3 < fraction1 || is_zero_diff) {\n        residual = residual - exponent_bits;\n        overflow_bit = (fraction1 - temp3) - (uint)!is_equal;\n      }\n      if (temp3 < fraction1 || is_zero_diff) {\n        fraction2 = fraction2 | temp1 >> 1;\n      }\n      fraction1 = temp2 >> 2;\n      mantissa_high_bits = (uint)((temp3 & 1) != 0) << 0x1f | exponent_bits >> 1;\n      is_equal = mantissa_high_bits <= residual;\n      is_zero_diff = overflow_bit - fraction1 < (uint)is_equal;\n      temp3 = overflow_bit;\n      if (fraction1 < overflow_bit || is_zero_diff) {\n        residual = residual - mantissa_high_bits;\n        temp3 = (overflow_bit - fraction1) - (uint)!is_equal;\n      }\n      if (fraction1 < overflow_bit || is_zero_diff) {\n        fraction2 = fraction2 | temp1 >> 2;\n      }\n      temp4 = temp2 >> 3;\n      exponent_bits = (uint)((fraction1 & 1) != 0) << 0x1f | mantissa_high_bits >> 1;\n      is_equal = exponent_bits <= residual;\n      is_zero_diff = temp3 - temp4 < (uint)is_equal;\n      fraction1 = temp3;\n      if (temp4 < temp3 || is_zero_diff) {\n        residual = residual - exponent_bits;\n        fraction1 = (temp3 - temp4) - (uint)!is_equal;\n      }\n      if (temp4 < temp3 || is_zero_diff) {\n        fraction2 = fraction2 | temp1 >> 3;\n      }\n      overflow_bit = fraction1 | residual;\n      if (overflow_bit == 0) break;\n      fraction1 = fraction1 << 4 | residual >> 0x1c;\n      residual = residual << 4;\n      temp2 = temp2 & 0xfffffff8 | exponent_bits >> 0x1d;\n      exponent_bits = (mantissa_high_bits >> 1) << 3;\n      temp1 = temp1 >> 4;\n      if (temp1 == 0) {\n        temp4 = temp2;\n        if ((temp5 & 0x100000) != 0) goto LAB_0800083a;\n        temp5 = temp5 | fraction2;\n        fraction2 = 0;\n        temp1 = 0x80000000;\n      }\n    }\n    if ((temp5 & 0x100000) == 0) {\n      temp5 = temp5 | fraction2;\n      fraction2 = 0;\n    }\nLAB_0800083a:\n    is_negative = 0xfc < exponent1;\n    is_equal = SBORROW4(exponent1,0xfd);\n    temp2 = exponent_diff + 0x300;\n    is_zero_diff = temp2 == 0;\n    temp1 = temp2;\n    if (is_negative && !is_zero_diff) {\n      is_negative = 0x6ff < temp2;\n      is_equal = SBORROW4(temp2,0x700);\n      temp1 = exponent_diff - 0x400;\n      is_zero_diff = temp2 == 0x700;\n    }\n    if (!is_negative || is_zero_diff) {\n      is_zero_diff = temp4 <= fraction1;\n      if (fraction1 == temp4) {\n        is_zero_diff = exponent_bits <= residual;\n      }\n      if (fraction1 == temp4 && residual == exponent_bits) {\n        is_zero_diff = (fraction2 & 1) != 0;\n      }\n      return CONCAT44(temp5 + exponent1 * 0x100000 + (uint)CARRY4(fraction2,(uint)is_zero_diff),fraction2 + is_zero_diff);\n    }\n  }\n  if (!is_zero_diff && (int)temp1 < 0 == is_equal) {\n    return (ulonglong)(temp5 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  is_negative = SCARRY4(exponent1,0x36);\n  is_zero_diff = (int)(exponent1 + 0x36) < 0;\n  is_equal = exponent1 == 0xffffffca;\n  if (is_equal || is_zero_diff != is_negative) {\n    fraction2 = 0;\n  }\n  if (is_equal || is_zero_diff != is_negative) {\n    temp5 = temp5 & 0x80000000;\n  }\n  if (is_equal || is_zero_diff != is_negative) {\n    return CONCAT44(temp5,fraction2);\n  }\n  temp1 = -exponent1;\n  fraction1 = temp1 - 0x20;\n  if (0x1f < (int)temp1) {\n    temp1 = fraction2 >> (fraction1 & 0xff) | temp5 << (0x20 - fraction1 & 0xff);\n    exponent1 = (temp5 >> (fraction1 & 0xff) & ~((temp5 & 0x80000000) >> (fraction1 & 0xff))) -\n            ((int)temp1 >> 0x1f);\n    if ((overflow_bit | fraction2 << (0x20 - fraction1 & 0xff) | temp1 << 1) == 0) {\n      exponent1 = exponent1 & ~(temp1 >> 0x1f);\n    }\n    return CONCAT44(temp5,exponent1) & 0x80000000ffffffff;\n  }\n  exponent_diff = temp1 - 0x14;\n  if (exponent_diff != 0 && exponent_diff < 0 == SCARRY4(fraction1,0xc)) {\n    exponent1 = 0xc - exponent_diff;\n    temp1 = fraction2 << (exponent1 & 0xff);\n    fraction2 = fraction2 >> (0x20 - exponent1 & 0xff) | temp5 << (exponent1 & 0xff);\n    exponent1 = fraction2 + -((int)temp1 >> 0x1f);\n    if ((overflow_bit | temp1 << 1) == 0) {\n      exponent1 = exponent1 & ~(temp1 >> 0x1f);\n    }\n    return CONCAT44((temp5 & 0x80000000) + (uint)CARRY4(fraction2,-((int)temp1 >> 0x1f)),exponent1);\n  }\n  fraction1 = fraction2 << (exponent1 + 0x20 & 0xff);\n  fraction2 = fraction2 >> (temp1 & 0xff) | temp5 << (exponent1 + 0x20 & 0xff);\n  exponent1 = fraction2 + -((int)fraction1 >> 0x1f);\n  if ((overflow_bit | fraction1 << 1) == 0) {\n    exponent1 = exponent1 & ~(fraction1 >> 0x1f);\n  }\n  return CONCAT44((temp5 & 0x80000000) +\n                  ((temp5 & 0x7fffffff) >> (temp1 & 0xff)) +\n                  (uint)CARRY4(fraction2,-((int)fraction1 >> 0x1f)),exponent1);\n}\n\n",
            "renaming": {
                "FUN_0800071c": "calculate_floating_point_0800071c",
                "param_1": "sign",
                "param_2": "exponent",
                "param_3": "mantissa_high",
                "param_4": "mantissa_low",
                "uVar1": "exponent_bits",
                "uVar2": "mantissa_high_bits",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "temp4",
                "uVar7": "temp5",
                "iVar8": "exponent_diff",
                "uVar9": "exponent1",
                "unaff_r5": "exponent2",
                "uVar10": "fraction1",
                "uVar11": "fraction2",
                "uVar12": "residual",
                "uVar13": "overflow_bit",
                "bVar14": "is_zero_diff",
                "bVar15": "is_equal",
                "bVar16": "is_negative"
            },
            "calling": [
                "FUN_080079e8",
                "FUN_08004d78",
                "FUN_08005838",
                "FUN_080059f0",
                "FUN_08004bd8"
            ],
            "called": [
                "FUN_0800088a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800088a": {
            "entrypoint": "0x0800088a",
            "current_name": "decode_value_0800088a",
            "code": "\nulonglong decode_value_0800088a(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint bit_1;\n  uint bit_2;\n  uint bit_3;\n  uint bit_4;\n  uint bit_5;\n  bool is_zero;\n  \n  bit_3 = bit_5 & input_4 >> 0x14;\n  bit_4 = input_2;\n  if (bit_2 != bit_5 || bit_3 != bit_5) {\n    if (bit_2 == bit_5) {\n      if (((input_1 | input_2 << 0xc) == 0) && (input_1 = input_3, bit_4 = input_4, bit_3 != bit_5)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bit_3 == bit_5) {\n      input_1 = input_3;\n      bit_4 = input_4;\n      if ((input_3 | input_4 << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      is_zero = (input_1 | input_2 << 1) == 0;\n      if (!is_zero) {\n        is_zero = (input_3 | input_4 << 1) == 0;\n      }\n      if (!is_zero) {\n        if (bit_2 == 0) {\n          bit_4 = input_2 & 0x80000000;\n          do {\n            bit_1 = input_1 & 0x80000000;\n            input_1 = input_1 << 1;\n            input_2 = input_2 * 2 + (uint)(bit_1 != 0);\n          } while ((input_2 & 0x100000) == 0);\n          input_2 = input_2 | bit_4;\n          if (bit_3 != 0) {\n            return CONCAT44(input_2,input_1);\n          }\n        }\n        do {\n          bit_4 = input_3 & 0x80000000;\n          input_3 = input_3 << 1;\n          input_4 = input_4 * 2 + (uint)(bit_4 != 0);\n        } while ((input_4 & 0x100000) == 0);\n        return CONCAT44(input_2,input_1);\n      }\n      if ((input_1 | input_2 << 1) != 0) goto LAB_080006fc;\n      if ((input_3 | input_4 << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(bit_4,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800088a": "decode_value_0800088a",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "bit_1",
                "unaff_r4": "bit_2",
                "uVar2": "bit_3",
                "uVar3": "bit_4",
                "in_r12": "bit_5",
                "bVar4": "is_zero"
            },
            "calling": [
                "FUN_0800071c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_parameters_080008fc",
            "code": "\nuint check_parameters_080008fc(uint input1,uint input2,uint input3,uint output)\n\n{\n  uint result_xor;\n  bool is_zero;\n  bool is_negative;\n  \n  if (((int)(input2 << 1) >> 0x15 == -1 || (int)(output << 1) >> 0x15 == -1) &&\n     ((((int)(input2 << 1) >> 0x15 == -1 && ((input1 | input2 << 0xc) != 0)) ||\n      (((int)(output << 1) >> 0x15 == -1 && ((input3 | output << 0xc) != 0)))))) {\n    return 1;\n  }\n  is_zero = (input1 | input2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (input3 | output << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = input2 == output;\n  }\n  if (is_zero) {\n    is_zero = input1 == input3;\n  }\n  if (!is_zero) {\n    result_xor = input2 ^ output;\n    is_zero = result_xor == 0;\n    if (-1 < (int)result_xor) {\n      is_zero = input2 == output;\n    }\n    is_negative = -1 < (int)result_xor && output <= input2;\n    if (is_zero) {\n      is_negative = input3 <= input1;\n    }\n    output = (int)output >> 0x1f;\n    if (!is_negative) {\n      output = ~output;\n    }\n    return output | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_parameters_080008fc",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "output",
                "uVar1": "result_xor",
                "bVar2": "is_zero",
                "bVar3": "is_negative"
            },
            "calling": [
                "FUN_08000988"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000978": {
            "entrypoint": "0x08000978",
            "current_name": "execute_function_08000978",
            "code": "\nvoid executeFunction_08000978(undefined4 arg1,undefined4 arg2,undefined4 arg3,undefined4 arg4)\n\n{\n  FUN_08000988(arg3,arg4,arg1,arg2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000978": "execute_function_08000978",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4"
            },
            "calling": [
                "FUN_080009d4",
                "FUN_080009e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000988": {
            "entrypoint": "0x08000988",
            "current_name": "initialize_08000988",
            "code": "\nundefined4 initialize_08000988(undefined4 input)\n\n{\n  FUN_080008fc();\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000988": "initialize_08000988",
                "param_1": "input"
            },
            "calling": [
                "FUN_080009ac",
                "FUN_08000998",
                "FUN_08000978",
                "FUN_080009c0"
            ],
            "called": [
                "FUN_080008fc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "check_if_input_not_empty_08000998",
            "code": "\nbool checkIfInputNotEmpty_08000998(void)\n\n{\n  char inputChar;\n  \n  FUN_08000988();\n  return inputChar != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000998": "check_if_input_not_empty_08000998",
                "in_ZR": "inputChar"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009ac": {
            "entrypoint": "0x080009ac",
            "current_name": "check_if_null_terminated_080009ac",
            "code": "\nbool check_if_null_terminated_080009ac(void)\n\n{\n  char input_character;\n  \n  FUN_08000988();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009ac": "check_if_null_terminated_080009ac",
                "in_CY": "input_character"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c0": {
            "entrypoint": "0x080009c0",
            "current_name": "is_carry_or_zero_080009c0",
            "code": "\nbool is_carry_or_zero_080009c0(void)\n\n{\n  undefined is_zero;\n  undefined is_carry;\n  \n  FUN_08000988();\n  return !(bool)is_carry || (bool)is_zero;\n}\n\n",
            "renaming": {
                "FUN_080009c0": "is_carry_or_zero_080009c0",
                "in_ZR": "is_zero",
                "in_CY": "is_carry"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009d4": {
            "entrypoint": "0x080009d4",
            "current_name": "check_inverted_flags_080009d4",
            "code": "\nbool check_inverted_flags_080009d4(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_result;\n  \n  FUN_08000978();\n  return !(bool)is_carry_result || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009d4": "check_inverted_flags_080009d4",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_result"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000978"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009e8": {
            "entrypoint": "0x080009e8",
            "current_name": "check_empty_string_080009e8",
            "code": "\nbool checkEmptyString_080009e8(void)\n\n{\n  char inputChar;\n  \n  FUN_08000978();\n  return inputChar == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009e8": "check_empty_string_080009e8",
                "in_CY": "inputChar"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8",
                "FUN_080059f0"
            ],
            "called": [
                "FUN_08000978"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009fc": {
            "entrypoint": "0x080009fc",
            "current_name": "floating_point_conversion_080009fc",
            "code": "\nuint floatingPointConversion_080009fc(uint inputSign,uint inputValue)\n\n{\n  uint result;\n  uint temp;\n  uint roundedValue;\n  uint roundedValueWithGuard;\n  bool isZero;\n  bool isBelowThreshold;\n  \n  temp = inputValue * 2;\n  isBelowThreshold = temp < 0x70000000;\n  roundedValue = temp + 0x90000000;\n  result = roundedValue;\n  if (!isBelowThreshold) {\n    roundedValueWithGuard = temp + 0x8fe00000;\n    result = roundedValueWithGuard;\n  }\n  isZero = result == 0;\n  if (!isBelowThreshold && roundedValue >= 0x200000) {\n    isZero = roundedValueWithGuard == 0x1fc00000;\n  }\n  if (((isBelowThreshold || roundedValue < 0x200000) || 0x1fc00000 < roundedValueWithGuard) || isZero) {\n    if ((inputValue & 0x40000000) != 0) {\n      if (((int)temp >> 0x15 == -1) && ((inputSign | inputValue << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return inputValue & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(temp + 0x92e00000) < 0 != SCARRY4(roundedValue,0x2e00000)) {\n      return inputValue & 0x80000000;\n    }\n    temp = 0x18 - (temp + 0x92e00000 >> 0x15);\n    result = inputSign >> (temp & 0xff);\n    if (inputSign << (0x20 - temp & 0xff) != 0) {\n      result = result | 1;\n    }\n    roundedValue = inputValue & 0x1fffff | 0x100000;\n    inputSign = result | roundedValue << (0x20 - temp & 0xff);\n    roundedValue = (roundedValue >> (temp & 0xff)) << 1;\n  }\n  result = (inputValue & 0x80000000 | inputSign >> 0x1d) + roundedValue * 4 + (uint)(0x7fffffff < inputSign * 8);\n  if (inputSign * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080009fc": "floating_point_conversion_080009fc",
                "param_1": "inputSign",
                "param_2": "inputValue",
                "uVar1": "result",
                "uVar2": "temp",
                "uVar3": "roundedValue",
                "in_r12": "roundedValueWithGuard",
                "bVar4": "isZero",
                "bVar5": "isBelowThreshold"
            },
            "calling": [
                "FUN_08004d78",
                "FUN_08004bd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa4": {
            "entrypoint": "0x08000aa4",
            "current_name": "calculate_float_08000aa4",
            "code": "\nuint calculateFloat_08000aa4(uint float1,uint float2,undefined4 param3,uint param4)\n\n{\n  int shiftRightAmount;\n  int shiftRightAmount2;\n  uint float2Inverse;\n  uint float2InverseRev;\n  uint float1Shifted;\n  uint newFloat1;\n  uint floatDifference;\n  bool isConditionMet;\n  \n  float2Inverse = float2 ^ 0x80000000;\n  float1Shifted = float1 << 1;\n  isConditionMet = float1Shifted == 0;\n  if (!isConditionMet) {\n    param4 = float2 << 1;\n    isConditionMet = param4 == 0;\n  }\n  if (!isConditionMet) {\n    isConditionMet = float1Shifted == param4;\n  }\n  shiftRightAmount = (int)float1Shifted >> 0x18;\n  if (!isConditionMet) {\n    isConditionMet = shiftRightAmount == -1;\n  }\n  if (!isConditionMet) {\n    isConditionMet = (int)param4 >> 0x18 == -1;\n  }\n  if (isConditionMet) {\n    shiftRightAmount2 = (int)(float2 << 1) >> 0x18;\n    if (shiftRightAmount == -1 || shiftRightAmount2 == -1) {\n      float1Shifted = float2Inverse;\n      if (shiftRightAmount == -1) {\n        float1Shifted = float1;\n      }\n      if (shiftRightAmount != -1 || shiftRightAmount2 != -1) {\n        float2Inverse = float1Shifted;\n      }\n      isConditionMet = (float1Shifted & 0x7fffff) == 0;\n      if (isConditionMet) {\n        isConditionMet = (float2Inverse & 0x7fffff) == 0;\n      }\n      if (isConditionMet) {\n        isConditionMet = float1Shifted == float2Inverse;\n      }\n      if (!isConditionMet) {\n        float1Shifted = float1Shifted | 0x400000;\n      }\n      return float1Shifted;\n    }\n    if (((float1 ^ float2Inverse) & 0x7fffffff) != 0) {\n      if (float1Shifted == 0) {\n        float1 = float2Inverse;\n      }\n      return float1;\n    }\n    if (float1 != float2Inverse) {\n      return 0;\n    }\n    if ((float1Shifted & 0xff000000) == 0) {\n      float2Inverse = float1 << 1;\n      if ((float1 & 0x80000000) != 0) {\n        float2Inverse = float2Inverse | 0x80000000;\n      }\n      return float2Inverse;\n    }\n    if (float1Shifted < 0xfe000000) {\n      return float1 + 0x800000;\n    }\n    float1 = float1 & 0x80000000;\nLAB_08000bde:\n    return float1 | 0x7f800000;\n  }\n  float1Shifted = float1Shifted >> 0x18;\n  param4 = param4 >> 0x18;\n  floatDifference = param4 - float1Shifted;\n  isConditionMet = floatDifference != 0;\n  newFloat1 = float1Shifted;\n  if (isConditionMet && float1Shifted <= param4) {\n    newFloat1 = float1Shifted + floatDifference;\n  }\n  if (isConditionMet && float1Shifted <= param4) {\n    float2Inverse = float2Inverse ^ float1;\n  }\n  if (isConditionMet && float1Shifted <= param4) {\n    float1 = float1 ^ float2Inverse;\n  }\n  if (isConditionMet && float1Shifted <= param4) {\n    float2Inverse = float2Inverse ^ float1;\n  }\n  if (param4 < float1Shifted) {\n    floatDifference = -floatDifference;\n  }\n  if (0x19 < floatDifference) {\n    return float1;\n  }\n  float1Shifted = float1 & 0xffffff | 0x800000;\n  if ((float1 & 0x80000000) != 0) {\n    float1Shifted = -float1Shifted;\n  }\n  float2InverseRev = float2Inverse & 0xffffff | 0x800000;\n  if ((float2Inverse & 0x80000000) != 0) {\n    float2InverseRev = -float2InverseRev;\n  }\n  if (newFloat1 == floatDifference) {\n    float2InverseRev = float2InverseRev ^ 0x800000;\n    if (newFloat1 == 0) {\n      float1Shifted = float1Shifted ^ 0x800000;\n      newFloat1 = 1;\n    }\n    else {\n      floatDifference = floatDifference - 1;\n    }\n  }\n  float1Shifted = float1Shifted + ((int)float2InverseRev >> (floatDifference & 0xff));\n  float2InverseRev = float2InverseRev << (0x20 - floatDifference & 0xff);\n  float1 = float1Shifted & 0x80000000;\n  if ((int)float1Shifted < 0) {\n    isConditionMet = float2InverseRev != 0;\n    float2InverseRev = -float2InverseRev;\n    float1Shifted = -float1Shifted - (uint)isConditionMet;\n  }\n  if (float1Shifted < 0x800000) {\n    float2Inverse = float2InverseRev & 0x80000000;\n    float2InverseRev = float2InverseRev << 1;\n    float1Shifted = float1Shifted * 2 + (uint)(float2Inverse != 0);\n    float2Inverse = newFloat1 - 2;\n    if ((float1Shifted & 0x800000) == 0) {\n      floatDifference = LZCOUNT(float1Shifted) - 8;\n      float1Shifted = float1Shifted << (floatDifference & 0xff);\n      if ((int)float2Inverse < (int)floatDifference) {\n        float1Shifted = float1Shifted >> (-(float2Inverse - floatDifference) & 0xff);\n      }\n      else {\n        float1Shifted = float1Shifted + (float2Inverse - floatDifference) * 0x800000;\n      }\n      return float1Shifted | float1;\n    }\n  }\n  else {\n    float2Inverse = newFloat1 - 1;\n    if (0xffffff < float1Shifted) {\n      float2Inverse = float1Shifted & 1;\n      float1Shifted = float1Shifted >> 1;\n      float2InverseRev = (uint)(float2Inverse != 0) << 0x1f | float2InverseRev >> 1;\n      float2Inverse = newFloat1;\n      if (0xfd < newFloat1) goto LAB_08000bde;\n    }\n  }\n  float1Shifted = float1Shifted + float2Inverse * 0x800000 + (uint)(0x7fffffff < float2InverseRev);\n  if (float2InverseRev == 0x80000000) {\n    float1Shifted = float1Shifted & 0xfffffffe;\n  }\n  return float1Shifted | float1;\n}\n\n",
            "renaming": {
                "FUN_08000aa4": "calculate_float_08000aa4",
                "param_1": "float1",
                "param_2": "float2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar3": "float2Inverse",
                "uVar4": "float2InverseRev",
                "uVar5": "float1Shifted",
                "uVar6": "newFloat1",
                "uVar7": "floatDifference",
                "bVar8": "isConditionMet",
                "iVar1": "shiftRightAmount",
                "iVar2": "shiftRightAmount2"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08004bd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_float_08000aa8",
            "code": "\nuint calculateFloat_08000aa8(uint num1,uint num2,undefined4 flags,uint result)\n\n{\n  int upperWordNum1;\n  int upperWordNum2;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  bool isZero;\n  \n  temp2 = num1 << 1;\n  isZero = temp2 == 0;\n  if (!isZero) {\n    result = num2 << 1;\n    isZero = result == 0;\n  }\n  if (!isZero) {\n    isZero = temp2 == result;\n  }\n  upperWordNum1 = (int)temp2 >> 0x18;\n  if (!isZero) {\n    isZero = upperWordNum1 == -1;\n  }\n  if (!isZero) {\n    isZero = (int)result >> 0x18 == -1;\n  }\n  if (isZero) {\n    upperWordNum2 = (int)(num2 << 1) >> 0x18;\n    if (upperWordNum1 == -1 || upperWordNum2 == -1) {\n      temp2 = num2;\n      if (upperWordNum1 == -1) {\n        temp2 = num1;\n      }\n      if (upperWordNum1 != -1 || upperWordNum2 != -1) {\n        num2 = temp2;\n      }\n      isZero = (temp2 & 0x7fffff) == 0;\n      if (isZero) {\n        isZero = (num2 & 0x7fffff) == 0;\n      }\n      if (isZero) {\n        isZero = temp2 == num2;\n      }\n      if (!isZero) {\n        temp2 = temp2 | 0x400000;\n      }\n      return temp2;\n    }\n    if (((num1 ^ num2) & 0x7fffffff) != 0) {\n      if (temp2 == 0) {\n        num1 = num2;\n      }\n      return num1;\n    }\n    if (num1 != num2) {\n      return 0;\n    }\n    if ((temp2 & 0xff000000) == 0) {\n      temp2 = num1 << 1;\n      if ((num1 & 0x80000000) != 0) {\n        temp2 = temp2 | 0x80000000;\n      }\n      return temp2;\n    }\n    if (temp2 < 0xfe000000) {\n      return num1 + 0x800000;\n    }\n    num1 = num1 & 0x80000000;\nLAB_08000bde:\n    return num1 | 0x7f800000;\n  }\n  temp2 = temp2 >> 0x18;\n  result = result >> 0x18;\n  temp4 = result - temp2;\n  isZero = temp4 != 0;\n  temp3 = temp2;\n  if (isZero && temp2 <= result) {\n    temp3 = temp2 + temp4;\n  }\n  if (isZero && temp2 <= result) {\n    num2 = num2 ^ num1;\n  }\n  if (isZero && temp2 <= result) {\n    num1 = num1 ^ num2;\n  }\n  if (isZero && temp2 <= result) {\n    num2 = num2 ^ num1;\n  }\n  if (result < temp2) {\n    temp4 = -temp4;\n  }\n  if (0x19 < temp4) {\n    return num1;\n  }\n  temp2 = num1 & 0xffffff | 0x800000;\n  if ((num1 & 0x80000000) != 0) {\n    temp2 = -temp2;\n  }\n  temp1 = num2 & 0xffffff | 0x800000;\n  if ((num2 & 0x80000000) != 0) {\n    temp1 = -temp1;\n  }\n  if (temp3 == temp4) {\n    temp1 = temp1 ^ 0x800000;\n    if (temp3 == 0) {\n      temp2 = temp2 ^ 0x800000;\n      temp3 = 1;\n    }\n    else {\n      temp4 = temp4 - 1;\n    }\n  }\n  temp2 = temp2 + ((int)temp1 >> (temp4 & 0xff));\n  temp1 = temp1 << (0x20 - temp4 & 0xff);\n  num1 = temp2 & 0x80000000;\n  if ((int)temp2 < 0) {\n    isZero = temp1 != 0;\n    temp1 = -temp1;\n    temp2 = -temp2 - (uint)isZero;\n  }\n  if (temp2 < 0x800000) {\n    temp4 = temp1 & 0x80000000;\n    temp1 = temp1 << 1;\n    temp2 = temp2 * 2 + (uint)(temp4 != 0);\n    temp4 = temp3 - 2;\n    if ((temp2 & 0x800000) == 0) {\n      temp3 = LZCOUNT(temp2) - 8;\n      temp2 = temp2 << (temp3 & 0xff);\n      if ((int)temp4 < (int)temp3) {\n        temp2 = temp2 >> (-(temp4 - temp3) & 0xff);\n      }\n      else {\n        temp2 = temp2 + (temp4 - temp3) * 0x800000;\n      }\n      return temp2 | num1;\n    }\n  }\n  else {\n    temp4 = temp3 - 1;\n    if (0xffffff < temp2) {\n      temp4 = temp2 & 1;\n      temp2 = temp2 >> 1;\n      temp1 = (uint)(temp4 != 0) << 0x1f | temp1 >> 1;\n      temp4 = temp3;\n      if (0xfd < temp3) goto LAB_08000bde;\n    }\n  }\n  temp2 = temp2 + temp4 * 0x800000 + (uint)(0x7fffffff < temp1);\n  if (temp1 == 0x80000000) {\n    temp2 = temp2 & 0xfffffffe;\n  }\n  return temp2 | num1;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_float_08000aa8",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "flags",
                "param_4": "result",
                "iVar1": "upperWordNum1",
                "iVar2": "upperWordNum2",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "temp4",
                "bVar7": "isZero"
            },
            "calling": [
                "FUN_080049cc",
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c08": {
            "entrypoint": "0x08000c08",
            "current_name": "calculate_modified_value_08000c08",
            "code": "\nuint calculateModifiedValue_08000c08(uint inputValue)\n\n{\n  uint leadingZerosCount;\n  uint shiftAmount;\n  int constantValue;\n  uint mask;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZerosCount = LZCOUNT(inputValue);\n  shiftAmount = leadingZerosCount - 8;\n  constantValue = shiftAmount * -0x800000 + 0x4a800000;\n  if (7 < leadingZerosCount) {\n    mask = 0 << (shiftAmount & 0xff);\n    leadingZerosCount = constantValue + (inputValue << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < mask);\n    if (mask == 0x80000000) {\n      leadingZerosCount = leadingZerosCount & 0xfffffffe;\n    }\n    return leadingZerosCount;\n  }\n  shiftAmount = inputValue << leadingZerosCount + 0x18;\n  leadingZerosCount = constantValue + ((inputValue >> (0x20 - (leadingZerosCount + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    leadingZerosCount = leadingZerosCount & ~(shiftAmount >> 0x1f);\n  }\n  return leadingZerosCount;\n}\n\n",
            "renaming": {
                "FUN_08000c08": "calculate_modified_value_08000c08",
                "param_1": "inputValue",
                "uVar1": "leadingZerosCount",
                "uVar2": "shiftAmount",
                "iVar3": "constantValue",
                "uVar4": "mask"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c10": {
            "entrypoint": "0x08000c10",
            "current_name": "calculate_shifted_08000c10",
            "code": "\nuint calculate_shifted_08000c10(uint input_value)\n\n{\n  uint leading_zeros;\n  uint shifted_value;\n  uint is_negative;\n  int result;\n  \n  is_negative = input_value & 0x80000000;\n  if ((int)is_negative < 0) {\n    input_value = -input_value;\n  }\n  if (input_value == 0) {\n    return 0;\n  }\n  leading_zeros = count_leading_zeros(input_value);\n  shifted_value = leading_zeros - 8;\n  result = ((is_negative | 0x4b000000) - 0x800000) + shifted_value * -0x800000;\n  if (7 < leading_zeros) {\n    leading_zeros = 0 << (shifted_value & 0xff);\n    is_negative = result + (input_value << (shifted_value & 0xff)) +\n            (0U >> (0x20 - shifted_value & 0xff)) + (uint)(0x7fffffff < leading_zeros);\n    if (leading_zeros == 0x80000000) {\n      is_negative = is_negative & 0xfffffffe;\n    }\n    return is_negative;\n  }\n  shifted_value = input_value << leading_zeros + 0x18;\n  is_negative = result + ((input_value >> (0x20 - (leading_zeros + 0x18) & 0xff)) - ((int)shifted_value >> 0x1f));\n  if ((shifted_value & 0x7fffffff) == 0) {\n    is_negative = is_negative & ~(shifted_value >> 0x1f);\n  }\n  return is_negative;\n}\n\n",
            "renaming": {
                "FUN_08000c10": "calculate_shifted_08000c10",
                "param_1": "input_value",
                "uVar1": "leading_zeros",
                "uVar2": "shifted_value",
                "uVar3": "is_negative",
                "iVar4": "result",
                "LZCOUNT(param_1)": "count_leading_zeros(input_value)"
            },
            "calling": [
                "FUN_080049cc",
                "FUN_08004ae0",
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cb8": {
            "entrypoint": "0x08000cb8",
            "current_name": "calculate_floating_point_08000cb8",
            "code": "\nuint calculateFloatingPoint_08000cb8(uint inputA,uint inputB,undefined4 inputC,uint inputD)\n\n{\n  longlong product;\n  uint result;\n  uint shiftA;\n  int shiftSum;\n  int shiftDiff;\n  uint productLower;\n  int normalizedShift;\n  uint tempResult;\n  bool isZeroShift;\n  bool isNegativeShift;\n  \n  shiftA = inputA >> 0x17 & 0xff;\n  isZeroShift = shiftA == 0;\n  if (!isZeroShift) {\n    inputD = inputB >> 0x17 & 0xff;\n    isZeroShift = inputD == 0;\n  }\n  if (!isZeroShift) {\n    isZeroShift = shiftA == 0xff;\n  }\n  if (!isZeroShift) {\n    isZeroShift = inputD == 0xff;\n  }\n  if (isZeroShift) {\n    inputD = inputB >> 0x17 & 0xff;\n    if (shiftA == 0xff || inputD == 0xff) {\n      isZeroShift = inputA == 0 || inputA == 0x80000000;\n      result = inputB;\n      if (inputA != 0 && inputA != 0x80000000) {\n        isZeroShift = inputB == 0;\n        result = inputA;\n      }\n      if (!isZeroShift) {\n        isZeroShift = inputB == 0x80000000;\n      }\n      tempResult = result;\n      if (((isZeroShift) || ((shiftA == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((inputD == 0xff && (tempResult = inputB, (inputB & 0x7fffff) != 0)))) {\n        return tempResult | 0x7fc00000;\n      }\n      result = result ^ inputB;\n      goto LAB_08000e08;\n    }\n    isZeroShift = (inputA & 0x7fffffff) == 0;\n    if (!isZeroShift) {\n      isZeroShift = (inputB & 0x7fffffff) == 0;\n    }\n    if (isZeroShift) {\n      return (inputA ^ inputB) & 0x80000000;\n    }\n    isZeroShift = shiftA == 0;\n    result = inputA & 0x80000000;\n    while( true ) {\n      if (isZeroShift) {\n        inputA = inputA << 1;\n        isZeroShift = (inputA & 0x800000) == 0;\n      }\n      if (!isZeroShift) break;\n      shiftA = shiftA - 1;\n    }\n    inputA = inputA | result;\n    isZeroShift = inputD == 0;\n    result = inputB & 0x80000000;\n    while( true ) {\n      if (isZeroShift) {\n        inputB = inputB << 1;\n        isZeroShift = (inputB & 0x800000) == 0;\n      }\n      if (!isZeroShift) break;\n      inputD = inputD - 1;\n    }\n    inputB = inputB | result;\n  }\n  shiftSum = shiftA + inputD;\n  tempResult = inputA ^ inputB;\n  shiftA = inputA << 9;\n  isZeroShift = shiftA == 0;\n  if (!isZeroShift) {\n    inputB = inputB << 9;\n    isZeroShift = inputB == 0;\n  }\n  if (isZeroShift) {\n    if (shiftA == 0) {\n      inputB = inputB << 9;\n    }\n    result = tempResult & 0x80000000 | inputA & 0x7fffff | inputB >> 9;\n    isNegativeShift = SBORROW4(shiftSum,0x7f);\n    shiftDiff = shiftSum + -0x7f;\n    isZeroShift = shiftDiff == 0;\n    normalizedShift = shiftDiff;\n    if (!isZeroShift && 0x7e < shiftSum) {\n      isNegativeShift = SBORROW4(0xff,shiftDiff);\n      normalizedShift = 0xff - shiftDiff;\n      isZeroShift = shiftDiff == 0xff;\n    }\n    if (!isZeroShift && normalizedShift < 0 == isNegativeShift) {\n      result = result | shiftDiff * 0x800000;\n    }\n    if (!isZeroShift && normalizedShift < 0 == isNegativeShift) {\n      return result;\n    }\n    result = result | 0x800000;\n    productLower = 0;\n    isNegativeShift = SBORROW4(shiftDiff,1);\n    tempResult = shiftSum - 0x80;\n    isZeroShift = tempResult == 0;\n    shiftA = tempResult;\n  }\n  else {\n    product = (ulonglong)(shiftA >> 5 | 0x8000000) * (ulonglong)(inputB >> 5 | 0x8000000);\n    productLower = (uint)product;\n    result = (uint)((ulonglong)product >> 0x20);\n    isZeroShift = result < 0x800000;\n    if (isZeroShift) {\n      result = result << 1;\n    }\n    if (isZeroShift) {\n      result = result | productLower >> 0x1f;\n      productLower = productLower << 1;\n    }\n    result = tempResult & 0x80000000 | result;\n    tempResult = (shiftSum + -0x7f) - (uint)isZeroShift;\n    isNegativeShift = SBORROW4(tempResult,0xfd);\n    isZeroShift = tempResult == 0xfd;\n    shiftA = tempResult - 0xfd;\n    if (tempResult < 0xfe) {\n      result = result + tempResult * 0x800000 + (uint)(0x7fffffff < productLower);\n      if (productLower == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isZeroShift || (int)shiftA < 0 != isNegativeShift) {\n    isZeroShift = (int)(tempResult + 0x19) < 0;\n    if (tempResult == 0xffffffe7 || isZeroShift != SCARRY4(tempResult,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (tempResult != 0xffffffe7 && isZeroShift == SCARRY4(tempResult,0x19)) {\n      shiftA = (result << 1) >> (-tempResult & 0xff);\n      tempResult = result << (tempResult + 0x20 & 0xff);\n      shiftA = ((uint)((result & 0x80000000) != 0) << 0x1f | shiftA >> 1) + (uint)((byte)shiftA & 1);\n      if ((productLower | tempResult << 1) == 0) {\n        shiftA = shiftA & ~(tempResult >> 0x1f);\n      }\n      return shiftA;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cb8": "calculate_floating_point_08000cb8",
                "param_1": "inputA",
                "param_2": "inputB",
                "param_3": "inputC",
                "param_4": "inputD",
                "lVar1": "product",
                "uVar2": "result",
                "uVar3": "shiftA",
                "iVar4": "shiftSum",
                "iVar5": "shiftDiff",
                "uVar6": "productLower",
                "iVar7": "normalizedShift",
                "uVar8": "tempResult",
                "bVar9": "isZeroShift",
                "bVar10": "isNegativeShift"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e20": {
            "entrypoint": "0x08000e20",
            "current_name": "floating_point_conversion_08000e20",
            "code": "\nuint floatingPointConversion_08000e20(uint inputValue1,uint inputValue2,undefined4 flags,uint roundingMode)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  int tempVar3;\n  uint tempVar4;\n  int tempVar5;\n  uint tempVar6;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  tempVar2 = inputValue1 >> 0x17 & 0xff;\n  flag1 = tempVar2 == 0;\n  if (!flag1) {\n    roundingMode = inputValue2 >> 0x17 & 0xff;\n    flag1 = roundingMode == 0;\n  }\n  if (!flag1) {\n    flag1 = tempVar2 == 0xff;\n  }\n  if (!flag1) {\n    flag1 = roundingMode == 0xff;\n  }\n  if (flag1) {\n    roundingMode = inputValue2 >> 0x17 & 0xff;\n    tempVar6 = inputValue1;\n    if (tempVar2 == 0xff) {\n      if (((inputValue1 & 0x7fffff) != 0) || (tempVar6 = inputValue2, roundingMode == 0xff)) {\nLAB_08000e16:\n        return tempVar6 | 0x7fc00000;\n      }\n    }\n    else {\n      if (roundingMode == 0xff) {\n        tempVar6 = inputValue2;\n        if ((inputValue2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (inputValue1 ^ inputValue2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      flag1 = (inputValue1 & 0x7fffffff) == 0;\n      if (!flag1) {\n        flag1 = (inputValue2 & 0x7fffffff) == 0;\n      }\n      if (!flag1) {\n        flag1 = tempVar2 == 0;\n        tempVar6 = inputValue1 & 0x80000000;\n        while( true ) {\n          if (flag1) {\n            inputValue1 = inputValue1 << 1;\n            flag1 = (inputValue1 & 0x800000) == 0;\n          }\n          if (!flag1) break;\n          tempVar2 = tempVar2 - 1;\n        }\n        inputValue1 = inputValue1 | tempVar6;\n        flag1 = roundingMode == 0;\n        tempVar6 = inputValue2 & 0x80000000;\n        while( true ) {\n          if (flag1) {\n            inputValue2 = inputValue2 << 1;\n            flag1 = (inputValue2 & 0x800000) == 0;\n          }\n          if (!flag1) break;\n          roundingMode = roundingMode - 1;\n        }\n        inputValue2 = inputValue2 | tempVar6;\n        goto LAB_08000e38;\n      }\n      if ((inputValue1 & 0x7fffffff) == 0) {\n        if ((inputValue2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    inputValue1 = inputValue1 ^ inputValue2;\n  }\n  else {\nLAB_08000e38:\n    tempVar3 = tempVar2 - roundingMode;\n    if (inputValue2 << 9 == 0) {\n      inputValue1 = (inputValue1 ^ inputValue2) & 0x80000000 | inputValue1 & 0x7fffff;\n      flag3 = SCARRY4(tempVar3,0x7f);\n      tempVar5 = tempVar3 + 0x7f;\n      flag1 = tempVar5 < 0;\n      flag2 = tempVar5 == 0;\n      if (!flag2 && flag1 == flag3) {\n        flag3 = SBORROW4(0xff,tempVar5);\n        flag1 = 0xff - tempVar5 < 0;\n        flag2 = tempVar5 == 0xff;\n      }\n      if (!flag2 && flag1 == flag3) {\n        inputValue1 = inputValue1 | tempVar5 * 0x800000;\n      }\n      if (!flag2 && flag1 == flag3) {\n        return inputValue1;\n      }\n      inputValue1 = inputValue1 | 0x800000;\n      tempVar2 = 0;\n      flag2 = SBORROW4(tempVar5,1);\n      tempVar4 = tempVar3 + 0x7e;\n      flag1 = tempVar4 == 0;\n      tempVar6 = tempVar4;\n    }\n    else {\n      tempVar1 = (inputValue2 << 9) >> 4 | 0x10000000;\n      tempVar2 = (inputValue1 << 9) >> 4 | 0x10000000;\n      inputValue1 = (inputValue1 ^ inputValue2) & 0x80000000;\n      flag1 = tempVar1 <= tempVar2;\n      if (!flag1) {\n        tempVar2 = tempVar2 << 1;\n      }\n      tempVar4 = tempVar3 + 0x7d + (uint)flag1;\n      tempVar6 = 0x800000;\n      do {\n        if (tempVar1 <= tempVar2) {\n          tempVar2 = tempVar2 - tempVar1;\n          inputValue1 = inputValue1 | tempVar6;\n        }\n        flag1 = tempVar1 >> 1 <= tempVar2;\n        if (flag1) {\n          tempVar2 = tempVar2 - (tempVar1 >> 1);\n        }\n        if (flag1) {\n          inputValue1 = inputValue1 | tempVar6 >> 1;\n        }\n        flag1 = tempVar1 >> 2 <= tempVar2;\n        if (flag1) {\n          tempVar2 = tempVar2 - (tempVar1 >> 2);\n        }\n        if (flag1) {\n          inputValue1 = inputValue1 | tempVar6 >> 2;\n        }\n        flag1 = tempVar1 >> 3 <= tempVar2;\n        if (flag1) {\n          tempVar2 = tempVar2 - (tempVar1 >> 3);\n        }\n        if (flag1) {\n          inputValue1 = inputValue1 | tempVar6 >> 3;\n        }\n        tempVar2 = tempVar2 * 0x10;\n        flag1 = tempVar2 == 0;\n        if (!flag1) {\n          tempVar6 = tempVar6 >> 4;\n          flag1 = tempVar6 == 0;\n        }\n      } while (!flag1);\n      flag2 = SBORROW4(tempVar4,0xfd);\n      flag1 = tempVar4 == 0xfd;\n      tempVar6 = tempVar4 - 0xfd;\n      if (tempVar4 < 0xfe) {\n        inputValue1 = inputValue1 + tempVar4 * 0x800000 + (uint)(tempVar1 <= tempVar2);\n        if (tempVar2 - tempVar1 == 0) {\n          inputValue1 = inputValue1 & 0xfffffffe;\n        }\n        return inputValue1;\n      }\n    }\n    if (flag1 || (int)tempVar6 < 0 != flag2) {\n      flag1 = (int)(tempVar4 + 0x19) < 0;\n      if (tempVar4 == 0xffffffe7 || flag1 != SCARRY4(tempVar4,0x19)) {\n        inputValue1 = inputValue1 & 0x80000000;\n      }\n      if (tempVar4 == 0xffffffe7 || flag1 != SCARRY4(tempVar4,0x19)) {\n        return inputValue1;\n      }\n      tempVar6 = (inputValue1 << 1) >> (-tempVar4 & 0xff);\n      tempVar4 = inputValue1 << (tempVar4 + 0x20 & 0xff);\n      tempVar6 = ((uint)((inputValue1 & 0x80000000) != 0) << 0x1f | tempVar6 >> 1) + (uint)((byte)tempVar6 & 1);\n      if ((tempVar2 | tempVar4 << 1) == 0) {\n        tempVar6 = tempVar6 & ~(tempVar4 >> 0x1f);\n      }\n      return tempVar6;\n    }\n  }\n  return inputValue1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e20": "floating_point_conversion_08000e20",
                "param_1": "inputValue1",
                "param_2": "inputValue2",
                "param_3": "flags",
                "param_4": "roundingMode",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "iVar3": "tempVar3",
                "uVar4": "tempVar4",
                "iVar5": "tempVar5",
                "uVar6": "tempVar6",
                "bVar7": "flag1",
                "bVar8": "flag2",
                "bVar9": "flag3"
            },
            "calling": [
                "FUN_080049cc",
                "FUN_08004d78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f68": {
            "entrypoint": "0x08000f68",
            "current_name": "check_overflow_08000f68",
            "code": "\nuint checkOverflow_08000f68(uint num1,uint num2)\n\n{\n  bool isOverflow;\n  uint num1Times2;\n  uint num2Times2;\n  uint combinedNum;\n  bool isZero;\n  \n  num1Times2 = num1 * 2;\n  num2Times2 = num2 * 2;\n  if (((int)num1Times2 >> 0x18 == -1 || (int)num2Times2 >> 0x18 == -1) &&\n     ((((int)num1Times2 >> 0x18 == -1 && ((num1 & 0x7fffff) != 0)) ||\n      (((int)num2Times2 >> 0x18 == -1 && ((num2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combinedNum = num1Times2 | num2 & 0x7fffffff;\n  isZero = combinedNum == 0;\n  if (!isZero) {\n    combinedNum = num1 ^ num2;\n    isZero = combinedNum == 0;\n  }\n  isOverflow = -1 < (int)combinedNum;\n  if (isOverflow) {\n    num1 = num1Times2 + num2 * -2;\n    isZero = num1 == 0;\n  }\n  if ((isOverflow && num2Times2 <= num1Times2) && !isZero) {\n    num1 = (int)num2 >> 0x1f;\n  }\n  if (!isOverflow || num2Times2 > num1Times2) {\n    num1 = ~((int)num2 >> 0x1f);\n  }\n  if (!isZero) {\n    num1 = num1 | 1;\n  }\n  return num1;\n}\n\n",
            "renaming": {
                "FUN_08000f68": "check_overflow_08000f68",
                "param_1": "num1",
                "param_2": "num2",
                "bVar1": "isOverflow",
                "uVar2": "num1Times2",
                "uVar3": "num2Times2",
                "uVar4": "combinedNum",
                "bVar5": "isZero"
            },
            "calling": [
                "FUN_08000fd0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fc8": {
            "entrypoint": "0x08000fc8",
            "current_name": "perform_function_08000fc8",
            "code": "\nvoid performFunction_08000fc8(undefined4 inputParam,undefined4 outputParam)\n\n{\n  FUN_08000fd0(outputParam,inputParam);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fc8": "perform_function_08000fc8",
                "param_1": "inputParam",
                "param_2": "outputParam"
            },
            "calling": [
                "FUN_08001030"
            ],
            "called": [
                "FUN_08000fd0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fd0": {
            "entrypoint": "0x08000fd0",
            "current_name": "concatenate_params_08000fd0",
            "code": "\nundefined8 concatenate_params_08000fd0(undefined4 first_param,undefined4 second_param)\n\n{\n  FUN_08000f68();\n  return CONCAT44(second_param,first_param);\n}\n\n",
            "renaming": {
                "FUN_08000fd0": "concatenate_params_08000fd0",
                "param_1": "first_param",
                "param_2": "second_param"
            },
            "calling": [
                "FUN_08000ff4",
                "FUN_08000fc8"
            ],
            "called": [
                "FUN_08000f68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ff4": {
            "entrypoint": "0x08000ff4",
            "current_name": "check_if_string_empty_08000ff4",
            "code": "\nbool check_if_string_empty_08000ff4(void)\n\n{\n  char input_char;\n  \n  FUN_08000fd0();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000ff4": "check_if_string_empty_08000ff4",
                "in_CY": "input_char"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000fd0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001030": {
            "entrypoint": "0x08001030",
            "current_name": "check_if_string_empty_08001030",
            "code": "\nbool check_if_string_empty_08001030(void)\n\n{\n  char input_string;\n  \n  FUN_08000fc8();\n  return input_string == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001030": "check_if_string_empty_08001030",
                "in_CY": "input_string"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000fc8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001044": {
            "entrypoint": "0x08001044",
            "current_name": "check_param_08001044",
            "code": "\nuint check_param_08001044(uint input)\n\n{\n  uint shift_value;\n  \n  if (((input & 0x80000000) != 0) || (input << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shift_value = 0x9e - ((input << 1) >> 0x18);\n  if (-1 < (int)shift_value) {\n    return (input << 8 | 0x80000000) >> (shift_value & 0xff);\n  }\n  if ((shift_value == 0xffffff9f) && ((input & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08001044": "check_param_08001044",
                "param_1": "input",
                "uVar1": "shift_value"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001084": {
            "entrypoint": "0x08001084",
            "current_name": "copy_memory_08001084",
            "code": "\nundefined4 * copyMemory_08001084(undefined4 *dest,undefined4 *src,uint size)\n\n{\n  undefined4 *destPtr;\n  undefined4 *destOffsetPtr;\n  undefined4 *srcOffsetPtr;\n  uint remainingSize;\n  uint copySize;\n  bool isRemaining;\n  \n  destOffsetPtr = dest;\n  if ((((uint)src | (uint)dest) & 3) != 0) {\n    if (size < 8) {\n      copySize = size - 4;\n      if (3 < size) {\n        do {\n          destPtr = src;\n          srcOffsetPtr = destOffsetPtr;\n          isRemaining = copySize != 0;\n          copySize = copySize - 1;\n          *(undefined *)srcOffsetPtr = *(undefined *)destPtr;\n          destOffsetPtr = (undefined4 *)((int)srcOffsetPtr + 1);\n          src = (undefined4 *)((int)destPtr + 1);\n        } while (isRemaining);\n        *(undefined *)(undefined4 *)((int)srcOffsetPtr + 1) =\n             *(undefined *)(undefined4 *)((int)destPtr + 1);\n        *(undefined *)((int)srcOffsetPtr + 2) = *(undefined *)((int)destPtr + 2);\n        *(undefined *)((int)srcOffsetPtr + 3) = *(undefined *)((int)destPtr + 3);\n        return dest;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)src & 3) != 0) && (((uint)dest & 3) != 0)) {\n      copySize = 4 - ((uint)dest & 3);\n      size = size - copySize;\n      destPtr = dest;\n      srcOffsetPtr = src;\n      if (((uint)dest & 1) != 0) {\n        srcOffsetPtr = (undefined4 *)((int)src + 1);\n        destPtr = (undefined4 *)((int)dest + 1);\n        *(undefined *)dest = *(undefined *)src;\n      }\n      destOffsetPtr = destPtr;\n      src = srcOffsetPtr;\n      if ((copySize & 2) != 0) {\n        src = (undefined4 *)((int)srcOffsetPtr + 2);\n        destOffsetPtr = (undefined4 *)((int)destPtr + 2);\n        *(undefined2 *)destPtr = *(undefined2 *)srcOffsetPtr;\n      }\n    }\n  }\n  while (0x3f < size) {\n    *destOffsetPtr = *src;\n    destOffsetPtr[1] = src[1];\n    destOffsetPtr[2] = src[2];\n    destOffsetPtr[3] = src[3];\n    destOffsetPtr[4] = src[4];\n    destOffsetPtr[5] = src[5];\n    destOffsetPtr[6] = src[6];\n    destOffsetPtr[7] = src[7];\n    destOffsetPtr[8] = src[8];\n    destOffsetPtr[9] = src[9];\n    destOffsetPtr[10] = src[10];\n    destOffsetPtr[0xb] = src[0xb];\n    destOffsetPtr[0xc] = src[0xc];\n    destOffsetPtr[0xd] = src[0xd];\n    destOffsetPtr[0xe] = src[0xe];\n    destOffsetPtr[0xf] = src[0xf];\n    destOffsetPtr = destOffsetPtr + 0x10;\n    src = src + 0x10;\n    size = size - 0x40;\n  }\n  remainingSize = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n      *destOffsetPtr = *src;\n      destOffsetPtr[1] = src[1];\n      destOffsetPtr[2] = src[2];\n      destOffsetPtr[3] = src[3];\n      destOffsetPtr = destOffsetPtr + 4;\n      src = src + 4;\n      isRemaining = 0xf < remainingSize;\n      remainingSize = remainingSize - 0x10;\n    } while (isRemaining);\n  }\n  copySize = remainingSize + 0xc;\n  srcOffsetPtr = destOffsetPtr;\n  destPtr = src;\n  if (0xfffffff3 < remainingSize) {\n    do {\n      src = destPtr + 1;\n      *srcOffsetPtr = *destPtr;\n      isRemaining = 3 < copySize;\n      copySize = copySize - 4;\n      destOffsetPtr = srcOffsetPtr + 1;\n      srcOffsetPtr = srcOffsetPtr + 1;\n      destPtr = src;\n    } while (isRemaining);\n  }\nLAB_08001108:\n  if (copySize + 4 != 0) {\n    destPtr = destOffsetPtr;\n    srcOffsetPtr = src;\n    if ((copySize & 1) != 0) {\n      srcOffsetPtr = (undefined4 *)((int)src + 1);\n      destPtr = (undefined4 *)((int)destOffsetPtr + 1);\n      *(undefined *)destOffsetPtr = *(undefined *)src;\n    }\n    if ((copySize + 4 & 2) != 0) {\n      *(undefined2 *)destPtr = *(undefined2 *)srcOffsetPtr;\n    }\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "puVar1": "destPtr",
                "puVar2": "destOffsetPtr",
                "puVar3": "srcOffsetPtr",
                "uVar4": "remainingSize",
                "uVar5": "copySize",
                "bVar6": "isRemaining"
            },
            "calling": [
                "FUN_080097cc",
                "FUN_080079e8",
                "FUN_08009120"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "check_params_08001170",
            "code": "\nundefined4 checkParams_08001170(uint input1,int input2,uint input3,int input4)\n\n{\n  if ((((input2 << 1) >> 0x15 != -1) || ((input1 | input2 << 0xc) == 0)) &&\n     (((input4 << 1) >> 0x15 != -1 || ((input3 | input4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001170": "check_params_08001170",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800119c": {
            "entrypoint": "0x0800119c",
            "current_name": "calculate_result_0800119c",
            "code": "\nuint calculateResult_0800119c(uint input1,uint input2)\n\n{\n  uint shiftedResult;\n  int shiftedValue;\n  uint adjustedResult;\n  \n  shiftedValue = input2 * 2 + 0x200000;\n  if (input2 * 2 < 0xffe00000) {\n    if (-1 < shiftedValue) {\n      return 0;\n    }\n    shiftedResult = shiftedValue >> 0x15;\n    adjustedResult = -shiftedResult - 0x3e1;\n    if (shiftedResult < 0xfffffc20 && adjustedResult != 0) {\n      shiftedResult = (input2 << 0xb | 0x80000000 | input1 >> 0x15) >> (adjustedResult & 0xff);\n      if ((input2 & 0x80000000) != 0) {\n        shiftedResult = -shiftedResult;\n      }\n      return shiftedResult;\n    }\n  }\n  else if ((input1 | input2 << 0xc) != 0) {\n    return 0;\n  }\n  input2 = input2 & 0x80000000;\n  if (input2 == 0) {\n    input2 = 0x7fffffff;\n  }\n  return input2;\n}\n\n",
            "renaming": {
                "FUN_0800119c": "calculate_result_0800119c",
                "param_1": "input1",
                "param_2": "input2",
                "iVar2": "shiftedValue",
                "uVar1": "shiftedResult",
                "uVar3": "adjustedResult"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011ec": {
            "entrypoint": "0x080011ec",
            "current_name": "check_params_and_return_value_080011ec",
            "code": "\nundefined8 checkParamsAndReturnValue_080011ec(int input1,int input2,int input3,int input4)\n\n{\n  undefined8 result;\n  \n  if ((input4 == 0) && (input3 == 0)) {\n    if (input2 != 0 || input1 != 0) {\n      input2 = -1;\n      input1 = -1;\n    }\n    return CONCAT44(input2,input1);\n  }\n  result = FUN_0800121c();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080011ec": "check_params_and_return_value_080011ec",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_0800121c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800121c": {
            "entrypoint": "0x0800121c",
            "current_name": "calculate_division_remainder_0800121c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 calculate_division_remainder_0800121c(uint dividend,uint dividend_high,uint divisor,uint divisor_high,uint *remainder)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  ulonglong product_low;\n  uint quotient_low;\n  uint quocdiv_low;\n  uint product_high;\n  int iVar5;\n  uint quotient_high;\n  uint quocdiv_high;\n  uint temp_high;\n  uint *remainder_ptr;\n  uint temp_low;\n  uint divisor_low;\n  uint temp_low2;\n  bool bVar13;\n  undefined8 new_remainder;\n  \n  if (divisor_high == 0) {\n    if (dividend_high < divisor) {\n      iVar5 = LZCOUNT(divisor);\n      quocdiv_high = divisor;\n      if (iVar5 != 0) {\n        quocdiv_high = divisor << iVar5;\n        dividend_high = dividend >> (0x20U - iVar5 & 0xff) | dividend_high << iVar5;\n        dividend = dividend << iVar5;\n      }\n      divisor_low = quocdiv_high >> 0x10;\n      temp_high = dividend_high / divisor_low;\n      temp_low = temp_high * (quocdiv_high & 0xffff);\n      quotient_high = dividend >> 0x10 | (dividend_high - divisor_low * temp_high) * 0x10000;\n      quocdiv_low = temp_high;\n      if (quotient_high <= temp_low && temp_low - quotient_high != 0) {\n        bVar13 = CARRY4(quocdiv_high,quotient_high);\n        quotient_high = quocdiv_high + quotient_high;\n        quocdiv_low = temp_high - 1;\n        if ((bVar13 == false) && (quotient_high <= temp_low && temp_low - quotient_high != 0)) {\n          quocdiv_low = temp_high - 2;\n          quotient_high = quotient_high + quocdiv_high;\n        }\n      }\n      quotient_low = (quotient_high - temp_low) / divisor_low;\n      product_high = quotient_low * (quocdiv_high & 0xffff);\n      temp_high = dividend & 0xffff | ((quotient_high - temp_low) - divisor_low * quotient_low) * 0x10000;\n      quotient_high = quotient_low;\n      if (temp_high <= product_high && product_high - temp_high != 0) {\n        bVar13 = CARRY4(quocdiv_high,temp_high);\n        temp_high = quocdiv_high + temp_high;\n        quotient_high = quotient_low - 1;\n        if ((bVar13 == false) && (temp_high <= product_high && product_high - temp_high != 0)) {\n          quotient_high = quotient_low - 2;\n          temp_high = temp_high + quocdiv_high;\n        }\n      }\n      quotient_high = quotient_high | quocdiv_low << 0x10;\n      remainder_ptr = (uint *)0x0;\n      temp_high = temp_high - product_high;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x8001302);\n        new_remainder = (*UNRECOVERED_JUMPTABLE)();\n        return new_remainder;\n      }\n      iVar5 = LZCOUNT(divisor);\n      if (iVar5 == 0) {\n        remainder_ptr = (uint *)0x1;\n        dividend_high = dividend_high - divisor;\n        divisor_low = divisor >> 0x10;\n        quotient_low = divisor & 0xffff;\n        quocdiv_high = divisor;\n      }\n      else {\n        quocdiv_high = divisor << iVar5;\n        quotient_high = dividend_high >> (0x20U - iVar5 & 0xff);\n        divisor_low = quocdiv_high >> 0x10;\n        temp_low = quotient_high / divisor_low;\n        quotient_low = quocdiv_high & 0xffff;\n        product_high = temp_low * quotient_low;\n        temp_high = dividend >> (0x20U - iVar5 & 0xff) | dividend_high << iVar5;\n        quocdiv_low = temp_high >> 0x10 | (quotient_high - divisor_low * temp_low) * 0x10000;\n        dividend = dividend << iVar5;\n        quotient_high = temp_low;\n        if (quocdiv_low <= product_high && product_high - quocdiv_low != 0) {\n          bVar13 = CARRY4(quocdiv_high,quocdiv_low);\n          quocdiv_low = quocdiv_high + quocdiv_low;\n          quotient_high = temp_low - 1;\n          if ((bVar13 == false) && (quocdiv_low <= product_high && product_high - quocdiv_low != 0)) {\n            quotient_high = temp_low - 2;\n            quocdiv_low = quocdiv_low + quocdiv_high;\n          }\n        }\n        temp_low = (quocdiv_low - product_high) / divisor_low;\n        temp_low2 = temp_low * quotient_low;\n        dividend_high = temp_high & 0xffff | ((quocdiv_low - product_high) - divisor_low * temp_low) * 0x10000;\n        quocdiv_low = temp_low;\n        if (dividend_high <= temp_low2 && temp_low2 - dividend_high != 0) {\n          bVar13 = CARRY4(quocdiv_high,dividend_high);\n          dividend_high = quocdiv_high + dividend_high;\n          quocdiv_low = temp_low - 1;\n          if ((bVar13 == false) && (dividend_high <= temp_low2 && temp_low2 - dividend_high != 0)) {\n            quocdiv_low = temp_low - 2;\n            dividend_high = dividend_high + quocdiv_high;\n          }\n        }\n        dividend_high = dividend_high - temp_low2;\n        remainder_ptr = (uint *)(quocdiv_low | quotient_high << 0x10);\n      }\n      temp_low = dividend_high / divisor_low;\n      quotient_high = quotient_low * temp_low;\n      temp_high = dividend >> 0x10 | (dividend_high - divisor_low * temp_low) * 0x10000;\n      quocdiv_low = temp_low;\n      if (temp_high <= quotient_high && quotient_high - temp_high != 0) {\n        bVar13 = CARRY4(quocdiv_high,temp_high);\n        temp_high = quocdiv_high + temp_high;\n        quocdiv_low = temp_low - 1;\n        if ((bVar13 == false) && (temp_high <= quotient_high && quotient_high - temp_high != 0)) {\n          quocdiv_low = temp_low - 2;\n          temp_high = temp_high + quocdiv_high;\n        }\n      }\n      temp_low = (temp_high - quotient_high) / divisor_low;\n      quotient_low = quotient_low * temp_low;\n      temp_high = dividend & 0xffff | ((temp_high - quotient_high) - divisor_low * temp_low) * 0x10000;\n      quotient_high = temp_low;\n      if (temp_high <= quotient_low && quotient_low - temp_high != 0) {\n        bVar13 = CARRY4(quocdiv_high,temp_high);\n        temp_high = quocdiv_high + temp_high;\n        quotient_high = temp_low - 1;\n        if ((bVar13 == false) && (temp_high <= quotient_low && quotient_low - temp_high != 0)) {\n          quotient_high = temp_low - 2;\n          temp_high = temp_high + quocdiv_high;\n        }\n      }\n      temp_high = temp_high - quotient_low;\n      quotient_high = quotient_high | quocdiv_low << 0x10;\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = temp_high >> LZCOUNT(divisor);\n      remainder[1] = 0;\n    }\n  }\n  else {\n    remainder_ptr = remainder;\n    if (dividend_high < divisor_high) {\n      if (remainder != (uint *)0x0) {\n        *remainder = dividend;\n        remainder[1] = dividend_high;\n        return 0;\n      }\n      quotient_high = 0;\n    }\n    else {\n      iVar5 = LZCOUNT(divisor_high);\n      if (iVar5 == 0) {\n        if ((divisor_high < dividend_high) || (divisor <= dividend)) {\n          bVar13 = dividend < divisor;\n          dividend = dividend - divisor;\n          dividend_high = (dividend_high - divisor_high) - (uint)bVar13;\n          quotient_high = 1;\n        }\n        else {\n          quotient_high = 0;\n        }\n        remainder_ptr = (uint *)0x0;\n        if (remainder != (uint *)0x0) {\n          *remainder = dividend;\n          remainder[1] = dividend_high;\n        }\n      }\n      else {\n        temp_high = 0x20 - iVar5;\n        quotient_low = divisor >> (temp_high & 0xff) | divisor_high << iVar5;\n        quocdiv_high = dividend_high >> (temp_high & 0xff);\n        product_high = quotient_low >> 0x10;\n        temp_low = quocdiv_high / product_high;\n        divisor_low = temp_low * (quotient_low & 0xffff);\n        quotient_high = dividend_high << iVar5 | dividend >> (temp_high & 0xff);\n        quocdiv_low = quotient_high >> 0x10 | (quocdiv_high - product_high * temp_low) * 0x10000;\n        dividend = dividend << iVar5;\n        quocdiv_high = temp_low;\n        if (quocdiv_low <= divisor_low && divisor_low - quocdiv_low != 0) {\n          bVar13 = CARRY4(quotient_low,quocdiv_low);\n          quocdiv_low = quotient_low + quocdiv_low;\n          quocdiv_high = temp_low - 1;\n          if ((bVar13 == false) && (quocdiv_low <= divisor_low && divisor_low - quocdiv_low != 0)) {\n            quocdiv_high = temp_low - 2;\n            quocdiv_low = quocdiv_low + quotient_low;\n          }\n        }\n        temp_low = (quocdiv_low - divisor_low) / product_high;\n        temp_low2 = temp_low * (quotient_low & 0xffff);\n        quocdiv_low = quotient_high & 0xffff | ((quocdiv_low - divisor_low) - product_high * temp_low) * 0x10000;\n        quotient_high = temp_low;\n        if (quocdiv_low <= temp_low2 && temp_low2 - quocdiv_low != 0) {\n          bVar13 = CARRY4(quotient_low,quocdiv_low);\n          quocdiv_low = quotient_low + quocdiv_low;\n          quotient_high = temp_low - 1;\n          if ((bVar13 == false) && (quocdiv_low <= temp_low2 && temp_low2 - quocdiv_low != 0)) {\n            quotient_high = temp_low - 2;\n            quocdiv_low = quocdiv_low + quotient_low;\n          }\n        }\n        quotient_high = quotient_high | quocdiv_high << 0x10;\n        product_low = (ulonglong)quotient_high * (ulonglong)(divisor << iVar5);\n        if (CONCAT44(quocdiv_low - temp_low2,dividend) < product_low) {\n          quotient_high = quotient_high - 1;\n          product_low = product_low - CONCAT44(quotient_low,divisor << iVar5);\n        }\n        if (remainder != (uint *)0x0) {\n          quocdiv_high = ((quocdiv_low - temp_low2) - (int)(product_low >> 0x20)) - (uint)(dividend < (uint)product_low);\n          *remainder = quocdiv_high << (temp_high & 0xff) | dividend - (uint)product_low >> iVar5;\n          remainder[1] = quocdiv_high >> iVar5;\n          remainder_ptr = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(remainder_ptr,quotient_high);\n}\n\n",
            "renaming": {
                "FUN_0800121c": "calculate_division_remainder_0800121c",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor",
                "param_4": "divisor_high",
                "param_5": "remainder",
                "uVar1": "product_low",
                "uVar2": "quotient_low",
                "uVar3": "quocdiv_low",
                "uVar4": "product_high",
                "uVar6": "quotient_high",
                "uVar7": "quocdiv_high",
                "uVar8": "temp_high",
                "uVar10": "temp_low",
                "uVar11": "divisor_low",
                "uVar12": "temp_low2",
                "puVar9": "remainder_ptr",
                "uVar14": "new_remainder"
            },
            "calling": [
                "FUN_080011ec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014f0": {
            "entrypoint": "0x080014f0",
            "current_name": "update_status_and_call_functions_080014f0",
            "code": "\n\n\nundefined4 updateStatusAndCallFunctions_080014f0(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  FUN_08001714(3);\n  FUN_0800151c(0xf);\n  FUNC_08002d8a();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080014f0": "update_status_and_call_functions_080014f0"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08001714",
                "FUN_08002d8a",
                "FUN_0800151c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800151c": {
            "entrypoint": "0x0800151c",
            "current_name": "check_and_set_param_0800151c",
            "code": "\nundefined4 checkAndSetParam_0800151c(uint inputParam)\n\n{\n  int result;\n  undefined4 returnValue;\n  \n  result = FUN_08001762((int)((ulonglong)DAT_20000018 / (1000 / (ulonglong)DAT_20000004)));\n  if (result == 0) {\n    if (inputParam < 0x10) {\n      FUN_0800172a(0xffffffff,inputParam,0);\n      returnValue = 0;\n      DAT_20000000 = inputParam;\n    }\n    else {\n      returnValue = 1;\n    }\n  }\n  else {\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800151c": "check_and_set_param_0800151c",
                "param_1": "inputParam",
                "iVar1": "result",
                "uVar2": "returnValue"
            },
            "calling": [
                "FUN_08003260",
                "FUN_080014f0"
            ],
            "called": [
                "FUN_08001762",
                "FUN_0800172a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "increment_dat_value_0800157c",
            "code": "\nvoid incrementDatValue_0800157c(void)\n\n{\n  DAT_20000a48 = DAT_20000a48 + (uint)DAT_20000004;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "increment_dat_value_0800157c"
            },
            "calling": [
                "FUN_08005704"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015a0": {
            "entrypoint": "0x080015a0",
            "current_name": "get_data_080015a0",
            "code": "\nundefined4 get_data_080015a0(void)\n\n{\n  return DAT_20000a48;\n}\n\n",
            "renaming": {
                "FUN_080015a0": "get_data_080015a0"
            },
            "calling": [
                "FUN_08002ca8",
                "FUN_08004436",
                "FUN_08003260",
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_08001ccc",
                "FUN_080027f4",
                "FUN_08002d98",
                "FUN_08002c2e",
                "FUN_08001f6c",
                "FUN_08002640",
                "FUN_08004f2c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b4": {
            "entrypoint": "0x080015b4",
            "current_name": "set_control_register_bits_080015b4",
            "code": "\n\n\nvoid setControlRegisterBits_080015b4(uint inputValue)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (inputValue & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b4": "set_control_register_bits_080015b4",
                "param_1": "inputValue"
            },
            "calling": [
                "FUN_08001714"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015fc": {
            "entrypoint": "0x080015fc",
            "current_name": "get_shifted_bits_080015fc",
            "code": "\n\n\nuint getShiftedBits_080015fc(void)\n\n{\n  return _DAT_e000ed0c >> 8 & 7;\n}\n\n",
            "renaming": {
                "FUN_080015fc": "get_shifted_bits_080015fc"
            },
            "calling": [
                "FUN_0800172a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001618": {
            "entrypoint": "0x08001618",
            "current_name": "update_memory_value_08001618",
            "code": "\nvoid updateMemoryValue_08001618(byte byteValue,uint byteToWrite)\n\n{\n  if ((char)byteValue < '\\0') {\n    *(char *)((byteValue & 0xf) + 0xe000ed14) = (char)((byteToWrite & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)byteValue + -0x1fff1c00) = (char)((byteToWrite & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001618": "update_memory_value_08001618",
                "param_1": "byteValue",
                "param_2": "byteToWrite"
            },
            "calling": [
                "FUN_080016d0",
                "FUN_0800172a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800166c": {
            "entrypoint": "0x0800166c",
            "current_name": "apply_bit_mask_0800166c",
            "code": "\nuint applyBitMask_0800166c(uint bitOffset,uint oldValue,uint bitMask)\n\n{\n  uint newValue;\n  \n  bitOffset = bitOffset & 7;\n  newValue = 7 - bitOffset;\n  if (3 < newValue) {\n    newValue = 4;\n  }\n  if (bitOffset + 4 < 7) {\n    bitOffset = 0;\n  }\n  else {\n    bitOffset = bitOffset - 3;\n  }\n  return bitMask & ~(-1 << (bitOffset & 0xff)) |\n         (~(-1 << (newValue & 0xff)) & oldValue) << (bitOffset & 0xff);\n}\n\n",
            "renaming": {
                "FUN_0800166c": "apply_bit_mask_0800166c",
                "param_1": "bitOffset",
                "param_2": "oldValue",
                "param_3": "bitMask",
                "uVar1": "newValue"
            },
            "calling": [
                "FUN_0800172a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016d0": {
            "entrypoint": "0x080016d0",
            "current_name": "check_and_update_value_080016d0",
            "code": "\n\n\nbool checkAndUpdateValue_080016d0(int value)\n\n{\n  bool isValueValid;\n  \n  isValueValid = value - 1U < 0x1000000;\n  if (isValueValid) {\n    _DAT_e000e014 = value + -1;\n    FUN_08001618(0xffffffff,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return !isValueValid;\n}\n\n",
            "renaming": {
                "FUN_080016d0": "check_and_update_value_080016d0",
                "param_1": "value",
                "bVar1": "isValueValid"
            },
            "calling": [
                "FUN_08001762"
            ],
            "called": [
                "FUN_08001618"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001714": {
            "entrypoint": "0x08001714",
            "current_name": "execute_initial_setup_08001714",
            "code": "\nvoid executeInitialSetup_08001714(undefined4 inputData)\n\n{\n  FUN_080015b4(inputData);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001714": "execute_initial_setup_08001714",
                "param_1": "inputData"
            },
            "calling": [
                "FUN_080014f0"
            ],
            "called": [
                "FUN_080015b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800172a": {
            "entrypoint": "0x0800172a",
            "current_name": "process_data_0800172a",
            "code": "\nvoid processData_0800172a(char inputChar,undefined4 param_2,undefined4 param_3)\n\n{\n  undefined4 result;\n  \n  result = FUN_080015fc();\n  result = FUN_0800166c(result,param_2,param_3);\n  FUN_08001618((int)inputChar,result);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800172a": "process_data_0800172a",
                "param_1": "inputChar",
                "uVar1": "result"
            },
            "calling": [
                "FUN_080052a0",
                "FUN_0800151c"
            ],
            "called": [
                "FUN_08001618",
                "FUN_0800166c",
                "FUN_080015fc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001762": {
            "entrypoint": "0x08001762",
            "current_name": "execute_function_08001762",
            "code": "\nundefined4 executeFunction_08001762(undefined4 input)\n\n{\n  undefined4 result;\n  \n  result = FUN_080016d0(input);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001762": "execute_function_08001762",
                "param_1": "input",
                "uVar1": "result"
            },
            "calling": [
                "FUN_080052a0",
                "FUN_0800151c"
            ],
            "called": [
                "FUN_080016d0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800177c": {
            "entrypoint": "0x0800177c",
            "current_name": "set_flag_if_equals_four_0800177c",
            "code": "\n\n\nvoid setFlagIfEqualsFour_0800177c(int value)\n\n{\n  if (value == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800177c": "set_flag_if_equals_four_0800177c",
                "param_1": "value"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017b4": {
            "entrypoint": "0x080017b4",
            "current_name": "initialize_application_080017b4",
            "code": "\nvoid initializeApplication_080017b4(void)\n\n{\n  FUN_08004f78(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080017b4": "initialize_application_080017b4"
            },
            "calling": [
                "FUN_08005704"
            ],
            "called": [
                "FUN_08004f78"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017c4": {
            "entrypoint": "0x080017c4",
            "current_name": "update_configuration_080017c4",
            "code": "\n\n\nvoid updateConfiguration_080017c4(uint *configVarPtr,uint *inputVarPtr)\n\n{\n  uint flag;\n  uint inputBit;\n  uint configValue;\n  uint *configVarPtrIter;\n  int configIndex;\n  uint newValue;\n  uint bitIndex;\n  \n  newValue = 0;\n  bitIndex = 0;\n  do {\n    if (0xf < bitIndex) {\n      return;\n    }\n    flag = 1 << (bitIndex & 0xff);\n    inputBit = *inputVarPtr & flag;\n    if (inputBit == flag) {\n      configValue = inputVarPtr[1];\n      if (configValue == 0x12) {\n        newValue = inputVarPtr[3] + 0xc;\n      }\n      else if (configValue < 0x13) {\n        if (configValue == 2) {\n          newValue = inputVarPtr[3] + 8;\n        }\n        else if (configValue < 3) {\n          if (configValue == 0) goto LAB_08001882;\n          if (configValue == 1) {\n            newValue = inputVarPtr[3];\n          }\n        }\n        else if (configValue == 3) {\n          newValue = 0;\n        }\n        else if (configValue == 0x11) {\n          newValue = inputVarPtr[3] + 4;\n        }\n      }\n      else if (configValue == 0x10210000) {\nLAB_08001882:\n        if (inputVarPtr[2] == 0) {\n          newValue = 4;\n        }\n        else if (inputVarPtr[2] == 1) {\n          newValue = 8;\n          configVarPtr[4] = flag;\n        }\n        else {\n          newValue = 8;\n          configVarPtr[5] = flag;\n        }\n      }\n      else if (configValue < 0x10210001) {\n        if ((configValue == 0x10110000) || (configValue == 0x10120000)) goto LAB_08001882;\n      }\n      else if (((configValue == 0x10310000) || (configValue == 0x10320000)) || (configValue == 0x10220000))\n      goto LAB_08001882;\n      if (inputBit < 0x100) {\n        flag = bitIndex << 2;\n        configVarPtrIter = configVarPtr;\n      }\n      else {\n        configVarPtrIter = configVarPtr + 1;\n        flag = (bitIndex - 8) * 4;\n      }\n      *configVarPtrIter = *configVarPtrIter & ~(0xf << (flag & 0xff)) | newValue << (flag & 0xff);\n      if ((inputVarPtr[1] & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        if (configVarPtr == (uint *)0x40010800) {\n          configIndex = 0;\n        }\n        else if (configVarPtr == (uint *)0x40010c00) {\n          configIndex = 1;\n        }\n        else if (configVarPtr == (uint *)0x40011000) {\n          configIndex = 2;\n        }\n        else if (configVarPtr == (uint *)0x40011400) {\n          configIndex = 3;\n        }\n        else {\n          configIndex = 4;\n        }\n        *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000) =\n             configIndex << ((bitIndex & 3) << 2) |\n             ~(0xf << ((bitIndex & 3) << 2)) & *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000);\n        if ((inputVarPtr[1] & 0x10000) == 0) {\n          _DAT_40010400 = ~inputBit & _DAT_40010400;\n        }\n        else {\n          _DAT_40010400 = inputBit | _DAT_40010400;\n        }\n        if ((inputVarPtr[1] & 0x20000) == 0) {\n          _DAT_40010404 = ~inputBit & _DAT_40010404;\n        }\n        else {\n          _DAT_40010404 = inputBit | _DAT_40010404;\n        }\n        if ((inputVarPtr[1] & 0x100000) == 0) {\n          _DAT_40010408 = ~inputBit & _DAT_40010408;\n        }\n        else {\n          _DAT_40010408 = inputBit | _DAT_40010408;\n        }\n        if ((inputVarPtr[1] & 0x200000) == 0) {\n          _DAT_4001040c = ~inputBit & _DAT_4001040c;\n        }\n        else {\n          _DAT_4001040c = inputBit | _DAT_4001040c;\n        }\n      }\n    }\n    bitIndex = bitIndex + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080017c4": "update_configuration_080017c4",
                "param_1": "configVarPtr",
                "param_2": "inputVarPtr",
                "uVar1": "flag",
                "uVar2": "inputBit",
                "uVar3": "configValue",
                "puVar4": "configVarPtrIter",
                "iVar5": "configIndex",
                "local_10": "newValue",
                "local_c": "bitIndex"
            },
            "calling": [
                "FUN_08005680",
                "FUN_080055f4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a80": {
            "entrypoint": "0x08001a80",
            "current_name": "set_param_value_08001a80",
            "code": "\nvoid setParamValue_08001a80(int dataPtr,ushort value,char isShifted)\n\n{\n  if (isShifted == '\\0') {\n    *(unsignedInt *)(dataPtr + 0x10) = (unsignedInt)value << 0x10;\n  }\n  else {\n    *(unsignedInt *)(dataPtr + 0x10) = (unsignedInt)value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a80": "set_param_value_08001a80",
                "param_1": "dataPtr",
                "param_2": "value",
                "param_3": "isShifted",
                "uint": "unsignedInt"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_080055f4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "calculate_params_08001ab0",
            "code": "\nundefined4 calculateParams_08001ab0(uint **params)\n\n{\n  uint result;\n  char flag;\n  undefined4 returnValue;\n  uint temp;\n  bool isZero;\n  \n  if (params == (uint **)0x0) {\n    returnValue = 1;\n  }\n  else {\n    if (*(char *)((int)params + 0x3d) == '\\0') {\n      *(undefined *)(params + 0xf) = 0;\n      FUNC_08001cb8(params);\n    }\n    *(undefined *)((int)params + 0x3d) = 0x24;\n    **params = **params & 0xfffffffe;\n    result = FUN_08003518();\n    if (params[1] < (uint *)0x186a1) {\n      temp = result;\n      if (result < 2000000) {\n        temp = 1;\n      }\n      flag = (char)temp;\n      if (1999999 < result) {\n        flag = '\\0';\n      }\n    }\n    else {\n      temp = result;\n      if (result < 4000000) {\n        temp = 1;\n      }\n      flag = (char)temp;\n      if (3999999 < result) {\n        flag = '\\0';\n      }\n    }\n    if (flag == '\\0') {\n      temp = result / 1000000;\n      (*params)[1] = temp;\n      if ((uint *)0x186a0 < params[1]) {\n        temp = (temp * 300) / 1000;\n      }\n      (*params)[8] = temp + 1;\n      if (params[1] < (uint *)0x186a1) {\n        result = (result - 1) / (uint)((int)params[1] << 1) + 1 & 0xfff;\n        if (result < 4) {\n          result = 4;\n        }\n      }\n      else {\n        if (params[2] == (uint *)0x0) {\n          temp = (result - 1) / (uint)((int)params[1] * 3) + 1 & 0xfff;\n          isZero = temp == 0;\n          if (isZero) {\n            temp = 1;\n          }\n          flag = (char)temp;\n          if (!isZero) {\n            flag = '\\0';\n          }\n        }\n        else {\n          temp = (result - 1) / (uint)((int)params[1] * 0x19) + 1 & 0xfff;\n          isZero = temp == 0;\n          if (isZero) {\n            temp = 1;\n          }\n          flag = (char)temp;\n          if (!isZero) {\n            flag = '\\0';\n          }\n        }\n        if (flag == '\\0') {\n          if (params[2] == (uint *)0x0) {\n            result = (result - 1) / (uint)((int)params[1] * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            result = (result - 1) / (uint)((int)params[1] * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          result = 1;\n        }\n      }\n      (*params)[7] = result;\n      **params = (uint)params[8] | (uint)params[7];\n      (*params)[2] = (uint)params[3] | (uint)params[4];\n      (*params)[3] = (uint)params[6] | (uint)params[5];\n      **params = **params | 1;\n      params[0x10] = (uint *)0x0;\n      *(undefined *)((int)params + 0x3d) = 0x20;\n      params[0xc] = (uint *)0x0;\n      *(undefined *)((int)params + 0x3e) = 0;\n      returnValue = 0;\n    }\n    else {\n      returnValue = 1;\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "calculate_params_08001ab0",
                "param_1": "params",
                "uVar1": "result",
                "cVar2": "flag",
                "uVar3": "returnValue",
                "uVar4": "temp",
                "bVar5": "isZero"
            },
            "calling": [
                "FUN_08005348"
            ],
            "called": [
                "FUN_08003518",
                "FUN_08001cb8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cb8": {
            "entrypoint": "0x08001cb8",
            "current_name": "FUNC_08001cb8",
            "code": "\nvoid FUNC_08001cb8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cb8": "FUNC_08001cb8"
            },
            "calling": [
                "FUN_08001ab0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ccc": {
            "entrypoint": "0x08001ccc",
            "current_name": "process_data_08001ccc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001d5e) */\n/* WARNING: Removing unreachable block (ram,0x08001d70) */\n/* WARNING: Removing unreachable block (ram,0x08001d72) */\n/* WARNING: Removing unreachable block (ram,0x08001d74) */\n\nundefined4\nprocessData_08001ccc(uint **data,undefined2 param2,undefined2 param3,undefined2 param4,uint *param5,\n            undefined2 param6,undefined4 param7)\n\n{\n  int result1;\n  int result2;\n  undefined4 returnValue;\n  uint *pointerVar;\n  \n  result1 = FUN_080015a0();\n  if (*(char *)((int)data + 0x3d) == ' ') {\n    do {\n      if ((~(*data)[6] & 2) != 0) {\n        result2 = 0;\n        goto LAB_08001d9c;\n      }\n      result2 = FUN_080015a0();\n    } while ((uint)(result2 - result1) < 0x1a);\n    data[0xc] = (uint *)0x0;\n    *(undefined *)((int)data + 0x3d) = 0x20;\n    *(undefined *)((int)data + 0x3e) = 0;\n    *(undefined *)(data + 0xf) = 0;\n    result2 = 3;\nLAB_08001d9c:\n    if (result2 == 0) {\n      if (*(char *)(data + 0xf) == '\\x01') {\n        returnValue = 2;\n      }\n      else {\n        *(undefined *)(data + 0xf) = 1;\n        if ((**data & 1) != 1) {\n          **data = **data | 1;\n        }\n        **data = **data & 0xfffff7ff;\n        *(undefined *)((int)data + 0x3d) = 0x21;\n        *(undefined *)((int)data + 0x3e) = 0x40;\n        data[0x10] = (uint *)0x0;\n        data[9] = param5;\n        *(undefined2 *)((int)data + 0x2a) = param6;\n        data[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(data + 10) = *(undefined2 *)((int)data + 0x2a);\n        result2 = FUN_08002640(data,param2,param3,param4,param7,result1);\n        if (result2 == 0) {\n          while (*(short *)(data + 10) != 0) {\n            result2 = FUN_08002bb4(data,param7,result1);\n            if (result2 != 0) {\n              if (data[0x10] == (uint *)0x4) {\n                **data = **data | 0x200;\n                return 1;\n              }\n              return 3;\n            }\n            pointerVar = data[9];\n            data[9] = (uint *)((int)pointerVar + 1);\n            (*data)[4] = (uint)*(byte *)pointerVar;\n            *(short *)(data + 10) = *(short *)(data + 10) + -1;\n            *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n            if ((((*data)[5] & 4) == 4) && (*(short *)(data + 10) != 0)) {\n              pointerVar = data[9];\n              data[9] = (uint *)((int)pointerVar + 1);\n              (*data)[4] = (uint)*(byte *)pointerVar;\n              *(short *)(data + 10) = *(short *)(data + 10) + -1;\n              *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n            }\n          }\n          result1 = FUN_08002c2e(data,param7,result1);\n          if (result1 == 0) {\n            **data = **data | 0x200;\n            *(undefined *)((int)data + 0x3d) = 0x20;\n            *(undefined *)((int)data + 0x3e) = 0;\n            *(undefined *)(data + 0xf) = 0;\n            returnValue = 0;\n          }\n          else if (data[0x10] == (uint *)0x4) {\n            **data = **data | 0x200;\n            returnValue = 1;\n          }\n          else {\n            returnValue = 3;\n          }\n        }\n        else if (data[0x10] == (uint *)0x4) {\n          *(undefined *)(data + 0xf) = 0;\n          returnValue = 1;\n        }\n        else {\n          *(undefined *)(data + 0xf) = 0;\n          returnValue = 3;\n        }\n      }\n    }\n    else {\n      returnValue = 2;\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08001ccc": "process_data_08001ccc",
                "param_1": "data",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "param_7": "param7",
                "iVar1": "result1",
                "iVar2": "result2",
                "uVar3": "returnValue",
                "puVar4": "pointerVar"
            },
            "calling": [
                "FUN_08004ea4"
            ],
            "called": [
                "FUN_08002bb4",
                "FUN_080015a0",
                "FUN_08002c2e",
                "FUN_08002640"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f6c": {
            "entrypoint": "0x08001f6c",
            "current_name": "process_signal_08001f6c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080024e6) */\n/* WARNING: Removing unreachable block (ram,0x080024f8) */\n/* WARNING: Removing unreachable block (ram,0x080024fa) */\n/* WARNING: Removing unreachable block (ram,0x080024fc) */\n/* WARNING: Removing unreachable block (ram,0x08002000) */\n/* WARNING: Removing unreachable block (ram,0x08002012) */\n/* WARNING: Removing unreachable block (ram,0x08002014) */\n/* WARNING: Removing unreachable block (ram,0x08002016) */\n/* WARNING: Removing unreachable block (ram,0x080023f4) */\n/* WARNING: Removing unreachable block (ram,0x08002406) */\n/* WARNING: Removing unreachable block (ram,0x08002408) */\n/* WARNING: Removing unreachable block (ram,0x0800240a) */\n/* WARNING: Removing unreachable block (ram,0x080022d6) */\n/* WARNING: Removing unreachable block (ram,0x080022e8) */\n/* WARNING: Removing unreachable block (ram,0x080022ea) */\n/* WARNING: Removing unreachable block (ram,0x080022ec) */\n\nundefined4\nprocessSignal_08001f6c(uint **signalData,undefined2 param1,undefined2 param2,undefined2 param3,uint *buffer,\n            undefined2 param4,uint param5)\n\n{\n  int initialValue;\n  uint value;\n  int errorCode;\n  undefined4 result;\n  uint *ptr;\n  \n  initialValue = FUN_080015a0();\n  if (*(char *)((int)signalData + 0x3d) == ' ') {\n    do {\n      if ((~(*signalData)[6] & 2) != 0) {\n        errorCode = 0;\n        goto label1;\n      }\n      errorCode = FUN_080015a0();\n    } while ((uint)(errorCode - initialValue) < 0x1a);\n    signalData[0xc] = (uint *)0x0;\n    *(undefined *)((int)signalData + 0x3d) = 0x20;\n    *(undefined *)((int)signalData + 0x3e) = 0;\n    *(undefined *)(signalData + 0xf) = 0;\n    errorCode = 3;\nlabel1:\n    if (errorCode == 0) {\n      if (*(char *)(signalData + 0xf) == '\\x01') {\n        result = 2;\n      }\n      else {\n        *(undefined *)(signalData + 0xf) = 1;\n        if ((**signalData & 1) != 1) {\n          **signalData = **signalData | 1;\n        }\n        **signalData = **signalData & 0xfffff7ff;\n        *(undefined *)((int)signalData + 0x3d) = 0x22;\n        *(undefined *)((int)signalData + 0x3e) = 0x40;\n        signalData[0x10] = (uint *)0x0;\n        signalData[9] = buffer;\n        *(undefined2 *)((int)signalData + 0x2a) = param4;\n        signalData[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(signalData + 10) = *(undefined2 *)((int)signalData + 0x2a);\n        errorCode = FUN_080027f4(signalData,param1,param2,param3,param5,initialValue);\n        if (errorCode == 0) {\n          if (*(short *)(signalData + 10) == 0) {\n            **signalData = **signalData | 0x200;\n          }\n          else if (*(short *)(signalData + 10) == 1) {\n            **signalData = **signalData & 0xfffffbff;\n            disableIRQinterrupts();\n            **signalData = **signalData | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (*(short *)(signalData + 10) == 2) {\n            **signalData = **signalData | 0x800;\n            disableIRQinterrupts();\n            **signalData = **signalData & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            **signalData = **signalData | 0x400;\n          }\n          while (*(short *)(signalData + 10) != 0) {\n            if (*(ushort *)(signalData + 10) < 4) {\n              if (*(short *)(signalData + 10) == 1) {\n                errorCode = FUN_08002ca8(signalData,param5,initialValue);\n                if (errorCode != 0) {\n                  if (signalData[0x10] == (uint *)0x20) {\n                    return 3;\n                  }\n                  return 1;\n                }\n                value = (*signalData)[4];\n                ptr = signalData[9];\n                signalData[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)value;\n                *(short *)(signalData + 10) = *(short *)(signalData + 10) + -1;\n                *(short *)((int)signalData + 0x2a) = *(short *)((int)signalData + 0x2a) + -1;\n              }\n              else if (*(short *)(signalData + 10) == 2) {\n                do {\n                  if ((~(*signalData)[5] & 4) == 0) {\n                    errorCode = 0;\n                    goto label2;\n                  }\n                } while ((param5 == 0xffffffff) ||\n                        ((param5 != 0 && (errorCode = FUN_080015a0(), (uint)(errorCode - initialValue) <= param5)\n                         )));\n                signalData[0xc] = (uint *)0x0;\n                *(undefined *)((int)signalData + 0x3d) = 0x20;\n                *(undefined *)((int)signalData + 0x3e) = 0;\n                *(undefined *)(signalData + 0xf) = 0;\n                errorCode = 3;\nlabel2:\n                if (errorCode != 0) {\n                  return 3;\n                }\n                disableIRQinterrupts();\n                **signalData = **signalData | 0x200;\n                value = (*signalData)[4];\n                ptr = signalData[9];\n                signalData[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)value;\n                *(short *)(signalData + 10) = *(short *)(signalData + 10) + -1;\n                *(short *)((int)signalData + 0x2a) = *(short *)((int)signalData + 0x2a) + -1;\n                enableIRQinterrupts();\n                value = (*signalData)[4];\n                ptr = signalData[9];\n                signalData[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)value;\n                *(short *)(signalData + 10) = *(short *)(signalData + 10) + -1;\n                *(short *)((int)signalData + 0x2a) = *(short *)((int)signalData + 0x2a) + -1;\n              }\n              else {\n                do {\n                  if ((~(*signalData)[5] & 4) == 0) {\n                    errorCode = 0;\n                    goto label3;\n                  }\n                } while ((param5 == 0xffffffff) ||\n                        ((param5 != 0 && (errorCode = FUN_080015a0(), (uint)(errorCode - initialValue) <= param5)\n                         )));\n                signalData[0xc] = (uint *)0x0;\n                *(undefined *)((int)signalData + 0x3d) = 0x20;\n                *(undefined *)((int)signalData + 0x3e) = 0;\n                *(undefined *)(signalData + 0xf) = 0;\n                errorCode = 3;\nlabel3:\n                if (errorCode != 0) {\n                  return 3;\n                }\n                **signalData = **signalData & 0xfffffbff;\n                disableIRQinterrupts();\n                value = (*signalData)[4];\n                ptr = signalData[9];\n                signalData[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)value;\n                *(short *)(signalData + 10) = *(short *)(signalData + 10) + -1;\n                *(short *)((int)signalData + 0x2a) = *(short *)((int)signalData + 0x2a) + -1;\n                do {\n                  if ((~(*signalData)[5] & 4) == 0) {\n                    errorCode = 0;\n                    goto label4;\n                  }\n                } while ((param5 == 0xffffffff) ||\n                        ((param5 != 0 && (errorCode = FUN_080015a0(), (uint)(errorCode - initialValue) <= param5)\n                         )));\n                signalData[0xc] = (uint *)0x0;\n                *(undefined *)((int)signalData + 0x3d) = 0x20;\n                *(undefined *)((int)signalData + 0x3e) = 0;\n                *(undefined *)(signalData + 0xf) = 0;\n                errorCode = 3;\nlabel4:\n                if (errorCode != 0) {\n                  return 3;\n                }\n                **signalData = **signalData | 0x200;\n                value = (*signalData)[4];\n                ptr = signalData[9];\n                signalData[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)value;\n                *(short *)(signalData + 10) = *(short *)(signalData + 10) + -1;\n                *(short *)((int)signalData + 0x2a) = *(short *)((int)signalData + 0x2a) + -1;\n                enableIRQinterrupts();\n                value = (*signalData)[4];\n                ptr = signalData[9];\n                signalData[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)value;\n                *(short *)(signalData + 10) = *(short *)(signalData + 10) + -1;\n                *(short *)((int)signalData + 0x2a) = *(short *)((int)signalData + 0x2a) + -1;\n              }\n            }\n            else {\n              errorCode = FUN_08002ca8(signalData,param5,initialValue);\n              if (errorCode != 0) {\n                if (signalData[0x10] == (uint *)0x20) {\n                  return 3;\n                }\n                return 1;\n              }\n              value = (*signalData)[4];\n              ptr = signalData[9];\n              signalData[9] = (uint *)((int)ptr + 1);\n              *(char *)ptr = (char)value;\n              *(short *)(signalData + 10) = *(short *)(signalData + 10) + -1;\n              *(short *)((int)signalData + 0x2a) = *(short *)((int)signalData + 0x2a) + -1;\n              if (((*signalData)[5] & 4) == 4) {\n                value = (*signalData)[4];\n                ptr = signalData[9];\n                signalData[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)value;\n                *(short *)(signalData + 10) = *(short *)(signalData + 10) + -1;\n                *(short *)((int)signalData + 0x2a) = *(short *)((int)signalData + 0x2a) + -1;\n              }\n            }\n          }\n          *(undefined *)((int)signalData + 0x3d) = 0x20;\n          *(undefined *)((int)signalData + 0x3e) = 0;\n          *(undefined *)(signalData + 0xf) = 0;\n          result = 0;\n        }\n        else if (signalData[0x10] == (uint *)0x4) {\n          *(undefined *)(signalData + 0xf) = 0;\n          result = 1;\n        }\n        else {\n          *(undefined *)(signalData + 0xf) = 0;\n          result = 3;\n        }\n      }\n    }\n    else {\n      result = 2;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001f6c": "process_signal_08001f6c",
                "param_1": "signalData",
                "param_2": "param1",
                "param_3": "param2",
                "param_4": "param3",
                "param_5": "buffer",
                "param_6": "param4",
                "param_7": "param5",
                "iVar1": "initialValue",
                "uVar2": "value",
                "iVar3": "errorCode",
                "uVar4": "result",
                "puVar5": "ptr",
                "LAB_08002040": "label1",
                "LAB_080022fa": "label2",
                "LAB_08002418": "label3",
                "LAB_0800250a": "label4"
            },
            "calling": [
                "FUN_08004ee8"
            ],
            "called": [
                "FUN_08002ca8",
                "FUN_080015a0",
                "FUN_080027f4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002640": {
            "entrypoint": "0x08002640",
            "current_name": "update_flags_and_check_condition_08002640",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nundefined4\nupdateFlagsAndCheckCondition_08002640(uint **parameters,byte flag,undefined2 value,short mode,uint limit,int threshold)\n\n{\n  int result;\n  undefined4 returnValue;\n  \n  **parameters = **parameters | 0x100;\n  do {\n    if ((~(*parameters)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_0800270a;\n    }\n  } while ((limit == 0xffffffff) ||\n          ((limit != 0 && (result = FUN_080015a0(), (uint)(result - threshold) <= limit))));\n  parameters[0xc] = (uint *)0x0;\n  *(undefined *)((int)parameters + 0x3d) = 0x20;\n  *(undefined *)((int)parameters + 0x3e) = 0;\n  *(undefined *)(parameters + 0xf) = 0;\n  result = 3;\nLAB_0800270a:\n  if (result == 0) {\n    (*parameters)[4] = flag & 0xfe;\n    result = FUN_08002ad8(parameters,0x10002,limit,threshold);\n    if (result == 0) {\n      result = FUN_08002bb4(parameters,limit,threshold,(*parameters)[6]);\n      if (result == 0) {\n        if (mode == 1) {\n          (*parameters)[4] = (uint)(byte)value;\n        }\n        else {\n          (*parameters)[4] = (uint)(byte)((ushort)value >> 8);\n          result = FUN_08002bb4(parameters,limit,threshold);\n          if (result != 0) {\n            if (parameters[0x10] == (uint *)0x4) {\n              **parameters = **parameters | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*parameters)[4] = (uint)(byte)value;\n        }\n        returnValue = 0;\n      }\n      else if (parameters[0x10] == (uint *)0x4) {\n        **parameters = **parameters | 0x200;\n        returnValue = 1;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n    else if (parameters[0x10] == (uint *)0x4) {\n      returnValue = 1;\n    }\n    else {\n      returnValue = 3;\n    }\n  }\n  else {\n    returnValue = 3;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08002640": "update_flags_and_check_condition_08002640",
                "param_1": "parameters",
                "param_2": "flag",
                "param_3": "value",
                "param_4": "mode",
                "param_5": "limit",
                "param_6": "threshold",
                "iVar1": "result",
                "uVar2": "returnValue"
            },
            "calling": [
                "FUN_08001ccc"
            ],
            "called": [
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f4": {
            "entrypoint": "0x080027f4",
            "current_name": "handle_data_processing_080027f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nundefined4\nhandleDataProcessing_080027f4(uint **pData,byte byteVal,undefined2 halfWordVal,short shortVal,uint uintVal,int intVal)\n\n{\n  int result;\n  undefined4 returnValue;\n  \n  **pData = **pData | 0x400;\n  **pData = **pData | 0x100;\n  do {\n    if ((~(*pData)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_080028d2;\n    }\n  } while ((uintVal == 0xffffffff) ||\n          ((uintVal != 0 && (result = FUN_080015a0(), (uint)(result - intVal) <= uintVal))));\n  pData[0xc] = (uint *)0x0;\n  *(undefined *)((int)pData + 0x3d) = 0x20;\n  *(undefined *)((int)pData + 0x3e) = 0;\n  *(undefined *)(pData + 0xf) = 0;\n  result = 3;\nLAB_080028d2:\n  if (result == 0) {\n    (*pData)[4] = byteVal & 0xfe;\n    result = FUN_08002ad8(pData,0x10002,uintVal,intVal);\n    if (result == 0) {\n      result = FUN_08002bb4(pData,uintVal,intVal,(*pData)[6]);\n      if (result == 0) {\n        if (shortVal == 1) {\n          (*pData)[4] = (uint)(byte)halfWordVal;\n        }\n        else {\n          (*pData)[4] = (uint)(byte)((ushort)halfWordVal >> 8);\n          result = FUN_08002bb4(pData,uintVal,intVal);\n          if (result != 0) {\n            if (pData[0x10] == (uint *)0x4) {\n              **pData = **pData | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*pData)[4] = (uint)(byte)halfWordVal;\n        }\n        result = FUN_08002bb4(pData,uintVal,intVal);\n        if (result == 0) {\n          **pData = **pData | 0x100;\n          do {\n            if ((~(*pData)[5] & 1) == 0) {\n              result = 0;\n              goto LAB_08002a90;\n            }\n          } while ((uintVal == 0xffffffff) ||\n                  ((uintVal != 0 && (result = FUN_080015a0(), (uint)(result - intVal) <= uintVal))));\n          pData[0xc] = (uint *)0x0;\n          *(undefined *)((int)pData + 0x3d) = 0x20;\n          *(undefined *)((int)pData + 0x3e) = 0;\n          *(undefined *)(pData + 0xf) = 0;\n          result = 3;\nLAB_08002a90:\n          if (result == 0) {\n            (*pData)[4] = (uint)(byteVal | 1);\n            result = FUN_08002ad8(pData,0x10002,uintVal,intVal);\n            if (result == 0) {\n              returnValue = 0;\n            }\n            else if (pData[0x10] == (uint *)0x4) {\n              returnValue = 1;\n            }\n            else {\n              returnValue = 3;\n            }\n          }\n          else {\n            returnValue = 3;\n          }\n        }\n        else if (pData[0x10] == (uint *)0x4) {\n          **pData = **pData | 0x200;\n          returnValue = 1;\n        }\n        else {\n          returnValue = 3;\n        }\n      }\n      else if (pData[0x10] == (uint *)0x4) {\n        **pData = **pData | 0x200;\n        returnValue = 1;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n    else if (pData[0x10] == (uint *)0x4) {\n      returnValue = 1;\n    }\n    else {\n      returnValue = 3;\n    }\n  }\n  else {\n    returnValue = 3;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080027f4": "handle_data_processing_080027f4",
                "param_1": "pData",
                "param_2": "byteVal",
                "param_3": "halfWordVal",
                "param_4": "shortVal",
                "param_5": "uintVal",
                "param_6": "intVal",
                "iVar1": "result",
                "uVar2": "returnValue"
            },
            "calling": [
                "FUN_08001f6c"
            ],
            "called": [
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "check_and_update_flags_08002ad8",
            "code": "\nundefined4 check_and_update_flags_08002ad8(uint **ptr_arr,uint flag,uint limit,int comp_value)\n\n{\n  int comp_result;\n  char updated_flag;\n  uint updated_flag_val;\n  bool flag_updated;\n  \n  do {\n    if ((flag >> 0x10 & 0xff) == 1) {\n      updated_flag_val = flag & ~(*ptr_arr)[5] & 0xffff;\n      flag_updated = updated_flag_val != 0;\n      if (flag_updated) {\n        updated_flag_val = 1;\n      }\n      updated_flag = (char)updated_flag_val;\n      if (!flag_updated) {\n        updated_flag = '\\0';\n      }\n    }\n    else {\n      updated_flag_val = flag & ~(*ptr_arr)[6] & 0xffff;\n      flag_updated = updated_flag_val != 0;\n      if (flag_updated) {\n        updated_flag_val = 1;\n      }\n      updated_flag = (char)updated_flag_val;\n      if (!flag_updated) {\n        updated_flag = '\\0';\n      }\n    }\n    if (updated_flag == '\\0') {\n      return 0;\n    }\n    if (((*ptr_arr)[5] & 0x400) == 0x400) {\n      **ptr_arr = **ptr_arr | 0x200;\n      (*ptr_arr)[5] = 0xfffffbff;\n      ptr_arr[0x10] = (uint *)0x4;\n      ptr_arr[0xc] = (uint *)0x0;\n      *(undefined *)((int)ptr_arr + 0x3d) = 0x20;\n      *(undefined *)(ptr_arr + 0xf) = 0;\n      return 1;\n    }\n  } while ((limit == 0xffffffff) ||\n          ((limit != 0 && (comp_result = FUN_080015a0(), (uint)(comp_result - comp_value) <= limit))));\n  ptr_arr[0xc] = (uint *)0x0;\n  *(undefined *)((int)ptr_arr + 0x3d) = 0x20;\n  *(undefined *)(ptr_arr + 0xf) = 0;\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "check_and_update_flags_08002ad8",
                "param_1": "ptr_arr",
                "param_2": "flag",
                "param_3": "limit",
                "param_4": "comp_value",
                "iVar1": "comp_result",
                "cVar2": "updated_flag",
                "uVar3": "updated_flag_val",
                "bVar4": "flag_updated"
            },
            "calling": [
                "FUN_080027f4",
                "FUN_08002640"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bb4": {
            "entrypoint": "0x08002bb4",
            "current_name": "check_permissions_08002bb4",
            "code": "\nundefined4 checkPermissions_08002bb4(int *ptr,uint flags,int offset)\n\n{\n  int result;\n  \n  while( true ) {\n    if ((*(uint *)(*ptr + 0x14) & 0x80) == 0x80) {\n      return 0;\n    }\n    result = FUN_08002d3c(ptr);\n    if (result != 0) break;\n    if ((flags != 0xffffffff) &&\n       ((flags == 0 || (result = FUN_080015a0(), flags < (uint)(result - offset))))) {\n      ptr[0x10] = ptr[0x10] | 0x20;\n      ptr[0xc] = 0;\n      *(undefined *)((int)ptr + 0x3d) = 0x20;\n      *(undefined *)(ptr + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002bb4": "check_permissions_08002bb4",
                "param_1": "ptr",
                "param_2": "flags",
                "param_3": "offset",
                "iVar1": "result"
            },
            "calling": [
                "FUN_08001ccc",
                "FUN_080027f4",
                "FUN_08002640"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_08002d3c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2e": {
            "entrypoint": "0x08002c2e",
            "current_name": "check_and_update_status_08002c2e",
            "code": "\nundefined4 check_and_update_status_08002c2e(int *ptr_array,uint size_limit,int offset)\n\n{\n  int result;\n  \n  while( true ) {\n    if ((*(uint *)(*ptr_array + 0x14) & 4) == 4) {\n      return 0;\n    }\n    result = FUN_08002d3c(ptr_array);\n    if (result != 0) break;\n    if ((size_limit != 0xffffffff) &&\n       ((size_limit == 0 || (result = FUN_080015a0(), size_limit < (uint)(result - offset))))) {\n      ptr_array[0x10] = ptr_array[0x10] | 0x20;\n      ptr_array[0xc] = 0;\n      *(undefined *)((int)ptr_array + 0x3d) = 0x20;\n      *(undefined *)(ptr_array + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002c2e": "check_and_update_status_08002c2e",
                "param_1": "ptr_array",
                "param_2": "size_limit",
                "param_3": "offset",
                "iVar1": "result",
                "param_1[0xc]": "ptr_array[0xc]"
            },
            "calling": [
                "FUN_08001ccc"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_08002d3c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca8": {
            "entrypoint": "0x08002ca8",
            "current_name": "check_access_08002ca8",
            "code": "\nundefined4 checkAccess_08002ca8(int *ptr,uint size,int offset)\n\n{\n  int result;\n  \n  while( true ) {\n    if ((*(uint *)(*ptr + 0x14) & 0x40) == 0x40) {\n      return 0;\n    }\n    if ((*(uint *)(*ptr + 0x14) & 0x10) == 0x10) break;\n    if ((size == 0) || (result = FUN_080015a0(), size < (uint)(result - offset))) {\n      flag1 = flag1 | 0x20;\n      *(undefined *)((int)ptr + 0x3d) = 0x20;\n      *(undefined *)(ptr + 0xf) = 0;\n      return 3;\n    }\n  }\n  *(undefined4 *)(*ptr + 0x14) = 0xffffffef;\n  flag1 = 0;\n  val1 = 0;\n  *(undefined *)((int)ptr + 0x3d) = 0x20;\n  *(undefined *)(ptr + 0xf) = 0;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002ca8": "check_access_08002ca8",
                "param_1": "ptr",
                "param_2": "size",
                "param_3": "offset",
                "iVar1": "result",
                "param_1[0x10]": "flag1",
                "param_1[0xc]": "val1"
            },
            "calling": [
                "FUN_08001f6c"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d3c": {
            "entrypoint": "0x08002d3c",
            "current_name": "update_parameter_status_08002d3c",
            "code": "\nbool updateParameterStatus_08002d3c(int *parameter)\n\n{\n  bool isConditionMet;\n  \n  isConditionMet = (*(uint *)(*parameter + 0x14) & 0x400) == 0x400;\n  if (isConditionMet) {\n    *(undefined4 *)(*parameter + 0x14) = 0xfffffbff;\n    parameter[0x10] = 4;\n    parameter[0xc] = 0;\n    *(undefined *)((int)parameter + 0x3d) = 0x20;\n    *(undefined *)(parameter + 0xf) = 0;\n  }\n  return isConditionMet;\n}\n\n",
            "renaming": {
                "FUN_08002d3c": "update_parameter_status_08002d3c",
                "param_1": "parameter",
                "bVar1": "isConditionMet"
            },
            "calling": [
                "FUN_08002bb4",
                "FUN_08002c2e"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d8a": {
            "entrypoint": "0x08002d8a",
            "current_name": "FUNC_08002d8a",
            "code": "\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "calling": [
                "FUN_080014f0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d98": {
            "entrypoint": "0x08002d98",
            "current_name": "check_and_modify_settings_08002d98",
            "code": "\n\n\nundefined4 checkAndModifySettings_08002d98(uint *settings)\n\n{\n  int startValue;\n  int currentValue;\n  undefined4 result;\n  bool isFlagSet;\n  \n  if ((*settings & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0x10000)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (settings[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      if (settings[1] == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (settings[1] == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (settings[1] == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (settings[1] == 0) {\n        startValue = FUN_080015a0();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentValue = FUN_080015a0();\n          if (100 < (uint)(currentValue - startValue)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        startValue = FUN_080015a0();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentValue = FUN_080015a0();\n          if (100 < (uint)(currentValue - startValue)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*settings & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (settings[4] != 1)) {\n        return 1;\n      }\n      _DAT_40021000 = settings[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n    else if (settings[4] == 0) {\n      _DAT_42420000 = 0;\n      startValue = FUN_080015a0();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentValue = FUN_080015a0();\n        if (2 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startValue = FUN_080015a0();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentValue = FUN_080015a0();\n        if (2 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n      _DAT_40021000 = settings[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n  }\n  if ((*settings & 8) != 0) {\n    if (settings[6] == 0) {\n      _DAT_42420480 = 0;\n      startValue = FUN_080015a0();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentValue = FUN_080015a0();\n        if (2 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startValue = FUN_080015a0();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentValue = FUN_080015a0();\n        if (2 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n      FUN_08003568(1);\n    }\n  }\n  if ((*settings & 4) != 0) {\n    isFlagSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isFlagSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startValue = FUN_080015a0();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentValue = FUN_080015a0();\n        if (100 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    if (settings[3] == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (settings[3] == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (settings[3] == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (settings[3] == 0) {\n      startValue = FUN_080015a0();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentValue = FUN_080015a0();\n        if (5000 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      startValue = FUN_080015a0();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentValue = FUN_080015a0();\n        if (5000 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    if (isFlagSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if (settings[7] == 0) {\nLAB_0800324a:\n    result = 0;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    result = 1;\n  }\n  else if (settings[7] == 2) {\n    _DAT_42420060 = 0;\n    startValue = FUN_080015a0();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if (settings[8] == 0x10000) {\n          _DAT_40021004 = settings[2] | _DAT_40021004 & 0xfffdffff;\n        }\n        _DAT_40021004 = settings[9] | settings[8] | _DAT_40021004 & 0xffc2ffff;\n        _DAT_42420060 = 1;\n        startValue = FUN_080015a0();\n        while ((_DAT_40021000 & 0x2000000) == 0) {\n          currentValue = FUN_080015a0();\n          if (2 < (uint)(currentValue - startValue)) {\n            return 3;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      currentValue = FUN_080015a0();\n    } while ((uint)(currentValue - startValue) < 3);\n    result = 3;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startValue = FUN_080015a0();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) goto LAB_0800324a;\n      currentValue = FUN_080015a0();\n    } while ((uint)(currentValue - startValue) < 3);\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002d98": "check_and_modify_settings_08002d98",
                "param_1": "settings",
                "iVar1": "startValue",
                "iVar2": "currentValue",
                "uVar3": "result",
                "bVar4": "isFlagSet"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_08003568"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003260": {
            "entrypoint": "0x08003260",
            "current_name": "prepare_memory_08003260",
            "code": "\n\n\nundefined4 prepareMemory_08003260(uint *memoryConfig,uint size)\n\n{\n  int initialValue;\n  int currentValue;\n  uint uVar3;\n  undefined4 result;\n  \n  if (((_DAT_40022000 & 7) < size) &&\n     (_DAT_40022000 = size | _DAT_40022000 & 0xfffffff8, size != (size & 7))) {\n    result = 1;\n  }\n  else {\n    if ((*memoryConfig & 2) != 0) {\n      _DAT_40021004 = memoryConfig[2] | _DAT_40021004 & 0xffffff0f;\n    }\n    if ((*memoryConfig & 1) == 0) {\nLAB_08003394:\n      if ((size < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = size | _DAT_40022000 & 0xfffffff8, size != (size & 7))) {\n        result = 1;\n      }\n      else {\n        if ((*memoryConfig & 4) != 0) {\n          _DAT_40021004 = memoryConfig[3] | _DAT_40021004 & 0xfffff8ff;\n        }\n        if ((*memoryConfig & 8) != 0) {\n          _DAT_40021004 = memoryConfig[4] << 3 | _DAT_40021004 & 0xffffc7ff;\n        }\n        uVar3 = FUN_08003440();\n        DAT_20000018 = uVar3 >> (&DAT_08009eb0)[_DAT_40021004 >> 4 & 0xf];\n        FUN_0800151c(0xf);\n        result = 0;\n      }\n    }\n    else {\n      if (memoryConfig[1] == 1) {\n        if ((_DAT_40021000 & 0x20000) == 0) {\n          return 1;\n        }\n      }\n      else if ((memoryConfig[1] != 2) && ((_DAT_40021000 & 2) == 0)) {\n        return 1;\n      }\n      _DAT_40021004 = memoryConfig[1] | _DAT_40021004 & 0xfffffffc;\n      initialValue = FUN_080015a0();\n      if (memoryConfig[1] == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_08003394;\n          currentValue = FUN_080015a0();\n        } while ((uint)(currentValue - initialValue) < 0x1389);\n        result = 3;\n      }\n      else if (memoryConfig[1] == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_08003394;\n          currentValue = FUN_080015a0();\n        } while ((uint)(currentValue - initialValue) < 0x1389);\n        result = 3;\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_08003394;\n          currentValue = FUN_080015a0();\n        } while ((uint)(currentValue - initialValue) < 0x1389);\n        result = 3;\n      }\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003260": "prepare_memory_08003260",
                "param_1": "memoryConfig",
                "param_2": "size",
                "uVar4": "result",
                "iVar1": "initialValue",
                "iVar2": "currentValue"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_0800151c",
                "FUN_08003440"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003440": {
            "entrypoint": "0x08003440",
            "current_name": "calculate_execution_time_08003440",
            "code": "\n\n\nuint calculateExecutionTime_08003440(void)\n\n{\n  undefined2 timeoutValue;\n  undefined4 constant1;\n  undefined4 constant2;\n  undefined4 constant3;\n  undefined4 constant4;\n  uint variable1;\n  undefined4 variable2;\n  uint dataSegment;\n  uint executionTime;\n  uint calculationResult;\n  \n  constant1 = 0x5040302;\n  constant2 = 0x9080706;\n  constant3 = 0xd0c0b0a;\n  constant4 = 0x10100f0e;\n  timeoutValue = 0x201;\n  variable2 = 0;\n  calculationResult = 0;\n  variable1 = 0;\n  executionTime = 0;\n  dataSegment = _DAT_40021004;\n  if ((_DAT_40021004 & 0xc) == 4) {\n    executionTime = 8000000;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    variable1 = (uint)*(byte *)((int)&constant1 + (_DAT_40021004 >> 0x12 & 0xf));\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      calculationResult = variable1 * 4000000;\n    }\n    else {\n      calculationResult = (variable1 * 8000000) / (uint)*(byte *)((int)&timeoutValue + (_DAT_40021004 >> 0x11 & 1))\n      ;\n    }\n    executionTime = calculationResult;\n  }\n  else {\n    executionTime = 8000000;\n  }\n  return executionTime;\n}\n\n",
            "renaming": {
                "FUN_08003440": "calculate_execution_time_08003440",
                "local_30": "timeoutValue",
                "local_2c": "constant1",
                "uStack_28": "constant2",
                "uStack_24": "constant3",
                "uStack_20": "constant4",
                "local_1c": "variable1",
                "local_18": "variable2",
                "local_14": "dataSegment",
                "local_10": "executionTime",
                "local_c": "calculationResult"
            },
            "calling": [
                "FUN_08003260"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003504": {
            "entrypoint": "0x08003504",
            "current_name": "get_data_value_08003504",
            "code": "\nundefined4 get_data_value_08003504(void)\n\n{\n  return DAT_20000018;\n}\n\n",
            "renaming": {
                "FUN_08003504": "get_data_value_08003504"
            },
            "calling": [
                "FUN_080052a0",
                "FUN_08003540",
                "FUN_08003518"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003518": {
            "entrypoint": "0x08003518",
            "current_name": "shifted_value_08003518",
            "code": "\n\n\nuint shiftedValue_08003518(void)\n\n{\n  uint result;\n  \n  result = FUN_08003504();\n  return result >> *(sbyte *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 8 & 7));\n}\n\n",
            "renaming": {
                "FUN_08003518": "shifted_value_08003518",
                "uVar1": "result"
            },
            "calling": [
                "FUN_08001ab0",
                "FUN_080046ec"
            ],
            "called": [
                "FUN_08003504"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003540": {
            "entrypoint": "0x08003540",
            "current_name": "shift_bits_based_on_index_08003540",
            "code": "\n\n\nuint shiftBitsBasedOnIndex_08003540(void)\n\n{\n  uint result;\n  \n  result = FUN_08003504();\n  return result >> *(sbyte *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 0xb & 7));\n}\n\n",
            "renaming": {
                "FUN_08003540": "shift_bits_based_on_index_08003540",
                "uVar1": "result"
            },
            "calling": [
                "FUN_080046ec"
            ],
            "called": [
                "FUN_08003504"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003568": {
            "entrypoint": "0x08003568",
            "current_name": "delay_milliseconds_08003568",
            "code": "\nvoid delayMilliseconds_08003568(int milliseconds)\n\n{\n  bool bVar1;\n  int iterations;\n  \n  iterations = milliseconds * (DAT_20000018 / 8000);\n  do {\n    bVar1 = iterations != 0;\n    iterations = iterations + -1;\n  } while (bVar1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003568": "delay_milliseconds_08003568",
                "param_1": "milliseconds",
                "local_c": "iterations"
            },
            "calling": [
                "FUN_08002d98"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035a4": {
            "entrypoint": "0x080035a4",
            "current_name": "check_and_update_status_080035a4",
            "code": "\nundefined4 check_and_update_status_080035a4(undefined4 *input_data)\n\n{\n  undefined4 result;\n  \n  if (input_data == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)input_data + 0x3d) == '\\0') {\n      *(undefined *)(input_data + 0xf) = 0;\n      FUNC_080035fa(input_data);\n    }\n    *(undefined *)((int)input_data + 0x3d) = 2;\n    FUN_08003c94(*input_data,input_data + 1);\n    *(undefined *)((int)input_data + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080035a4": "check_and_update_status_080035a4",
                "param_1": "input_data",
                "uVar1": "result"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [
                "FUN_08003c94",
                "FUN_080035fa"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fa": {
            "entrypoint": "0x080035fa",
            "current_name": "FUNC_080035fa",
            "code": "\nvoid FUNC_080035fa(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fa": "FUNC_080035fa"
            },
            "calling": [
                "FUN_080035a4"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800360c": {
            "entrypoint": "0x0800360c",
            "current_name": "set_flags_0800360c",
            "code": "\nundefined4 setFlags_0800360c(uint **ptr)\n\n{\n  (*ptr)[3] = (*ptr)[3] | 1;\n  **ptr = **ptr | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800360c": "set_flags_0800360c",
                "param_1": "ptr"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003640": {
            "entrypoint": "0x08003640",
            "current_name": "handle_params_08003640",
            "code": "\nundefined4 handleParams_08003640(undefined4 *params)\n\n{\n  undefined4 result;\n  \n  if (params == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)params + 0x3d) == '\\0') {\n      *(undefined *)(params + 0xf) = 0;\n      FUNC_08003696(params);\n    }\n    *(undefined *)((int)params + 0x3d) = 2;\n    FUN_08003c94(*params,params + 1);\n    *(undefined *)((int)params + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003640": "handle_params_08003640",
                "param_1": "params",
                "uVar1": "result"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_08003c94",
                "FUN_08003696"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003696": {
            "entrypoint": "0x08003696",
            "current_name": "FUNC_08003696",
            "code": "\nvoid FUNC_08003696(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003696": "FUNC_08003696"
            },
            "calling": [
                "FUN_08003640"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080036a8": {
            "entrypoint": "0x080036a8",
            "current_name": "set_flags_and_permissions_080036a8",
            "code": "\nundefined4 setFlagsAndPermissions_080036a8(uint **ptrToParam,undefined4 paramValue)\n\n{\n  FUN_080041ea(*ptrToParam,paramValue,1);\n  if (*ptrToParam == (uint *)0x40012c00) {\n    (*ptrToParam)[0x11] = (*ptrToParam)[0x11] | 0x8000;\n  }\n  **ptrToParam = **ptrToParam | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080036a8": "set_flags_and_permissions_080036a8",
                "param_1": "ptrToParam",
                "param_2": "paramValue"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_080041ea"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f8": {
            "entrypoint": "0x080036f8",
            "current_name": "handle_params_080036f8",
            "code": "\nvoid handleParams_080036f8(int *param)\n\n{\n  if (((*(uint *)(*param + 0x10) & 2) == 2) && ((*(uint *)(*param + 0xc) & 2) == 2)) {\n    *(undefined4 *)(*param + 0x10) = 0xfffffffd;\n    *(undefined *)(param + 7) = 1;\n    if ((*(uint *)(*param + 0x18) & 3) == 0) {\n      FUNC_08003c4a(param);\n      FUNC_08003c6e(param);\n    }\n    else {\n      FUNC_08003c5c(param);\n    }\n    *(undefined *)(param + 7) = 0;\n  }\n  if (((*(uint *)(*param + 0x10) & 4) == 4) && ((*(uint *)(*param + 0xc) & 4) == 4)) {\n    *(undefined4 *)(*param + 0x10) = 0xfffffffb;\n    *(undefined *)(param + 7) = 2;\n    if ((*(uint *)(*param + 0x18) & 0x300) == 0) {\n      FUNC_08003c4a(param);\n      FUNC_08003c6e(param);\n    }\n    else {\n      FUNC_08003c5c(param);\n    }\n    *(undefined *)(param + 7) = 0;\n  }\n  if (((*(uint *)(*param + 0x10) & 8) == 8) && ((*(uint *)(*param + 0xc) & 8) == 8)) {\n    *(undefined4 *)(*param + 0x10) = 0xfffffff7;\n    *(undefined *)(param + 7) = 4;\n    if ((*(uint *)(*param + 0x1c) & 3) == 0) {\n      FUNC_08003c4a(param);\n      FUNC_08003c6e(param);\n    }\n    else {\n      FUNC_08003c5c(param);\n    }\n    *(undefined *)(param + 7) = 0;\n  }\n  if (((*(uint *)(*param + 0x10) & 0x10) == 0x10) && ((*(uint *)(*param + 0xc) & 0x10) == 0x10))\n  {\n    *(undefined4 *)(*param + 0x10) = 0xffffffef;\n    *(undefined *)(param + 7) = 8;\n    if ((*(uint *)(*param + 0x1c) & 0x300) == 0) {\n      FUNC_08003c4a(param);\n      FUNC_08003c6e(param);\n    }\n    else {\n      FUNC_08003c5c(param);\n    }\n    *(undefined *)(param + 7) = 0;\n  }\n  if (((*(uint *)(*param + 0x10) & 1) == 1) && ((*(uint *)(*param + 0xc) & 1) == 1)) {\n    *(undefined4 *)(*param + 0x10) = 0xfffffffe;\n    FUN_08004f78(param);\n  }\n  if (((*(uint *)(*param + 0x10) & 0x80) == 0x80) && ((*(uint *)(*param + 0xc) & 0x80) == 0x80))\n  {\n    *(undefined4 *)(*param + 0x10) = 0xffffff7f;\n    FUNC_08004378(param);\n  }\n  if (((*(uint *)(*param + 0x10) & 0x40) == 0x40) && ((*(uint *)(*param + 0xc) & 0x40) == 0x40))\n  {\n    *(undefined4 *)(*param + 0x10) = 0xffffffbf;\n    FUNC_08003c80(param);\n  }\n  if (((*(uint *)(*param + 0x10) & 0x20) == 0x20) && ((*(uint *)(*param + 0xc) & 0x20) == 0x20))\n  {\n    *(undefined4 *)(*param + 0x10) = 0xffffffdf;\n    FUNC_08004366(param);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036f8": "handle_params_080036f8",
                "param_1": "param"
            },
            "calling": [
                "FUN_08005714"
            ],
            "called": [
                "FUN_08004366",
                "FUN_08004378",
                "FUN_08004f78",
                "FUN_08003c5c",
                "FUN_08003c4a",
                "FUN_08003c6e",
                "FUN_08003c80"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003908": {
            "entrypoint": "0x08003908",
            "current_name": "check_and_update_status_08003908",
            "code": "\nundefined4 checkAndUpdateStatus_08003908(int *data,int size,undefined4 case_value)\n\n{\n  undefined4 status;\n  \n  if (*(char *)(data + 0xf) == '\\x01') {\n    status = 2;\n  }\n  else {\n    *(undefined *)(data + 0xf) = 1;\n    *(undefined *)((int)data + 0x3d) = 2;\n    switch(case_value) {\n    case 0:\n      FUN_08003d60(*data,size);\n      *(uint *)(*data + 0x18) = *(uint *)(*data + 0x18) | 8;\n      *(uint *)(*data + 0x18) = *(uint *)(*data + 0x18) & 0xfffffffb;\n      *(uint *)(*data + 0x18) = *(uint *)(size + 0x10) | *(uint *)(*data + 0x18);\n      break;\n    case 4:\n      FUN_08003e38(*data,size);\n      *(uint *)(*data + 0x18) = *(uint *)(*data + 0x18) | 0x800;\n      *(uint *)(*data + 0x18) = *(uint *)(*data + 0x18) & 0xfffffbff;\n      *(uint *)(*data + 0x18) = *(int *)(size + 0x10) << 8 | *(uint *)(*data + 0x18);\n      break;\n    case 8:\n      FUN_08003f18(*data,size);\n      *(uint *)(*data + 0x1c) = *(uint *)(*data + 0x1c) | 8;\n      *(uint *)(*data + 0x1c) = *(uint *)(*data + 0x1c) & 0xfffffffb;\n      *(uint *)(*data + 0x1c) = *(uint *)(size + 0x10) | *(uint *)(*data + 0x1c);\n      break;\n    case 0xc:\n      FUN_08003ff8(*data,size);\n      *(uint *)(*data + 0x1c) = *(uint *)(*data + 0x1c) | 0x800;\n      *(uint *)(*data + 0x1c) = *(uint *)(*data + 0x1c) & 0xfffffbff;\n      *(uint *)(*data + 0x1c) = *(int *)(size + 0x10) << 8 | *(uint *)(*data + 0x1c);\n    }\n    *(undefined *)((int)data + 0x3d) = 1;\n    *(undefined *)(data + 0xf) = 0;\n    status = 0;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003908": "check_and_update_status_08003908",
                "param_1": "data",
                "param_2": "size",
                "param_3": "case_value",
                "uVar1": "status"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_08003ff8",
                "FUN_08003e38",
                "FUN_08003f18",
                "FUN_08003d60"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a94": {
            "entrypoint": "0x08003a94",
            "current_name": "process_data_08003a94",
            "code": "\nundefined4 processData_08003a94(int *dataPointer,uint *paramPointer)\n\n{\n  undefined4 result;\n  uint paramValue;\n  \n  if (*(char *)(dataPointer + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(dataPointer + 0xf) = 1;\n    *(undefined *)((int)dataPointer + 0x3d) = 2;\n    *(uint *)(*dataPointer + 8) = *(uint *)(*dataPointer + 8) & 0xffff0088;\n    paramValue = *paramPointer;\n    if (paramValue == 0x40) {\n      FUN_080040a0(*dataPointer,paramPointer[1],paramPointer[3]);\n      FUN_0800416a(*dataPointer,0x40);\n    }\n    else if (paramValue < 0x41) {\n      if (paramValue == 0x10) {\n        FUN_0800416a(*dataPointer,0x10);\n      }\n      else if (paramValue < 0x11) {\n        if (paramValue == 0) {\n          FUN_0800416a(*dataPointer,0);\n        }\n      }\n      else if (paramValue == 0x20) {\n        FUN_0800416a(*dataPointer,0x20);\n      }\n      else if (paramValue == 0x30) {\n        FUN_0800416a(*dataPointer,0x30);\n      }\n    }\n    else if (paramValue == 0x70) {\n      FUN_080041a8(*dataPointer,paramPointer[2],paramPointer[1],paramPointer[3]);\n      *(uint *)(*dataPointer + 8) = *(uint *)(*dataPointer + 8) & 0xffffff88 | 0x77;\n    }\n    else if (paramValue < 0x71) {\n      if (paramValue == 0x50) {\n        FUN_080040a0(*dataPointer,paramPointer[1],paramPointer[3]);\n        FUN_0800416a(*dataPointer,0x50);\n      }\n      else if (paramValue == 0x60) {\n        FUN_08004104(*dataPointer,paramPointer[1],paramPointer[3]);\n        FUN_0800416a(*dataPointer,0x60);\n      }\n    }\n    else if (paramValue == 0x1000) {\n      *(uint *)(*dataPointer + 8) = *(uint *)(*dataPointer + 8) & 0xfffffff8;\n    }\n    else if (paramValue == 0x2000) {\n      FUN_080041a8(*dataPointer,paramPointer[2],paramPointer[1],paramPointer[3]);\n      *(uint *)(*dataPointer + 8) = *(uint *)(*dataPointer + 8) | 0x4000;\n    }\n    *(undefined *)((int)dataPointer + 0x3d) = 1;\n    *(undefined *)(dataPointer + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003a94": "process_data_08003a94",
                "param_1": "dataPointer",
                "param_2": "paramPointer",
                "uVar1": "result",
                "uVar2": "paramValue"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [
                "FUN_08004104",
                "FUN_080040a0",
                "FUN_0800416a",
                "FUN_080041a8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c4a": {
            "entrypoint": "0x08003c4a",
            "current_name": "FUNC_08003c4a",
            "code": "\nvoid FUNC_08003c4a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c4a": "FUNC_08003c4a"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c5c": {
            "entrypoint": "0x08003c5c",
            "current_name": "FUNC_08003c5c",
            "code": "\nvoid FUNC_08003c5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c5c": "FUNC_08003c5c"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c6e": {
            "entrypoint": "0x08003c6e",
            "current_name": "FUNC_08003c6e",
            "code": "\nvoid FUNC_08003c6e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c6e": "FUNC_08003c6e"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c80": {
            "entrypoint": "0x08003c80",
            "current_name": "FUNC_08003c80",
            "code": "\nvoid FUNC_08003c80(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c80": "FUNC_08003c80"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c94": {
            "entrypoint": "0x08003c94",
            "current_name": "update_memory_08003c94",
            "code": "\nvoid updateMemory_08003c94(uint *memoryAddress,uint *data)\n\n{\n  uint tempValue;\n  \n  tempValue = *memoryAddress;\n  if ((((memoryAddress == (uint *)0x40012c00) || (memoryAddress == (uint *)0x40000000)) ||\n      (memoryAddress == (uint *)0x40000400)) || (memoryAddress == (uint *)0x40000800)) {\n    tempValue = data[1] | tempValue & 0xffffff8f;\n  }\n  if (((memoryAddress == (uint *)0x40012c00) || (memoryAddress == (uint *)0x40000000)) ||\n     ((memoryAddress == (uint *)0x40000400 || (memoryAddress == (uint *)0x40000800)))) {\n    tempValue = data[3] | tempValue & 0xfffffcff;\n  }\n  *memoryAddress = data[5] | tempValue & 0xffffff7f;\n  memoryAddress[0xb] = data[2];\n  memoryAddress[10] = *data;\n  if (memoryAddress == (uint *)0x40012c00) {\n    uRam40012c30 = data[4];\n  }\n  memoryAddress[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c94": "update_memory_08003c94",
                "param_1": "memoryAddress",
                "param_2": "data",
                "local_c": "tempValue"
            },
            "calling": [
                "FUN_08003640",
                "FUN_080035a4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d60": {
            "entrypoint": "0x08003d60",
            "current_name": "update_parameters_08003d60",
            "code": "\nvoid updateParameters_08003d60(int baseAddress,uint *parameters)\n\n{\n  uint value1;\n  uint value2;\n  uint localVar;\n  \n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xfffffffe;\n  localVar = *(uint *)(baseAddress + 4);\n  value1 = *parameters;\n  value2 = parameters[2] | *(uint *)(baseAddress + 0x20) & 0xfffffffd;\n  if (baseAddress == 0x40012c00) {\n    value2 = (parameters[3] | value2 & 0xfffffff7) & 0xfffffffb;\n    localVar = parameters[6] | parameters[5] | localVar & 0xfffffcff;\n  }\n  *(uint *)(baseAddress + 4) = localVar;\n  *(uint *)(baseAddress + 0x18) = value1 | *(uint *)(baseAddress + 0x18) & 0xffffff8c;\n  *(uint *)(baseAddress + 0x34) = parameters[1];\n  *(uint *)(baseAddress + 0x20) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003d60": "update_parameters_08003d60",
                "param_1": "baseAddress",
                "param_2": "parameters",
                "uVar1": "value1",
                "uVar2": "value2",
                "local_10": "localVar"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e38": {
            "entrypoint": "0x08003e38",
            "current_name": "update_params_08003e38",
            "code": "\nvoid updateParams_08003e38(int baseAddress,int *parameters)\n\n{\n  int tempVar1;\n  uint tempVar2;\n  uint tempVar3;\n  \n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xffffffef;\n  tempVar3 = *(uint *)(baseAddress + 4);\n  tempVar1 = *parameters;\n  tempVar2 = parameters[2] << 4 | *(uint *)(baseAddress + 0x20) & 0xffffffdf;\n  if (baseAddress == 0x40012c00) {\n    tempVar2 = (parameters[3] << 4 | tempVar2 & 0xffffff7f) & 0xffffffbf;\n    tempVar3 = parameters[6] << 2 | parameters[5] << 2 | tempVar3 & 0xfffff3ff;\n  }\n  *(uint *)(baseAddress + 4) = tempVar3;\n  *(uint *)(baseAddress + 0x18) = tempVar1 << 8 | *(uint *)(baseAddress + 0x18) & 0xffff8cff;\n  *(int *)(baseAddress + 0x38) = parameters[1];\n  *(uint *)(baseAddress + 0x20) = tempVar2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e38": "update_params_08003e38",
                "param_1": "baseAddress",
                "param_2": "parameters",
                "iVar1": "tempVar1",
                "uVar2": "tempVar2",
                "local_10": "tempVar3"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "update_params_08003f18",
            "code": "\nvoid updateParams_08003f18(int baseAddress,uint *paramsArray)\n\n{\n  uint paramValue1;\n  uint paramValue2;\n  uint localValue;\n  \n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xfffffeff;\n  localValue = *(uint *)(baseAddress + 4);\n  paramValue1 = *paramsArray;\n  paramValue2 = paramsArray[2] << 8 | *(uint *)(baseAddress + 0x20) & 0xfffffdff;\n  if (baseAddress == 0x40012c00) {\n    paramValue2 = (paramsArray[3] << 8 | paramValue2 & 0xfffff7ff) & 0xfffffbff;\n    localValue = paramsArray[6] << 4 | paramsArray[5] << 4 | localValue & 0xffffcfff;\n  }\n  *(uint *)(baseAddress + 4) = localValue;\n  *(uint *)(baseAddress + 0x1c) = paramValue1 | *(uint *)(baseAddress + 0x1c) & 0xffffff8c;\n  *(uint *)(baseAddress + 0x3c) = paramValue3;\n  *(uint *)(baseAddress + 0x20) = paramValue2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "update_params_08003f18",
                "param_1": "baseAddress",
                "param_2": "paramsArray",
                "uVar1": "paramValue1",
                "uVar2": "paramValue2",
                "local_10": "localValue",
                "param_2[1]": "paramValue3"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff8": {
            "entrypoint": "0x08003ff8",
            "current_name": "update_parameters_08003ff8",
            "code": "\nvoid updateParameters_08003ff8(int param,int *parameters)\n\n{\n  int var1;\n  int var2;\n  uint localValue;\n  \n  *(uint *)(param + 0x20) = *(uint *)(param + 0x20) & 0xffffefff;\n  localValue = *(uint *)(param + 4);\n  var1 = *parameters;\n  var2 = parameters[2];\n  if (param == 0x40012c00) {\n    localValue = parameters[5] << 6 | localValue & 0xffffbfff;\n  }\n  *(uint *)(param + 4) = localValue;\n  *(uint *)(param + 0x1c) = var1 << 8 | *(uint *)(param + 0x1c) & 0xffff8cff;\n  *(int *)(param + 0x40) = parameters[1];\n  *(uint *)(param + 0x20) = var2 << 0xc | *(uint *)(param + 0x20) & 0xffffdfff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff8": "update_parameters_08003ff8",
                "param_1": "param",
                "param_2": "parameters",
                "iVar1": "var1",
                "iVar2": "var2",
                "local_c": "localValue"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040a0": {
            "entrypoint": "0x080040a0",
            "current_name": "update_values_080040a0",
            "code": "\nvoid updateValues_080040a0(int address,uint value1,int value2)\n\n{\n  uint temp1;\n  \n  temp1 = *(uint *)(address + 0x20);\n  *(uint *)(address + 0x20) = *(uint *)(address + 0x20) & 0xfffffffe;\n  *(uint *)(address + 0x18) = value2 << 4 | *(uint *)(address + 0x18) & 0xffffff0f;\n  *(uint *)(address + 0x20) = value1 | temp1 & 0xfffffff5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040a0": "update_values_080040a0",
                "param_1": "address",
                "param_2": "value1",
                "param_3": "value2",
                "uVar1": "temp1"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004104": {
            "entrypoint": "0x08004104",
            "current_name": "update_flags_and_values_08004104",
            "code": "\nvoid updateFlagsAndValues_08004104(int ptr1,int param2,int param3)\n\n{\n  *(uint *)(ptr1 + 0x20) = *(uint *)(ptr1 + 0x20) & 0xffffffef;\n  *(uint *)(ptr1 + 0x18) = param3 << 0xc | *(uint *)(ptr1 + 0x18) & 0xffff0fff;\n  *(uint *)(ptr1 + 0x20) = param2 << 4 | *(uint *)(ptr1 + 0x20) & 0xffffff5f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004104": "update_flags_and_values_08004104",
                "param_1": "ptr1",
                "param_2": "param2",
                "param_3": "param3"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800416a": {
            "entrypoint": "0x0800416a",
            "current_name": "update_parameter_flags_0800416a",
            "code": "\nvoid updateParameterFlags_0800416a(int dataPointer,ushort newFlag)\n\n{\n  *(unsignedInteger *)(dataPointer + 8) = *(unsignedInteger *)(dataPointer + 8) & 0xffffff8f | (unsignedInteger)(newFlag | 7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800416a": "update_parameter_flags_0800416a",
                "param_1": "dataPointer",
                "param_2": "newFlag",
                "uint": "unsignedInteger"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a8": {
            "entrypoint": "0x080041a8",
            "current_name": "update_parameter_value_080041a8",
            "code": "\nvoid updateParameterValue_080041a8(int inputPointer,uint value1,uint value2,int value3)\n\n{\n  *(uint *)(inputPointer + 8) = value1 | value3 << 8 | value2 | *(uint *)(inputPointer + 8) & 0xffff00ff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a8": "update_parameter_value_080041a8",
                "param_1": "inputPointer",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ea": {
            "entrypoint": "0x080041ea",
            "current_name": "update_bits_080041ea",
            "code": "\nvoid updateBits_080041ea(int baseAddress,uint bitPosition,int value)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & ~(1 << (bitPosition & 0xff));\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) | value << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041ea": "update_bits_080041ea",
                "param_1": "baseAddress",
                "param_2": "bitPosition",
                "param_3": "value"
            },
            "calling": [
                "FUN_080036a8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800422e": {
            "entrypoint": "0x0800422e",
            "current_name": "set_flag_and_calculate_value_0800422e",
            "code": "\nundefined4 setFlagAndCalculateValue_0800422e(int *pointer1,uint *pointer2)\n\n{\n  undefined4 returnValue;\n  \n  if (*(char *)(pointer1 + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(pointer1 + 0xf) = 1;\n    *(uint *)(*pointer1 + 0x44) =\n         pointer2[6] |\n         (pointer2[6] |\n         (pointer2[5] |\n         (pointer2[4] |\n         (*pointer2 | (pointer2[1] | (pointer2[2] | pointer2[3] & 0xfffffcff) & 0xfffffbff) & 0xfffff7ff\n         ) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    *(undefined *)(pointer1 + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800422e": "set_flag_and_calculate_value_0800422e",
                "param_1": "pointer1",
                "param_2": "pointer2",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042de": {
            "entrypoint": "0x080042de",
            "current_name": "update_flags_and_values_080042de",
            "code": "\nundefined4 updateFlagsAndValues_080042de(int *inputArray,uint *updateArray)\n\n{\n  undefined4 updatedValue;\n  \n  if (*(char *)(inputArray + 0xf) == '\\x01') {\n    updatedValue = 2;\n  }\n  else {\n    *(undefined *)(inputArray + 0xf) = 1;\n    *(undefined *)((int)inputArray + 0x3d) = 2;\n    *(uint *)(*inputArray + 4) = *(uint *)(*inputArray + 4) & 0xffffff8f;\n    *(uint *)(*inputArray + 4) = *updateArray | *(uint *)(*inputArray + 4);\n    *(uint *)(*inputArray + 8) = *(uint *)(*inputArray + 8) & 0xffffff7f;\n    *(uint *)(*inputArray + 8) = updateArray[1] | *(uint *)(*inputArray + 8);\n    *(undefined *)((int)inputArray + 0x3d) = 1;\n    *(undefined *)(inputArray + 0xf) = 0;\n    updatedValue = 0;\n  }\n  return updatedValue;\n}\n\n",
            "renaming": {
                "FUN_080042de": "update_flags_and_values_080042de",
                "param_1": "inputArray",
                "param_2": "updateArray",
                "uVar1": "updatedValue"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004366": {
            "entrypoint": "0x08004366",
            "current_name": "FUNC_08004366",
            "code": "\nvoid FUNC_08004366(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004366": "FUNC_08004366"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004378": {
            "entrypoint": "0x08004378",
            "current_name": "FUNC_08004378",
            "code": "\nvoid FUNC_08004378(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004378": "FUNC_08004378"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800438a": {
            "entrypoint": "0x0800438a",
            "current_name": "initialize_data_0800438a",
            "code": "\nundefined4 initializeData_0800438a(int *data)\n\n{\n  undefined4 returnValue;\n  \n  if (data == (int *)0x0) {\n    returnValue = 1;\n  }\n  else {\n    if (*(char *)((int)data + 0x39) == '\\0') {\n      *(undefined *)(data + 0xe) = 0;\n      FUNC_08004424(data);\n    }\n    *(undefined *)((int)data + 0x39) = 0x24;\n    *(uint *)(*data + 0xc) = *(uint *)(*data + 0xc) & 0xffffdfff;\n    FUN_080046ec(data);\n    *(uint *)(*data + 0x10) = *(uint *)(*data + 0x10) & 0xffffb7ff;\n    *(uint *)(*data + 0x14) = *(uint *)(*data + 0x14) & 0xffffffd5;\n    *(uint *)(*data + 0xc) = *(uint *)(*data + 0xc) | 0x2000;\n    data[0xf] = 0;\n    *(undefined *)((int)data + 0x39) = 0x20;\n    *(undefined *)((int)data + 0x3a) = 0x20;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800438a": "initialize_data_0800438a",
                "param_1": "data",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_08005598"
            ],
            "called": [
                "FUN_080046ec",
                "FUN_08004424"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004424": {
            "entrypoint": "0x08004424",
            "current_name": "FUNC_08004424",
            "code": "\nvoid FUNC_08004424(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004424": "FUNC_08004424"
            },
            "calling": [
                "FUN_0800438a"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004436": {
            "entrypoint": "0x08004436",
            "current_name": "process_data_08004436",
            "code": "\nundefined4 processData_08004436(uint **data,ushort *buffer,short bufferSize,uint timeout)\n\n{\n  int result;\n  int comparison;\n  undefined4 returnValue;\n  ushort *currentByte;\n  \n  if (*(char *)((int)data + 0x39) == ' ') {\n    if ((buffer == (ushort *)0x0) || (bufferSize == 0)) {\n      returnValue = 1;\n    }\n    else if (*(char *)(data + 0xe) == '\\x01') {\n      returnValue = 2;\n    }\n    else {\n      *(undefined *)(data + 0xe) = 1;\n      data[0xf] = (uint *)0x0;\n      *(undefined *)((int)data + 0x39) = 0x21;\n      result = FUN_080015a0();\n      *(short *)(data + 9) = bufferSize;\n      *(short *)((int)data + 0x26) = bufferSize;\n      currentByte = buffer;\n      while (*(short *)((int)data + 0x26) != 0) {\n        *(short *)((int)data + 0x26) = *(short *)((int)data + 0x26) + -1;\n        if (data[2] == (uint *)0x1000) {\n          do {\n            if ((**data & 0x80) == 0x80) {\n              comparison = 0;\n              goto LAB_0800454c;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (comparison = FUN_080015a0(), (uint)(comparison - result) <= timeout))));\n          (*data)[3] = (*data)[3] & 0xfffffe5f;\n          (*data)[5] = (*data)[5] & 0xfffffffe;\n          *(undefined *)((int)data + 0x39) = 0x20;\n          *(undefined *)((int)data + 0x3a) = 0x20;\n          *(undefined *)(data + 0xe) = 0;\n          comparison = 3;\nLAB_0800454c:\n          if (comparison != 0) {\n            return 3;\n          }\n          (*data)[1] = *currentByte & 0x1ff;\n          if (data[4] == (uint *)0x0) {\n            currentByte = currentByte + 1;\n          }\n          else {\n            currentByte = (ushort *)((int)currentByte + 1);\n          }\n        }\n        else {\n          do {\n            if ((**data & 0x80) == 0x80) {\n              comparison = 0;\n              goto LAB_08004614;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (comparison = FUN_080015a0(), (uint)(comparison - result) <= timeout))));\n          (*data)[3] = (*data)[3] & 0xfffffe5f;\n          (*data)[5] = (*data)[5] & 0xfffffffe;\n          *(undefined *)((int)data + 0x39) = 0x20;\n          *(undefined *)((int)data + 0x3a) = 0x20;\n          *(undefined *)(data + 0xe) = 0;\n          comparison = 3;\nLAB_08004614:\n          if (comparison != 0) {\n            return 3;\n          }\n          (*data)[1] = (uint)*(byte *)currentByte;\n          currentByte = (ushort *)((int)currentByte + 1);\n        }\n      }\n      do {\n        if ((**data & 0x40) == 0x40) {\n          result = 0;\n          goto LAB_080046c6;\n        }\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (comparison = FUN_080015a0(), (uint)(comparison - result) <= timeout))));\n      (*data)[3] = (*data)[3] & 0xfffffe5f;\n      (*data)[5] = (*data)[5] & 0xfffffffe;\n      *(undefined *)((int)data + 0x39) = 0x20;\n      *(undefined *)((int)data + 0x3a) = 0x20;\n      *(undefined *)(data + 0xe) = 0;\n      result = 3;\nLAB_080046c6:\n      if (result == 0) {\n        *(undefined *)((int)data + 0x39) = 0x20;\n        *(undefined *)(data + 0xe) = 0;\n        returnValue = 0;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004436": "process_data_08004436",
                "param_1": "data",
                "param_2": "buffer",
                "param_3": "bufferSize",
                "param_4": "timeout",
                "iVar1": "result",
                "iVar2": "comparison",
                "uVar3": "returnValue",
                "local_58": "currentByte"
            },
            "calling": [
                "FUN_08004f3c"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046ec": {
            "entrypoint": "0x080046ec",
            "current_name": "update_params_080046ec",
            "code": "\nvoid updateParams_080046ec(int *paramArray)\n\n{\n  ulonglong quotient;\n  int tempVar1;\n  int tempVar2;\n  uint result;\n  int tempVar3;\n  undefined8 randomValue;\n  \n  *(uint *)(*paramArray + 0x10) = paramArray[3] | *(uint *)(*paramArray + 0x10) & 0xffffcfff;\n  *(uint *)(*paramArray + 0xc) =\n       *(uint *)(*paramArray + 0xc) & 0xffffe9f3 | paramArray[5] | paramArray[2] | paramArray[4];\n  *(uint *)(*paramArray + 0x14) = paramArray[6] | *(uint *)(*paramArray + 0x14) & 0xfffffcff;\n  if (*paramArray == 0x40013800) {\n    randomValue = FUN_08003540();\n    quotient = (ulonglong)(uint)((int)randomValue * 0x19) / (ulonglong)(uint)(paramArray[1] << 2);\n    tempVar1 = FUN_08003540((int)randomValue,(int)((ulonglong)randomValue >> 0x20),(int)(quotient * 0x51eb851f));\n    tempVar2 = paramArray[1];\n    randomValue = FUN_08003540();\n    result = ((uint)(tempVar1 * 0x19) / (uint)(tempVar2 << 2) +\n            (int)(((ulonglong)(uint)((int)randomValue * 0x19) / (ulonglong)(uint)(paramArray[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    tempVar1 = FUN_08003540((int)randomValue,(int)((ulonglong)randomValue >> 0x20),result * 0x51eb851f);\n    tempVar3 = paramArray[1];\n    tempVar2 = FUN_08003540();\n    *(uint *)(*paramArray + 8) =\n         ((((uint)(tempVar1 * 0x19) / (uint)(tempVar3 << 2) +\n           (int)(((ulonglong)(uint)(tempVar2 * 0x19) / (ulonglong)(uint)(paramArray[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(quotient / 100) * 0x10 + (result / 100 & 0xf0);\n  }\n  else {\n    randomValue = FUN_08003518();\n    quotient = (ulonglong)(uint)((int)randomValue * 0x19) / (ulonglong)(uint)(paramArray[1] << 2);\n    tempVar1 = FUN_08003518((int)randomValue,(int)((ulonglong)randomValue >> 0x20),(int)(quotient * 0x51eb851f));\n    tempVar2 = paramArray[1];\n    randomValue = FUN_08003518();\n    result = ((uint)(tempVar1 * 0x19) / (uint)(tempVar2 << 2) +\n            (int)(((ulonglong)(uint)((int)randomValue * 0x19) / (ulonglong)(uint)(paramArray[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    tempVar1 = FUN_08003518((int)randomValue,(int)((ulonglong)randomValue >> 0x20),result * 0x51eb851f);\n    tempVar3 = paramArray[1];\n    tempVar2 = FUN_08003518();\n    *(uint *)(*paramArray + 8) =\n         ((((uint)(tempVar1 * 0x19) / (uint)(tempVar3 << 2) +\n           (int)(((ulonglong)(uint)(tempVar2 * 0x19) / (ulonglong)(uint)(paramArray[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(quotient / 100) * 0x10 + (result / 100 & 0xf0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046ec": "update_params_080046ec",
                "param_1": "paramArray",
                "uVar1": "quotient",
                "iVar2": "tempVar1",
                "iVar3": "tempVar2",
                "uVar4": "result",
                "iVar5": "tempVar3",
                "uVar6": "randomValue"
            },
            "calling": [
                "FUN_0800438a"
            ],
            "called": [
                "FUN_08003540",
                "FUN_08003518"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800491c": {
            "entrypoint": "0x0800491c",
            "current_name": "initialize_memory_0800491c",
            "code": "\nvoid initializeMemory_0800491c(undefined4 *memoryPtr)\n\n{\n  undefined zeroByte1;\n  undefined hexValue;\n  undefined byteArray [5];\n  \n  zeroByte1 = 0;\n  (*DAT_20000a54)(0xd0,0x6b,&zeroByte1,1);\n  hexValue = 0x10;\n  (*DAT_20000a54)(0xd0,0x1c,&hexValue,1);\n  byteArray[0] = 8;\n  (*DAT_20000a54)(0xd0,0x1b,byteArray,1);\n  *memoryPtr = 0;\n  memoryPtr[1] = 0;\n  memoryPtr[2] = 0;\n  memoryPtr[3] = 0;\n  memoryPtr[4] = 0;\n  memoryPtr[5] = 0;\n  memoryPtr[6] = 0;\n  memoryPtr[7] = 0;\n  memoryPtr[8] = 0;\n  memoryPtr[9] = 0;\n  memoryPtr[10] = 0;\n  FUN_080049cc(memoryPtr);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800491c": "initialize_memory_0800491c",
                "param_1": "memoryPtr",
                "local_13": "zeroByte1",
                "local_12": "hexValue",
                "local_11": "byteArray"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_080049cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049cc": {
            "entrypoint": "0x080049cc",
            "current_name": "calculate_averages_080049cc",
            "code": "\nvoid calculateAverages_080049cc(int array)\n\n{\n  undefined4 result;\n  undefined4 sum1;\n  undefined4 sum2;\n  undefined4 getTime;\n  int length;\n  int i;\n  undefined4 average1;\n  undefined4 average2;\n  undefined4 value1;\n  undefined4 value2;\n  \n  length = 1;\n  value2 = 0;\n  value1 = 0;\n  average2 = 0;\n  average1 = 0;\n  getTime = (*DAT_20000a50)();\n  i = 0;\n  while( true ) {\n    if (length <= i) break;\n    sum2 = 0;\n    sum1 = 0;\n    FUN_08004ae0(array);\n    FUN_08004d78(array,&sum2,&sum1);\n    average2 = FUN_08000aa8(average2,sum2);\n    average1 = FUN_08000aa8(average1,sum1);\n    value2 = FUN_08000aa8(value2,*(undefined4 *)(array + 0x10));\n    value1 = FUN_08000aa8(value1,*(undefined4 *)(array + 0x14));\n    getTime = (*DAT_20000a50)();\n    i = i + 1;\n  }\n  result = FUN_08000c10(length);\n  result = FUN_08000e20(value2,result);\n  *(undefined4 *)(array + 0x1c) = result;\n  result = FUN_08000c10(length);\n  result = FUN_08000e20(value1,result);\n  *(undefined4 *)(array + 0x20) = result;\n  result = FUN_08000c10(length);\n  result = FUN_08000e20(average2,result);\n  *(undefined4 *)(array + 0x24) = result;\n  result = FUN_08000c10(length);\n  result = FUN_08000e20(average1,result);\n  *(undefined4 *)(array + 0x28) = result;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049cc": "calculate_averages_080049cc",
                "param_1": "array",
                "uVar1": "result",
                "local_2c": "sum1",
                "local_28": "sum2",
                "local_24": "getTime",
                "local_20": "length",
                "local_1c": "i",
                "local_18": "average1",
                "local_14": "average2",
                "local_10": "value1",
                "local_c": "value2"
            },
            "calling": [
                "FUN_0800491c"
            ],
            "called": [
                "FUN_08004d78",
                "FUN_08000e20",
                "FUN_08004ae0",
                "FUN_08000aa8",
                "FUN_08000c10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ae0": {
            "entrypoint": "0x08004ae0",
            "current_name": "initialize_param_array_08004ae0",
            "code": "\nvoid initializeParamArray_08004ae0(undefined4 *paramArray)\n\n{\n  undefined4 uVar1;\n  undefined byte1;\n  undefined byte2;\n  undefined byte3;\n  undefined byte4;\n  undefined byte5;\n  undefined byte6;\n  undefined byte7;\n  undefined byte8;\n  undefined byte9;\n  undefined byte10;\n  undefined byte11;\n  undefined byte12;\n  undefined byte13;\n  undefined byte14;\n  short short1;\n  short short2;\n  short short3;\n  short short4;\n  short short5;\n  short short6;\n  \n  (*DAT_20000a4c)(0xd0,0x3b,&byte1,0xe);\n  short6 = CONCAT11(byte3,byte4);\n  short5 = CONCAT11(byte5,byte6);\n  short4 = CONCAT11(byte7,byte8);\n  short3 = CONCAT11(byte9,byte10);\n  short2 = CONCAT11(byte11,byte12);\n  short1 = CONCAT11(byte13,byte14);\n  uVar1 = FUN_08000c10((int)CONCAT11(byte1,byte2));\n  *paramArray = uVar1;\n  uVar1 = FUN_08000c10((int)short6);\n  paramArray[1] = uVar1;\n  uVar1 = FUN_08000c10((int)short5);\n  paramArray[2] = uVar1;\n  uVar1 = FUN_08000c10((int)short4);\n  paramArray[3] = uVar1;\n  uVar1 = FUN_08000c10((int)short3);\n  paramArray[4] = uVar1;\n  uVar1 = FUN_08000c10((int)short2);\n  paramArray[5] = uVar1;\n  uVar1 = FUN_08000c10((int)short1);\n  paramArray[6] = uVar1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ae0": "initialize_param_array_08004ae0",
                "param_1": "paramArray",
                "local_2c": "byte1",
                "local_2b": "byte2",
                "local_2a": "byte3",
                "local_29": "byte4",
                "local_28": "byte5",
                "local_27": "byte6",
                "local_26": "byte7",
                "local_25": "byte8",
                "local_24": "byte9",
                "local_23": "byte10",
                "local_22": "byte11",
                "local_21": "byte12",
                "local_20": "byte13",
                "local_1f": "byte14",
                "local_1e": "short1",
                "local_1c": "short2",
                "local_1a": "short3",
                "local_18": "short4",
                "local_16": "short5",
                "local_14": "short6"
            },
            "calling": [
                "FUN_080049cc",
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000c10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bd8": {
            "entrypoint": "0x08004bd8",
            "current_name": "calculate_result_08004bd8",
            "code": "\nvoid calculateResult_08004bd8(int inputParam,undefined4 *outputParam)\n\n{\n  undefined4 result1;\n  undefined8 result2;\n  undefined8 result3;\n  \n  result1 = FUN_08000aa4(*(undefined4 *)(inputParam + 0x10),*(undefined4 *)(inputParam + 0x1c));\n  result2 = FUN_08000418(DAT_200009e4);\n  result3 = FUN_08000418(result1);\n  result3 = FUN_080004c8((int)result3,(int)((ulonglong)result3 >> 0x20),0x83f5c366,0x3f340215);\n  result2 = FUN_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                       (int)((ulonglong)result3 >> 0x20));\n  DAT_200009e4 = FUN_080009fc((int)result2,(int)((ulonglong)result2 >> 0x20));\n  result2 = FUN_08000418(*(undefined4 *)(inputParam + 4));\n  result2 = FUN_0800071c((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x40b00000);\n  result3 = FUN_08000418(*(undefined4 *)(inputParam + 8));\n  result3 = FUN_0800071c((int)result3,(int)((ulonglong)result3 >> 0x20),0,0x40b00000);\n  result2 = thunk_FUN_08005838((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                             (int)((ulonglong)result3 >> 0x20));\n  result2 = FUN_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x40668000);\n  result2 = FUN_0800071c((int)result2,(int)((ulonglong)result2 >> 0x20),0x54442d18,0x400921fb);\n  result3 = FUN_08000418(*(undefined4 *)(inputParam + 0x24));\n  result2 = FUN_08000158((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                       (int)((ulonglong)result3 >> 0x20));\n  result2 = FUN_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x40568000);\n  result1 = FUN_080009fc((int)result2,(int)((ulonglong)result2 >> 0x20));\n  if (DAT_20000005 == '\\0') {\n    result2 = FUN_08000418(DAT_200009e4);\n    result2 = FUN_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),0x9999999a,0x3fe99999);\n    result3 = FUN_08000418(result1);\n    result3 = FUN_080004c8((int)result3,(int)((ulonglong)result3 >> 0x20),0x9999999a,0x3fc99999);\n    result2 = FUN_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                         (int)((ulonglong)result3 >> 0x20));\n    DAT_200009e4 = FUN_080009fc((int)result2,(int)((ulonglong)result2 >> 0x20));\n  }\n  else {\n    DAT_20000005 = '\\0';\n    DAT_200009e4 = result1;\n  }\n  *outputParam = DAT_200009e4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bd8": "calculate_result_08004bd8",
                "param_1": "inputParam",
                "param_2": "outputParam",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "result3"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000aa4",
                "thunk_FUN_08005838",
                "FUN_0800015c",
                "FUN_080004c8",
                "FUN_080009fc",
                "FUN_08000418",
                "FUN_0800071c",
                "FUN_08000158"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d78": {
            "entrypoint": "0x08004d78",
            "current_name": "calculate_result_08004d78",
            "code": "\nvoid calculateResult_08004d78(undefined4 *inputValues,undefined4 *outputValue1,undefined4 *outputValue2)\n\n{\n  undefined4 result1;\n  undefined4 result2;\n  undefined4 result3;\n  undefined8 temp1;\n  undefined8 temp2;\n  \n  result1 = FUN_08000e20(*inputValues,0x45800000);\n  result2 = FUN_08000e20(inputValues[1],0x45800000);\n  result3 = FUN_08000e20(inputValues[2],0x45800000);\n  temp1 = FUN_08000418(result2);\n  temp2 = FUN_08000418(result3);\n  temp1 = thunk_FUN_08005838((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                             (int)((ulonglong)temp2 >> 0x20));\n  temp1 = FUN_080004c8((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40668000);\n  temp1 = FUN_0800071c((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x54442d18,0x400921fb);\n  result2 = FUN_080009fc((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  temp1 = FUN_08000418(result1);\n  temp2 = FUN_08000418(result3);\n  temp1 = thunk_FUN_08005838((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                             (int)((ulonglong)temp2 >> 0x20));\n  temp1 = FUN_080004c8((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40668000);\n  temp1 = FUN_0800071c((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x54442d18,0x400921fb);\n  result1 = FUN_080009fc((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  *outputValue1 = result2;\n  *outputValue2 = result1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d78": "calculate_result_08004d78",
                "param_1": "inputValues",
                "param_2": "outputValue1",
                "param_3": "outputValue2",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "result3",
                "uVar4": "temp1",
                "uVar5": "temp2"
            },
            "calling": [
                "FUN_080049cc"
            ],
            "called": [
                "FUN_08000e20",
                "thunk_FUN_08005838",
                "FUN_080004c8",
                "FUN_080009fc",
                "FUN_08000418",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e6c": {
            "entrypoint": "0x08004e6c",
            "current_name": "perform_system_call_08004e6c",
            "code": "\nvoid performSystemCall_08004e6c(void)\n\n{\n  triggerSoftInterrupt(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e6c": "perform_system_call_08004e6c",
                "software_interrupt": "triggerSoftInterrupt"
            },
            "calling": [
                "FUN_08004e74"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "initialize_data_08004e74",
            "code": "\nundefined4 initializeData_08004e74(undefined4 inputData)\n\n{\n  undefined4 returnValue;\n  \n  if (DAT_200009f0 == 0) {\n    returnValue = FUN_08004e6c(1,inputData,0);\n  }\n  else {\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "initialize_data_08004e74",
                "param_1": "inputData",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08004e6c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ea4": {
            "entrypoint": "0x08004ea4",
            "current_name": "initialize_data_08004ea4",
            "code": "\nvoid initializeData_08004ea4(undefined dataPointer1,undefined dataPointer2,undefined4 value,undefined2 length)\n\n{\n  FUN_08001ccc(&DAT_20000a88,dataPointer1,dataPointer2,1,value,length,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ea4": "initialize_data_08004ea4",
                "param_1": "dataPointer1",
                "param_2": "dataPointer2",
                "param_3": "value",
                "param_4": "length"
            },
            "calling": [],
            "called": [
                "FUN_08001ccc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "initialize_data_08004ee8",
            "code": "\nvoid initialize_data_08004ee8(undefined data_ptr,undefined buffer_ptr,undefined4 size,undefined2 flags)\n\n{\n  FUN_08001f6c(&DAT_20000a88,data_ptr,buffer_ptr,1,size,flags,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "initialize_data_08004ee8",
                "param_1": "data_ptr",
                "param_2": "buffer_ptr",
                "param_3": "size",
                "param_4": "flags"
            },
            "calling": [],
            "called": [
                "FUN_08001f6c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "initialize_application_08004f2c",
            "code": "\nundefined4 initializeApplication_08004f2c(void)\n\n{\n  undefined4 result;\n  \n  result = FUN_080015a0();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "initialize_application_08004f2c",
                "uVar1": "result"
            },
            "calling": [],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "initialize_data_08004f3c",
            "code": "\nvoid initializeData_08004f3c(undefined4 dataPointer,undefined2 value)\n\n{\n  FUN_08004436(&DAT_20000adc,dataPointer,value,0x32);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "initialize_data_08004f3c",
                "param_1": "dataPointer",
                "param_2": "value"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08004436"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "initialize_memory_08004f60",
            "code": "\nvoid initializeMemory_08004f60(void)\n\n{\n  FUN_08005d68(&DAT_20000ba8,0,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "initialize_memory_08004f60"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08005d68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f78": {
            "entrypoint": "0x08004f78",
            "current_name": "process_audio_08004f78",
            "code": "\nvoid processAudio_08004f78(void)\n\n{\n  undefined4 result;\n  int status;\n  undefined4 temp;\n  uint mask;\n  undefined8 pitch;\n  byte pitchValue;\n  \n  FUN_08004ae0(&DAT_20000a5c);\n  FUN_08004bd8(&DAT_20000a5c,&DAT_20000ba0);\n  FUN_08004f60();\n  pitch = FUN_08000418(DAT_20000ba0);\n  FUN_08005dfc(&DAT_20000ba8,\"Pitch: %f\\n\",(int)pitch,(int)((ulonglong)pitch >> 0x20));\n  result = FUN_08005e40(&DAT_20000ba8);\n  FUN_08004f3c(&DAT_20000ba8,result);\n  DAT_200009f8 = FUN_08000aa4(DAT_20000014,DAT_20000ba0);\n  DAT_20000be8 = FUN_08000cb8(DAT_20000a00,DAT_200009f8);\n  result = FUN_08000cb8(DAT_20000a04,DAT_200009f8);\n  DAT_20000b5c = FUN_08000aa8(result,DAT_20000b5c);\n  result = FUN_08000c10(DAT_20000010);\n  status = FUN_08000ff4(result,DAT_20000b5c);\n  if (status == 0) {\n    result = FUN_08000c10(DAT_200009f4);\n    status = FUN_08001030(result,DAT_20000b5c);\n    if (status != 0) {\n      DAT_20000b5c = FUN_08000c08(DAT_200009f4);\n    }\n  }\n  else {\n    DAT_20000b5c = FUN_08000c08(DAT_20000010);\n  }\n  mask = DAT_20000a08 ^ 0x80000000;\n  result = FUN_08000aa4(DAT_200009f8,DAT_200009fc);\n  DAT_20000a58 = FUN_08000cb8(mask,result);\n  result = FUN_08000aa8(DAT_20000be8,DAT_20000b5c);\n  result = FUN_08000aa8(result,DAT_20000a58);\n  temp = FUN_08000c10(DAT_20000010);\n  status = FUN_08001030(result,temp);\n  if (status == 0) {\n    temp = FUN_08000c10(DAT_200009f4);\n    status = FUN_08000ff4(result,temp);\n    if (status == 0) {\n      pitchValue = FUN_08001044(result);\n    }\n    else {\n      pitchValue = DAT_200009f4;\n    }\n  }\n  else {\n    pitchValue = DAT_20000010;\n  }\n  DAT_200009fc = DAT_200009f8;\n  status = FUN_08001030(DAT_200009f8,0);\n  FUN_08001a80(0x40010800,2,status != 0);\n  status = FUN_08001030(DAT_200009f8,0);\n  FUN_08001a80(0x40010800,4,status == 0);\n  status = FUN_08001030(DAT_200009f8,0);\n  FUN_08001a80(0x40010800,8,status != 0);\n  status = FUN_08001030(DAT_200009f8,0);\n  FUN_08001a80(0x40010800,0x10,status == 0);\n  *(uint *)(DAT_20000b1c + 0x34) = (uint)pitchValue;\n  *(uint *)(DAT_20000b1c + 0x40) = (uint)pitchValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f78": "process_audio_08004f78",
                "uVar1": "result",
                "iVar2": "status",
                "uVar3": "temp",
                "uVar4": "mask",
                "uVar5": "pitch",
                "local_11": "pitchValue"
            },
            "calling": [
                "FUN_080036f8",
                "FUN_080017b4"
            ],
            "called": [
                "FUN_08001044",
                "FUN_08004f60",
                "FUN_08005dfc",
                "FUN_08000cb8",
                "FUN_08001a80",
                "FUN_08004bd8",
                "FUN_08005e40",
                "FUN_08000c08",
                "FUN_08000aa4",
                "FUN_08000aa8",
                "FUN_08004ae0",
                "FUN_08000ff4",
                "FUN_08004f3c",
                "FUN_08000c10",
                "FUN_08001030",
                "FUN_08000418"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005224": {
            "entrypoint": "0x08005224",
            "current_name": "initialize_program_08005224",
            "code": "\nvoid initializeProgram_08005224(void)\n\n{\n  FUN_080014f0();\n  FUN_080052a0();\n  FUN_080055f4();\n  FUN_08005348();\n  FUN_08005598();\n  FUN_08005500();\n  FUN_080053b0();\n  DAT_20000a54 = 0x8004ea5;\n  DAT_20000a4c = 0x8004ee9;\n  DAT_20000a50 = 0x8004f2d;\n  FUN_080036a8(&DAT_20000b1c,0);\n  FUN_080036a8(&DAT_20000b1c,0xc);\n  FUN_0800491c(&DAT_20000a5c);\n  FUN_0800360c(&DAT_20000b60);\n  FUN_08004e74(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005224": "initialize_program_08005224"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_08005348",
                "FUN_0800360c",
                "FUN_08005598",
                "FUN_080052a0",
                "FUN_08004e74",
                "FUN_080036a8",
                "FUN_080055f4",
                "FUN_0800491c",
                "FUN_080014f0",
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052a0": {
            "entrypoint": "0x080052a0",
            "current_name": "initialize_application_080052a0",
            "code": "\nvoid initializeApplication_080052a0(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined4 mode;\n  undefined4 option;\n  undefined4 flag;\n  undefined4 count;\n  undefined4 index;\n  undefined4 isInitialized;\n  undefined4 value1;\n  undefined4 value2;\n  undefined4 value3;\n  undefined4 value4;\n  undefined4 value5;\n  undefined4 value6;\n  \n  isInitialized = 1;\n  value1 = 0x10000;\n  value2 = 0;\n  value3 = 1;\n  value4 = 2;\n  value5 = 0x10000;\n  value6 = 0x1c0000;\n  iVar1 = FUN_08002d98(&isInitialized);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x151);\n  }\n  mode = 0xf;\n  option = 2;\n  flag = 0x80;\n  count = 0;\n  index = 0;\n  iVar1 = FUN_08003260(&mode,2);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x15e);\n  }\n  uVar2 = FUN_08003504();\n  FUN_08001762((uint)uVar2 / 1000,(int)((ulonglong)uVar2 >> 0x20),(uint)uVar2 * 0x10624dd3);\n  FUN_0800177c(4);\n  FUN_0800172a(0xffffffff,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052a0": "initialize_application_080052a0",
                "local_44": "mode",
                "local_40": "option",
                "local_3c": "flag",
                "local_38": "count",
                "local_34": "index",
                "local_30": "isInitialized",
                "local_2c": "value1",
                "local_28": "value2",
                "local_20": "value3",
                "local_14": "value4",
                "local_10": "value5",
                "local_c": "value6"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_0800177c",
                "FUN_08003260",
                "FUN_08005674",
                "FUN_08001762",
                "FUN_0800172a",
                "FUN_08003504",
                "FUN_08002d98"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005348": {
            "entrypoint": "0x08005348",
            "current_name": "initialize_data_08005348",
            "code": "\nvoid initializeData_08005348(void)\n\n{\n  int result;\n  \n  DAT_20000a88 = 0x40005400;\n  DAT_20000a8c = 400000;\n  DAT_20000a90 = 0;\n  DAT_20000a94 = 0;\n  DAT_20000a98 = 0x4000;\n  DAT_20000a9c = 0;\n  DAT_20000aa0 = 0;\n  DAT_20000aa4 = 0;\n  DAT_20000aa8 = 0;\n  result = FUN_08001ab0(&DAT_20000a88);\n  if (result != 0) {\n    FUN_08005674(\"../src/main.c\",0x17a);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005348": "initialize_data_08005348",
                "iVar1": "result"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08001ab0",
                "FUN_08005674"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053b0": {
            "entrypoint": "0x080053b0",
            "current_name": "initialize_program_080053b0",
            "code": "\nvoid initializeProgram_080053b0(void)\n\n{\n  int iVar1;\n  undefined4 size1;\n  undefined4 size2;\n  undefined4 size3;\n  undefined4 size4;\n  undefined4 size5;\n  undefined4 size6;\n  undefined4 size7;\n  undefined4 size8;\n  undefined4 size9;\n  undefined4 size10;\n  undefined4 size11;\n  undefined4 size12;\n  undefined4 size13;\n  undefined4 size14;\n  undefined4 size15;\n  undefined4 size16;\n  undefined4 arrayOfSizes [4];\n  \n  DAT_20000b1c = 0x40012c00;\n  DAT_20000b20 = 0x708;\n  DAT_20000b24 = 0;\n  DAT_20000b28 = 100;\n  DAT_20000b2c = 0;\n  DAT_20000b30 = 0;\n  DAT_20000b34 = 0;\n  iVar1 = FUN_080035a4(&DAT_20000b1c);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",399);\n  }\n  arrayOfSizes[0] = 0x1000;\n  iVar1 = FUN_08003a94(&DAT_20000b1c,arrayOfSizes);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x194);\n  }\n  iVar1 = FUN_08003640(&DAT_20000b1c);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x198);\n  }\n  size15 = 0;\n  size16 = 0;\n  iVar1 = FUN_080042de(&DAT_20000b1c,&size15);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x19f);\n  }\n  size8 = 0x60;\n  size9 = 0;\n  size10 = 0;\n  size11 = 0;\n  size12 = 0;\n  size13 = 0;\n  size14 = 0;\n  iVar1 = FUN_08003908(&DAT_20000b1c,&size8,0);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x1ab);\n  }\n  iVar1 = FUN_08003908(&DAT_20000b1c,&size8,0xc);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x1b0);\n  }\n  size1 = 0;\n  size2 = 0;\n  size3 = 0;\n  size4 = 0;\n  size5 = 0;\n  size6 = 0x2000;\n  size7 = 0;\n  iVar1 = FUN_0800422e(&DAT_20000b1c,&size1);\n  if (iVar1 != 0) {\n    FUN_08005674(\"../src/main.c\",0x1bc);\n  }\n  FUN_08005680(&DAT_20000b1c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053b0": "initialize_program_080053b0",
                "local_58": "size1",
                "local_54": "size2",
                "local_50": "size3",
                "local_4c": "size4",
                "local_48": "size5",
                "local_44": "size6",
                "local_40": "size7",
                "local_3c": "size8",
                "local_38": "size9",
                "local_34": "size10",
                "local_30": "size11",
                "local_2c": "size12",
                "local_28": "size13",
                "local_24": "size14",
                "local_20": "size15",
                "local_1c": "size16",
                "local_18": "arrayOfSizes"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08003640",
                "FUN_08003908",
                "FUN_08005674",
                "FUN_0800422e",
                "FUN_08005680",
                "FUN_080035a4",
                "FUN_080042de",
                "FUN_08003a94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005500": {
            "entrypoint": "0x08005500",
            "current_name": "initialize_system_08005500",
            "code": "\nvoid initializeSystem_08005500(void)\n\n{\n  int errorCode;\n  undefined4 bufferSize;\n  undefined4 bytesRead;\n  undefined4 parameters [4];\n  \n  DAT_20000b60 = 0x40000000;\n  DAT_20000b64 = 36000;\n  DAT_20000b68 = 0;\n  DAT_20000b6c = 0x14;\n  DAT_20000b70 = 0;\n  DAT_20000b78 = 0;\n  errorCode = FUN_080035a4(&DAT_20000b60);\n  if (errorCode != 0) {\n    FUN_08005674(\"../src/main.c\",0x1d0);\n  }\n  parameters[0] = 0x1000;\n  errorCode = FUN_08003a94(&DAT_20000b60,parameters);\n  if (errorCode != 0) {\n    FUN_08005674(\"../src/main.c\",0x1d5);\n  }\n  bufferSize = 0x20;\n  bytesRead = 0;\n  errorCode = FUN_080042de(&DAT_20000b60,&bufferSize);\n  if (errorCode != 0) {\n    FUN_08005674(\"../src/main.c\",0x1dc);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005500": "initialize_system_08005500",
                "local_20": "bufferSize",
                "local_1c": "bytesRead",
                "local_18": "parameters",
                "iVar1": "errorCode"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08005674",
                "FUN_080035a4",
                "FUN_080042de",
                "FUN_08003a94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005598": {
            "entrypoint": "0x08005598",
            "current_name": "initialize_data_08005598",
            "code": "\nvoid initializeData_08005598(void)\n\n{\n  int result;\n  \n  DAT_20000adc = 0x40013800;\n  DAT_20000ae0 = 0x1c200;\n  DAT_20000ae4 = 0;\n  DAT_20000ae8 = 0;\n  DAT_20000aec = 0;\n  DAT_20000af0 = 0xc;\n  DAT_20000af4 = 0;\n  DAT_20000af8 = 0;\n  result = FUN_0800438a(&DAT_20000adc);\n  if (result != 0) {\n    FUN_08005674(\"../src/main.c\",0x1ed);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005598": "initialize_data_08005598",
                "iVar1": "result"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08005674",
                "FUN_0800438a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055f4": {
            "entrypoint": "0x080055f4",
            "current_name": "initialize_application_080055f4",
            "code": "\n\n\nvoid initializeApplication_080055f4(void)\n\n{\n  undefined4 local_18;\n  undefined4 local_14;\n  undefined4 local_c;\n  \n  _DAT_40021018 = _DAT_40021018 | 0x2c;\n  FUN_08001a80(0x40010800,0x1e,0,_DAT_40021018 & 8);\n  local_18 = 0x1e;\n  local_14 = 1;\n  local_c = 2;\n  FUN_080017c4(0x40010800,&local_18);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055f4": "initialize_application_080055f4"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_080017c4",
                "FUN_08001a80"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005674": {
            "entrypoint": "0x08005674",
            "current_name": "run_infinite_loop_08005674",
            "code": "\nvoid runInfiniteLoop_08005674(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005674": "run_infinite_loop_08005674"
            },
            "calling": [
                "FUN_08005348",
                "FUN_080052a0",
                "FUN_08005598",
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005680": {
            "entrypoint": "0x08005680",
            "current_name": "initialize_parameters_08005680",
            "code": "\nvoid initializeParameters_08005680(int *inputPtr)\n\n{\n  undefined4 value;\n  undefined4 count;\n  undefined4 index;\n  \n  if (*inputPtr == 0x40012c00) {\n    value = 0x900;\n    count = 2;\n    index = 2;\n    FUN_080017c4(0x40010800,&value);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005680": "initialize_parameters_08005680",
                "param_1": "inputPtr",
                "local_18": "value",
                "local_14": "count",
                "local_c": "index"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_080017c4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005704": {
            "entrypoint": "0x08005704",
            "current_name": "execute_initialization_08005704",
            "code": "\nvoid executeInitialization_08005704(void)\n\n{\n  FUN_0800157c();\n  FUN_080017b4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005704": "execute_initialization_08005704"
            },
            "calling": [],
            "called": [
                "FUN_0800157c",
                "FUN_080017b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "initialize_data_08005714",
            "code": "\nvoid initializeData_08005714(void)\n\n{\n  FUN_080036f8(&DAT_20000b60);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005714": "initialize_data_08005714"
            },
            "calling": [],
            "called": [
                "FUN_080036f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "allocate_memory_08005728",
            "code": "\nundefined * allocateMemory_08005728(int size)\n\n{\n  undefined4 *ptr;\n  undefined *result;\n  undefined tempStack [4];\n  int remainingSize;\n  undefined *currentPtr;\n  \n  if (DAT_20000a10 == (undefined *)0x0) {\n    DAT_20000a10 = &DAT_20000c18;\n  }\n  currentPtr = DAT_20000a10;\n  if (tempStack < DAT_20000a10 + size) {\n    remainingSize = size;\n    ptr = (undefined4 *)FUN_08005d14();\n    *ptr = 0xc;\n    result = (undefined *)0xffffffff;\n  }\n  else {\n    result = DAT_20000a10;\n    DAT_20000a10 = DAT_20000a10 + size;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005728": "allocate_memory_08005728",
                "param_1": "size",
                "puVar1": "ptr",
                "puVar2": "result",
                "auStack_18": "tempStack",
                "local_14": "remainingSize",
                "local_c": "currentPtr"
            },
            "calling": [
                "FUN_08009744"
            ],
            "called": [
                "FUN_08005d14"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005780": {
            "entrypoint": "0x08005780",
            "current_name": "initialize_memory_08005780",
            "code": "\n\n\nvoid initializeMemory_08005780(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005780": "initialize_memory_08005780"
            },
            "calling": [
                "entry"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "entry": {
            "entrypoint": "0x080057e8",
            "current_name": "entry",
            "code": "\nvoid entry(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (iVar1 = 0; (undefined4 *)(iVar1 + 0x20000000) < &DAT_200009c8; iVar1 = iVar1 + 4) {\n    *(undefined4 *)(iVar1 + 0x20000000) = *(undefined4 *)(iVar1 + 0x800a1a4);\n  }\n  for (puVar2 = &DAT_200009c8; puVar2 < &DAT_20000c14; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  FUN_08005780();\n  FUN_08005d20();\n  UNRECOVERED_JUMPTABLE = (code *)0x800581a;\n  FUN_08005224();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "FUN_08005224",
                "FUN_08005d20",
                "FUN_08005780"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_08005838": {
            "entrypoint": "0x08005834",
            "current_name": "calculate_result_thunk_08005838",
            "code": "\nuint calculate_result_thunk_08005838(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  int difference;\n  undefined4 result_upper;\n  uint flag;\n  uint param_4_modified;\n  uint param_2_modified;\n  undefined8 result;\n  \n  param_4_modified = input_4 & 0x7fffffff;\n  if ((0x7ff00000 < (param_4_modified | (-input_3 | input_3) >> 0x1f)) ||\n     (param_2_modified = input_2 & 0x7fffffff, 0x7ff00000 < (param_2_modified | (-input_1 | input_1) >> 0x1f))) {\n    param_4_modified = FUN_0800015c(input_3,input_4,input_1,input_2);\n    return param_4_modified;\n  }\n  if ((input_4 + 0xc0100000 | input_3) == 0) {\n    param_4_modified = FUN_080059f0();\n    return param_4_modified;\n  }\n  flag = (int)input_4 >> 0x1e & 2U | input_2 >> 0x1f;\n  if ((param_2_modified | input_1) == 0) {\n    if (flag == 2) {\n      return 0x54442d18;\n    }\n    if (flag != 3) {\n      return input_1;\n    }\n  }\n  else if ((param_4_modified | input_3) != 0) {\n    if (param_4_modified == 0x7ff00000) {\n      if (param_2_modified == 0x7ff00000) {\n        if (flag == 2) {\n          return 0x7f3321d2;\n        }\n        if (flag == 3) {\n          return 0x7f3321d2;\n        }\n        if (flag == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (flag == 2) {\n        return 0x54442d18;\n      }\n      if (flag != 3) {\n        if (flag != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (param_2_modified != 0x7ff00000) {\n      difference = (int)(param_2_modified - param_4_modified) >> 0x14;\n      if (difference < 0x3d) {\n        if (((int)input_4 < 0) && (difference + 0x3c < 0 != SCARRY4(difference,0x3c))) {\n          result = 0;\n        }\n        else {\n          FUN_0800071c(input_1,input_2,input_3,input_4,input_4);\n          FUNC_08005d0c();\n          result = FUN_080059f0();\n        }\n      }\n      else {\n        result = 0x3ff921fb54442d18;\n      }\n      result_upper = (undefined4)((ulonglong)result >> 0x20);\n      param_4_modified = (uint)result;\n      if (flag == 1) {\n        return param_4_modified;\n      }\n      if (flag == 2) {\n        result = FUN_08000158(param_4_modified,result_upper,0x33145c07,0x3ca1a626);\n        param_4_modified = FUN_08000158(0x54442d18,0x400921fb,(int)result,(int)((ulonglong)result >> 0x20));\n        return param_4_modified;\n      }\n      if (flag != 0) {\n        result = FUN_08000158(param_4_modified,result_upper,0x33145c07,0x3ca1a626);\n        param_4_modified = FUN_08000158((int)result,(int)((ulonglong)result >> 0x20),0x54442d18,0x400921fb);\n        return param_4_modified;\n      }\n      return param_4_modified;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "thunk_FUN_08005838": "calculate_result_thunk_08005838",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "difference",
                "uVar2": "result_upper",
                "uVar3": "flag",
                "uVar4": "param_4_modified",
                "uVar5": "param_2_modified",
                "uVar6": "result"
            },
            "calling": [
                "FUN_08004d78",
                "FUN_08004bd8"
            ],
            "called": [
                "FUN_08005838"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005838": {
            "entrypoint": "0x08005838",
            "current_name": "calculate_return_value_08005838",
            "code": "\nuint calculateReturnValue_08005838(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int tempVar1;\n  undefined4 tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  undefined8 tempVar6;\n  \n  tempVar4 = input4 & 0x7fffffff;\n  if ((0x7ff00000 < (tempVar4 | (-input3 | input3) >> 0x1f)) ||\n     (tempVar5 = input2 & 0x7fffffff, 0x7ff00000 < (tempVar5 | (-input1 | input1) >> 0x1f))) {\n    tempVar4 = FUN_0800015c(input3,input4,input1,input2);\n    return tempVar4;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    tempVar4 = FUN_080059f0();\n    return tempVar4;\n  }\n  tempVar3 = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((tempVar5 | input1) == 0) {\n    if (tempVar3 == 2) {\n      return 0x54442d18;\n    }\n    if (tempVar3 != 3) {\n      return input1;\n    }\n  }\n  else if ((tempVar4 | input3) != 0) {\n    if (tempVar4 == 0x7ff00000) {\n      if (tempVar5 == 0x7ff00000) {\n        if (tempVar3 == 2) {\n          return 0x7f3321d2;\n        }\n        if (tempVar3 == 3) {\n          return 0x7f3321d2;\n        }\n        if (tempVar3 == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (tempVar3 == 2) {\n        return 0x54442d18;\n      }\n      if (tempVar3 != 3) {\n        if (tempVar3 != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (tempVar5 != 0x7ff00000) {\n      tempVar1 = (int)(tempVar5 - tempVar4) >> 0x14;\n      if (tempVar1 < 0x3d) {\n        if (((int)input4 < 0) && (tempVar1 + 0x3c < 0 != SCARRY4(tempVar1,0x3c))) {\n          tempVar6 = 0;\n        }\n        else {\n          FUN_0800071c(input1,input2,input3,input4,input4);\n          FUNC_08005d0c();\n          tempVar6 = FUN_080059f0();\n        }\n      }\n      else {\n        tempVar6 = 0x3ff921fb54442d18;\n      }\n      tempVar2 = (undefined4)((ulonglong)tempVar6 >> 0x20);\n      tempVar4 = (uint)tempVar6;\n      if (tempVar3 == 1) {\n        return tempVar4;\n      }\n      if (tempVar3 == 2) {\n        tempVar6 = FUN_08000158(tempVar4,tempVar2,0x33145c07,0x3ca1a626);\n        tempVar4 = FUN_08000158(0x54442d18,0x400921fb,(int)tempVar6,(int)((ulonglong)tempVar6 >> 0x20));\n        return tempVar4;\n      }\n      if (tempVar3 != 0) {\n        tempVar6 = FUN_08000158(tempVar4,tempVar2,0x33145c07,0x3ca1a626);\n        tempVar4 = FUN_08000158((int)tempVar6,(int)((ulonglong)tempVar6 >> 0x20),0x54442d18,0x400921fb);\n        return tempVar4;\n      }\n      return tempVar4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "FUN_08005838": "calculate_return_value_08005838",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "uVar6": "tempVar6"
            },
            "calling": [
                "thunk_FUN_08005838"
            ],
            "called": [
                "FUN_08005d0c",
                "FUN_0800015c",
                "FUN_080059f0",
                "FUN_0800071c",
                "FUN_08000158"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f0": {
            "entrypoint": "0x080059f0",
            "current_name": "calculate_result_080059f0",
            "code": "\nundefined8 calculate_result_080059f0(int input_val_1,uint input_val_2,undefined4 unused_param_1,undefined4 unused_param_2)\n\n{\n  undefined4 result_1;\n  undefined4 result_2;\n  undefined4 result_3;\n  undefined4 result_4;\n  undefined4 result_5;\n  undefined4 result_6;\n  uint temp_val;\n  int control_var;\n  undefined8 temp_result_1;\n  undefined8 temp_result_2;\n  \n  temp_result_2 = CONCAT44(input_val_2,input_val_1);\n  temp_val = input_val_2 & 0x7fffffff;\n  if (temp_val < 0x44100000) {\n    if (temp_val < 0x3fdc0000) {\n      if (temp_val < 0x3e200000) {\n        temp_result_1 = FUN_0800015c(input_val_1,input_val_2,0x8800759c,0x7e37e43c,unused_param_2);\n        control_var = FUN_080009e8((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0,0x3ff00000);\n        if (control_var != 0) {\n          return CONCAT44(input_val_2,input_val_1);\n        }\n      }\n      control_var = -1;\n    }\n    else {\n      temp_result_2 = FUNC_08005d0c();\n      result_4 = (undefined4)((ulonglong)temp_result_2 >> 0x20);\n      result_1 = (undefined4)temp_result_2;\n      if (temp_val < 0x3ff30000) {\n        if (temp_val < 0x3fe60000) {\n          temp_result_2 = FUN_0800015c(result_1,result_4,result_1,result_4);\n          temp_result_2 = FUN_08000158((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0,0x3ff00000);\n          temp_result_1 = FUN_0800015c(result_1,result_4,0,0x40000000);\n          temp_result_2 = FUN_0800071c((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),(int)temp_result_1,\n                                (int)((ulonglong)temp_result_1 >> 0x20));\n          control_var = 0;\n        }\n        else {\n          temp_result_2 = FUN_08000158(result_1,result_4,0,0x3ff00000);\n          temp_result_1 = FUN_0800015c(result_1,result_4,0,0x3ff00000);\n          temp_result_2 = FUN_0800071c((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),(int)temp_result_1,\n                                (int)((ulonglong)temp_result_1 >> 0x20));\n          control_var = 1;\n        }\n      }\n      else if (temp_val < 0x40038000) {\n        temp_result_2 = FUN_08000158(result_1,result_4,0,0x3ff80000);\n        temp_result_1 = FUN_080004c8(result_1,result_4,0,0x3ff80000);\n        temp_result_1 = FUN_0800015c((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0,0x3ff00000);\n        temp_result_2 = FUN_0800071c((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),(int)temp_result_1,\n                              (int)((ulonglong)temp_result_1 >> 0x20));\n        control_var = 2;\n      }\n      else {\n        temp_result_2 = FUN_0800071c(0,0xbff00000,result_1,result_4);\n        control_var = 3;\n      }\n    }\n    result_6 = (undefined4)((ulonglong)temp_result_2 >> 0x20);\n    result_5 = (undefined4)temp_result_2;\n    temp_result_2 = FUN_080004c8(result_5,result_6,result_5,result_6);\n    result_2 = (undefined4)((ulonglong)temp_result_2 >> 0x20);\n    result_1 = (undefined4)temp_result_2;\n    temp_result_2 = FUN_080004c8(result_1,result_2,result_1,result_2);\n    result_3 = (undefined4)((ulonglong)temp_result_2 >> 0x20);\n    result_4 = (undefined4)temp_result_2;\n    temp_result_2 = FUN_080004c8(result_4,result_3,0xe322da11,0x3f90ad3a);\n    temp_result_2 = FUN_0800015c((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0x24760deb,0x3fa97b4b);\n    temp_result_2 = FUN_080004c8((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),result_4,result_3);\n    temp_result_2 = FUN_0800015c((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0xa0d03d51,0x3fb10d66);\n    temp_result_2 = FUN_080004c8((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),result_4,result_3);\n    temp_result_2 = FUN_0800015c((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0xc54c206e,0x3fb745cd);\n    temp_result_2 = FUN_080004c8((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),result_4,result_3);\n    temp_result_2 = FUN_0800015c((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0x920083ff,0x3fc24924);\n    temp_result_2 = FUN_080004c8((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),result_4,result_3);\n    temp_result_2 = FUN_0800015c((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0x5555550d,0x3fd55555);\n    temp_result_2 = FUN_080004c8((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),result_1,result_2);\n    temp_result_1 = FUN_080004c8(result_4,result_3,0x2c6a6c2f,0xbfa2b444);\n    temp_result_1 = FUN_08000158((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0x52defd9a,0x3fadde2d);\n    temp_result_1 = FUN_080004c8((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),result_4,result_3);\n    temp_result_1 = FUN_08000158((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    temp_result_1 = FUN_080004c8((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),result_4,result_3);\n    temp_result_1 = FUN_08000158((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0xfe231671,0x3fbc71c6);\n    temp_result_1 = FUN_080004c8((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),result_4,result_3);\n    temp_result_1 = FUN_08000158((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0x9998ebc4,0x3fc99999);\n    temp_result_1 = FUN_080004c8((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),result_4,result_3);\n    temp_result_2 = FUN_0800015c((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),(int)temp_result_1,\n                          (int)((ulonglong)temp_result_1 >> 0x20));\n    temp_result_2 = FUN_080004c8((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),result_5,result_6);\n    result_1 = (undefined4)((ulonglong)temp_result_2 >> 0x20);\n    if (control_var == -1) {\n      temp_result_2 = FUN_08000158(result_5,result_6,(int)temp_result_2,result_1);\n      return temp_result_2;\n    }\n    control_var = control_var * 8;\n    temp_result_2 = FUN_08000158((int)temp_result_2,result_1,*(undefined4 *)(&UNK_08009ee8 + control_var),\n                          *(undefined4 *)(&UNK_08009eec + control_var));\n    temp_result_2 = FUN_08000158((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),result_5,result_6);\n    temp_result_2 = FUN_08000158(*(undefined4 *)(&UNK_08009ec8 + control_var),\n                          *(undefined4 *)(&UNK_08009ecc + control_var),(int)temp_result_2,\n                          (int)((ulonglong)temp_result_2 >> 0x20));\n    if ((int)input_val_2 < 0) {\n      return CONCAT44((int)((ulonglong)temp_result_2 >> 0x20) + -0x80000000,(int)temp_result_2);\n    }\n  }\n  else {\n    if ((temp_val < 0x7ff00001) && ((temp_val != 0x7ff00000 || (input_val_1 == 0)))) {\n      result_1 = 0xbff921fb;\n      if (0 < (int)input_val_2) {\n        result_1 = 0x3ff921fb;\n      }\n      return CONCAT44(result_1,0x54442d18);\n    }\n    temp_result_2 = FUN_0800015c(input_val_1,input_val_2,input_val_1,input_val_2,unused_param_2);\n  }\n  return temp_result_2;\n}\n\n",
            "renaming": {
                "FUN_080059f0": "calculate_result_080059f0",
                "param_1": "input_val_1",
                "param_2": "input_val_2",
                "param_3": "unused_param_1",
                "param_4": "unused_param_2",
                "uVar1": "result_1",
                "uVar2": "result_2",
                "uVar3": "result_3",
                "uVar4": "result_4",
                "uVar5": "result_5",
                "uVar6": "result_6",
                "uVar7": "temp_val",
                "iVar8": "control_var",
                "uVar9": "temp_result_1",
                "uVar10": "temp_result_2"
            },
            "calling": [
                "FUN_08005838"
            ],
            "called": [
                "FUN_08005d0c",
                "FUN_080009e8",
                "FUN_0800015c",
                "FUN_080004c8",
                "FUN_0800071c",
                "FUN_08000158"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d0c": {
            "entrypoint": "0x08005d0c",
            "current_name": "FUNC_08005d0c",
            "code": "\nvoid FUNC_08005d0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d0c": "FUNC_08005d0c"
            },
            "calling": [
                "FUN_08005838",
                "FUN_080059f0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005d14": {
            "entrypoint": "0x08005d14",
            "current_name": "get_data_address_08005d14",
            "code": "\nundefined4 get_data_address_08005d14(void)\n\n{\n  return DAT_2000001c;\n}\n\n",
            "renaming": {
                "FUN_08005d14": "get_data_address_08005d14"
            },
            "calling": [
                "FUN_08005728"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d20": {
            "entrypoint": "0x08005d20",
            "current_name": "execute_functions_08005d20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005d2c) */\n/* WARNING: Removing unreachable block (ram,0x08005d2e) */\n\nvoid executeFunctions_08005d20(void)\n\n{\n  int iterationCount;\n  code **functionPointerArray;\n  \n  FUNC_08009e68();\n  iterationCount = 0;\n  functionPointerArray = (code **)&DAT_0800a198;\n  do {\n    iterationCount = iterationCount + 1;\n    (**functionPointerArray)();\n    functionPointerArray = functionPointerArray + 1;\n  } while (iterationCount != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d20": "execute_functions_08005d20",
                "iVar1": "iterationCount",
                "ppcVar2": "functionPointerArray"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_08009e68",
                "FUN_080078a0",
                "FUN_08000134"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d68": {
            "entrypoint": "0x08005d68",
            "current_name": "memset_08005d68",
            "code": "\nvoid memset_08005d68(undefined4 *dest,undefined value,uint size)\n\n{\n  undefined4 *dest_iter;\n  undefined4 *temp;\n  uint remaining_size;\n  undefined4 value_32bit;\n  bool is_zero;\n  \n  if (((uint)dest & 3) != 0) {\n    remaining_size = size - 1;\n    dest_iter = dest;\n    if (size == 0) {\n      return;\n    }\n    while( true ) {\n      dest = (undefined4 *)((int)dest_iter + 1);\n      *(undefined *)dest_iter = value;\n      size = remaining_size;\n      if (((uint)dest & 3) == 0) break;\n      is_zero = remaining_size == 0;\n      remaining_size = remaining_size - 1;\n      dest_iter = dest;\n      if (is_zero) {\n        return;\n      }\n    }\n  }\n  if (3 < size) {\n    value_32bit = CONCAT22(CONCAT11(value,value),CONCAT11(value,value));\n    remaining_size = size;\n    dest_iter = dest;\n    if (0xf < size) {\n      remaining_size = size - 0x10;\n      dest_iter = dest + 4;\n      do {\n        dest_iter[-4] = value_32bit;\n        dest_iter[-3] = value_32bit;\n        dest_iter[-2] = value_32bit;\n        dest_iter[-1] = value_32bit;\n        dest_iter = dest_iter + 4;\n      } while (dest_iter != (undefined4 *)((int)dest + (remaining_size & 0xfffffff0) + 0x20));\n      size = size & 0xf;\n      dest = dest + ((remaining_size >> 4) + 1) * 4;\n      remaining_size = size;\n      dest_iter = dest;\n      if (size < 4) goto end_loop;\n    }\n    do {\n      size = size - 4;\n      *dest = value_32bit;\n      dest = dest + 1;\n    } while (3 < size);\n    dest = (undefined4 *)((int)dest_iter + (remaining_size - 4 & 0xfffffffc) + 4);\n    size = remaining_size & 3;\n  }\nend_loop:\n  if (size != 0) {\n    dest_iter = dest;\n    do {\n      temp = (undefined4 *)((int)dest_iter + 1);\n      *(undefined *)dest_iter = value;\n      dest_iter = temp;\n    } while ((undefined4 *)(size + (int)dest) != temp);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d68": "memset_08005d68",
                "param_1": "dest",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "dest_iter",
                "puVar2": "temp",
                "uVar3": "remaining_size",
                "uVar4": "value_32bit",
                "bVar5": "is_zero",
                "LAB_08005de4": "end_loop"
            },
            "calling": [
                "FUN_08004f60",
                "FUN_08009980"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dfc": {
            "entrypoint": "0x08005dfc",
            "current_name": "initialize_data_08005dfc",
            "code": "\nvoid initializeData_08005dfc(undefined *dataPtr,undefined4 value1,undefined4 value2,undefined4 value3)\n\n{\n  undefined *dataArray [2];\n  undefined4 maxValue1;\n  undefined4 initValue;\n  undefined *currentDataPtr;\n  undefined4 maxValue2;\n  undefined4 value2Copy;\n  undefined4 value3Copy;\n  \n  maxValue2 = 0x7fffffff;\n  maxValue1 = 0x7fffffff;\n  initValue = 0xffff0208;\n  dataArray[0] = dataPtr;\n  currentDataPtr = dataPtr;\n  value2Copy = value2;\n  value3Copy = value3;\n  FUNC_08005e9c(DAT_2000001c,dataArray,value1,&value2Copy);\n  *dataArray[0] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005dfc": "initialize_data_08005dfc",
                "param_1": "dataPtr",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3",
                "local_80": "dataArray",
                "local_78": "maxValue1",
                "uStack_74": "initValue",
                "local_70": "currentDataPtr",
                "local_6c": "maxValue2",
                "uStack_8": "value2Copy",
                "uStack_4": "value3Copy"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08005e9c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e40": {
            "entrypoint": "0x08005e40",
            "current_name": "count_leading_zeros_08005e40",
            "code": "\nint countLeadingZeros_08005e40(uint input)\n\n{\n  int count;\n  uint *data;\n  uint mask;\n  \n  data = (uint *)(input & 0xfffffffc);\n  count = -(input & 3);\n  mask = *data;\n  if ((input & 3) != 0) {\n    mask = mask | 0xffffffffU >> ((count + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    data = data + 1;\n    mask = mask + 0xfefefeff & ~mask & 0x80808080;\n    if (mask != 0) break;\n    mask = *data;\n    count = count + 4;\n  }\n  return count + (0x1fU - LZCOUNT(mask & -mask) >> 3);\n}\n\n",
            "renaming": {
                "FUN_08005e40": "count_leading_zeros_08005e40",
                "param_1": "input",
                "iVar1": "count",
                "puVar2": "data",
                "uVar3": "mask"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e9c": {
            "entrypoint": "0x08005e9c",
            "current_name": "FUNC_08005e9c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  int iVar8;\n  int *piVar9;\n  undefined4 uVar10;\n  int **ppiVar11;\n  undefined uVar12;\n  ushort uVar13;\n  int **ppiVar14;\n  byte **ppbVar15;\n  int *piVar16;\n  int **ppiVar17;\n  char *pcVar18;\n  uint uVar19;\n  undefined *puVar20;\n  int *piVar21;\n  int *piVar22;\n  int *piVar23;\n  int *piVar24;\n  int *piVar25;\n  byte *pbVar26;\n  int *piVar27;\n  int *piVar28;\n  undefined4 *puVar29;\n  byte *pbVar30;\n  bool bVar31;\n  longlong lVar32;\n  undefined8 uVar33;\n  undefined8 uVar34;\n  undefined4 local_188;\n  int *piStack_184;\n  int **local_180;\n  undefined *puStack_17c;\n  int **local_178;\n  undefined4 *local_16c;\n  int *local_168;\n  byte *local_164;\n  int *local_160;\n  int *local_15c;\n  char *local_158;\n  int **local_154;\n  undefined8 local_150;\n  int *local_148;\n  int *local_144;\n  int *local_140;\n  int **local_13c;\n  int *local_138;\n  int *local_134;\n  int *local_130;\n  uint local_12c;\n  undefined4 local_128;\n  undefined4 local_124;\n  undefined4 local_120;\n  char *local_11c;\n  int *local_118;\n  int *local_114;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  int *local_100;\n  int *local_fc;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0;\n  undefined auStack_ec [4];\n  char local_e8;\n  undefined local_e7;\n  char local_e6 [6];\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int *local_d4;\n  int *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  local_16c = param_1;\n  local_160 = param_2;\n  local_154 = param_4;\n  ppiVar2 = (int **)FUN_08008ad4();\n  local_114 = *ppiVar2;\n  local_118 = (int *)FUN_08005e40(local_114);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar3 = FUN_08008af8(local_16c,0x40);\n    *local_160 = iVar3;\n    local_160[4] = iVar3;\n    if (iVar3 == 0) {\n      *local_16c = 0xc;\n      return (byte *)0xffffffff;\n    }\n    local_160[5] = 0x40;\n  }\n  local_128 = 0;\n  local_138 = (int *)0x0;\n  local_12c = 0;\n  local_d4 = (int *)0x0;\n  local_d0 = (int *)0x0;\n  local_11c = (char *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  local_124 = 0;\n  local_120 = 0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = local_164 + (int)piVar27;\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    piVar25 = (int *)0x0;\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    puVar29 = local_16c;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    switch(piVar24) {\n    case (int *)0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (piVar24 == (int *)0x0) goto LAB_08006216;\n      piVar16 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_158 = (char *)0x1;\n      piVar23 = (int *)&local_8c;\n      piVar22 = piVar16;\n      local_8c = (char)piVar24;\n      goto LAB_08006298;\n    case (int *)0x23:\n      piVar25 = (int *)((uint)piVar25 | 1);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x27:\n      iVar3 = FUN_08008ad4(local_16c);\n      local_110 = *(int **)(iVar3 + 4);\n      piVar24 = (int *)FUN_08005e40(local_110);\n      local_104 = piVar24;\n      iVar3 = FUN_08008ad4(puVar29);\n      local_108 = *(byte **)(iVar3 + 8);\n      if (piVar24 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 0x400);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2a:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2b:\n      local_f5 = 0x2b;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x2d:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\nLAB_08006602:\n      piVar25 = (int *)((uint)piVar25 | 4);\n      goto LAB_08005f4a;\n    case (int *)0x2e:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x2a) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (piVar24 + -0xc < (int *)0xa) {\n        piVar27 = (int *)((int)(piVar24 + -0xc) + (int)piVar27 * 10);\n        piVar24 = (int *)(uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case (int *)0x30:\n      piVar25 = (int *)((uint)piVar25 | 0x80);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x31:\n    case (int *)0x32:\n    case (int *)0x33:\n    case (int *)0x34:\n    case (int *)0x35:\n    case (int *)0x36:\n    case (int *)0x37:\n    case (int *)0x38:\n    case (int *)0x39:\n      goto switchD_08005f58_caseD_31;\n    case (int *)0x41:\n    case (int *)0x45:\n    case (int *)0x46:\n    case (int *)0x47:\n    case (int *)0x61:\n    case (int *)0x65:\n    case (int *)0x66:\n    case (int *)0x67:\n      puVar29 = (undefined4 *)((int)local_154 + 7U & 0xfffffff8);\n      uVar10 = *puVar29;\n      local_12c = puVar29[1];\n      local_168 = (int *)(local_12c & 0x7fffffff);\n      local_154 = (int **)(puVar29 + 2);\n      local_128 = uVar10;\n      iVar3 = FUN_08001170(uVar10,local_168,0xffffffff,0x7fefffff);\n      if ((iVar3 == 0) && (iVar3 = FUN_080009c0(uVar10,local_168,0xffffffff,0x7fefffff), iVar3 == 0)\n         ) {\n        iVar3 = FUN_080009ac(local_128,local_12c,local_124,local_120);\n        if (iVar3 == 0) {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        piVar23 = (int *)&UNK_08009f10;\n        piVar27 = (int *)&UNK_08009f0c;\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (piVar24 < (int *)0x48) {\n          piVar23 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar25 = (int *)((uint)piVar25 & 0xffffff7f);\n        local_158 = (char *)0x3;\n        local_13c = (int **)0x0;\n        piVar22 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      iVar3 = FUN_08001170(local_128,local_12c,local_128,local_12c);\n      if (iVar3 != 0) {\n        if ((int)local_12c < 0) {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        piVar23 = (int *)&UNK_08009f18;\n        piVar27 = (int *)&UNK_08009f14;\n        goto LAB_08006524;\n      }\n      if (piVar24 == (int *)0x61) {\n        uVar12 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar12,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          piVar25 = (int *)((uint)piVar25 | 2);\n        }\n        else {\n          param_3 = (int *)FUN_08008af8(local_16c,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar13 = *(ushort *)(local_160 + 3) | 0x40;\n            *(ushort *)(local_160 + 3) = uVar13;\n            goto LAB_0800604e;\n          }\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          piVar25 = (int *)((uint)piVar25 | 2);\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = (int *)0x2d;\n          uVar19 = local_12c + 0x80000000;\n        }\n        else {\n          local_144 = (int *)0x0;\n          uVar19 = local_12c;\n        }\n        local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n        piVar22 = piVar27;\n        local_158 = (char *)local_128;\n        if (piVar24 == (int *)0x61) {\n          uVar33 = FUN_080096e0(local_128,uVar19,&local_f0);\n          local_150 = FUN_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = FUN_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 != 0) {\n            local_f0 = (int *)0x1;\n          }\n          local_158 = \"0123456789abcdef\";\n          local_13c = ppiVar2;\n          local_138 = piVar28;\n          local_134 = piVar24;\n          local_130 = piVar27;\n          local_100 = piVar25;\n          local_fc = param_3;\n          pcVar18 = local_158;\n          uVar33 = local_150;\n          goto LAB_080072ba;\n        }\n        if (piVar24 == (int *)0x41) {\n          uVar33 = FUN_080096e0(local_128,uVar19,&local_f0);\n          local_150 = FUN_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = FUN_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 == 0) {\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          else {\n            local_f0 = (int *)0x1;\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (piVar24 == (int *)0x41) {\n          uVar12 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = (int *)((uint)piVar25 | 0x100);\n        local_148 = (int *)0x0;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar27 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if (((uint)piVar24 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar27 = (int *)0x1;\n            local_148 = (int *)0x0;\n          }\n          goto LAB_0800724a;\n        }\n        if ((int)local_12c < 0) goto LAB_08007414;\n        local_144 = (int *)0x0;\n        uVar19 = local_12c;\n      }\n      local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n      piStack_184 = piVar27;\n      local_158 = (char *)local_128;\n      if (piVar24 == (int *)0x66) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)FUN_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar22 = (int *)((int)piVar23 + (int)piVar27);\n        local_150._0_4_ = piVar27;\nLAB_0800764c:\n        if ((*(byte *)piVar23 == 0x30) &&\n           (iVar3 = FUN_08000998(local_158,uVar19,local_124,local_120), iVar3 == 0)) {\n          local_f0 = (int *)(1 - (int)(int *)local_150);\n        }\n        piVar22 = (int *)((int)piVar22 + (int)local_f0);\n      }\n      else if (piVar24 == (int *)0x46) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)FUN_080079e8(local_16c,local_180,local_128,uVar19);\n        local_150._0_4_ = piVar27;\nLAB_08007760:\n        piVar22 = (int *)((int)piVar23 + (int)(int *)local_150);\n        if (piVar24 == (int *)0x46) goto LAB_0800764c;\n      }\n      else {\n        local_178 = &local_e0;\n        local_150._0_4_ = piVar27;\n        if (local_168 == (int *)0x45) {\n          local_150._0_4_ = (int *)((int)piVar27 + 1);\n        }\n        local_188 = 2;\n        piStack_184 = (int *)local_150;\n        local_180 = &local_f0;\n        puStack_17c = auStack_ec;\n        piVar23 = (int *)FUN_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar16 = local_e0;\n        if (piVar24 == (int *)0x67) {\n          if (((uint)piVar25 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (piVar24 == (int *)0x47) {\n          if (((uint)piVar25 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar22 = (int *)((int)(int *)local_150 + (int)piVar23);\n      }\n      iVar3 = FUN_08000998(local_158,uVar19,local_124,local_120);\n      piVar16 = piVar22;\n      if (iVar3 == 0) {\n        for (; piVar16 = local_e0, local_e0 < piVar22; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)piVar16 - (int)piVar23);\n      goto LAB_08006cb0;\n    case (int *)0x43:\n    case (int *)0x63:\n      piVar16 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar22 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (char *)0x1;\n      local_8c = SUB41(piVar27,0);\n      piVar23 = (int *)&local_8c;\n      goto LAB_08006298;\n    case (int *)0x44:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_08006102;\n    case (int *)0x4c:\n      piVar25 = (int *)((uint)piVar25 | 8);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x4f:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n    case (int *)0x6f:\n      if (((uint)piVar25 & 0x20) == 0) {\n        ppiVar14 = local_154 + 1;\n        if (((uint)piVar25 & 0x10) == 0) {\n          if (((uint)piVar25 & 0x40) == 0) {\n            if (((uint)piVar25 & 0x200) == 0) goto LAB_08006be2;\n            piVar22 = (int *)(uint)*(byte *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n          else {\n            piVar22 = (int *)(uint)*(ushort *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar22 = *local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\n        ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar22 = *ppiVar14;\n        piVar16 = ppiVar14[1];\n        local_154 = ppiVar14 + 2;\n      }\n      iVar3 = 0;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n      break;\n    case (int *)0x53:\n    case (int *)0x73:\n      local_f5 = 0;\n      piVar23 = *local_154;\n      ppiVar14 = local_154 + 1;\n      if (piVar23 == (int *)0x0) {\n        if ((int *)0x5 < piVar27) {\n          piVar27 = (int *)0x6;\n        }\n        piVar23 = (int *)&UNK_08009f44;\n        piVar16 = (int *)0x0;\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar22 = (int *)0x0;\n        local_168 = piVar27;\n        local_158 = (char *)piVar27;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (piVar27 == (int *)0xffffffff) {\n          local_158 = (char *)FUN_08005e40(piVar23);\n        }\n        else {\n          iVar3 = FUN_0800901c(piVar23,0,piVar27);\n          if (iVar3 == 0) {\n            piVar16 = (int *)(uint)local_f5;\n            local_148 = (int *)0x0;\n            local_13c = (int **)0x0;\n            local_134 = (int *)0x0;\n            local_130 = (int *)0x0;\n            piVar22 = (int *)0x0;\n            local_168 = piVar27;\n            local_158 = (char *)piVar27;\n            local_154 = ppiVar14;\n            goto LAB_08006538;\n          }\n          local_158 = (char *)(iVar3 - (int)piVar23);\n        }\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar16 = (int *)(uint)local_f5;\n        piVar22 = (int *)0x0;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        local_154 = ppiVar14;\n      }\n      goto LAB_08006538;\n    case (int *)0x55:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      iVar3 = 1;\n      local_154 = ppiVar14 + 2;\n      break;\n    case (int *)0x58:\n      local_11c = \"0123456789ABCDEF\";\n      if (((uint)piVar25 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_080061be;\n    case (int *)0x64:\n    case (int *)0x69:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bcc:\n        piVar22 = *local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(int)*(short *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bcc;\n        piVar22 = (int *)(int)*(char *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\nLAB_08006102:\n      if ((int)piVar16 < 0) {\n        bVar31 = piVar22 != (int *)0x0;\n        piVar22 = (int *)-(int)piVar22;\n        piVar16 = (int *)(-(int)piVar16 - (uint)bVar31);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar3 = 1;\n        iVar8 = 1;\n        piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n        if (((uint)piVar22 | (uint)piVar16) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      piVar21 = piVar25;\n      if (piVar16 != (int *)0x0 || (int *)0x9 < piVar22) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case (int *)0x68:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x68) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar25 = (int *)((uint)piVar25 | 0x200);\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        piVar25 = (int *)((uint)piVar25 | 0x40);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x6a:\n    case (int *)0x71:\n      piVar25 = (int *)((uint)piVar25 | 0x20);\n    case (int *)0x74:\n    case (int *)0x7a:\nswitchD_08005f58_caseD_74:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case (int *)0x6e:\n      ppiVar14 = local_154 + 1;\n      ppbVar15 = (byte **)*local_154;\n      local_154 = ppiVar14;\n      if (((uint)piVar25 & 0x20) != 0) {\n        *ppbVar15 = local_164;\n        ppbVar15[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) != 0) {\n          *(short *)ppbVar15 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if (((uint)piVar25 & 0x200) != 0) {\n          *(char *)ppbVar15 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar15 = local_164;\n      goto LAB_0800620e;\n    case (int *)0x70:\n      local_f4 = 0x7830;\n      piVar22 = *local_154;\n      local_11c = \"0123456789abcdef\";\n      piVar25 = (int *)((uint)piVar25 | 2);\n      piVar16 = (int *)0x0;\n      iVar3 = 2;\n      piVar24 = (int *)0x78;\n      local_154 = local_154 + 1;\n      break;\n    case (int *)0x75:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bf2:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(uint)*(ushort *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bf2;\n        piVar22 = (int *)(uint)*(byte *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      break;\n    case (int *)0x78:\n      local_11c = \"0123456789abcdef\";\n      if (((uint)piVar25 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar14 = local_154 + 1;\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) == 0) {\n          if (((uint)piVar25 & 0x200) == 0) goto LAB_08006bbc;\n          piVar22 = (int *)(uint)*(byte *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n        else {\n          piVar22 = (int *)(uint)*(ushort *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        local_154 = ppiVar14;\n      }\nLAB_080061be:\n      if ((((uint)piVar25 & 1) != 0) && (((uint)piVar22 | (uint)piVar16) != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 2);\n        local_f4 = CONCAT11((char)piVar24,0x30);\n      }\n      iVar3 = 2;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      if (iVar3 != 1) goto LAB_08006136;\nLAB_08006980:\n      piVar21 = piVar25;\n      if (piVar16 == (int *)0x0 && piVar22 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar32 = CONCAT44(piVar16,piVar22);\n      piVar23 = (int *)(&bStack_2a + 2);\n      piVar22 = (int *)0x0;\n      pbVar26 = local_108;\n      local_168 = piVar23;\n      local_158 = (char *)ppiVar2;\n      local_150._0_4_ = piVar25;\n      local_148 = piVar24;\n      do {\n        iVar3 = (int)((ulonglong)lVar32 >> 0x20);\n        uVar19 = (uint)lVar32;\n        cVar6 = '\\n';\n        FUN_080011ec(uVar19,iVar3,10,0);\n        *(byte *)((int)piVar23 + -1) = cVar6 + 0x30;\n        piVar22 = (int *)((int)piVar22 + 1);\n        piVar23 = (int *)((int)piVar23 + -1);\n        if ((((((uint)piVar25 & 0x400) != 0) && (piVar22 == (int *)(uint)*pbVar26)) &&\n            (piVar22 != (int *)0xff)) && (iVar3 != 0 || 9 < uVar19)) {\n          piVar23 = (int *)((int)piVar23 - (int)local_104);\n          FUN_08009768(piVar23,local_110,local_104);\n          if (pbVar26[1] == 0) {\n            piVar22 = (int *)0x0;\n          }\n          else {\n            pbVar26 = pbVar26 + 1;\n            piVar22 = (int *)0x0;\n          }\n        }\n        lVar32 = FUN_080011ec(uVar19,iVar3,10,0);\n      } while (lVar32 != 0);\n      piVar24 = local_148;\n      piVar25 = (int *)local_150;\n      ppiVar2 = (int **)local_158;\n      local_158 = (char *)((int)local_168 - (int)piVar23);\n      local_138 = piVar22;\n      local_108 = pbVar26;\n    }\n    else {\n      piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n      iVar8 = iVar3;\n      if (((uint)piVar22 | (uint)piVar16) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar3 == 0) {\n            local_158 = (char *)((uint)piVar25 & 1);\n            if ((int *)local_158 == (int *)0x0) {\n              piVar23 = (int *)(&bStack_2a + 2);\n              piVar25 = piVar21;\n            }\n            else {\n              piVar23 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n              piVar25 = piVar21;\n            }\n          }\n          else {\n            piVar23 = (int *)(&bStack_2a + 2);\n            piVar25 = piVar21;\n            local_158 = (char *)piVar27;\n          }\n        }\n        else {\n          piVar25 = piVar21;\n          if (iVar3 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar22 + '0';\n          piVar23 = (int *)(&bStack_2a + 1);\n          local_158 = (char *)0x1;\n          piVar25 = piVar21;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar3 = iVar8;\n        piVar25 = piVar21;\n        if (iVar8 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar3 == 2) {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = (int *)((uint)piVar22 >> 4 | (int)piVar16 << 0x1c);\n            piVar16 = (int *)((uint)piVar16 >> 4);\n            piVar23 = (int *)((int)piVar23 + -1);\n            *(char *)piVar23 = local_11c[(uint)piVar22 & 0xf];\n            piVar22 = piVar21;\n          } while (((uint)piVar21 | (uint)piVar16) != 0);\n        }\n        else {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = piVar23;\n            piVar9 = (int *)((uint)piVar22 >> 3 | (int)piVar16 << 0x1d);\n            piVar16 = (int *)((uint)piVar16 >> 3);\n            iVar3 = ((uint)piVar22 & 7) + 0x30;\n            *(byte *)((int)piVar21 + -1) = (byte)iVar3;\n            piVar23 = (int *)((int)piVar21 + -1);\n            piVar22 = piVar9;\n          } while (((uint)piVar9 | (uint)piVar16) != 0);\n          if ((((uint)piVar25 & 1) != 0) && (iVar3 != 0x30)) {\n            piVar23 = (int *)((int)piVar21 + -2);\n            *(byte *)((int)piVar21 + -2) = 0x30;\n            local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  piVar28 = local_160;\n  if (local_d0 == (int *)0x0) {\nLAB_0800604a:\n    uVar13 = *(ushort *)(local_160 + 3);\n  }\n  else {\n    FUN_080097cc(local_16c,local_160,&local_d8);\n    uVar13 = *(ushort *)(piVar28 + 3);\n  }\nLAB_0800604e:\n  if ((uVar13 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (piVar24 == (int *)0x6c) {\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    piVar25 = (int *)((uint)piVar25 | 0x20);\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    piVar25 = (int *)((uint)piVar25 | 0x10);\n  }\n  goto LAB_08005f4a;\n  while( true ) {\n    iVar8 = FUN_08000998((int)uVar33,uVar10,local_124,local_120);\n    if (iVar8 != 0) break;\nLAB_080072ba:\n    piVar16 = param_3;\n    piVar22 = (int *)((int)piVar22 + -1);\n    uVar33 = FUN_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x40300000);\n    iVar3 = FUN_0800119c();\n    uVar34 = FUN_080003f4();\n    uVar33 = FUN_08000158((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar34,\n                          (int)((ulonglong)uVar34 >> 0x20));\n    uVar10 = (undefined4)((ulonglong)uVar33 >> 0x20);\n    param_3 = (int *)((int)piVar16 + 1);\n    *(char *)piVar16 = pcVar18[iVar3];\n    if (piVar22 == (int *)0xffffffff) break;\n  }\n  piVar23 = local_fc;\n  piVar25 = local_100;\n  piVar27 = local_130;\n  piVar24 = local_134;\n  piVar28 = local_138;\n  ppiVar2 = local_13c;\n  local_13c = (int **)piVar22;\n  local_134 = piVar16;\n  local_150 = uVar33;\n  iVar8 = FUN_080009e8((int)uVar33,uVar10,0,0x3fe00000);\n  if (iVar8 == 0) {\n    iVar8 = FUN_08000998((int *)local_150,local_150._4_4_,0,0x3fe00000);\n    if ((iVar8 != 0) && (iVar3 << 0x1f < 0)) goto LAB_0800748a;\n    if (-1 < (int)local_13c) {\n      piVar16 = (int *)((byte *)((int)local_13c + 1) + (int)param_3);\n      piVar22 = param_3;\n      do {\n        param_3 = (int *)((int)piVar22 + 1);\n        *(byte *)piVar22 = 0x30;\n        piVar22 = param_3;\n      } while (piVar16 != param_3);\n    }\n  }\n  else {\nLAB_0800748a:\n    bVar1 = local_158[0xf];\n    bVar7 = *(byte *)piVar16;\n    piVar22 = param_3;\n    local_e0 = local_134;\n    while (bVar1 == bVar7) {\n      *(byte *)((int)piVar22 + -1) = 0x30;\n      bVar7 = *(byte *)((int)local_e0 + -1);\n      piVar22 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar7 == 0x39) {\n      bVar7 = local_158[10];\n    }\n    else {\n      bVar7 = bVar7 + 1;\n    }\n    *(byte *)((int)piVar22 + -1) = bVar7;\n  }\n  local_138 = (int *)((int)param_3 - (int)piVar23);\nLAB_08006cb0:\n  local_134 = local_f0;\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0 + 3) < 0 == SCARRY4((int)local_f0,3)) &&\n       ((int)local_f0 <= (int)piVar27)) {\n      if ((int)local_f0 < (int)local_138) {\n        local_158 = (char *)((int)local_138 + (int)local_118);\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (char *)((int)local_158 + (1 - (int)local_f0));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        piVar24 = (int *)0x67;\n      }\n      else {\n        if ((int)piVar25 << 0x1f < 0) {\n          local_158 = (char *)((int)local_f0 + (int)local_118);\n        }\n        else {\n          local_158 = (char *)local_f0;\n        }\n        if (-1 < (int)piVar25 << 0x15) {\n          piVar24 = (int *)0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074fc;\n        }\n        piVar24 = (int *)0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    piVar24 = (int *)((int)piVar24 + -2);\n    local_168 = (int *)((uint)piVar24 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8 = (char)piVar24;\n    if (local_168 == (int *)0x41) {\n      local_e8 = local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0 + -1);\n    if ((int)piVar27 < 0) {\n      local_e7 = 0x2d;\n      local_f0 = (int *)(1 - (int)local_f0);\n    }\n    else {\n      local_e7 = 0x2b;\n      local_f0 = piVar27;\n    }\n    if ((int)local_f0 < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e6[0] = 0x30;\n        pcVar18 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar18 = (char)local_f0 + '0';\n      pcVar18 = pcVar18 + 1;\n    }\n    else {\n      pbVar30 = abStack_dc + 3;\n      pbVar26 = pbVar30;\n      do {\n        pbVar5 = pbVar26;\n        piVar22 = (int *)((uint)local_f0 / 10);\n        pbVar5[-1] = (char)local_f0 + (char)piVar22 * -10 + 0x30;\n        pbVar26 = pbVar5 + -1;\n        local_f0 = piVar22;\n      } while ((int *)0x9 < piVar22);\n      uVar19 = (uint)(piVar22 + 0xc) & 0xff;\n      pbVar5[-2] = (byte)uVar19;\n      if (pbVar5 + -2 < pbVar30) {\n        pbVar5 = pbVar26;\n        puVar20 = (undefined *)((int)&local_e8 + 2);\n        while( true ) {\n          *puVar20 = (char)uVar19;\n          if (pbVar30 == pbVar5) break;\n          uVar19 = (uint)*pbVar5;\n          pbVar5 = pbVar5 + 1;\n          puVar20 = puVar20 + 1;\n        }\n        pcVar18 = (char *)(((int)&local_188 * 2 - (int)pbVar26) + 0x152);\n      }\n      else {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar18 + -(int)&local_e8);\n    local_158 = (char *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)piVar25 << 0x1f < 0)) {\n      local_158 = (char *)((int)local_158 + (int)local_118);\n    }\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    piVar25 = (int *)((uint)piVar25 & 0xfffffbff | 0x100);\n    local_f0 = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0 < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_168 = (int *)0x1;\n        local_158 = (char *)0x1;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_118 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      piVar25 = local_140;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)local_f0;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_f0 + (int)local_118) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)piVar25 << 0x15) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      uVar19 = (uint)*local_108;\n      while (uVar19 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar19) goto LAB_08007524;\n          uVar4 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar19);\n          if (uVar4 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = (int *)((int)local_130 + 1);\n          uVar19 = uVar4;\n          if (uVar4 == 0xff) goto LAB_08007524;\n        }\n        local_13c = (int **)((int)local_13c + 1);\n      }\nLAB_08007524:\n      local_158 = (char *)((int)local_158 + (int)local_104 * ((int)local_130 + (int)local_13c));\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      piVar25 = local_140;\n    }\n  }\n  if (local_144 == (int *)0x0) {\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = (int *)0x0;\nLAB_08006538:\n    if (piVar16 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar16 = (int *)0x2d;\n    piVar22 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n  }\nLAB_08006298:\n  piVar27 = local_160;\n  puVar29 = local_16c;\n  local_150._0_4_ = (int *)((uint)piVar25 & 2);\n  if ((int *)local_150 != (int *)0x0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  local_144 = (int *)((uint)piVar25 & 0x84);\n  if ((local_144 == (int *)0x0) &&\n     (piVar21 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar21)) {\n    if (0x10 < (int)piVar21) {\n      piVar16 = (int *)0x10;\n      local_100 = piVar24;\n      do {\n        piVar9 = piVar21;\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = piVar16;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n          piVar24 = local_100;\n        }\n        else {\n          local_140 = piVar16;\n          iVar3 = FUN_080097cc(puVar29,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = local_140;\n          piVar24 = local_100;\n        }\n        piVar21 = piVar9 + -4;\n        local_100 = piVar24;\n      } while (0x10 < (int)piVar21);\n      piVar21 = piVar9 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar21);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar21;\n    if ((int)local_d4 < 8) {\n      piVar16 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar16 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar16 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 1);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((int *)local_150 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 2);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  if ((local_144 == (int *)0x80) &&\n     (piVar16 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar16)) {\n    if (0x10 < (int)piVar16) {\n      do {\n        while( true ) {\n          piVar21 = piVar16;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = FUN_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = piVar21 + -4;\n          if ((int)(piVar21 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar16 = piVar21 + -4;\n      } while (0x10 < (int)(piVar21 + -4));\nLAB_08006882:\n      piVar16 = piVar21 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar16);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar16;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  piVar22 = (int *)((int)piVar22 - (int)local_158);\n  if (0 < (int)piVar22) {\n    if (0x10 < (int)piVar22) {\n      do {\n        while( true ) {\n          piVar16 = piVar22;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = FUN_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar22 = piVar16 + -4;\n          if ((int)(piVar16 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar22 = piVar16 + -4;\n      } while (0x10 < (int)(piVar16 + -4));\nLAB_080063d2:\n      piVar22 = piVar16 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar22);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar22;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_d0;\n  if (((uint)piVar25 & 0x100) == 0) {\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)local_158);\n    *ppiVar2 = piVar23;\n    ppiVar2[1] = (int *)local_158;\n    if ((int)local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else if ((int)piVar24 < 0x66) {\n    local_158 = (char *)((int)local_d0 + 1);\n    piVar27 = (int *)((int)local_d4 + 1);\n    ppiVar14 = ppiVar2 + 2;\n    local_d0 = (int *)local_158;\n    if (((int)local_138 < 2) && (((uint)piVar25 & 1) == 0)) {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)piVar27 < 8) {\n        local_150._0_4_ = (int *)((int)local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = piVar27;\n        iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        local_150._0_4_ = (int *)((int)local_d4 + 1);\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = piVar27;\n      if (7 < (int)piVar27) {\n        iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n      }\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_158 = (char *)((int)local_158 + (int)local_118);\n      *ppiVar14 = local_114;\n      ppiVar14[1] = local_118;\n      local_d0 = (int *)local_158;\n      if ((int)local_d4 < 8) {\n        ppiVar17 = ppiVar14 + 2;\n      }\n      else {\n        iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar17 = local_cc;\n      }\n      piVar24 = local_d4;\n      local_150._0_4_ = (int *)((int)local_d4 + 1);\n      piVar22 = (int *)((int)local_138 + -1);\n      ppiVar11 = ppiVar17 + 2;\n      local_158 = (char *)local_d0;\n      local_144 = (int *)local_150;\n      iVar3 = FUN_08000998(local_128,local_12c,local_124,local_120);\n      piVar27 = local_160;\n      puVar29 = local_16c;\n      if (iVar3 == 0) {\n        local_158 = (char *)((int)local_158 + (int)piVar22);\n        *ppiVar17 = (int *)((int)piVar23 + 1);\n        ppiVar17[1] = piVar22;\n        local_d0 = (int *)local_158;\n        if ((int)(int *)local_150 < 8) {\n          local_150._0_4_ = (int *)((int)piVar24 + 2);\n          ppiVar14 = ppiVar11;\n          ppiVar2 = ppiVar17 + 4;\n        }\n        else {\nLAB_08006d9c:\n          local_158 = (char *)local_d0;\n          local_d4 = (int *)local_150;\n          iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          local_150._0_4_ = (int *)((int)local_d4 + 1);\n          local_158 = (char *)local_d0;\n          ppiVar14 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar14 = ppiVar17;\n        ppiVar2 = ppiVar11;\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)local_158;\n          local_d4 = local_144;\n          if (0x10 < (int)piVar22) {\n            while( true ) {\n              local_d0 = local_d0 + 4;\n              *ppiVar17 = (int *)0x8009f60;\n              ppiVar17[1] = (int *)0x10;\n              if ((int)local_d4 < 8) {\n                ppiVar17 = ppiVar17 + 2;\n              }\n              else {\n                iVar3 = FUN_080097cc(puVar29,piVar27,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar17 = local_cc;\n              }\n              piVar22 = piVar22 + -4;\n              if ((int)piVar22 < 0x11) break;\n              local_d4 = (int *)((int)local_d4 + 1);\n            }\n            local_150._0_4_ = (int *)((int)local_d4 + 1);\n            ppiVar11 = ppiVar17 + 2;\n            local_158 = (char *)local_d0;\n          }\n          *ppiVar17 = (int *)0x8009f60;\n          ppiVar17[1] = piVar22;\n          local_158 = (char *)((int)local_158 + (int)piVar22);\n          local_d0 = (int *)local_158;\n          if (7 < (int)(int *)local_150) goto LAB_08006d9c;\n          local_150._0_4_ = (int *)((int)(int *)local_150 + 1);\n          ppiVar2 = ppiVar11 + 2;\n          ppiVar14 = ppiVar11;\n        }\n      }\n    }\n    ppiVar14[1] = local_10c;\n    local_d0 = (int *)((int)local_158 + (int)local_10c);\n    local_d4 = (int *)local_150;\n    *ppiVar14 = (int *)&local_e8;\n    piVar27 = local_d0;\n    if (7 < (int)(int *)local_150) {\n      iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else {\n    iVar3 = FUN_08000998(local_128,local_12c,local_124,local_120);\n    if (iVar3 == 0) {\n      if ((int)local_f0 < 1) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)piVar27 + 1);\n        *ppiVar2 = (int *)&DAT_08009f4c;\n        ppiVar2[1] = (int *)0x1;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0 != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)local_d0 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          puVar29 = local_16c;\n          if ((int)local_f0 < 0) {\n            piVar27 = (int *)-(int)local_f0;\n            if ((int)(local_f0 + 4) < 0 != SCARRY4((int)local_f0,0x10)) {\n              do {\n                local_d4 = (int *)((int)local_d4 + 1);\n                local_d0 = local_d0 + 4;\n                *ppiVar2 = (int *)0x8009f60;\n                ppiVar2[1] = (int *)0x10;\n                if ((int)local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar3 = FUN_080097cc(puVar29,local_160,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)local_d0 + (int)piVar27);\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = piVar27;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = (int *)((int)local_d0 + (int)local_138);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar24 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar24 = local_138;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar24);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = piVar24;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        piVar22 = local_134;\n        if (-1 < (int)piVar24) {\n          piVar22 = (int *)((int)local_134 - (int)piVar24);\n        }\n        if (0 < (int)piVar22) {\n          for (; 0x10 < (int)piVar22; piVar22 = piVar22 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = piVar27 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          local_d4 = (int *)((int)local_d4 + 1);\n          piVar27 = (int *)((int)piVar27 + (int)piVar22);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar22;\n          local_d0 = piVar27;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar22 = local_104;\n        piVar24 = local_160;\n        puVar29 = local_16c;\n        piVar16 = (int *)((int)local_134 + (int)piVar23);\n        if (((uint)piVar25 & 0x400) != 0) {\n          local_158 = (char *)((int)piVar23 + (int)local_138);\n          pbVar26 = local_108;\n          local_150._0_4_ = piVar28;\n          local_144 = piVar25;\n          local_140 = piVar23;\n          if (local_130 == (int *)0x0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != (int **)0x0) goto LAB_0800717e;\n          pbVar26 = pbVar26 + -1;\n          local_130 = (int *)((int)local_130 + -1);\n          do {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)piVar27 + (int)piVar22);\n            *ppiVar2 = local_110;\n            ppiVar2[1] = piVar22;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = (int *)(uint)*pbVar26;\n            piVar28 = (int *)((int)local_158 - (int)piVar16);\n            if ((int)piVar27 <= (int)(int *)((int)local_158 - (int)piVar16)) {\n              piVar28 = piVar27;\n            }\n            if (0 < (int)piVar28) {\n              local_d0 = (int *)((int)local_d0 + (int)piVar28);\n              local_d4 = (int *)((int)local_d4 + 1);\n              *ppiVar2 = piVar16;\n              ppiVar2[1] = piVar28;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar27 = (int *)(uint)*pbVar26;\n              }\n            }\n            piVar25 = piVar27;\n            if (-1 < (int)piVar28) {\n              piVar25 = (int *)((int)piVar27 - (int)piVar28);\n            }\n            if (0 < (int)piVar25) {\n              for (; 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n                while( true ) {\n                  local_d4 = (int *)((int)local_d4 + 1);\n                  local_d0 = local_d0 + 4;\n                  *ppiVar2 = (int *)0x8009f60;\n                  ppiVar2[1] = (int *)0x10;\n                  if ((int)local_d4 < 8) break;\n                  iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  piVar25 = piVar25 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar25 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = (int *)((int)local_d4 + 1);\n              local_d0 = (int *)((int)local_d0 + (int)piVar25);\n              *ppiVar2 = (int *)0x8009f60;\n              ppiVar2[1] = piVar25;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = local_cc;\n              }\n            }\n            piVar16 = (int *)((int)piVar16 + (int)piVar27);\n            piVar27 = local_d0;\n            if (local_130 != (int *)0x0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == (int **)0x0) {\n              piVar23 = local_140;\n              piVar25 = local_144;\n              piVar28 = (int *)local_150;\n              local_108 = pbVar26;\n              if ((int *)((int)local_140 + (int)local_138) <= piVar16) {\n                piVar16 = (int *)((int)local_140 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = (int **)((int)local_13c + -1);\n          } while( true );\n        }\n        if (((int)local_f0 < (int)local_138) || (((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)piVar27 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar24 = (int *)((int)local_138 - (int)local_f0);\n        piVar22 = (int *)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16);\n        if ((int)piVar24 <= (int)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16)) {\n          piVar22 = piVar24;\n        }\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar22);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar16;\n          ppiVar2[1] = piVar22;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar24 = (int *)((int)local_138 - (int)local_f0);\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        if (-1 < (int)piVar22) {\n          piVar24 = (int *)((int)piVar24 - (int)piVar22);\n        }\n        if (0 < (int)piVar24) {\n          for (; local_d0 = piVar27, 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_d0 = (int *)((int)piVar27 + 1);\n      *ppiVar2 = (int *)&DAT_08009f4c;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0 < (int)local_138) || (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)local_118);\n        *ppiVar2 = local_114;\n        ppiVar2[1] = local_118;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = FUN_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar22 = local_160;\n        puVar29 = local_16c;\n        piVar24 = (int *)((int)local_138 + -1);\n        piVar27 = local_d0;\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = FUN_080097cc(puVar29,piVar22,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\nLAB_08007014:\n          local_d0 = (int *)((int)local_d0 + (int)piVar24);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar24;\njoined_r0x08006a1c:\n          local_d4 = (int *)((int)local_d4 + 1);\n          if (7 < (int)local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  piVar24 = local_160;\n  puVar29 = local_16c;\n  if ((((uint)piVar25 & 4) != 0) &&\n     (piVar25 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar25)) {\n    for (; local_d0 = piVar27, 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n      while( true ) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if ((int)local_d4 < 8) break;\n        iVar3 = FUN_080097cc(puVar29,piVar24,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        piVar25 = piVar25 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar25 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar25);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar25;\n    piVar27 = local_d0;\n    if ((7 < (int)local_d4) &&\n       (iVar3 = FUN_080097cc(local_16c,local_160,&local_d8), piVar27 = local_d0, iVar3 != 0))\n    goto LAB_0800603e;\n  }\n  piVar24 = local_15c;\n  if ((int)local_15c < (int)local_168) {\n    piVar24 = local_168;\n  }\n  local_164 = local_164 + (int)piVar24;\n  if ((piVar27 == (int *)0x0) || (iVar3 = FUN_080097cc(local_16c,local_160,&local_d8), iVar3 == 0))\n  {\n    local_d4 = (int *)0x0;\n    if (local_148 != (int *)0x0) {\n      FUN_080088ec(local_16c,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    FUN_080088ec(local_16c,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  piVar16 = piVar24 + -0xc;\n  piVar22 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar22 + 1);\n    piVar24 = (int *)(uint)*(byte *)piVar22;\n    local_15c = (int *)((int)piVar16 + (int)local_15c * 10);\n    piVar16 = piVar24 + -0xc;\n    piVar22 = piVar28;\n  } while (piVar16 < (int *)0xa);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "calling": [
                "FUN_08005dfc"
            ],
            "called": [
                "FUN_080097cc",
                "FUN_080079e8",
                "FUN_0800901c",
                "FUN_080011ec",
                "FUN_080009e8",
                "FUN_08001170",
                "FUN_08005e40",
                "FUN_080003f4",
                "FUN_0800119c",
                "FUN_080009ac",
                "FUN_08008ad4",
                "FUN_080088ec",
                "FUN_08000998",
                "FUN_080004c8",
                "FUN_080009c0",
                "FUN_08009768",
                "FUN_080096e0",
                "FUN_08008af8",
                "FUN_08000158"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078a0": {
            "entrypoint": "0x080078a0",
            "current_name": "FUNC_080078a0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080078a4) */\n\nvoid FUNC_080078a0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078a0": "FUNC_080078a0"
            },
            "calling": [
                "FUN_08005d20"
            ],
            "called": [
                "FUN_080098c0"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078c0": {
            "entrypoint": "0x080078c0",
            "current_name": "calculate_division_080078c0",
            "code": "\nuint calculateDivision_080078c0(int numerator,int denominator)\n\n{\n  uint carry;\n  uint *numeratorPtr;\n  int tempSubtract;\n  int numeratorSize;\n  int denominatorSize;\n  uint quotient;\n  uint *denominatorPtr;\n  uint *quotientPtr;\n  uint *lastIndexPtr;\n  uint tempMultiply;\n  uint *tempDenominatorPtr;\n  uint *tempDenominatorPtrIter;\n  \n  numeratorSize = *(int *)(denominator + 0x10);\n  if (*(int *)(numerator + 0x10) < numeratorSize) {\n    return 0;\n  }\n  denominatorSize = numeratorSize + -1;\n  denominatorPtr = (uint *)(denominator + 0x14);\n  quotientPtr = (uint *)(numerator + 0x14);\n  quotient = quotientPtr[denominatorSize] / (denominatorPtr[denominatorSize] + 1);\n  lastIndexPtr = denominatorPtr + denominatorSize;\n  if (quotient != 0) {\n    carry = 0;\n    tempSubtract = 0;\n    numeratorPtr = quotientPtr;\n    tempDenominatorPtr = denominatorPtr;\n    do {\n      tempDenominatorPtrIter = tempDenominatorPtr + 1;\n      carry = quotient * (*tempDenominatorPtr & 0xffff) + carry;\n      tempMultiply = quotient * (*tempDenominatorPtr >> 0x10) + (carry >> 0x10);\n      carry = (tempSubtract - (carry & 0xffff)) + (*numeratorPtr & 0xffff);\n      tempSubtract = ((*numeratorPtr >> 0x10) - (tempMultiply & 0xffff)) + ((int)carry >> 0x10);\n      *numeratorPtr = carry & 0xffff | tempSubtract * 0x10000;\n      tempSubtract = tempSubtract >> 0x10;\n      carry = tempMultiply >> 0x10;\n      numeratorPtr = numeratorPtr + 1;\n      tempDenominatorPtr = tempDenominatorPtrIter;\n    } while (tempDenominatorPtrIter <= lastIndexPtr);\n    if (quotientPtr[denominatorSize] == 0) {\n      if ((quotientPtr < quotientPtr + numeratorSize + -2) && (quotientPtr[numeratorSize + -2] == 0)) {\n        numeratorPtr = quotientPtr + numeratorSize + -3;\n        do {\n          denominatorSize = denominatorSize + -1;\n          if (numeratorPtr <= quotientPtr) break;\n          carry = *numeratorPtr;\n          numeratorPtr = numeratorPtr + -1;\n        } while (carry == 0);\n      }\n      *(int *)(numerator + 0x10) = denominatorSize;\n    }\n  }\n  numeratorSize = FUN_080094f8();\n  if (-1 < numeratorSize) {\n    numeratorSize = 0;\n    quotient = quotient + 1;\n    numeratorPtr = quotientPtr;\n    do {\n      tempDenominatorPtr = denominatorPtr + 1;\n      carry = (numeratorSize - (*denominatorPtr & 0xffff)) + (*numeratorPtr & 0xffff);\n      numeratorSize = ((*numeratorPtr >> 0x10) - (*denominatorPtr >> 0x10)) + ((int)carry >> 0x10);\n      *numeratorPtr = carry & 0xffff | numeratorSize * 0x10000;\n      numeratorSize = numeratorSize >> 0x10;\n      numeratorPtr = numeratorPtr + 1;\n      denominatorPtr = tempDenominatorPtr;\n    } while (tempDenominatorPtr <= lastIndexPtr);\n    if (quotientPtr[denominatorSize] == 0) {\n      if ((quotientPtr < quotientPtr + denominatorSize + -1) && (quotientPtr[denominatorSize + -1] == 0)) {\n        denominatorPtr = quotientPtr + denominatorSize + -2;\n        do {\n          denominatorSize = denominatorSize + -1;\n          if (denominatorPtr <= quotientPtr) break;\n          carry = *denominatorPtr;\n          denominatorPtr = denominatorPtr + -1;\n        } while (carry == 0);\n      }\n      *(int *)(numerator + 0x10) = denominatorSize;\n    }\n  }\n  return quotient;\n}\n\n",
            "renaming": {
                "FUN_080078c0": "calculate_division_080078c0",
                "param_1": "numerator",
                "param_2": "denominator",
                "iVar4": "numeratorSize",
                "iVar5": "denominatorSize",
                "uVar1": "carry",
                "puVar2": "numeratorPtr",
                "puVar7": "denominatorPtr",
                "puVar8": "quotientPtr",
                "puVar9": "lastIndexPtr",
                "uVar6": "quotient",
                "puVar11": "tempDenominatorPtr",
                "puVar12": "tempDenominatorPtrIter",
                "uVar10": "tempMultiply",
                "iVar3": "tempSubtract"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080094f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e8": {
            "entrypoint": "0x080079e8",
            "current_name": "convert_float_to_string_080079e8",
            "code": "\nchar * convertFloatToString_080079e8(int value,undefined4 param,uint sign,uint exponent,uint min_width,\n                   uint precision,int *formatted_length,uint *is_negative,char **formatted_string)\n\n{\n  bool is_zero;\n  bool is_infinity;\n  bool add_exponent;\n  char digit;\n  byte carry;\n  undefined4 value64;\n  int digit_count;\n  int carry_count;\n  int result;\n  char *pcVar10;\n  uint num_zeroes;\n  undefined4 mask;\n  undefined4 temp;\n  int current_digit;\n  int current_carry;\n  undefined4 exponent_mask;\n  uint abs_value;\n  uint abs_exponent;\n  int exponent_bias;\n  char *pcVar20;\n  char *pcVar21;\n  undefined4 *puVar22;\n  undefined4 temp_exponent;\n  int ascii_value;\n  bool is_infinity5;\n  undefined8 temp_result;\n  undefined8 temp_result2;\n  undefined8 temp_result3;\n  uint decimal_string;\n  uint abs_exponent_copy;\n  uint formatted_exponent;\n  int digit_index;\n  uint precision_copy;\n  int carry_index;\n  int exponent_diff;\n  uint extra_digits;\n  uint temp_value;\n  uint uStack_44;\n  uint formatted_width;\n  uint decimal_digits;\n  int carry_digits;\n  int exponent_data [2];\n  \n  current_digit = *(int *)(value + 0x40);\n  if (current_digit != 0) {\n    abs_exponent = *(uint *)(value + 0x44);\n    *(uint *)(current_digit + 4) = abs_exponent;\n    *(int *)(current_digit + 8) = 1 << (abs_exponent & 0xff);\n    FUN_0800910c(value,current_digit);\n    *(undefined4 *)(value + 0x40) = 0;\n  }\n  is_infinity5 = (int)exponent < 0;\n  abs_exponent = exponent;\n  if (is_infinity5) {\n    abs_exponent = exponent & 0x7fffffff;\n  }\n  *is_negative = (uint)is_infinity5;\n  abs_exponent_copy = exponent;\n  if (is_infinity5) {\n    abs_exponent_copy = abs_exponent;\n  }\n  abs_value = abs_exponent_copy;\n  if ((~abs_exponent & 0x7ff00000) == 0) {\n    *formatted_length = 9999;\n    if ((sign == 0) && ((abs_exponent & 0xfffff) == 0)) {\n      pcVar10 = \"Infinity\";\n      if (formatted_string == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    else {\n      pcVar10 = \"NaN\";\n      if (formatted_string == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    *formatted_string = pcVar21;\n    return pcVar10;\n  }\n  temp_result = FUN_08000998(sign,abs_exponent_copy,0,0);\n  if ((int)temp_result != 0) {\n    *formatted_length = 1;\n    if (formatted_string != (char **)0x0) {\n      *formatted_string = \"\";\n      return \"0\";\n    }\n    return \"0\";\n  }\n  value64 = FUN_08009630(value,(int)((ulonglong)temp_result >> 0x20),sign,abs_exponent_copy,exponent_data,&carry_digits)\n  ;\n  current_digit = carry_digits;\n  if (abs_exponent >> 0x14 == 0) {\n    exponent_bias = exponent_data[0] + carry_digits;\n    current_carry = exponent_bias + 0x432;\n    if (current_carry < 0x21) {\n      abs_exponent = sign << (0x20U - current_carry & 0xff);\n    }\n    else {\n      abs_exponent = sign >> (exponent_bias + 0x412U & 0xff) | abs_exponent << (0x40U - current_carry & 0xff);\n    }\n    temp_result = FUN_080003d4(abs_exponent);\n    exponent_bias = exponent_bias + -1;\n    is_infinity5 = true;\n    num_zeroes = (int)((ulonglong)temp_result >> 0x20) + 0xfe100000;\n    abs_exponent = (uint)temp_result;\n  }\n  else {\n    exponent_bias = (abs_exponent >> 0x14) - 0x3ff;\n    num_zeroes = abs_exponent_copy & 0xfffff | 0x3ff00000;\n    is_infinity5 = false;\n    abs_exponent = sign;\n  }\n  temp_result = FUN_08000158(abs_exponent,num_zeroes,0,0x3ff80000);\n  temp_result = FUN_080004c8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0x636f4361,0x3fd287a7);\n  temp_result = FUN_0800015c((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0x8b60c8b3,0x3fc68a28);\n  temp_result2 = FUN_080003f4(exponent_bias);\n  temp_result2 = FUN_080004c8((int)temp_result2,(int)((ulonglong)temp_result2 >> 0x20),0x509f79fb,0x3fd34413);\n  temp_result = FUN_0800015c((int)temp_result,(int)((ulonglong)temp_result >> 0x20),(int)temp_result2,\n                        (int)((ulonglong)temp_result2 >> 0x20));\n  temp = (undefined4)((ulonglong)temp_result >> 0x20);\n  formatted_exponent = FUN_0800119c();\n  current_carry = FUN_080009ac((int)temp_result,temp,0,0);\n  if (current_carry != 0) {\n    temp_result2 = FUN_080003f4(formatted_exponent);\n    current_carry = FUN_08000998((int)temp_result2,(int)((ulonglong)temp_result2 >> 0x20),(int)temp_result,temp);\n    if (current_carry == 0) {\n      formatted_exponent = formatted_exponent - 1;\n    }\n  }\n  if (formatted_exponent < 0x17) {\n    current_carry = FUN_080009e8(*(undefined4 *)(&DAT_08009fa8 + formatted_exponent * 8),\n                          *(undefined4 *)(&DAT_08009fac + formatted_exponent * 8),sign,abs_exponent_copy);\n    if (current_carry == 0) {\n      is_infinity = false;\n    }\n    else {\n      formatted_exponent = formatted_exponent - 1;\n      is_infinity = false;\n    }\n  }\n  else {\n    is_infinity = true;\n  }\n  current_carry = (current_digit - exponent_bias) + -1;\n  if (current_carry < 0) {\n    digit_index = 1 - (current_digit - exponent_bias);\n    current_carry = 0;\n  }\n  else {\n    digit_index = 0;\n  }\n  if ((int)formatted_exponent < 0) {\n    extra_digits = 0;\n    digit_index = digit_index - formatted_exponent;\n    exponent_diff = -formatted_exponent;\n  }\n  else {\n    current_carry = current_carry + formatted_exponent;\n    extra_digits = formatted_exponent;\n    exponent_diff = 0;\n  }\n  if (9 < min_width) {\n    formatted_width = 0xffffffff;\n    is_zero = true;\n    precision_copy = 0xffffffff;\n    add_exponent = true;\n    min_width = 0;\n    precision = 0;\n    goto LAB_08007c24;\n  }\n  is_zero = (int)min_width < 6;\n  if (!is_zero) {\n    min_width = min_width - 4;\n  }\n  switch(min_width) {\n  case 2:\n    add_exponent = false;\n    break;\n  case 3:\n    add_exponent = false;\n    goto LAB_08008300;\n  case 4:\n    add_exponent = true;\n    break;\n  case 5:\n    add_exponent = true;\nLAB_08008300:\n    formatted_width = formatted_exponent + precision;\n    precision_copy = formatted_width + 1;\n    abs_exponent = precision_copy;\n    if ((int)precision_copy < 1) {\n      abs_exponent = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(value + 0x44) = 0;\n    pcVar10 = (char *)FUN_080090c0(value,0);\n    formatted_width = 0xffffffff;\n    precision_copy = 0xffffffff;\n    precision = 0;\n    *(char **)(value + 0x40) = pcVar10;\n    add_exponent = true;\n    goto LAB_08007e36;\n  }\n  if ((int)precision < 1) {\n    formatted_width = 1;\n    precision = 1;\n    precision_copy = 1;\nLAB_08007c24:\n    *(undefined4 *)(value + 0x44) = 0;\n    num_zeroes = formatted_width;\n  }\n  else {\n    formatted_width = precision;\n    precision_copy = precision;\n    abs_exponent = precision;\nLAB_08008314:\n    *(undefined4 *)(value + 0x44) = 0;\n    num_zeroes = precision_copy;\n    if (0x17 < (int)abs_exponent) {\n      exponent_bias = 4;\n      current_digit = 1;\n      do {\n        digit_count = current_digit;\n        exponent_bias = exponent_bias * 2;\n        current_digit = digit_count + 1;\n      } while (exponent_bias + 0x14U <= abs_exponent);\n      *(int *)(value + 0x44) = digit_count;\n    }\n  }\n  pcVar10 = (char *)FUN_080090c0(value);\n  *(char **)(value + 0x40) = pcVar10;\n  if ((num_zeroes < 0xf) && (is_zero)) {\n    if ((int)formatted_exponent < 1) {\n      if (formatted_exponent == 0) {\n        current_digit = 2;\n        decimal_string = sign;\n      }\n      else {\n        current_digit = (-formatted_exponent & 0xf) * 8;\n        temp_result = FUN_080004c8(sign,abs_exponent_copy,*(undefined4 *)(&DAT_08009fa8 + current_digit),\n                              *(undefined4 *)(&DAT_08009fac + current_digit));\n        abs_exponent_copy = (uint)((ulonglong)temp_result >> 0x20);\n        decimal_string = (uint)temp_result;\n        exponent_bias = (int)-formatted_exponent >> 4;\n        if (exponent_bias == 0) {\n          current_digit = 2;\n        }\n        else {\n          is_zero = false;\n          current_digit = 2;\n          puVar22 = &DAT_08009f80;\n          do {\n            if (exponent_bias << 0x1f < 0) {\n              temp_result = FUN_080004c8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),*puVar22,puVar22[1]\n                                   );\n              is_zero = true;\n              current_digit = current_digit + 1;\n            }\n            exponent_bias = exponent_bias >> 1;\n            puVar22 = puVar22 + 2;\n          } while (exponent_bias != 0);\n          if (is_zero) {\n            decimal_string = (uint)temp_result;\n            abs_exponent_copy = (uint)((ulonglong)temp_result >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      abs_exponent = (int)formatted_exponent >> 4;\n      temp_result2 = *(undefined8 *)(&DAT_08009fa8 + (formatted_exponent & 0xf) * 8);\n      temp_result = *(undefined8 *)(&DAT_08009fa8 + (formatted_exponent & 0xf) * 8);\n      if ((int)(abs_exponent << 0x1b) < 0) {\n        temp_result3 = FUN_0800071c(sign,abs_exponent_copy,0x7f73bf3c,0x75154fdd);\n        uStack_44 = (uint)((ulonglong)temp_result3 >> 0x20);\n        temp_value = (uint)temp_result3;\n        current_digit = 3;\n        abs_exponent = abs_exponent & 0xf;\n      }\n      else {\n        current_digit = 2;\n        uStack_44 = abs_exponent_copy;\n        temp_value = sign;\n      }\n      if (abs_exponent != 0) {\n        puVar22 = &DAT_08009f80;\n        do {\n          if ((int)(abs_exponent << 0x1f) < 0) {\n            temp_result = FUN_080004c8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),*puVar22,puVar22[1]);\n            current_digit = current_digit + 1;\n          }\n          abs_exponent = (int)abs_exponent >> 1;\n          puVar22 = puVar22 + 2;\n          temp_result2 = temp_result;\n        } while (abs_exponent != 0);\n      }\n      abs_exponent_copy = (uint)((ulonglong)temp_result2 >> 0x20);\n      decimal_string = (uint)temp_result2;\n      temp_result = FUN_0800071c(temp_value,uStack_44,decimal_string,abs_exponent_copy);\n      decimal_string = (uint)temp_result;\n      abs_exponent_copy = (uint)((ulonglong)temp_result >> 0x20);\n    }\n    temp_result = CONCAT44(abs_exponent_copy,decimal_string);\n    if ((is_infinity) && (exponent_bias = FUN_080009ac(decimal_string,abs_exponent_copy,0,0x3ff00000), exponent_bias != 0)) {\n      if (precision_copy == 0) {\n        temp_result = FUN_080003f4(current_digit);\n        temp_result = FUN_080004c8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),decimal_string,abs_exponent_copy);\n        temp_result = FUN_0800015c((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0,0x401c0000);\n        temp = (undefined4)temp_result;\n        current_digit = (int)((ulonglong)temp_result >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)formatted_width) {\n        temp_result = FUN_080004c8(decimal_string,abs_exponent_copy,0,0x40240000);\n        temp_result2 = FUN_080003f4(current_digit + 1);\n        temp_result2 = FUN_080004c8((int)temp_result2,(int)((ulonglong)temp_result2 >> 0x20),(int)temp_result,\n                              (int)((ulonglong)temp_result >> 0x20));\n        temp_result2 = FUN_0800015c((int)temp_result2,(int)((ulonglong)temp_result2 >> 0x20),0,0x401c0000);\n        temp = (undefined4)temp_result2;\n        temp_value = formatted_width;\n        decimal_digits = formatted_exponent - 1;\n        current_digit = (int)((ulonglong)temp_result2 >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    temp_result2 = FUN_080003f4(current_digit);\n    temp_result2 = FUN_080004c8((int)temp_result2,(int)((ulonglong)temp_result2 >> 0x20),decimal_string,abs_exponent_copy);\n    temp_result2 = FUN_0800015c((int)temp_result2,(int)((ulonglong)temp_result2 >> 0x20),0,0x401c0000);\n    temp = (undefined4)temp_result2;\n    current_digit = (int)((ulonglong)temp_result2 >> 0x20) + -0x3400000;\n    if (precision_copy != 0) {\n      decimal_digits = formatted_exponent;\n      temp_value = precision_copy;\nLAB_08007cfa:\n      abs_exponent_copy = (uint)((ulonglong)temp_result >> 0x20);\n      decimal_string = (uint)temp_result;\n      digit = FUN_0800119c(decimal_string,abs_exponent_copy);\n      digit = digit + '0';\n      exponent_mask = (&DAT_08009fa0)[temp_value * 2];\n      mask = (&DAT_08009fa4)[temp_value * 2];\n      temp_result = FUN_080003f4();\n      temp_result = FUN_08000158(decimal_string,abs_exponent_copy,(int)temp_result,(int)((ulonglong)temp_result >> 0x20));\n      temp_exponent = (undefined4)((ulonglong)temp_result >> 0x20);\n      pcVar21 = pcVar10 + 1;\n      if (add_exponent) {\n        temp_result2 = FUN_0800071c(0,0x3fe00000,exponent_mask,mask);\n        temp_result2 = FUN_08000158((int)temp_result2,(int)((ulonglong)temp_result2 >> 0x20),temp,current_digit);\n        temp = (undefined4)((ulonglong)temp_result2 >> 0x20);\n        *pcVar10 = digit;\n        current_digit = FUN_080009e8((int)temp_result2,temp,(int)temp_result,temp_exponent);\n        if (current_digit != 0) {\nLAB_08008784:\n          formatted_exponent = decimal_digits;\n          goto LAB_08008294;\n        }\n        temp_result3 = FUN_08000158(0,0x3ff00000,(int)temp_result,temp_exponent);\n        current_digit = FUN_080009e8((int)temp_result2,temp,(int)temp_result3,(int)((ulonglong)temp_result3 >> 0x20));\n        if (current_digit == 0) {\n          if (temp_value != 1) {\n            pcVar20 = pcVar21;\n            do {\n              temp_result2 = FUN_080004c8((int)temp_result2,(int)((ulonglong)temp_result2 >> 0x20),0,0x40240000);\n              temp = (undefined4)((ulonglong)temp_result2 >> 0x20);\n              temp_result = FUN_080004c8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0,0x40240000);\n              digit = FUN_0800119c();\n              temp_result3 = FUN_080003f4();\n              temp_result = FUN_08000158((int)temp_result,(int)((ulonglong)temp_result >> 0x20),(int)temp_result3,\n                                    (int)((ulonglong)temp_result3 >> 0x20));\n              exponent_mask = (undefined4)((ulonglong)temp_result >> 0x20);\n              digit = digit + '0';\n              pcVar21 = pcVar20 + 1;\n              *pcVar20 = digit;\n              current_digit = FUN_080009ac((int)temp_result,exponent_mask,(int)temp_result2,temp);\n              if (current_digit != 0) {\n                formatted_exponent = decimal_digits;\n                goto LAB_08008294;\n              }\n              temp_result3 = FUN_08000158(0,0x3ff00000,(int)temp_result,exponent_mask);\n              current_digit = FUN_080009ac((int)temp_result3,(int)((ulonglong)temp_result3 >> 0x20),(int)temp_result2,temp)\n              ;\n              if (current_digit != 0) goto LAB_08008798;\n              pcVar20 = pcVar21;\n            } while (pcVar21 != pcVar10 + temp_value);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        formatted_exponent = decimal_digits;\n      }\n      else {\n        temp_result2 = FUN_080004c8(temp,current_digit,exponent_mask,mask);\n        temp = (undefined4)((ulonglong)temp_result2 >> 0x20);\n        *pcVar10 = digit;\n        if (temp_value != 1) {\n          pcVar20 = pcVar21;\n          do {\n            temp_result = FUN_080004c8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0,0x40240000);\n            digit = FUN_0800119c();\n            temp_result3 = FUN_080003f4();\n            temp_result = FUN_08000158((int)temp_result,(int)((ulonglong)temp_result >> 0x20),(int)temp_result3,\n                                  (int)((ulonglong)temp_result3 >> 0x20));\n            pcVar21 = pcVar20 + 1;\n            *pcVar20 = digit + '0';\n            pcVar20 = pcVar21;\n          } while (pcVar21 != pcVar10 + temp_value);\n        }\n        exponent_mask = (undefined4)((ulonglong)temp_result >> 0x20);\n        temp_result3 = FUN_0800015c((int)temp_result2,temp,0,0x3fe00000);\n        current_digit = FUN_080009ac((int)temp_result3,(int)((ulonglong)temp_result3 >> 0x20),(int)temp_result,exponent_mask);\n        if (current_digit == 0) {\n          temp_result2 = FUN_08000158(0,0x3fe00000,(int)temp_result2,temp);\n          current_digit = FUN_080009e8((int)temp_result2,(int)((ulonglong)temp_result2 >> 0x20),(int)temp_result,exponent_mask);\n          pcVar20 = pcVar21;\n          if (current_digit == 0) goto LAB_08007e36;\n          do {\n            pcVar21 = pcVar20;\n            pcVar20 = pcVar21 + -1;\n          } while (pcVar21[-1] == '0');\n          goto LAB_08008784;\n        }\n        formatted_exponent = decimal_digits;\n        digit = pcVar21[-1];\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    temp_result = FUN_08000158(decimal_string,abs_exponent_copy,0,0x40140000);\n    exponent_mask = (undefined4)((ulonglong)temp_result >> 0x20);\n    exponent_bias = FUN_080009e8((int)temp_result,exponent_mask,temp,current_digit);\n    if (exponent_bias == 0) {\n      current_digit = FUN_080009ac((int)temp_result,exponent_mask,temp,current_digit + -0x80000000);\n      if (current_digit == 0) goto LAB_08007e36;\n      exponent_bias = 0;\n      current_digit = 0;\n      pcVar21 = pcVar10;\n      goto LAB_080084f0;\n    }\n    current_carry = 0;\n    digit_count = 0;\nLAB_08008406:\n    *pcVar10 = '1';\n    formatted_exponent = formatted_exponent + 1;\n    pcVar21 = pcVar10 + 1;\n    exponent_bias = digit_count;\n    current_digit = current_carry;\nLAB_08008416:\n    FUN_0800910c(value,current_digit);\n    if (exponent_bias == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pcVar21 = pcVar10;\n    if ((-1 < exponent_data[0]) && ((int)formatted_exponent < 0xf)) {\n      temp = *(undefined4 *)(&DAT_08009fa8 + formatted_exponent * 8);\n      exponent_mask = *(undefined4 *)(&DAT_08009fac + formatted_exponent * 8);\n      if ((-1 < (int)precision) || (0 < (int)precision_copy)) {\n        FUN_0800071c(sign,abs_value,temp,exponent_mask);\n        carry = FUN_0800119c();\n        temp_result = FUN_080003f4();\n        temp_result = FUN_080004c8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),temp,exponent_mask);\n        temp_result = FUN_08000158(sign,abs_value,(int)temp_result,(int)((ulonglong)temp_result >> 0x20));\n        *pcVar10 = carry + 0x30;\n        pcVar21 = pcVar10 + 1;\n        if (precision_copy != 1) {\n          temp_result = FUN_080004c8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0,0x40240000);\n          current_digit = FUN_08000998((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0,0);\n          while (current_digit == 0) {\n            temp_exponent = (undefined4)((ulonglong)temp_result >> 0x20);\n            FUN_0800071c((int)temp_result,temp_exponent,temp,exponent_mask);\n            carry = FUN_0800119c();\n            temp_result2 = FUN_080003f4();\n            temp_result2 = FUN_080004c8((int)temp_result2,(int)((ulonglong)temp_result2 >> 0x20),temp,exponent_mask);\n            temp_result = FUN_08000158((int)temp_result,temp_exponent,(int)temp_result2,(int)((ulonglong)temp_result2 >> 0x20));\n            pcVar20 = pcVar21 + 1;\n            *pcVar21 = carry + 0x30;\n            pcVar21 = pcVar20;\n            if (precision_copy == (int)pcVar20 - (int)pcVar10) goto LAB_08007f3a;\n            temp_result = FUN_080004c8((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0,0x40240000);\n            current_digit = FUN_08000998((int)temp_result,(int)((ulonglong)temp_result >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        temp_result = FUN_0800015c((int)temp_result,(int)((ulonglong)temp_result >> 0x20));\n        temp_exponent = (undefined4)((ulonglong)temp_result >> 0x20);\n        current_digit = FUN_080009e8((int)temp_result,temp_exponent,temp,exponent_mask);\n        if ((current_digit == 0) &&\n           ((current_digit = FUN_08000998((int)temp_result,temp_exponent,temp,exponent_mask), current_digit == 0 ||\n            ((carry & 1) == 0)))) goto LAB_08008294;\n        digit = pcVar21[-1];\nLAB_08007f7c:\n        while (pcVar20 = pcVar21 + -1, digit == '9') {\n          if (pcVar10 == pcVar20) {\n            *pcVar10 = '0';\n            digit = pcVar21[-1];\n            formatted_exponent = formatted_exponent + 1;\n            pcVar20 = pcVar10;\n            break;\n          }\n          digit = pcVar21[-2];\n          pcVar21 = pcVar20;\n        }\n        *pcVar20 = digit + '\\x01';\n        goto LAB_08008294;\n      }\n      if (precision_copy == 0) {\n        temp_result = FUN_080004c8(temp,exponent_mask,0,0x40140000);\n        result = FUN_080009d4((int)temp_result,(int)((ulonglong)temp_result >> 0x20),sign,abs_value);\n        exponent_bias = 0;\n        current_carry = 0;\n        digit_count = 0;\n        current_digit = 0;\n        if (result == 0) goto LAB_08008406;\n      }\n      else {\n        exponent_bias = 0;\n        current_digit = 0;\n      }\nLAB_080084f0:\n      formatted_exponent = ~precision;\n      pcVar10 = pcVar21;\n      goto LAB_08008416;\n    }\n    current_digit = exponent_diff;\n    if (add_exponent) {\n      if ((int)min_width < 2) {\n        if (is_infinity5) {\n          carry_index = digit_index;\n          digit_index = digit_index + exponent_data[0] + 0x433;\n          current_carry = current_carry + exponent_data[0] + 0x433;\n        }\n        else {\n          carry_index = digit_index;\n          digit_index = digit_index + (0x36 - carry_digits);\n          current_carry = current_carry + (0x36 - carry_digits);\n        }\n      }\n      else {\n        exponent_bias = precision_copy - 1;\n        if (exponent_diff < exponent_bias) {\n          extra_digits = extra_digits + (exponent_bias - exponent_diff);\n          current_digit = 0;\n          exponent_diff = exponent_bias;\n        }\n        else {\n          current_digit = exponent_diff - exponent_bias;\n        }\n        if ((int)precision_copy < 0) {\n          carry_index = digit_index - precision_copy;\n        }\n        else {\n          current_carry = current_carry + precision_copy;\n          carry_index = digit_index;\n          digit_index = digit_index + precision_copy;\n        }\n      }\n      exponent_bias = FUN_08009244(value,1);\n    }\n    else {\n      carry_index = digit_index;\n      exponent_bias = 0;\n    }\n    if ((0 < carry_index) && (0 < current_carry)) {\n      digit_count = carry_index;\n      if (current_carry <= carry_index) {\n        digit_count = current_carry;\n      }\n      current_carry = current_carry - digit_count;\n      digit_index = digit_index - digit_count;\n      carry_index = carry_index - digit_count;\n    }\n    if (exponent_diff != 0) {\n      if (add_exponent) {\n        temp = value64;\n        if (current_digit != 0) {\n          exponent_bias = FUN_080093a4(value,exponent_bias,current_digit);\n          temp = FUN_08009258(value,exponent_bias,value64);\n          FUN_0800910c(value,value64);\n          value64 = temp;\n          if (exponent_diff - current_digit == 0) goto LAB_08008062;\n        }\n        value64 = FUN_080093a4(value,temp,exponent_diff - current_digit);\n      }\n      else {\n        value64 = FUN_080093a4(value,value64,exponent_diff);\n      }\n    }\nLAB_08008062:\n    current_digit = FUN_08009244(value,1);\n    if (extra_digits == 0) {\n      if (((int)min_width < 2) && (sign == 0)) {\nLAB_0800835a:\n        if ((abs_value & 0xfffff) == 0) {\n          abs_value = abs_value & 0x7ff00000;\n          if (abs_value != 0) {\n            current_carry = current_carry + 1;\n            digit_index = digit_index + 1;\n            abs_value = 1;\n          }\n        }\n        else {\n          abs_value = 0;\n        }\n        is_infinity5 = extra_digits != 0;\n        abs_exponent = sign;\n        extra_digits = abs_value;\n        if (is_infinity5) goto LAB_080082d4;\n      }\n      digit_count = 1;\n    }\n    else {\n      temp_result = FUN_080093a4(value,current_digit);\n      current_digit = (int)temp_result;\n      if (((int)min_width < 2) && (sign == 0)) goto LAB_0800835a;\n      extra_digits = 0;\n      abs_exponent = (uint)((ulonglong)temp_result >> 0x20);\nLAB_080082d4:\n      digit_count = FUN_080091a4(*(undefined4 *)(current_digit + *(int *)(current_digit + 0x10) * 4 + 0x10),abs_exponent);\n      digit_count = 0x20 - digit_count;\n    }\n    abs_exponent = digit_count + current_carry & 0x1f;\n    if (abs_exponent == 0) {\n      digit_count = 0x1c;\nLAB_08008096:\n      current_carry = current_carry + digit_count;\n      digit_index = digit_index + digit_count;\n      carry_index = carry_index + digit_count;\n    }\n    else {\n      if (4 < (int)(0x20 - abs_exponent)) {\n        digit_count = 0x1c - abs_exponent;\n        goto LAB_08008096;\n      }\n      if (0x20 - abs_exponent != 4) {\n        digit_count = 0x3c - abs_exponent;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < digit_index) {\n      value64 = FUN_08009444(value,value64,digit_index);\n    }\n    if (0 < current_carry) {\n      current_digit = FUN_08009444(value,current_digit,current_carry);\n    }\n    pcVar20 = pcVar10;\n    if ((is_infinity) && (current_carry = FUN_080094f8(value64,current_digit), current_carry < 0)) {\n      formatted_exponent = formatted_exponent - 1;\n      value64 = FUN_08009120(value,value64,10,0);\n      if (add_exponent) {\n        exponent_bias = FUN_08009120(value,exponent_bias,10,0);\n        if ((0 < (int)formatted_width) || ((int)min_width < 3)) {\n          precision_copy = formatted_width;\n          goto LAB_080080de;\n        }\n      }\n      else if ((0 < (int)formatted_width) || ((int)min_width < 3)) {\n        precision_copy = formatted_width;\n        goto LAB_0800820a;\n      }\n      precision_copy = formatted_width;\nLAB_080084e8:\n      if (precision_copy == 0) {\n        current_carry = FUN_08009120(value,current_digit,5);\n        result = FUN_080094f8(value64,current_carry);\n        digit_count = exponent_bias;\n        current_digit = current_carry;\n        if (0 < result) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)precision_copy < 1) && (2 < (int)min_width)) goto LAB_080084e8;\n    if (add_exponent) {\nLAB_080080de:\n      decimal_string = exponent_bias;\n      if (0 < carry_index) {\n        decimal_string = FUN_08009444(value,exponent_bias,carry_index);\n      }\n      exponent_bias = decimal_string;\n      if (extra_digits != 0) {\n        exponent_bias = FUN_080090c0(value,*(undefined4 *)(decimal_string + 4));\n        FUN_08001084(exponent_bias + 0xc,decimal_string + 0xc,(*(int *)(decimal_string + 0x10) + 2) * 4);\n        exponent_bias = FUN_08009444(value,exponent_bias,1);\n      }\nLAB_08008108:\n      current_carry = FUN_080078c0(value64,current_digit);\n      digit_count = FUN_080094f8(value64,decimal_string);\n      result = FUN_08009530(value,current_digit,exponent_bias);\n      ascii_value = current_carry + 0x30;\n      if (*(int *)(result + 0xc) == 0) {\n        carry_count = FUN_080094f8(value64);\n        FUN_0800910c(value,result);\n        if ((carry_count != 0) || (min_width != 0)) goto LAB_0800815a;\n        if ((sign & 1) != 0) {\n          carry_count = 0;\n          goto LAB_0800815a;\n        }\n        if (ascii_value != 0x39) {\n          if (0 < digit_count) goto LAB_0800874c;\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pcVar21 = pcVar20 + 1;\n        digit = '9';\n        *pcVar20 = '9';\n        goto LAB_08008268;\n      }\n      FUN_0800910c(value,result);\n      carry_count = 1;\nLAB_0800815a:\n      if ((digit_count < 0) || (((digit_count == 0 && (min_width == 0)) && ((sign & 1) == 0)))) {\n        if (0 < carry_count) {\n          value64 = FUN_08009444(value,value64,1);\n          digit_count = FUN_080094f8(value64,current_digit);\n          if ((0 < digit_count) || ((digit_count == 0 && (current_carry << 0x1f < 0)))) {\n            if (ascii_value == 0x39) goto LAB_08008752;\nLAB_0800874c:\n            ascii_value = current_carry + 0x31;\n          }\n        }\nLAB_080085a4:\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)ascii_value;\n        goto LAB_08008274;\n      }\n      pcVar21 = pcVar20 + 1;\n      if (0 < carry_count) {\n        if (ascii_value == 0x39) goto LAB_08008752;\n        *pcVar20 = (char)current_carry + '1';\n        goto LAB_08008274;\n      }\n      *pcVar20 = (char)ascii_value;\n      if (pcVar10 + (precision_copy - 1) != pcVar20) {\n        value64 = FUN_08009120(value,value64,10,0);\n        pcVar20 = pcVar21;\n        if (decimal_string == exponent_bias) {\n          decimal_string = FUN_08009120(value,decimal_string,10,0);\n          exponent_bias = decimal_string;\n        }\n        else {\n          decimal_string = FUN_08009120(value,decimal_string,10,0);\n          exponent_bias = FUN_08009120(value,exponent_bias,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    else {\nLAB_0800820a:\n      while( true ) {\n        ascii_value = FUN_080078c0(value64,current_digit);\n        ascii_value = ascii_value + 0x30;\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)ascii_value;\n        if ((int)precision_copy <= (int)pcVar21 - (int)pcVar10) break;\n        value64 = FUN_08009120(value,value64,10,0);\n        pcVar20 = pcVar21;\n      }\n      decimal_string = 0;\n    }\n    value64 = FUN_08009444(value,value64,1);\n    current_carry = FUN_080094f8(value64,current_digit);\n    digit = pcVar21[-1];\n    if ((0 < current_carry) || ((current_carry == 0 && (ascii_value << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pcVar20 = pcVar21 + -1;\n        if (digit != '9') goto code_r0x08008270;\n        if (pcVar10 == pcVar20) {\n          *pcVar10 = '1';\n          formatted_exponent = formatted_exponent + 1;\n          goto LAB_08008274;\n        }\n        digit = pcVar21[-2];\n        pcVar21 = pcVar20;\n      } while( true );\n    }\n    while (digit == '0') {\n      digit = pcVar21[-2];\n      pcVar21 = pcVar21 + -1;\n    }\nLAB_08008274:\n    FUN_0800910c(value,current_digit);\n    if (exponent_bias == 0) goto LAB_08008294;\n    if ((decimal_string != 0) && (decimal_string != exponent_bias)) {\n      FUN_0800910c(value);\n    }\n  }\n  FUN_0800910c(value,exponent_bias);\nLAB_08008294:\n  FUN_0800910c(value,value64);\n  *pcVar21 = '\\0';\n  *formatted_length = formatted_exponent + 1;\n  if (formatted_string == (char **)0x0) {\n    return pcVar10;\n  }\n  *formatted_string = pcVar21;\n  return pcVar10;\ncode_r0x08008270:\n  *pcVar20 = digit + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "renaming": {
                "FUN_080079e8": "convert_float_to_string_080079e8",
                "param_1": "value",
                "param_2": "param",
                "param_3": "sign",
                "param_4": "exponent",
                "param_5": "min_width",
                "param_6": "precision",
                "param_7": "formatted_length",
                "param_8": "is_negative",
                "param_9": "formatted_string",
                "bVar1": "is_zero",
                "bVar2": "is_infinity",
                "bVar3": "add_exponent",
                "cVar4": "digit",
                "bVar5": "carry",
                "uVar6": "value64",
                "iVar7": "digit_count",
                "iVar8": "carry_count",
                "iVar9": "result",
                "iVar14": "current_digit",
                "iVar15": "current_carry",
                "iVar19": "exponent_bias",
                "iVar24": "ascii_value",
                "uVar11": "num_zeroes",
                "uVar12": "mask",
                "uVar13": "temp",
                "uVar16": "exponent_mask",
                "uVar17": "abs_value",
                "uVar18": "abs_exponent",
                "uVar23": "temp_exponent",
                "uVar26": "temp_result",
                "uVar27": "temp_result2",
                "uVar28": "temp_result3",
                "local_80": "decimal_string",
                "local_7c": "abs_exponent_copy",
                "local_74": "formatted_exponent",
                "local_70": "digit_index",
                "local_68": "precision_copy",
                "local_60": "carry_index",
                "local_5c": "exponent_diff",
                "local_58": "extra_digits",
                "local_48": "temp_value",
                "local_38": "formatted_width",
                "local_34": "decimal_digits",
                "local_30": "carry_digits",
                "local_2c": "exponent_data"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_08001084",
                "FUN_08009258",
                "FUN_080078c0",
                "FUN_080003d4",
                "FUN_08009244",
                "FUN_080009e8",
                "FUN_080091a4",
                "FUN_0800910c",
                "FUN_0800015c",
                "FUN_080094f8",
                "FUN_08009120",
                "FUN_080003f4",
                "FUN_08009630",
                "FUN_08009444",
                "FUN_0800119c",
                "FUN_080090c0",
                "FUN_080009d4",
                "FUN_080009ac",
                "FUN_08000998",
                "FUN_08009530",
                "FUN_080093a4",
                "FUN_080004c8",
                "FUN_0800071c",
                "FUN_08000158"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800884c": {
            "entrypoint": "0x0800884c",
            "current_name": "allocate_memory_block_0800884c",
            "code": "\nundefined4 allocate_memory_block_0800884c(undefined4 allocator,int size)\n\n{\n  int result;\n  int adjusted_address;\n  uint block_header;\n  \n  FUN_080090a8();\n  block_header = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  adjusted_address = ((0xfef - size) + block_header & 0xfffff000) - 0x1000;\n  if (0xfff < adjusted_address) {\n    result = FUN_08009744(allocator,0);\n    if (result == DAT_20000454 + block_header) {\n      result = FUN_08009744(allocator,-adjusted_address);\n      if (result != -1) {\n        DAT_20000a14 = DAT_20000a14 - adjusted_address;\n        *(uint *)(DAT_20000454 + 4) = block_header - adjusted_address | 1;\n        FUN_080090b4(allocator);\n        return 1;\n      }\n      adjusted_address = FUN_08009744(allocator,0);\n      if (0xf < adjusted_address - DAT_20000454) {\n        DAT_20000a14 = adjusted_address - DAT_20000854;\n        *(uint *)(DAT_20000454 + 4) = adjusted_address - DAT_20000454 | 1;\n      }\n    }\n  }\n  FUN_080090b4(allocator);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800884c": "allocate_memory_block_0800884c",
                "param_1": "allocator",
                "param_2": "size",
                "iVar1": "result",
                "iVar2": "adjusted_address",
                "uVar3": "block_header"
            },
            "calling": [
                "FUN_080088ec"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_080090b4",
                "FUN_08009744"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088ec": {
            "entrypoint": "0x080088ec",
            "current_name": "allocate_memory_block_080088ec",
            "code": "\nvoid allocate_memory_block_080088ec(undefined4 param_1,int block_size,undefined4 param_3,undefined4 param_4)\n\n{\n  int index;\n  uint *current_block;\n  uint *next_block;\n  undefined *prev_block;\n  uint block_size_aligned;\n  uint next_block_size_aligned;\n  undefined *temp_ptr;\n  undefined *temp_ptr2;\n  undefined4 *ptr_to_data;\n  int loop_var;\n  uint flag;\n  uint temp_value;\n  \n  if (block_size == 0) {\n    return;\n  }\n  FUN_080090a8();\n  flag = *(uint *)(block_size + -4);\n  current_block = (uint *)(block_size + -8);\n  block_size_aligned = flag & 0xfffffffe;\n  next_block = (uint *)((int)current_block + block_size_aligned);\n  next_block_size_aligned = next_block[1] & 0xfffffffc;\n  if (DAT_20000454 == next_block) {\n    block_size_aligned = block_size_aligned + next_block_size_aligned;\n    if ((flag & 1) == 0) {\n      current_block = (uint *)((int)current_block - *(int *)(block_size + -8));\n      next_block_size_aligned = current_block[2];\n      flag = current_block[3];\n      block_size_aligned = block_size_aligned + *(int *)(block_size + -8);\n      *(uint *)(next_block_size_aligned + 0xc) = flag;\n      *(uint *)(flag + 8) = next_block_size_aligned;\n    }\n    next_block_size_aligned = DAT_20000858;\n    current_block[1] = block_size_aligned | 1;\n    DAT_20000454 = current_block;\n    if (next_block_size_aligned <= block_size_aligned) {\n      FUN_0800884c(param_1,DAT_20000a44);\n    }\nLAB_080089f0:\n    FUN_080090b4(param_1);\n    return;\n  }\n  next_block[1] = next_block_size_aligned;\n  if ((flag & 1) == 0) {\n    current_block = (uint *)((int)current_block - *(int *)(block_size + -8));\n    ptr_to_data = (undefined4 *)current_block[2];\n    block_size_aligned = block_size_aligned + *(int *)(block_size + -8);\n    flag = *(uint *)((int)next_block + next_block_size_aligned + 4) & 1;\n    if ((uint **)ptr_to_data == &DAT_20000454) {\n      if (flag == 0) {\n        flag = next_block[2];\n        temp_value = next_block[3];\n        block_size_aligned = block_size_aligned + next_block_size_aligned;\n        *(uint *)(flag + 0xc) = temp_value;\n        *(uint *)(temp_value + 8) = flag;\n        current_block[1] = block_size_aligned | 1;\n        *(uint *)((int)current_block + block_size_aligned) = block_size_aligned;\n      }\n      else {\n        current_block[1] = block_size_aligned | 1;\n        *next_block = block_size_aligned;\n      }\n      goto LAB_080089f0;\n    }\n    temp_value = current_block[3];\n    ptr_to_data[3] = temp_value;\n    *(undefined4 **)(temp_value + 8) = ptr_to_data;\n  }\n  else {\n    flag = *(uint *)((int)next_block + next_block_size_aligned + 4) & 1;\n  }\n  if (flag == 0) {\n    ptr_to_data = (undefined4 *)next_block[2];\n    block_size_aligned = block_size_aligned + next_block_size_aligned;\n    if ((uint **)ptr_to_data == &DAT_20000454) {\n      DAT_2000045c = current_block;\n      DAT_20000460 = current_block;\n      current_block[2] = (uint)&DAT_20000454;\n      current_block[3] = (uint)&DAT_20000454;\n      current_block[1] = block_size_aligned | 1;\n      *(uint *)((int)current_block + block_size_aligned) = block_size_aligned;\n      goto LAB_080089f0;\n    }\n    next_block_size_aligned = next_block[3];\n    ptr_to_data[3] = next_block_size_aligned;\n    *(undefined4 **)(next_block_size_aligned + 8) = ptr_to_data;\n    current_block[1] = block_size_aligned | 1;\n    *(uint *)((int)current_block + block_size_aligned) = block_size_aligned;\n  }\n  else {\n    current_block[1] = block_size_aligned | 1;\n    *(uint *)((int)current_block + block_size_aligned) = block_size_aligned;\n  }\n  if (block_size_aligned < 0x200) {\n    loop_var = (block_size_aligned >> 3) + 1;\n    block_size_aligned = 1 << ((int)(block_size_aligned >> 3) >> 2 & 0xffU) | (uint)DAT_20000450;\n    next_block_size_aligned = *(uint *)(&DAT_2000044c + loop_var * 8);\n    current_block[2] = next_block_size_aligned;\n    current_block[3] = (uint)(&DAT_20000444 + loop_var * 8);\n    DAT_20000450 = (undefined *)block_size_aligned;\n    *(uint **)(&DAT_2000044c + loop_var * 8) = current_block;\n    *(uint **)(next_block_size_aligned + 0xc) = current_block;\n    FUN_080090b4(param_1,current_block,block_size_aligned,param_4);\n    return;\n  }\n  next_block_size_aligned = block_size_aligned >> 9;\n  if (next_block_size_aligned < 5) {\n    loop_var = ((block_size_aligned >> 6) + 0x39) * 8;\n    index = (block_size_aligned >> 6) + 0x38;\n  }\n  else if (next_block_size_aligned < 0x15) {\n    loop_var = (next_block_size_aligned + 0x5c) * 8;\n    index = next_block_size_aligned + 0x5b;\n  }\n  else if (next_block_size_aligned < 0x55) {\n    loop_var = ((block_size_aligned >> 0xc) + 0x6f) * 8;\n    index = (block_size_aligned >> 0xc) + 0x6e;\n  }\n  else if (next_block_size_aligned < 0x155) {\n    loop_var = ((block_size_aligned >> 0xf) + 0x78) * 8;\n    index = (block_size_aligned >> 0xf) + 0x77;\n  }\n  else if (next_block_size_aligned < 0x555) {\n    loop_var = ((block_size_aligned >> 0x12) + 0x7d) * 8;\n    index = (block_size_aligned >> 0x12) + 0x7c;\n  }\n  else {\n    loop_var = 0x3f8;\n    index = 0x7e;\n  }\n  prev_block = *(undefined **)(&DAT_2000044c + loop_var);\n  temp_ptr = &DAT_20000444 + loop_var;\n  if (temp_ptr == prev_block) {\n    prev_block = (undefined *)(1 << (index >> 2 & 0xffU) | (uint)DAT_20000450);\n    temp_ptr2 = temp_ptr;\n    DAT_20000450 = prev_block;\n  }\n  else {\n    do {\n      temp_ptr2 = prev_block;\n      if ((*(uint *)(prev_block + 4) & 0xfffffffc) <= block_size_aligned) break;\n      prev_block = *(undefined **)(prev_block + 8);\n      temp_ptr2 = temp_ptr;\n    } while (temp_ptr != prev_block);\n    temp_ptr = *(undefined **)(temp_ptr2 + 0xc);\n  }\n  current_block[2] = (uint)temp_ptr2;\n  current_block[3] = (uint)temp_ptr;\n  *(uint **)(temp_ptr + 8) = current_block;\n  *(uint **)(temp_ptr2 + 0xc) = current_block;\n  FUN_080090b4(param_1,current_block,prev_block,param_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088ec": "allocate_memory_block_080088ec",
                "param_2": "block_size",
                "iVar1": "index",
                "puVar2": "current_block",
                "puVar3": "next_block",
                "puVar4": "prev_block",
                "uVar5": "block_size_aligned",
                "uVar6": "next_block_size_aligned",
                "puVar7": "temp_ptr",
                "puVar8": "temp_ptr2",
                "puVar9": "ptr_to_data",
                "iVar10": "loop_var",
                "uVar11": "flag",
                "uVar12": "temp_value"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080097cc",
                "FUN_08009adc",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_0800884c",
                "FUN_080090b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ad4": {
            "entrypoint": "0x08008ad4",
            "current_name": "get_modified_value_08008ad4",
            "code": "\nint getModifiedValue_08008ad4(void)\n\n{\n  int pointerValue;\n  \n  pointerValue = *(int *)(DAT_2000001c + 0x34);\n  if (pointerValue == 0) {\n    pointerValue = 0x2000085c;\n  }\n  return pointerValue + 0xf0;\n}\n\n",
            "renaming": {
                "FUN_08008ad4": "get_modified_value_08008ad4",
                "iVar1": "pointerValue"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "FUNC_08008af0",
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "calling": [
                "FUN_080090a8",
                "FUN_080098c0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af4": {
            "entrypoint": "0x08008af4",
            "current_name": "FUNC_08008af4",
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "calling": [
                "FUN_080090b4",
                "FUN_080098c0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af8": {
            "entrypoint": "0x08008af8",
            "current_name": "allocate_memory_08008af8",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_memory_08008af8(undefined4 *result_ptr,uint size)\n\n{\n  undefined *temp1;\n  uint temp2;\n  uint temp3;\n  int index1;\n  undefined *ptr1;\n  uint index2;\n  uint index3;\n  undefined4 *temp_ptr1;\n  undefined *temp_ptr2;\n  undefined *ptr2;\n  int *result;\n  uint temp_size;\n  uint temp_size_rounded;\n  int index4;\n  undefined4 *temp_ptr3;\n  undefined4 *temp_ptr4;\n  \n  temp_size = size + 0xb;\n  if (temp_size < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    FUN_080090a8();\n    temp_size_rounded = 0x10;\n    index1 = 0x18;\n    temp_size = 2;\nLAB_08008b18:\n    ptr2 = *(undefined **)((int)&DAT_20000450 + index1);\n    if ((ptr2 != &DAT_20000444 + index1) ||\n       (ptr2 = *(undefined **)((int)&DAT_20000458 + index1), &DAT_2000044c + index1 != ptr2)) {\n      index1 = *(int *)(ptr2 + 0xc);\n      ptr1 = ptr2 + (*(uint *)(ptr2 + 4) & 0xfffffffc);\n      temp_size = *(uint *)(ptr1 + 4);\nLAB_08008b34:\n      index4 = *(int *)(ptr2 + 8);\n      *(int *)(index4 + 0xc) = index1;\n      *(int *)(index1 + 8) = index4;\n      *(uint *)(ptr1 + 4) = temp_size | 1;\n      FUN_080090b4(result_ptr);\n      return (int *)(ptr2 + 8);\n    }\n    temp_size = temp_size + 2;\n  }\n  else {\n    temp_size_rounded = temp_size & 0xfffffff8;\n    if (((int)temp_size_rounded < 0) || (temp_size_rounded < size)) {\nLAB_08008c7a:\n      *result_ptr = 0xc;\n      return (int *)0x0;\n    }\n    FUN_080090a8();\n    if (temp_size_rounded < 0x1f8) {\n      temp_size = temp_size >> 3;\n      index1 = temp_size_rounded + 8;\n      goto LAB_08008b18;\n    }\n    temp2 = temp_size >> 9;\n    if (temp2 == 0) {\n      index1 = 0x200;\n      index2 = 0x40;\n      temp2 = 0x3f;\n    }\n    else if (temp2 < 5) {\n      index2 = (temp_size >> 6) + 0x39;\n      temp2 = (temp_size >> 6) + 0x38;\n      index1 = index2 * 8;\n    }\n    else if (temp2 < 0x15) {\n      index2 = temp2 + 0x5c;\n      temp2 = temp2 + 0x5b;\n      index1 = index2 * 8;\n    }\n    else if (temp2 < 0x55) {\n      index2 = (temp_size >> 0xc) + 0x6f;\n      temp2 = (temp_size >> 0xc) + 0x6e;\n      index1 = index2 * 8;\n    }\n    else if (temp2 < 0x155) {\n      index2 = (temp_size >> 0xf) + 0x78;\n      temp2 = (temp_size >> 0xf) + 0x77;\n      index1 = index2 * 8;\n    }\n    else if (temp2 < 0x555) {\n      index2 = (temp_size >> 0x12) + 0x7d;\n      temp2 = (temp_size >> 0x12) + 0x7c;\n      index1 = index2 * 8;\n    }\n    else {\n      index1 = 0x3f8;\n      index2 = 0x7f;\n      temp2 = 0x7e;\n    }\n    for (ptr2 = *(undefined **)((int)&DAT_20000450 + index1); temp_size = index2,\n        &DAT_20000444 + index1 != ptr2; ptr2 = *(undefined **)(ptr2 + 0xc)) {\n      index4 = (*(uint *)(ptr2 + 4) & 0xfffffffc) - temp_size_rounded;\n      temp_size = temp2;\n      if (0xf < index4) break;\n      if (-1 < index4) {\n        ptr1 = ptr2 + (*(uint *)(ptr2 + 4) & 0xfffffffc);\n        temp_size = *(uint *)(ptr1 + 4);\n        index1 = *(int *)(ptr2 + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  temp_ptr3 = DAT_2000045c;\n  if ((undefined **)DAT_2000045c == &DAT_20000454) {\n    index2 = 1 << ((int)temp_size >> 2 & 0xffU);\n    temp2 = DAT_20000450;\n    if (index2 <= DAT_20000450) goto LAB_08008c06;\n  }\n  else {\n    index2 = DAT_2000045c[1];\n    index3 = index2 & 0xfffffffc;\n    temp2 = index3 - temp_size_rounded;\n    if (0xf < (int)temp2) {\n      temp_ptr4 = (undefined4 *)(temp_size_rounded + (int)DAT_2000045c);\n      DAT_2000045c[1] = temp_size_rounded | 1;\n      DAT_2000045c = temp_ptr4;\n      DAT_20000460 = temp_ptr4;\n      temp_ptr4[2] = &DAT_20000454;\n      temp_ptr4[3] = &DAT_20000454;\n      temp_ptr4[1] = temp2 | 1;\n      *(uint *)((int)temp_ptr3 + index3) = temp2;\n      FUN_080090b4(result_ptr);\n      return temp_ptr3 + 2;\n    }\n    DAT_2000045c = &DAT_20000454;\n    DAT_20000460 = &DAT_20000454;\n    if (-1 < (int)temp2) {\n      *(uint *)((int)temp_ptr3 + index3 + 4) = *(uint *)((int)temp_ptr3 + index3 + 4) | 1;\n      FUN_080090b4(result_ptr);\n      return temp_ptr3 + 2;\n    }\n    if (index3 < 0x200) {\n      index1 = (index2 >> 3) + 1;\n      index4 = *(int *)(&DAT_2000044c + index1 * 8);\n      temp2 = 1 << ((int)(index2 >> 3) >> 2 & 0xffU) | DAT_20000450;\n      temp_ptr3[2] = index4;\n      temp_ptr3[3] = &DAT_20000444 + index1 * 8;\n      DAT_20000450 = temp2;\n      *(undefined4 **)(&DAT_2000044c + index1 * 8) = temp_ptr3;\n      *(undefined4 **)(index4 + 0xc) = temp_ptr3;\n    }\n    else {\n      temp2 = index2 >> 9;\n      if (temp2 < 5) {\n        index1 = ((index2 >> 6) + 0x39) * 8;\n        index4 = (index2 >> 6) + 0x38;\n      }\n      else if (temp2 < 0x15) {\n        index1 = (temp2 + 0x5c) * 8;\n        index4 = temp2 + 0x5b;\n      }\n      else if (temp2 < 0x55) {\n        index1 = ((index2 >> 0xc) + 0x6f) * 8;\n        index4 = (index2 >> 0xc) + 0x6e;\n      }\n      else if (temp2 < 0x155) {\n        index1 = ((index2 >> 0xf) + 0x78) * 8;\n        index4 = (index2 >> 0xf) + 0x77;\n      }\n      else if (temp2 < 0x555) {\n        index1 = ((index2 >> 0x12) + 0x7d) * 8;\n        index4 = (index2 >> 0x12) + 0x7c;\n      }\n      else {\n        index1 = 0x3f8;\n        index4 = 0x7e;\n      }\n      ptr2 = *(undefined **)(&DAT_2000044c + index1);\n      ptr1 = &DAT_20000444 + index1;\n      if (ptr1 == ptr2) {\n        DAT_20000450 = 1 << (index4 >> 2 & 0xffU) | DAT_20000450;\n      }\n      else {\n        do {\n          if ((*(uint *)(ptr2 + 4) & 0xfffffffc) <= index3) break;\n          ptr2 = *(undefined **)(ptr2 + 8);\n        } while (ptr1 != ptr2);\n        ptr1 = *(undefined **)(ptr2 + 0xc);\n      }\n      temp2 = DAT_20000450;\n      temp_ptr3[2] = ptr2;\n      temp_ptr3[3] = ptr1;\n      *(undefined4 **)(ptr1 + 8) = temp_ptr3;\n      *(undefined4 **)(ptr2 + 0xc) = temp_ptr3;\n    }\n    index2 = 1 << ((int)temp_size >> 2 & 0xffU);\n    if (index2 <= temp2) {\nLAB_08008c06:\n      if ((index2 & temp2) == 0) {\n        temp_size = temp_size & 0xfffffffc;\n        do {\n          index2 = index2 << 1;\n          temp_size = temp_size + 4;\n        } while ((index2 & temp2) == 0);\n      }\n      do {\n        temp_ptr4 = (undefined4 *)(&DAT_2000044c + temp_size * 8);\n        temp2 = temp_size;\n        temp_ptr3 = temp_ptr4;\n        do {\n          for (temp_ptr1 = (undefined4 *)temp_ptr3[3]; temp_ptr3 != temp_ptr1;\n              temp_ptr1 = (undefined4 *)temp_ptr1[3]) {\n            index3 = temp_ptr1[1] & 0xfffffffc;\n            temp3 = index3 - temp_size_rounded;\n            if (0xf < (int)temp3) {\n              index4 = temp_ptr1[2];\n              index1 = temp_ptr1[3];\n              temp_ptr3 = (undefined4 *)(temp_size_rounded + (int)temp_ptr1);\n              temp_ptr1[1] = temp_size_rounded | 1;\n              *(int *)(index4 + 0xc) = index1;\n              *(int *)(index1 + 8) = index4;\n              DAT_2000045c = temp_ptr3;\n              DAT_20000460 = temp_ptr3;\n              temp_ptr3[2] = &DAT_20000454;\n              temp_ptr3[3] = &DAT_20000454;\n              temp_ptr3[1] = temp3 | 1;\n              *(uint *)((int)temp_ptr1 + index3) = temp3;\n              FUN_080090b4(result_ptr);\n              return temp_ptr1 + 2;\n            }\n            if (-1 < (int)temp3) {\n              index1 = temp_ptr1[3];\n              index4 = temp_ptr1[2];\n              *(uint *)((int)temp_ptr1 + index3 + 4) = *(uint *)((int)temp_ptr1 + index3 + 4) | 1;\n              *(int *)(index4 + 0xc) = index1;\n              *(int *)(index1 + 8) = index4;\n              FUN_080090b4(result_ptr);\n              return temp_ptr1 + 2;\n            }\n          }\n          temp2 = temp2 + 1;\n          temp_ptr3 = temp_ptr3 + 2;\n        } while ((temp2 & 3) != 0);\n        do {\n          index3 = temp_size & 3;\n          temp_ptr3 = temp_ptr4 + -2;\n          temp_size = temp_size - 1;\n          if (index3 == 0) {\n            DAT_20000450 = DAT_20000450 & ~index2;\n            break;\n          }\n          temp_ptr4 = (undefined4 *)*temp_ptr4;\n        } while (temp_ptr4 == temp_ptr3);\n        index2 = index2 * 2;\n        if ((DAT_20000450 <= index2 && index2 - DAT_20000450 != 0) || (temp_size = temp2, index2 == 0))\n        break;\n        for (; (index2 & DAT_20000450) == 0; index2 = index2 << 1) {\n          temp_size = temp_size + 4;\n        }\n      } while( true );\n    }\n  }\n  ptr2 = DAT_20000454;\n  temp_size = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  if ((temp_size_rounded <= temp_size) && (temp2 = temp_size - temp_size_rounded, 0xf < (int)temp2)) goto LAB_08008dac;\n  if (DAT_20000854 == (undefined *)0xffffffff) {\n    temp2 = temp_size_rounded + DAT_20000a44 + 0x10;\n  }\n  else {\n    temp2 = temp_size_rounded + DAT_20000a44 + 0x100f & 0xfffff000;\n  }\n  ptr1 = (undefined *)FUN_08009744(result_ptr,temp2);\n  if (ptr1 == (undefined *)0xffffffff) {\nLAB_08008ed8:\n    temp_size = *(uint *)(DAT_20000454 + 4);\n  }\n  else {\n    temp1 = ptr2 + temp_size;\n    if (temp1 < ptr1 || temp1 == ptr1) {\n      temp_ptr2 = DAT_20000a14 + temp2;\n      if ((temp1 != ptr1) || (((uint)temp1 & 0xfff) != 0)) goto LAB_08008d02;\n      DAT_20000a14 = temp_ptr2;\n      *(uint *)(DAT_20000454 + 4) = temp_size + temp2 | 1;\n    }\n    else {\n      if (ptr2 != &DAT_2000044c) goto LAB_08008ed8;\nLAB_08008d02:\n      DAT_20000a14 = DAT_20000a14 + temp2;\n      temp_ptr2 = ptr1;\n      if (DAT_20000854 != (undefined *)0xffffffff) {\n        DAT_20000a14 = DAT_20000a14 + ((int)ptr1 - (int)temp1);\n        temp_ptr2 = DAT_20000854;\n      }\n      DAT_20000854 = temp_ptr2;\n      index2 = (uint)ptr1 & 7;\n      if (index2 == 0) {\n        index1 = 0x1000;\n      }\n      else {\n        ptr1 = ptr1 + (8 - index2);\n        index1 = 0x1008 - index2;\n      }\n      index1 = index1 - ((uint)(ptr1 + temp2) & 0xfff);\n      index4 = FUN_08009744(result_ptr,index1);\n      if (index4 == -1) {\n        temp2 = 1;\n        index1 = 0;\n      }\n      else {\n        temp2 = (index4 - (int)ptr1) + index1 | 1;\n      }\n      temp_ptr2 = DAT_20000a14 + index1;\n      DAT_20000454 = ptr1;\n      DAT_20000a14 = temp_ptr2;\n      *(uint *)(ptr1 + 4) = temp2;\n      if (ptr2 != &DAT_2000044c) {\n        if (temp_size < 0x10) {\n          *(undefined4 *)(ptr1 + 4) = 1;\n          goto LAB_08008eee;\n        }\n        temp_size = temp_size - 0xc & 0xfffffff8;\n        *(uint *)(ptr2 + 4) = *(uint *)(ptr2 + 4) & 1 | temp_size;\n        *(undefined4 *)(ptr2 + temp_size + 4) = 5;\n        *(undefined4 *)(ptr2 + temp_size + 8) = 5;\n        if (0xf < temp_size) {\n          FUN_080088ec(result_ptr,ptr2 + 8);\n          temp_ptr2 = DAT_20000a14;\n        }\n      }\n    }\n    if (DAT_20000a3c < temp_ptr2) {\n      DAT_20000a3c = temp_ptr2;\n    }\n    temp_size = *(uint *)(DAT_20000454 + 4);\n    if (DAT_20000a40 < temp_ptr2) {\n      DAT_20000a40 = temp_ptr2;\n    }\n  }\n  temp2 = (temp_size & 0xfffffffc) - temp_size_rounded;\n  if ((temp_size_rounded <= (temp_size & 0xfffffffc)) && (0xf < (int)temp2)) {\nLAB_08008dac:\n    ptr2 = DAT_20000454 + temp_size_rounded;\n    *(uint *)(DAT_20000454 + 4) = temp_size_rounded | 1;\n    result = (int *)(DAT_20000454 + 8);\n    DAT_20000454 = ptr2;\n    *(uint *)(ptr2 + 4) = temp2 | 1;\n    FUN_080090b4(result_ptr);\n    return result;\n  }\nLAB_08008eee:\n  FUN_080090b4(result_ptr);\n  return (int *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08008af8": "allocate_memory_08008af8",
                "param_1": "result_ptr",
                "param_2": "size",
                "puVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "iVar4": "index1",
                "puVar5": "ptr1",
                "uVar6": "index2",
                "uVar7": "index3",
                "puVar8": "temp_ptr1",
                "puVar9": "temp_ptr2",
                "puVar10": "ptr2",
                "piVar11": "result",
                "uVar12": "temp_size",
                "uVar13": "temp_size_rounded",
                "iVar14": "index4",
                "puVar15": "temp_ptr3",
                "puVar16": "temp_ptr4"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080097cc",
                "FUN_08009adc",
                "FUN_08009980"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_080090b4",
                "FUN_080088ec",
                "FUN_08009744"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800901c": {
            "entrypoint": "0x0800901c",
            "current_name": "find_byte_sequence_0800901c",
            "code": "\nuint * find_byte_sequence_0800901c(uint *input_ptr,uint value,uint size)\n\n{\n  uint temp;\n  uint combined_value;\n  uint *current_ptr;\n  uint byte_value;\n  bool is_zero;\n  \n  byte_value = value & 0xff;\n  if (((uint)input_ptr & 3) == 0) {\nLAB_0800904a:\n    if (3 < size) {\n      combined_value = (value & 0xff) << 8 | byte_value;\n      current_ptr = input_ptr;\n      do {\n        temp = *current_ptr ^ (combined_value | combined_value << 0x10);\n        input_ptr = current_ptr + 1;\n        if ((temp + 0xfefefeff & ~temp & 0x80808080) != 0) goto LAB_08009050;\n        size = size - 4;\n        current_ptr = input_ptr;\n      } while (3 < size);\n    }\n    current_ptr = input_ptr;\n    if (size == 0) {\n      input_ptr = (uint *)0x0;\n    }\n    else {\nLAB_08009050:\n      input_ptr = current_ptr;\n      if (*(byte *)input_ptr != byte_value) {\n        current_ptr = (uint *)(size + (int)input_ptr);\n        do {\n          input_ptr = (uint *)((int)input_ptr + 1);\n          if (current_ptr == input_ptr) goto LAB_0800906c;\n        } while (*(byte *)input_ptr != byte_value);\n      }\n    }\n  }\n  else {\n    combined_value = size - 1;\n    if (size == 0) {\nLAB_0800906c:\n      input_ptr = (uint *)0x0;\n    }\n    else if (*(byte *)input_ptr != byte_value) {\n      current_ptr = (uint *)((int)input_ptr + 1);\n      do {\n        input_ptr = current_ptr;\n        size = combined_value;\n        if (((uint)input_ptr & 3) == 0) goto LAB_0800904a;\n        is_zero = combined_value == 0;\n        combined_value = combined_value - 1;\n        if (is_zero) goto LAB_0800906c;\n        current_ptr = (uint *)((int)input_ptr + 1);\n      } while (*(byte *)input_ptr != byte_value);\n    }\n  }\n  return input_ptr;\n}\n\n",
            "renaming": {
                "FUN_0800901c": "find_byte_sequence_0800901c",
                "param_1": "input_ptr",
                "param_2": "value",
                "param_3": "size",
                "uVar1": "temp",
                "uVar2": "combined_value",
                "puVar3": "current_ptr",
                "uVar4": "byte_value",
                "bVar5": "is_zero"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090a8": {
            "entrypoint": "0x080090a8",
            "current_name": "initialize_data_080090a8",
            "code": "\nvoid initialize_data_080090a8(void)\n\n{\n  FUNC_08008af0(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090a8": "initialize_data_080090a8"
            },
            "calling": [
                "FUN_0800884c",
                "FUN_080088ec",
                "FUN_08009adc",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08008af0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "initialize_data_080090b4",
            "code": "\nvoid initializeData_080090b4(void)\n\n{\n  FUNC_08008af4(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "initialize_data_080090b4"
            },
            "calling": [
                "FUN_0800884c",
                "FUN_080088ec",
                "FUN_08009adc",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08008af4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c0": {
            "entrypoint": "0x080090c0",
            "current_name": "find_or_create_value_080090c0",
            "code": "\nundefined4 * findOrCreateValue_080090c0(int ptrToData,uint index)\n\n{\n  undefined4 *ptrToValue;\n  int ptrToTable;\n  \n  ptrToTable = *(int *)(ptrToData + 0x4c);\n  if (ptrToTable == 0) {\n    ptrToTable = FUN_08009980(ptrToData,4,0x21);\n    *(int *)(ptrToData + 0x4c) = ptrToTable;\n    if (ptrToTable == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  ptrToValue = *(undefined4 **)(ptrToTable + index * 4);\n  if (ptrToValue == (undefined4 *)0x0) {\n    ptrToTable = 1 << (index & 0xff);\n    ptrToValue = (undefined4 *)FUN_08009980(ptrToData,1,(ptrToTable + 5) * 4);\n    if (ptrToValue == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    ptrToValue[1] = index;\n    ptrToValue[2] = ptrToTable;\n  }\n  else {\n    *(undefined4 *)(ptrToTable + index * 4) = *ptrToValue;\n  }\n  ptrToValue[3] = 0;\n  ptrToValue[4] = 0;\n  return ptrToValue;\n}\n\n",
            "renaming": {
                "FUN_080090c0": "find_or_create_value_080090c0",
                "param_1": "ptrToData",
                "param_2": "index",
                "puVar1": "ptrToValue",
                "iVar2": "ptrToTable"
            },
            "calling": [
                "FUN_08009444",
                "FUN_08009258",
                "FUN_080079e8",
                "FUN_08009244",
                "FUN_08009530",
                "FUN_080093a4",
                "FUN_08009120",
                "FUN_08009630"
            ],
            "called": [
                "FUN_08009980"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800910c": {
            "entrypoint": "0x0800910c",
            "current_name": "update_param_value_0800910c",
            "code": "\nvoid updateParamValue_0800910c(int sourceAddress,undefined4 *targetPointer)\n\n{\n  int dataAddress;\n  \n  if (targetPointer != (undefined4 *)0x0) {\n    dataAddress = *(int *)(sourceAddress + 0x4c);\n    *targetPointer = *(undefined4 *)(dataAddress + targetPointer[1] * 4);\n    *(undefined4 **)(dataAddress + targetPointer[1] * 4) = targetPointer;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800910c": "update_param_value_0800910c",
                "param_1": "sourceAddress",
                "param_2": "targetPointer",
                "iVar1": "dataAddress"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009120": {
            "entrypoint": "0x08009120",
            "current_name": "calculate_checksum_08009120",
            "code": "\nundefined4 * calculateChecksum_08009120(int input,undefined4 *data,int multiplier,uint checksum)\n\n{\n  undefined4 *result;\n  uint carry;\n  int length;\n  uint *dataPtr;\n  int i;\n  \n  i = 0;\n  length = data[4];\n  dataPtr = data + 5;\n  do {\n    i = i + 1;\n    checksum = multiplier * (*dataPtr & 0xffff) + checksum;\n    carry = multiplier * (*dataPtr >> 0x10) + (checksum >> 0x10);\n    *dataPtr = (checksum & 0xffff) + carry * 0x10000;\n    checksum = carry >> 0x10;\n    dataPtr = dataPtr + 1;\n  } while (i < length);\n  result = data;\n  if (checksum != 0) {\n    if ((int)data[2] <= length) {\n      result = (undefined4 *)FUN_080090c0(input,data[1] + 1);\n      FUN_08001084(result + 3,data + 3,(data[4] + 2) * 4);\n      i = *(int *)(input + 0x4c);\n      *data = *(undefined4 *)(i + data[1] * 4);\n      *(undefined4 **)(i + data[1] * 4) = data;\n    }\n    result[length + 5] = checksum;\n    result[4] = length + 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009120": "calculate_checksum_08009120",
                "param_1": "input",
                "param_2": "data",
                "param_3": "multiplier",
                "param_4": "checksum",
                "puVar1": "result",
                "uVar2": "carry",
                "iVar3": "length",
                "puVar4": "dataPtr",
                "iVar5": "i"
            },
            "calling": [
                "FUN_080079e8",
                "FUN_080093a4"
            ],
            "called": [
                "FUN_08001084",
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a4": {
            "entrypoint": "0x080091a4",
            "current_name": "count_leading_zeros_080091a4",
            "code": "\nint countLeadingZeros_080091a4(uint input)\n\n{\n  int leadingZeros;\n  \n  if ((input & 0xffff0000) == 0) {\n    input = input << 0x10;\n    leadingZeros = 0x10;\n  }\n  else {\n    leadingZeros = 0;\n  }\n  if ((input & 0xff000000) == 0) {\n    input = input << 8;\n    leadingZeros = leadingZeros + 8;\n  }\n  if ((input & 0xf0000000) == 0) {\n    input = input << 4;\n    leadingZeros = leadingZeros + 4;\n  }\n  if ((input & 0xc0000000) == 0) {\n    input = input << 2;\n    leadingZeros = leadingZeros + 2;\n  }\n  if (-1 < (int)input) {\n    if ((int)(input << 1) < 0) {\n      return leadingZeros + 1;\n    }\n    leadingZeros = 0x20;\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_080091a4": "count_leading_zeros_080091a4",
                "param_1": "input",
                "iVar1": "leadingZeros"
            },
            "calling": [
                "FUN_080079e8",
                "FUN_08009630"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091e4": {
            "entrypoint": "0x080091e4",
            "current_name": "find_highest_set_bit_080091e4",
            "code": "\nint find_highest_set_bit_080091e4(uint *num_ptr)\n\n{\n  int bit_position;\n  uint num;\n  \n  num = *num_ptr;\n  if ((num & 7) == 0) {\n    if ((num & 0xffff) == 0) {\n      num = num >> 0x10;\n      bit_position = 0x10;\n    }\n    else {\n      bit_position = 0;\n    }\n    if ((num & 0xff) == 0) {\n      num = num >> 8;\n      bit_position = bit_position + 8;\n    }\n    if ((num & 0xf) == 0) {\n      num = num >> 4;\n      bit_position = bit_position + 4;\n    }\n    if ((num & 3) == 0) {\n      num = num >> 2;\n      bit_position = bit_position + 2;\n    }\n    if (-1 < (int)(num << 0x1f)) {\n      num = num >> 1;\n      if (num == 0) {\n        return 0x20;\n      }\n      bit_position = bit_position + 1;\n    }\n    *num_ptr = num;\n    return bit_position;\n  }\n  if ((int)(num << 0x1f) < 0) {\n    return 0;\n  }\n  if (-1 < (int)(num << 0x1e)) {\n    *num_ptr = num >> 2;\n    return 2;\n  }\n  *num_ptr = num >> 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080091e4": "find_highest_set_bit_080091e4",
                "param_1": "num_ptr",
                "iVar1": "bit_position",
                "uVar2": "num"
            },
            "calling": [
                "FUN_08009630"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009244": {
            "entrypoint": "0x08009244",
            "current_name": "initialize_data_08009244",
            "code": "\nvoid initializeData_08009244(undefined4 dataBuffer,undefined4 dataValue)\n\n{\n  int bufferAddress;\n  \n  bufferAddress = FUN_080090c0(dataBuffer,1);\n  *(undefined4 *)(bufferAddress + 0x10) = 1;\n  *(undefined4 *)(bufferAddress + 0x14) = dataValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009244": "initialize_data_08009244",
                "param_1": "dataBuffer",
                "param_2": "dataValue",
                "iVar1": "bufferAddress"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009258": {
            "entrypoint": "0x08009258",
            "current_name": "initialize_array_08009258",
            "code": "\nvoid initializeArray_08009258(undefined4 arg1,int array1,int array2)\n\n{\n  uint *ptr1;\n  uint *ptr2;\n  int length;\n  uint tempVar;\n  uint *ptr3;\n  uint start;\n  uint *ptr4;\n  uint var1;\n  int length1;\n  int length2;\n  uint var2;\n  int length1;\n  int length2;\n  uint *ptr5;\n  uint *ptr6;\n  uint *ptr7;\n  uint *ptr8;\n  uint *ptr9;\n  \n  length1 = *(int *)(array1 + 0x10);\n  length1 = *(int *)(array2 + 0x10);\n  length2 = length1;\n  length2 = array1;\n  if (length1 < length1) {\n    length2 = length1;\n    length1 = length1;\n    length2 = array2;\n    array2 = array1;\n  }\n  length1 = length1 + length2;\n  length = *(int *)(length2 + 4);\n  if (*(int *)(length2 + 8) < length1) {\n    length = length + 1;\n  }\n  length = FUN_080090c0(arg1,length);\n  ptr9 = (uint *)(length + 0x14);\n  ptr8 = ptr9 + length1;\n  for (ptr3 = ptr9; ptr3 < ptr8; ptr3 = ptr3 + 1) {\n    *ptr3 = 0;\n  }\n  start = array2 + 0x14;\n  var2 = start + length2 * 4;\n  ptr3 = (uint *)(length2 + 0x14);\n  if (start < var2) {\n    ptr4 = (uint *)(start + ((var2 - array2) - 0x15 & 0xfffffffc));\n    ptr7 = (uint *)(array2 + 0x10);\n    do {\n      while( true ) {\n        ptr7 = ptr7 + 1;\n        start = *ptr7 & 0xffff;\n        if (start != 0) break;\n        start = *ptr7 >> 0x10;\n        if (start == 0) goto LAB_080092d2;\nLAB_0800932c:\n        var1 = *ptr9;\n        tempVar = 0;\n        ptr1 = ptr3;\n        ptr5 = ptr9;\n        var2 = var1;\n        do {\n          ptr6 = ptr5;\n          tempVar = tempVar + start * *(ushort *)ptr1 + (var2 >> 0x10);\n          *ptr6 = var1 & 0xffff | tempVar * 0x10000;\n          ptr2 = ptr1 + 1;\n          var2 = ptr6[1];\n          var1 = start * (*ptr1 >> 0x10) + (var2 & 0xffff) + (tempVar >> 0x10);\n          tempVar = var1 >> 0x10;\n          ptr1 = ptr2;\n          ptr5 = ptr6 + 1;\n        } while (ptr2 < ptr3 + length1);\n        ptr6[1] = var1;\n        ptr9 = ptr9 + 1;\n        if (ptr4 == ptr7) goto LAB_0800937a;\n      }\n      var2 = 0;\n      ptr1 = ptr9;\n      ptr5 = ptr3;\n      do {\n        ptr2 = ptr1;\n        ptr6 = ptr5 + 1;\n        var1 = start * (*ptr5 & 0xffff) + (*ptr2 & 0xffff) + var2;\n        tempVar = start * (*ptr5 >> 0x10) + (*ptr2 >> 0x10) + (var1 >> 0x10);\n        var2 = tempVar >> 0x10;\n        *ptr2 = var1 & 0xffff | tempVar * 0x10000;\n        ptr1 = ptr2 + 1;\n        ptr5 = ptr6;\n      } while (ptr6 < ptr3 + length1);\n      ptr2[1] = var2;\n      start = *ptr7 >> 0x10;\n      if (start != 0) goto LAB_0800932c;\nLAB_080092d2:\n      ptr9 = ptr9 + 1;\n    } while (ptr4 != ptr7);\n  }\nLAB_0800937a:\n  if (0 < length1) {\n    start = ptr8[-1];\n    ptr8 = ptr8 + -1;\n    while ((start == 0 && (length1 = length1 + -1, length1 != 0))) {\n      ptr8 = ptr8 + -1;\n      start = *ptr8;\n    }\n  }\n  *(int *)(length + 0x10) = length1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009258": "initialize_array_08009258",
                "param_1": "arg1",
                "param_2": "array1",
                "param_3": "array2",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "iVar3": "length",
                "uVar4": "tempVar",
                "puVar5": "ptr3",
                "uVar6": "start",
                "puVar7": "ptr4",
                "uVar8": "var1",
                "iVar9": "length1",
                "iVar10": "length2",
                "uVar11": "var2",
                "iVar12": "length1",
                "iVar13": "length2",
                "puVar14": "ptr5",
                "puVar15": "ptr6",
                "puVar16": "ptr7",
                "puVar17": "ptr8",
                "puVar18": "ptr9"
            },
            "calling": [
                "FUN_080079e8",
                "FUN_080093a4"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080093a4": {
            "entrypoint": "0x080093a4",
            "current_name": "process_data_080093a4",
            "code": "\nundefined4 * processData_080093a4(int dataPtr,undefined4 *resultPtr,uint dataSize)\n\n{\n  int offset;\n  int numWords;\n  undefined4 *currentPtr;\n  undefined4 *tempPtr;\n  \n  if ((dataSize & 3) != 0) {\n    resultPtr = (undefined4 *)\n              FUN_08009120(dataPtr,resultPtr,*(undefined4 *)(&DAT_0800a070 + ((dataSize & 3) - 1) * 4),\n                           0);\n  }\n  numWords = (int)dataSize >> 2;\n  if (numWords != 0) {\n    tempPtr = *(undefined4 **)(dataPtr + 0x48);\n    if (tempPtr == (undefined4 *)0x0) {\n      tempPtr = (undefined4 *)FUN_080090c0(dataPtr,1);\n      tempPtr[4] = 1;\n      tempPtr[5] = 0x271;\n      *(undefined4 **)(dataPtr + 0x48) = tempPtr;\n      *tempPtr = 0;\n    }\n    currentPtr = resultPtr;\n    if (numWords << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    numWords = numWords >> 1;\n    currentPtr = tempPtr;\n    if (numWords != 0) {\n      while( true ) {\n        tempPtr = (undefined4 *)*currentPtr;\n        if (tempPtr == (undefined4 *)0x0) {\n          tempPtr = (undefined4 *)FUN_08009258(dataPtr,currentPtr,currentPtr);\n          *currentPtr = tempPtr;\n          *tempPtr = 0;\n        }\n        currentPtr = resultPtr;\n        if (-1 < numWords << 0x1f) break;\nLAB_080093d2:\n        resultPtr = (undefined4 *)FUN_08009258(dataPtr,currentPtr,tempPtr);\n        if (currentPtr == (undefined4 *)0x0) break;\n        offset = *(int *)(dataPtr + 0x4c);\n        numWords = numWords >> 1;\n        *currentPtr = *(undefined4 *)(offset + currentPtr[1] * 4);\n        *(undefined4 **)(offset + currentPtr[1] * 4) = currentPtr;\n        currentPtr = tempPtr;\n        if (numWords == 0) {\n          return resultPtr;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return resultPtr;\n}\n\n",
            "renaming": {
                "FUN_080093a4": "process_data_080093a4",
                "param_1": "dataPtr",
                "param_2": "resultPtr",
                "param_3": "dataSize",
                "iVar1": "offset",
                "iVar2": "numWords",
                "puVar3": "currentPtr",
                "puVar4": "tempPtr"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08009258",
                "FUN_080090c0",
                "FUN_08009120"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009444": {
            "entrypoint": "0x08009444",
            "current_name": "transform_data_08009444",
            "code": "\nvoid transformData_08009444(int inputData,undefined4 *outputData,uint bitSize)\n\n{\n  int loopIncrement;\n  int currentValue;\n  int offset;\n  undefined4 newValue;\n  int startOffset;\n  int tempValue;\n  uint *outputPtr;\n  uint *inputPtr;\n  uint *tempPtr;\n  uint *currentInputPtr;\n  int resultSize;\n  int newResultSize;\n  uint bitShiftAmount;\n  uint *currentOutputPtr;\n  \n  startOffset = outputData[4];\n  resultSize = (int)bitSize >> 5;\n  newResultSize = resultSize + startOffset + 1;\n  offset = outputData[1];\n  currentValue = outputData[2];\n  if ((int)outputData[2] < newResultSize) {\n    do {\n      tempValue = currentValue * 2;\n      loopIncrement = currentValue * -2;\n      offset = offset + 1;\n      currentValue = tempValue;\n    } while (newResultSize != tempValue && newResultSize + loopIncrement < 0 == SBORROW4(newResultSize,tempValue));\n  }\n  currentValue = FUN_080090c0(inputData,offset);\n  outputPtr = (uint *)(currentValue + 0x14);\n  if (0 < resultSize) {\n    currentInputPtr = outputPtr + resultSize;\n    inputPtr = outputPtr;\n    do {\n      currentOutputPtr = inputPtr + 1;\n      *inputPtr = 0;\n      outputPtr = currentInputPtr;\n      inputPtr = currentOutputPtr;\n    } while (currentOutputPtr != currentInputPtr);\n  }\n  offset = outputData[4];\n  inputPtr = outputData + 5;\n  bitSize = bitSize & 0x1f;\n  if (bitSize == 0) {\n    outputPtr = outputPtr + -1;\n    currentInputPtr = inputPtr;\n    do {\n      currentOutputPtr = currentInputPtr + 1;\n      outputPtr = outputPtr + 1;\n      *outputPtr = *currentInputPtr;\n      currentInputPtr = currentOutputPtr;\n    } while (currentOutputPtr < inputPtr + offset);\n  }\n  else {\n    bitShiftAmount = 0;\n    currentInputPtr = inputPtr;\n    do {\n      currentOutputPtr = outputPtr;\n      *currentOutputPtr = *currentInputPtr << bitSize | bitShiftAmount;\n      tempPtr = currentInputPtr + 1;\n      bitShiftAmount = *currentInputPtr >> (0x20 - bitSize & 0xff);\n      outputPtr = currentOutputPtr + 1;\n      currentInputPtr = tempPtr;\n    } while (tempPtr < inputPtr + offset);\n    currentOutputPtr[1] = bitShiftAmount;\n    if (bitShiftAmount != 0) {\n      newResultSize = resultSize + startOffset + 2;\n    }\n  }\n  startOffset = *(int *)(inputData + 0x4c);\n  offset = outputData[1];\n  newValue = *(undefined4 *)(startOffset + offset * 4);\n  *(int *)(currentValue + 0x10) = newResultSize + -1;\n  *outputData = newValue;\n  *(undefined4 **)(startOffset + offset * 4) = outputData;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009444": "transform_data_08009444",
                "param_1": "inputData",
                "param_2": "outputData",
                "param_3": "bitSize",
                "iVar1": "loopIncrement",
                "iVar2": "currentValue",
                "iVar3": "offset",
                "uVar4": "newValue",
                "iVar5": "startOffset",
                "iVar6": "tempValue",
                "puVar7": "outputPtr",
                "puVar8": "inputPtr",
                "puVar9": "currentOutputPtr",
                "puVar10": "tempPtr",
                "puVar11": "currentInputPtr",
                "iVar12": "resultSize",
                "iVar13": "newResultSize",
                "uVar14": "bitShiftAmount"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094f8": {
            "entrypoint": "0x080094f8",
            "current_name": "compare_arrays_080094f8",
            "code": "\nint compareArrays_080094f8(int array1_start,int array2_start)\n\n{\n  int array_size_difference;\n  uint *array2_ptr;\n  int array2_offset;\n  uint *array1_ptr;\n  \n  array2_offset = *(int *)(array2_start + 0x10);\n  array_size_difference = *(int *)(array1_start + 0x10) - array2_offset;\n  if (array_size_difference == 0) {\n    array2_ptr = (uint *)(array2_start + 0x14 + array2_offset * 4);\n    array1_ptr = (uint *)(array1_start + 0x14) + array2_offset;\n    do {\n      array1_ptr = array1_ptr + -1;\n      array2_ptr = array2_ptr + -1;\n      if (*array1_ptr != *array2_ptr) {\n        if (*array2_ptr <= *array1_ptr) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1_start + 0x14) < array1_ptr);\n  }\n  return array_size_difference;\n}\n\n",
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1_start",
                "param_2": "array2_start",
                "iVar1": "array_size_difference",
                "iVar3": "array2_offset",
                "puVar2": "array2_ptr",
                "puVar4": "array1_ptr"
            },
            "calling": [
                "FUN_080079e8",
                "FUN_080078c0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009530": {
            "entrypoint": "0x08009530",
            "current_name": "validate_and_copy_data_08009530",
            "code": "\nvoid validateAndCopyData_08009530(undefined4 input_param,uint *source_data,uint *destination_data,undefined4 additional_param)\n\n{\n  int output;\n  uint *source_data_last_item;\n  uint source_data_item;\n  uint sum;\n  undefined4 isValid;\n  uint *destination_data_last_item;\n  uint *source_data_iterator;\n  uint *source_data_start;\n  uint *destination_data_start;\n  uint *source_data_end;\n  int carry;\n  uint *source_data_start_second;\n  uint source_data_length;\n  uint *destination_data_iterator;\n  \n  source_data_last_item = (uint *)destination_data[4];\n  source_data_end = source_data + 5;\n  source_data_start_second = destination_data + 5;\n  source_data_iterator = source_data_end;\n  source_data_start = source_data;\n  if ((uint *)source_data[4] == source_data_last_item) {\n    destination_data_last_item = source_data_end + (int)source_data_last_item;\n    source_data_last_item = source_data_start_second + (int)source_data_last_item;\n    while( true ) {\n      destination_data_last_item = destination_data_last_item + -1;\n      source_data_last_item = source_data_last_item + -1;\n      if (*destination_data_last_item != *source_data_last_item) break;\n      if (destination_data_last_item <= source_data_end) {\n        carry = FUN_080090c0(input_param,0,destination_data_last_item,source_data_last_item,additional_param);\n        *(undefined4 *)(carry + 0x10) = 1;\n        *(undefined4 *)(carry + 0x14) = 0;\n        return;\n      }\n    }\n    isValid = 0;\n    if (*source_data_last_item <= *destination_data_last_item) goto LAB_08009578;\n  }\n  else if (-1 < (int)(uint *)source_data[4] - (int)source_data_last_item) {\n    isValid = 0;\n    destination_data_last_item = destination_data;\n    goto LAB_08009578;\n  }\n  isValid = 1;\n  destination_data_last_item = source_data_end;\n  source_data_last_item = source_data;\n  source_data_iterator = source_data_start_second;\n  source_data_start = destination_data;\n  destination_data = source_data;\n  source_data_start_second = source_data_end;\nLAB_08009578:\n  output = FUN_080090c0(input_param,source_data_start[1],destination_data_last_item,source_data_last_item,additional_param);\n  carry = 0;\n  source_data_length = source_data_start[4];\n  source_data_item = destination_data[4];\n  *(undefined4 *)(output + 0xc) = isValid;\n  source_data_end = source_data_iterator + source_data_length;\n  source_data_last_item = (uint *)(output + 0x14);\n  source_data_start = source_data_start_second;\n  do {\n    destination_data_iterator = source_data_iterator + 1;\n    destination_data_start = source_data_start + 1;\n    sum = ((*source_data_iterator & 0xffff) + carry) - (*source_data_start & 0xffff);\n    carry = ((*source_data_iterator >> 0x10) - (*source_data_start >> 0x10)) + ((int)sum >> 0x10);\n    sum = sum & 0xffff | carry * 0x10000;\n    destination_data_last_item = source_data_last_item + 1;\n    *source_data_last_item = sum;\n    carry = carry >> 0x10;\n    source_data_last_item = destination_data_last_item;\n    source_data_iterator = destination_data_iterator;\n    source_data_start = destination_data_start;\n  } while (destination_data_start < source_data_start_second + source_data_item);\n  source_data_last_item = destination_data_iterator;\n  source_data_iterator = destination_data_last_item;\n  if (destination_data_iterator < source_data_end) {\n    do {\n      source_data_start = source_data_last_item + 1;\n      source_data_item = (*source_data_last_item & 0xffff) + carry;\n      carry = ((int)source_data_item >> 0x10) + (*source_data_last_item >> 0x10);\n      sum = source_data_item & 0xffff | carry * 0x10000;\n      *source_data_iterator = sum;\n      carry = carry >> 0x10;\n      source_data_last_item = source_data_start;\n      source_data_iterator = source_data_iterator + 1;\n    } while (source_data_start < source_data_end);\n    destination_data_last_item = (uint *)((int)destination_data_last_item + ((int)source_data_end + ~(uint)destination_data_iterator & 0xfffffffc) + 4);\n  }\n  destination_data_last_item = destination_data_last_item + -1;\n  while (sum == 0) {\n    destination_data_last_item = destination_data_last_item + -1;\n    source_data_length = source_data_length - 1;\n    sum = *destination_data_last_item;\n  }\n  *(uint *)(output + 0x10) = source_data_length;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009530": "validate_and_copy_data_08009530",
                "param_1": "input_param",
                "param_2": "source_data",
                "param_3": "destination_data",
                "param_4": "additional_param",
                "iVar1": "output",
                "puVar2": "source_data_last_item",
                "uVar3": "source_data_item",
                "uVar4": "sum",
                "uVar5": "isValid",
                "puVar6": "destination_data_last_item",
                "puVar7": "source_data_iterator",
                "puVar8": "destination_data_iterator",
                "puVar9": "source_data_start",
                "puVar10": "destination_data_start",
                "puVar11": "source_data_end",
                "iVar12": "carry",
                "puVar13": "source_data_start_second",
                "uVar14": "source_data_length"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009630": {
            "entrypoint": "0x08009630",
            "current_name": "decode_and_transform_08009630",
            "code": "\nint decode_and_transform_08009630(undefined4 input_flag,undefined4 input_key,uint num1,uint num2,int *output_param1,\n                int *output_param2)\n\n{\n  int result;\n  uint var1;\n  int var2;\n  int var3;\n  uint var4;\n  uint var5;\n  undefined8 var6;\n  uint local_var1;\n  uint local_var2;\n  \n  result = FUN_080090c0(input_flag,1);\n  var5 = (num2 << 1) >> 0x15;\n  local_var2 = num2 & 0xfffff;\n  if (var5 != 0) {\n    local_var2 = local_var2 | 0x100000;\n  }\n  if (num1 == 0) {\n    var2 = FUN_080091e4(&local_var2);\n    var3 = 1;\n    var1 = var2 + 0x20;\n    *(undefined4 *)(result + 0x10) = 1;\n    *(uint *)(result + 0x14) = local_var2;\n  }\n  else {\n    local_var1 = num1;\n    var1 = FUN_080091e4(&local_var1);\n    if (var1 == 0) {\n      *(uint *)(result + 0x14) = local_var1;\n    }\n    else {\n      var4 = local_var2 << (0x20 - var1 & 0xff);\n      local_var2 = local_var2 >> (var1 & 0xff);\n      *(uint *)(result + 0x14) = var4 | local_var1;\n    }\n    if (local_var2 == 0) {\n      var3 = 1;\n    }\n    else {\n      var3 = 2;\n    }\n    *(uint *)(result + 0x18) = local_var2;\n    *(int *)(result + 0x10) = var3;\n  }\n  if (var5 == 0) {\n    *output_param1 = var1 - 0x432;\n    var6 = FUN_080091a4(*(undefined4 *)(result + var3 * 4 + 0x10));\n    *output_param2 = (int)((ulonglong)var6 >> 0x20) * 0x20 - (int)var6;\n    return result;\n  }\n  *output_param1 = (var5 - 0x433) + var1;\n  *output_param2 = 0x35 - var1;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009630": "decode_and_transform_08009630",
                "param_1": "input_flag",
                "param_2": "input_key",
                "param_3": "num1",
                "param_4": "num2",
                "param_5": "output_param1",
                "param_6": "output_param2",
                "iVar1": "result",
                "uVar2": "var1",
                "iVar3": "var2",
                "iVar4": "var3",
                "uVar5": "var4",
                "uVar6": "var5",
                "uVar7": "var6",
                "local_20": "local_var1",
                "local_1c": "local_var2"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080091e4",
                "FUN_080090c0",
                "FUN_080091a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e0": {
            "entrypoint": "0x080096e0",
            "current_name": "convert_floating_point_080096e0",
            "code": "\nundefined8 convertFloatingPoint_080096e0(uint num1,uint num2,int *result,undefined4 param4)\n\n{\n  int counter;\n  uint absNum2;\n  undefined8 combinedNum;\n  \n  combinedNum = CONCAT44(num2,num1);\n  counter = 0;\n  absNum2 = num2 & 0x7fffffff;\n  *result = 0;\n  if ((absNum2 < 0x7ff00000) && ((absNum2 | num1) != 0)) {\n    if (absNum2 < 0x100000) {\n      combinedNum = FUN_080004c8(num1,num2,0,0x43500000,param4);\n      counter = -0x36;\n      absNum2 = (uint)((ulonglong)combinedNum >> 0x20) & 0x7fffffff;\n    }\n    num1 = (uint)combinedNum;\n    num2 = (uint)((ulonglong)combinedNum >> 0x20) & 0x800fffff | 0x3fe00000;\n    *result = ((int)absNum2 >> 0x14) + -0x3fe + counter;\n  }\n  return CONCAT44(num2,num1);\n}\n\n",
            "renaming": {
                "FUN_080096e0": "convert_floating_point_080096e0",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "result",
                "param_4": "param4",
                "iVar1": "counter",
                "uVar2": "absNum2",
                "uVar3": "combinedNum"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_080004c8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009744": {
            "entrypoint": "0x08009744",
            "current_name": "handle_error_08009744",
            "code": "\nvoid handleError_08009744(int *output,undefined4 input)\n\n{\n  int result;\n  \n  DAT_20000c10 = 0;\n  result = FUN_08005728(input);\n  if ((result == -1) && (DAT_20000c10 != 0)) {\n    *output = DAT_20000c10;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009744": "handle_error_08009744",
                "param_1": "output",
                "param_2": "input",
                "iVar1": "result"
            },
            "calling": [
                "FUN_0800884c",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08005728"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009768": {
            "entrypoint": "0x08009768",
            "current_name": "copy_string_08009768",
            "code": "\nvoid copyString_08009768(uint *source,uint *destination,uint length)\n\n{\n  char currentChar;\n  uint *destPtr;\n  uint *srcPtr;\n  uint currentVal;\n  \n  if (((((uint)source | (uint)destination) & 3) == 0) &&\n     (srcPtr = source, destPtr = destination, 3 < length)) {\n    do {\n      destination = destPtr + 1;\n      currentVal = *destPtr;\n      source = srcPtr;\n      if ((currentVal + 0xfefefeff & ~currentVal & 0x80808080) != 0) goto LAB_0800979c;\n      length = length - 4;\n      source = srcPtr + 1;\n      *srcPtr = currentVal;\n      srcPtr = source;\n      destPtr = destination;\n    } while (3 < length);\n  }\n  destPtr = destination;\n  if (length != 0) {\nLAB_0800979c:\n    currentChar = *(char *)destPtr;\n    *(char *)source = currentChar;\n    while( true ) {\n      source = (uint *)((int)source + 1);\n      length = length - 1;\n      if (currentChar == '\\0') break;\n      if (length == 0) {\n        return;\n      }\n      destPtr = (uint *)((int)destPtr + 1);\n      currentChar = *(char *)destPtr;\n      *(char *)source = currentChar;\n    }\n    if (length != 0) {\n      destPtr = source;\n      do {\n        srcPtr = (uint *)((int)destPtr + 1);\n        *(char *)destPtr = '\\0';\n        destPtr = srcPtr;\n      } while (srcPtr != (uint *)(length + (int)source));\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009768": "copy_string_08009768",
                "param_1": "source",
                "param_2": "destination",
                "param_3": "length",
                "cVar1": "currentChar",
                "puVar2": "destPtr",
                "puVar3": "srcPtr",
                "uVar4": "currentVal"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080097cc": {
            "entrypoint": "0x080097cc",
            "current_name": "process_data_080097cc",
            "code": "\nundefined4 process_data_080097cc(undefined4 *result,int *data,int *info)\n\n{\n  int current_value;\n  uint temp_value;\n  int new_value;\n  int offset;\n  uint max_value;\n  uint value;\n  undefined4 *ptr_1;\n  undefined4 *ptr_2;\n  undefined4 data_value;\n  \n  if (info[2] != 0) {\n    current_value = *data;\n    max_value = data[2];\n    ptr_2 = (undefined4 *)*info;\n    do {\n      do {\n        ptr_1 = ptr_2 + 2;\n        data_value = *ptr_2;\n        value = ptr_2[1];\n        ptr_2 = ptr_1;\n      } while (value == 0);\n      temp_value = value;\n      if ((max_value <= value) && (temp_value = max_value, (*(ushort *)(data + 3) & 0x480) != 0)) {\n        offset = current_value - data[4];\n        max_value = (data[5] * 3) / 2;\n        temp_value = value + 1 + offset;\n        if (max_value < temp_value) {\n          max_value = temp_value;\n        }\n        if ((int)((uint)*(ushort *)(data + 3) << 0x15) < 0) {\n          new_value = FUN_08008af8(result,max_value);\n          if (new_value == 0) {\nLAB_08009896:\n            *result = 0xc;\n            *(ushort *)(data + 3) = *(ushort *)(data + 3) | 0x40;\n            info[1] = 0;\n            info[2] = 0;\n            return 0xffffffff;\n          }\n          FUN_08001084(new_value,data[4],offset);\n          *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          new_value = FUN_08009adc(result);\n          if (new_value == 0) {\n            FUN_080088ec(result,data[4]);\n            goto LAB_08009896;\n          }\n        }\n        current_value = new_value + offset;\n        data[5] = max_value;\n        data[4] = new_value;\n        *data = current_value;\n        data[2] = max_value - offset;\n        temp_value = value;\n      }\n      FUN_08009a18(current_value,data_value,temp_value);\n      offset = info[2];\n      max_value = data[2] - temp_value;\n      current_value = *data + temp_value;\n      data[2] = max_value;\n      *data = current_value;\n      info[2] = offset - value;\n    } while (offset - value != 0);\n  }\n  info[1] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080097cc": "process_data_080097cc",
                "param_1": "result",
                "param_2": "data",
                "param_3": "info",
                "iVar1": "current_value",
                "uVar2": "temp_value",
                "iVar3": "new_value",
                "iVar4": "offset",
                "uVar5": "max_value",
                "uVar6": "value",
                "puVar7": "ptr_1",
                "puVar8": "ptr_2",
                "uVar9": "data_value"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_08001084",
                "FUN_080088ec",
                "FUN_08009adc",
                "FUN_08009a18",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098c0": {
            "entrypoint": "0x080098c0",
            "current_name": "update_data_080098c0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009906) */\n/* WARNING: Removing unreachable block (ram,0x08009912) */\n\nundefined4 updateData_080098c0(int dataIndex,undefined4 newValue,undefined4 param1,undefined4 param2)\n\n{\n  undefined *dataPtr;\n  undefined4 returnValue;\n  uint bitMask;\n  uint numElements;\n  \n  FUNC_08008af0(DAT_20000448);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  dataPtr = DAT_20000168;\n  numElements = *(uint *)(DAT_20000168 + 4);\n  if ((int)numElements < 0x20) {\n    if (dataIndex != 0) {\n      *(undefined4 *)(DAT_20000168 + numElements * 4 + 0x88) = param1;\n      bitMask = 1 << (numElements & 0xff);\n      *(uint *)(dataPtr + 0x188) = *(uint *)(dataPtr + 0x188) | bitMask;\n      *(undefined4 *)(dataPtr + numElements * 4 + 0x108) = param2;\n      if (dataIndex == 2) {\n        *(uint *)(dataPtr + 0x18c) = bitMask | *(uint *)(dataPtr + 0x18c);\n      }\n    }\n    *(uint *)(dataPtr + 4) = numElements + 1;\n    returnValue = DAT_20000448;\n    *(undefined4 *)(dataPtr + (numElements + 2) * 4) = newValue;\n    FUNC_08008af4(returnValue);\n    returnValue = 0;\n  }\n  else {\n    FUNC_08008af4(DAT_20000448);\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080098c0": "update_data_080098c0",
                "param_1": "dataIndex",
                "param_2": "newValue",
                "param_3": "param1",
                "param_4": "param2",
                "puVar1": "dataPtr",
                "uVar2": "returnValue",
                "uVar3": "bitMask",
                "uVar4": "numElements"
            },
            "calling": [
                "FUN_080078a0"
            ],
            "called": [
                "FUN_08008af4",
                "FUN_08008af0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009980": {
            "entrypoint": "0x08009980",
            "current_name": "initialize_memory_08009980",
            "code": "\nundefined4 * initializeMemory_08009980(undefined4 data,int rowSize,int colSize)\n\n{\n  undefined4 *ptr;\n  uint headerSize;\n  undefined4 *dataPtr;\n  \n  ptr = (undefined4 *)FUN_08008af8(data,colSize * rowSize);\n  if (ptr == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  headerSize = (ptr[-1] & 0xfffffffc) - 4;\n  if (headerSize < 0x25) {\n    dataPtr = ptr;\n    if (0x13 < headerSize) {\n      *ptr = 0;\n      ptr[1] = 0;\n      if (0x1b < headerSize) {\n        ptr[2] = 0;\n        ptr[3] = 0;\n        if (headerSize == 0x24) {\n          ptr[4] = 0;\n          ptr[5] = 0;\n          dataPtr = ptr + 6;\n        }\n        else {\n          dataPtr = ptr + 4;\n        }\n        *dataPtr = 0;\n        dataPtr[1] = 0;\n        dataPtr[2] = 0;\n        return ptr;\n      }\n      dataPtr = ptr + 2;\n    }\n    *dataPtr = 0;\n    dataPtr[1] = 0;\n    dataPtr[2] = 0;\n    return ptr;\n  }\n  FUN_08005d68(ptr,0);\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08009980": "initialize_memory_08009980",
                "param_1": "data",
                "param_2": "rowSize",
                "param_3": "colSize",
                "puVar1": "ptr",
                "uVar2": "headerSize",
                "puVar3": "dataPtr"
            },
            "calling": [
                "FUN_080090c0"
            ],
            "called": [
                "FUN_08005d68",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a18": {
            "entrypoint": "0x08009a18",
            "current_name": "copy_memory_08009a18",
            "code": "\nvoid copyMemory_08009a18(undefined4 *dest,undefined4 *src,uint size)\n\n{\n  undefined4 *dest_ptr;\n  undefined4 *src_ptr;\n  int counter;\n  undefined *dest_end;\n  undefined4 *src_end;\n  uint temp_size;\n  uint remaining_size;\n  \n  if ((src < dest) && (src_ptr = (undefined4 *)((int)src + size), dest < src_ptr)) {\n    dest_end = (undefined *)((int)dest + size);\n    if (size != 0) {\n      do {\n        src_ptr = (undefined4 *)((int)src_ptr + -1);\n        dest_end = dest_end + -1;\n        *dest_end = *(undefined *)src_ptr;\n      } while (src != src_ptr);\n    }\n  }\n  else {\n    remaining_size = size;\n    if (0xf < size) {\n      if ((((uint)dest | (uint)src) & 3) != 0) goto LAB_08009abc;\n      src_ptr = src + 4;\n      dest_ptr = dest + 4;\n      do {\n        src_end = src_ptr + 4;\n        dest_ptr[-4] = src_ptr[-4];\n        dest_ptr[-3] = src_ptr[-3];\n        dest_ptr[-2] = src_ptr[-2];\n        dest_ptr[-1] = src_ptr[-1];\n        src_ptr = src_end;\n        dest_ptr = dest_ptr + 4;\n      } while (src_end != (undefined4 *)((int)src + (size - 0x10 & 0xfffffff0) + 0x20));\n      counter = (size - 0x10 >> 4) + 1;\n      remaining_size = size & 0xf;\n      src = src + counter * 4;\n      dest = dest + counter * 4;\n      if (3 < remaining_size) {\n        src_ptr = dest + -1;\n        temp_size = remaining_size;\n        dest_ptr = src;\n        do {\n          temp_size = temp_size - 4;\n          src_ptr = src_ptr + 1;\n          *src_ptr = *dest_ptr;\n          dest_ptr = dest_ptr + 1;\n        } while (3 < temp_size);\n        counter = (remaining_size - 4 & 0xfffffffc) + 4;\n        dest = (undefined4 *)((int)dest + counter);\n        src = (undefined4 *)((int)src + counter);\n        remaining_size = size & 3;\n      }\n    }\n    size = remaining_size;\n    if (remaining_size != 0) {\nLAB_08009abc:\n      dest_end = (undefined *)((int)dest + -1);\n      src_ptr = src;\n      do {\n        dest_ptr = (undefined4 *)((int)src_ptr + 1);\n        dest_end = dest_end + 1;\n        *dest_end = *(undefined *)src_ptr;\n        src_ptr = dest_ptr;\n      } while (dest_ptr != (undefined4 *)(size + (int)src));\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009a18": "copy_memory_08009a18",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr",
                "iVar3": "counter",
                "puVar4": "dest_end",
                "puVar5": "src_end",
                "uVar6": "temp_size",
                "uVar7": "remaining_size"
            },
            "calling": [
                "FUN_080097cc",
                "FUN_08009adc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009adc": {
            "entrypoint": "0x08009adc",
            "current_name": "allocate_memory_08009adc",
            "code": "\nint * allocateMemory_08009adc(undefined4 *param_ptr,int *memory_ptr,uint size)\n\n{\n  int *current_block_ptr;\n  int temp_var_1;\n  int *previous_block_ptr;\n  uint block_size;\n  int temp_var_2;\n  uint current_block_size;\n  int *temp_ptr_1;\n  uint adjusted_block_size;\n  uint adjusted_previous_block_size;\n  uint new_block_size;\n  int temp_var_3;\n  \n  if (memory_ptr == (int *)0x0) {\n    previous_block_ptr = (int *)FUN_08008af8(param_ptr,size);\n    return previous_block_ptr;\n  }\n  FUN_080090a8();\n  current_block_size = memory_ptr[-1];\n  adjusted_previous_block_size = current_block_size & 0xfffffffc;\n  previous_block_ptr = memory_ptr + -2;\n  if (size + 0xb < 0x17) {\n    adjusted_block_size = 0x10;\n  }\n  else {\n    adjusted_block_size = size + 0xb & 0xfffffff8;\n    if ((int)adjusted_block_size < 0) goto LAB_08009b8e;\n  }\n  if (adjusted_block_size < size) {\nLAB_08009b8e:\n    *param_ptr = 0xc;\n    return (int *)0x0;\n  }\n  temp_var_3 = (int)previous_block_ptr + adjusted_previous_block_size;\n  new_block_size = adjusted_previous_block_size;\n  if ((int)adjusted_previous_block_size < (int)adjusted_block_size) {\n    if (DAT_20000454 == temp_var_3) {\n      temp_var_3 = (*(uint *)(DAT_20000454 + 4) & 0xfffffffc) + adjusted_previous_block_size;\n      if ((int)(adjusted_block_size + 0x10) <= temp_var_3) {\n        DAT_20000454 = (int)previous_block_ptr + adjusted_block_size;\n        *(uint *)(DAT_20000454 + 4) = temp_var_3 - adjusted_block_size | 1;\n        memory_ptr[-1] = adjusted_block_size | memory_ptr[-1] & 1U;\n        FUN_080090b4(param_ptr);\n        return memory_ptr;\n      }\n      if (-1 < (int)(current_block_size << 0x1f)) {\n        current_block_ptr = (int *)((int)previous_block_ptr - memory_ptr[-2]);\n        current_block_size = current_block_ptr[1] & 0xfffffffc;\n        if ((int)(adjusted_block_size + 0x10) <= (int)(temp_var_3 + current_block_size)) {\n          temp_var_2 = current_block_ptr[3];\n          previous_block_ptr = current_block_ptr + 2;\n          temp_var_1 = *previous_block_ptr;\n          adjusted_previous_block_size = adjusted_previous_block_size - 4;\n          *(int *)(temp_var_1 + 0xc) = temp_var_2;\n          *(int *)(temp_var_2 + 8) = temp_var_1;\n          if (adjusted_previous_block_size < 0x25) {\n            temp_var_1 = *memory_ptr;\n            temp_ptr_1 = previous_block_ptr;\n            if (0x13 < adjusted_previous_block_size) {\n              current_block_ptr[2] = temp_var_1;\n              current_block_ptr[3] = memory_ptr[1];\n              temp_var_1 = memory_ptr[2];\n              if (adjusted_previous_block_size < 0x1c) {\n                memory_ptr = memory_ptr + 2;\n                temp_ptr_1 = current_block_ptr + 4;\n              }\n              else {\n                current_block_ptr[4] = temp_var_1;\n                current_block_ptr[5] = memory_ptr[3];\n                temp_var_1 = memory_ptr[4];\n                if (adjusted_previous_block_size == 0x24) {\n                  current_block_ptr[6] = temp_var_1;\n                  current_block_ptr[7] = memory_ptr[5];\n                  temp_var_1 = memory_ptr[6];\n                  memory_ptr = memory_ptr + 6;\n                  temp_ptr_1 = current_block_ptr + 8;\n                }\n                else {\n                  memory_ptr = memory_ptr + 4;\n                  temp_ptr_1 = current_block_ptr + 6;\n                }\n              }\n            }\n            *temp_ptr_1 = temp_var_1;\n            temp_ptr_1[1] = memory_ptr[1];\n            temp_ptr_1[2] = memory_ptr[2];\n          }\n          else {\n            FUN_08009a18(previous_block_ptr,memory_ptr);\n          }\n          DAT_20000454 = (int)current_block_ptr + adjusted_block_size;\n          *(uint *)(DAT_20000454 + 4) = (temp_var_3 + current_block_size) - adjusted_block_size | 1;\n          current_block_ptr[1] = adjusted_block_size | current_block_ptr[1] & 1U;\n          FUN_080090b4(param_ptr);\n          return previous_block_ptr;\n        }\nLAB_08009bb0:\n        new_block_size = adjusted_previous_block_size + current_block_size;\n        if ((int)adjusted_block_size <= (int)new_block_size) {\n          temp_var_2 = current_block_ptr[3];\n          temp_ptr_1 = current_block_ptr + 2;\n          temp_var_1 = *temp_ptr_1;\n          *(int *)(temp_var_1 + 0xc) = temp_var_2;\n          temp_var_3 = (int)current_block_ptr + new_block_size;\n          *(int *)(temp_var_2 + 8) = temp_var_1;\n          previous_block_ptr = current_block_ptr;\n          if (adjusted_previous_block_size - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          FUN_08009a18(temp_ptr_1,memory_ptr);\n          memory_ptr = temp_ptr_1;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(temp_var_3 + 4) & 0xfffffffe) + temp_var_3 + 4) << 0x1f) {\n        block_size = *(uint *)(temp_var_3 + 4) & 0xfffffffc;\n        new_block_size = adjusted_previous_block_size + block_size;\n        if ((int)new_block_size < (int)adjusted_block_size) {\n          if ((int)(current_block_size << 0x1f) < 0) goto LAB_08009b36;\n          current_block_ptr = (int *)((int)previous_block_ptr - memory_ptr[-2]);\n          current_block_size = current_block_ptr[1] & 0xfffffffc;\n          new_block_size = block_size + current_block_size + adjusted_previous_block_size;\n          if ((int)new_block_size < (int)adjusted_block_size) goto LAB_08009bb0;\n          temp_var_1 = *(int *)(temp_var_3 + 8);\n          temp_var_3 = *(int *)(temp_var_3 + 0xc);\n          *(int *)(temp_var_1 + 0xc) = temp_var_3;\n          *(int *)(temp_var_3 + 8) = temp_var_1;\n          temp_ptr_1 = current_block_ptr + 2;\n          temp_var_1 = *temp_ptr_1;\n          temp_var_2 = current_block_ptr[3];\n          *(int *)(temp_var_1 + 0xc) = temp_var_2;\n          temp_var_3 = (int)current_block_ptr + new_block_size;\n          *(int *)(temp_var_2 + 8) = temp_var_1;\n          previous_block_ptr = current_block_ptr;\n          if (0x24 < adjusted_previous_block_size - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          adjusted_previous_block_size = adjusted_previous_block_size - 4;\n          temp_var_1 = *memory_ptr;\n          current_block_ptr = temp_ptr_1;\n          if (0x13 < adjusted_previous_block_size) {\n            previous_block_ptr[2] = temp_var_1;\n            previous_block_ptr[3] = memory_ptr[1];\n            temp_var_1 = memory_ptr[2];\n            if (adjusted_previous_block_size < 0x1c) {\n              memory_ptr = memory_ptr + 2;\n              current_block_ptr = previous_block_ptr + 4;\n            }\n            else {\n              previous_block_ptr[4] = temp_var_1;\n              previous_block_ptr[5] = memory_ptr[3];\n              temp_var_1 = memory_ptr[4];\n              if (adjusted_previous_block_size == 0x24) {\n                previous_block_ptr[6] = temp_var_1;\n                previous_block_ptr[7] = memory_ptr[5];\n                temp_var_1 = memory_ptr[6];\n                memory_ptr = memory_ptr + 6;\n                current_block_ptr = previous_block_ptr + 8;\n              }\n              else {\n                memory_ptr = memory_ptr + 4;\n                current_block_ptr = previous_block_ptr + 6;\n              }\n            }\n          }\n          *current_block_ptr = temp_var_1;\n          current_block_ptr[1] = memory_ptr[1];\n          current_block_ptr[2] = memory_ptr[2];\n          memory_ptr = temp_ptr_1;\n        }\n        else {\n          temp_var_1 = *(int *)(temp_var_3 + 8);\n          temp_var_2 = *(int *)(temp_var_3 + 0xc);\n          *(int *)(temp_var_1 + 0xc) = temp_var_2;\n          temp_var_3 = (int)previous_block_ptr + new_block_size;\n          *(int *)(temp_var_2 + 8) = temp_var_1;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(current_block_size << 0x1f)) {\n        current_block_ptr = (int *)((int)previous_block_ptr - memory_ptr[-2]);\n        current_block_size = current_block_ptr[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    current_block_ptr = (int *)FUN_08008af8(param_ptr,size);\n    if (current_block_ptr != (int *)0x0) {\n      if ((int *)((memory_ptr[-1] & 0xfffffffeU) + (int)previous_block_ptr) == current_block_ptr + -2) {\n        new_block_size = adjusted_previous_block_size + (current_block_ptr[-1] & 0xfffffffcU);\n        temp_var_3 = (int)previous_block_ptr + new_block_size;\n        goto LAB_08009c00;\n      }\n      adjusted_previous_block_size = adjusted_previous_block_size - 4;\n      if (adjusted_previous_block_size < 0x25) {\n        temp_var_3 = *memory_ptr;\n        previous_block_ptr = memory_ptr;\n        temp_ptr_1 = current_block_ptr;\n        if (0x13 < adjusted_previous_block_size) {\n          *current_block_ptr = temp_var_3;\n          current_block_ptr[1] = memory_ptr[1];\n          if (adjusted_previous_block_size < 0x1c) {\n            temp_var_3 = memory_ptr[2];\n            previous_block_ptr = memory_ptr + 2;\n            temp_ptr_1 = current_block_ptr + 2;\n          }\n          else {\n            current_block_ptr[2] = memory_ptr[2];\n            current_block_ptr[3] = memory_ptr[3];\n            if (adjusted_previous_block_size == 0x24) {\n              current_block_ptr[4] = memory_ptr[4];\n              current_block_ptr[5] = memory_ptr[5];\n              temp_var_3 = memory_ptr[6];\n              previous_block_ptr = memory_ptr + 6;\n              temp_ptr_1 = current_block_ptr + 6;\n            }\n            else {\n              temp_var_3 = memory_ptr[4];\n              previous_block_ptr = memory_ptr + 4;\n              temp_ptr_1 = current_block_ptr + 4;\n            }\n          }\n        }\n        *temp_ptr_1 = temp_var_3;\n        temp_ptr_1[1] = previous_block_ptr[1];\n        temp_ptr_1[2] = previous_block_ptr[2];\n      }\n      else {\n        FUN_08009a18(current_block_ptr,memory_ptr);\n      }\n      FUN_080088ec(param_ptr,memory_ptr);\n    }\n    FUN_080090b4(param_ptr);\n    memory_ptr = current_block_ptr;\n  }\n  else {\nLAB_08009c00:\n    if (new_block_size - adjusted_block_size < 0x10) {\n      previous_block_ptr[1] = previous_block_ptr[1] & 1U | new_block_size;\n      *(uint *)(temp_var_3 + 4) = *(uint *)(temp_var_3 + 4) | 1;\n    }\n    else {\n      previous_block_ptr[1] = previous_block_ptr[1] & 1U | adjusted_block_size;\n      *(uint *)((int)previous_block_ptr + adjusted_block_size + 4) = new_block_size - adjusted_block_size | 1;\n      *(uint *)(temp_var_3 + 4) = *(uint *)(temp_var_3 + 4) | 1;\n      FUN_080088ec(param_ptr,(int)previous_block_ptr + adjusted_block_size + 8);\n    }\n    FUN_080090b4(param_ptr);\n  }\n  return memory_ptr;\n}\n\n",
            "renaming": {
                "FUN_08009adc": "allocate_memory_08009adc",
                "param_1": "param_ptr",
                "param_2": "memory_ptr",
                "param_3": "size",
                "piVar1": "current_block_ptr",
                "iVar2": "temp_var_1",
                "piVar3": "previous_block_ptr",
                "uVar4": "block_size",
                "iVar5": "temp_var_2",
                "uVar6": "current_block_size",
                "piVar7": "temp_ptr_1",
                "uVar8": "adjusted_block_size",
                "uVar9": "adjusted_previous_block_size",
                "uVar10": "new_block_size",
                "iVar11": "temp_var_3"
            },
            "calling": [
                "FUN_080097cc"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_080090b4",
                "FUN_080088ec",
                "FUN_08009a18",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e68": {
            "entrypoint": "0x08009e68",
            "current_name": "FUNC_08009e68",
            "code": "\nvoid FUNC_08009e68(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e68": "FUNC_08009e68"
            },
            "calling": [
                "FUN_08005d20",
                "FUN_08000110",
                "FUN_08000134"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009e74": {
            "entrypoint": "0x08009e74",
            "current_name": "FUNC_08009e74",
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 171745,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000158",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_080003f4",
            "FUN_08000418",
            "FUN_080004c8",
            "FUN_080006a4",
            "FUN_0800071c",
            "FUN_0800088a",
            "FUN_080008fc",
            "FUN_08000978",
            "FUN_08000988",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_080009c0",
            "FUN_080009d4",
            "FUN_080009e8",
            "FUN_080009fc",
            "FUN_08000aa4",
            "FUN_08000aa8",
            "FUN_08000c08",
            "FUN_08000c10",
            "FUN_08000cb8",
            "FUN_08000e20",
            "FUN_08000f68",
            "FUN_08000fc8",
            "FUN_08000fd0",
            "FUN_08000ff4",
            "FUN_08001030",
            "FUN_08001044",
            "FUN_08001084",
            "FUN_08001170",
            "FUN_0800119c",
            "FUN_080011ec",
            "FUN_0800121c",
            "FUN_080014f0",
            "FUN_0800151c",
            "FUN_0800157c",
            "FUN_080015a0",
            "FUN_080015b4",
            "FUN_080015fc",
            "FUN_08001618",
            "FUN_0800166c",
            "FUN_080016d0",
            "FUN_08001714",
            "FUN_0800172a",
            "FUN_08001762",
            "FUN_0800177c",
            "FUN_080017b4",
            "FUN_080017c4",
            "FUN_08001a80",
            "FUN_08001ab0",
            "FUN_08001ccc",
            "FUN_08001f6c",
            "FUN_08002640",
            "FUN_080027f4",
            "FUN_08002ad8",
            "FUN_08002bb4",
            "FUN_08002c2e",
            "FUN_08002ca8",
            "FUN_08002d3c",
            "FUN_08002d98",
            "FUN_08003260",
            "FUN_08003440",
            "FUN_08003504",
            "FUN_08003518",
            "FUN_08003540",
            "FUN_08003568",
            "FUN_080035a4",
            "FUN_0800360c",
            "FUN_08003640",
            "FUN_080036a8",
            "FUN_080036f8",
            "FUN_08003908",
            "FUN_08003a94",
            "FUN_08003c94",
            "FUN_08003d60",
            "FUN_08003e38",
            "FUN_08003f18",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08004104",
            "FUN_0800416a",
            "FUN_080041a8",
            "FUN_080041ea",
            "FUN_0800422e",
            "FUN_080042de",
            "FUN_0800438a",
            "FUN_08004436",
            "FUN_080046ec",
            "FUN_0800491c",
            "FUN_080049cc",
            "FUN_08004ae0",
            "FUN_08004bd8",
            "FUN_08004d78",
            "FUN_08004e6c",
            "FUN_08004e74",
            "FUN_08004ea4",
            "FUN_08004ee8",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f60",
            "FUN_08004f78",
            "FUN_08005224",
            "FUN_080052a0",
            "FUN_08005348",
            "FUN_080053b0",
            "FUN_08005500",
            "FUN_08005598",
            "FUN_080055f4",
            "FUN_08005674",
            "FUN_08005680",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_08005728",
            "FUN_08005780",
            "thunk_FUN_08005838",
            "FUN_08005838",
            "FUN_080059f0",
            "FUN_08005d14",
            "FUN_08005d20",
            "FUN_08005d68",
            "FUN_08005dfc",
            "FUN_08005e40",
            "FUN_080078c0",
            "FUN_080079e8",
            "FUN_0800884c",
            "FUN_080088ec",
            "FUN_08008ad4",
            "FUN_08008af8",
            "FUN_0800901c",
            "FUN_080090a8",
            "FUN_080090b4",
            "FUN_080090c0",
            "FUN_0800910c",
            "FUN_08009120",
            "FUN_080091a4",
            "FUN_080091e4",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_080093a4",
            "FUN_08009444",
            "FUN_080094f8",
            "FUN_08009530",
            "FUN_08009630",
            "FUN_080096e0",
            "FUN_08009744",
            "FUN_08009768",
            "FUN_080097cc",
            "FUN_080098c0",
            "FUN_08009980",
            "FUN_08009a18",
            "FUN_08009adc"
        ]
    ],
    "locked_functions": []
}