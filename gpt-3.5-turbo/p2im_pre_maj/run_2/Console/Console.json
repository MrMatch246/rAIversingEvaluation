{
    "functions": {
        "FUN_00000410": {
            "entrypoint": "0x00000410",
            "current_name": "initialize_memory_structure_00000410",
            "code": "\nvoid initializeMemoryStructure_00000410(void)\n\n{\n  initialize_memory_structure_00000df4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000410": "initialize_memory_structure_00000410"
            },
            "calling": [
                "FUN_0000459c"
            ],
            "called": [
                "FUN_00000df4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000428": {
            "entrypoint": "0x00000428",
            "current_name": "get_offset_and_update_00000428",
            "code": "\ndword getOffsetAndUpdate_00000428(undefined4 *result,int inputOffset)\n\n{\n  undefined4 irqEnabled;\n  dword updatedOffset;\n  \n  irqEnabled = check_irq_interrupts_enabled_00000cd0();\n  updatedOffset = Elf32_Rel_ARRAY_1fff0200[0].r_offset;\n  if ((inputOffset + Elf32_Rel_ARRAY_1fff0200[0].r_offset < 0x20030001) &&\n     (0x1fff0def < inputOffset + Elf32_Rel_ARRAY_1fff0200[0].r_offset)) {\n    Elf32_Rel_ARRAY_1fff0200[0].r_offset = inputOffset + Elf32_Rel_ARRAY_1fff0200[0].r_offset;\n  }\n  else {\n    *result = 0xc;\n    updatedOffset = 0xffffffff;\n  }\n  configure_ir_qinterrupts_00000d0c(irqEnabled);\n  return updatedOffset;\n}\n\n",
            "renaming": {
                "FUN_00000428": "get_offset_and_update_00000428",
                "param_1": "result",
                "param_2": "inputOffset",
                "uVar1": "irqEnabled",
                "local_c": "updatedOffset"
            },
            "calling": [
                "FUN_00004bd0"
            ],
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000490": {
            "entrypoint": "0x00000490",
            "current_name": "handle_interrupts_00000490",
            "code": "\nundefined4 handle_interrupts_00000490(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 result;\n  \n  result = process_with_interrupt_handling_00000e14(param_3,param_4);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00000490": "handle_interrupts_00000490",
                "uVar1": "result"
            },
            "calling": [
                "FUN_00004dc8"
            ],
            "called": [
                "FUN_00000e14"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004f2": {
            "entrypoint": "0x000004f2",
            "current_name": "initialize_value_and_return_000004f2",
            "code": "\nundefined4 initialize_value_and_return_000004f2(undefined4 *output_ptr)\n\n{\n  *output_ptr = 0x13;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000004f2": "initialize_value_and_return_000004f2",
                "param_1": "output_ptr"
            },
            "calling": [
                "FUN_00004e26",
                "FUN_00004dee"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000514": {
            "entrypoint": "0x00000514",
            "current_name": "set_value_and_return_00000514",
            "code": "\nundefined4 set_value_and_return_00000514(undefined4 *result_ptr)\n\n{\n  *result_ptr = 0x13;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00000514": "set_value_and_return_00000514",
                "param_1": "result_ptr"
            },
            "calling": [
                "FUN_000056b8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000534": {
            "entrypoint": "0x00000534",
            "current_name": "check_param_validity_00000534",
            "code": "\nundefined4 checkParamValidity_00000534(undefined4 *result,int inputValue)\n\n{\n  undefined4 isValid;\n  \n  *result = 0;\n  if (((inputValue == 0) || (inputValue == 1)) || (inputValue == 2)) {\n    isValid = 1;\n  }\n  else {\n    isValid = 0;\n  }\n  return isValid;\n}\n\n",
            "renaming": {
                "FUN_00000534": "check_param_validity_00000534",
                "param_1": "result",
                "param_2": "inputValue",
                "uVar1": "isValid"
            },
            "calling": [
                "FUN_00005700"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000566": {
            "entrypoint": "0x00000566",
            "current_name": "convert_byte_to_int_00000566",
            "code": "\nint convertByteToInt_00000566(int value)\n\n{\n  byte byte1;\n  byte byte2;\n  byte byte3;\n  byte byte4;\n  int result;\n  \n  byte2 = (byte)value;\n  byte3 = (byte)((uint)value >> 8);\n  byte4 = (byte)((uint)value >> 0x10);\n  byte1 = (byte)((uint)value >> 0x18);\n  result = LZCOUNT((uint)(byte)((((((((byte2 & 1) << 1 | byte2 >> 1 & 1) << 1 | byte2 >> 2 & 1) << 1\n                                  | byte2 >> 3 & 1) << 1 | byte2 >> 4 & 1) << 1 | byte2 >> 5 & 1) <<\n                                1 | byte2 >> 6 & 1) << 1 | byte2 >> 7) << 0x18 |\n                  (uint)(byte)((((((((byte3 & 1) << 1 | byte3 >> 1 & 1) << 1 | byte3 >> 2 & 1) << 1\n                                  | byte3 >> 3 & 1) << 1 | byte3 >> 4 & 1) << 1 | byte3 >> 5 & 1) <<\n                                1 | byte3 >> 6 & 1) << 1 | byte3 >> 7) << 0x10 |\n                  (uint)(byte)((((((((byte4 & 1) << 1 | byte4 >> 1 & 1) << 1 | byte4 >> 2 & 1) << 1\n                                  | byte4 >> 3 & 1) << 1 | byte4 >> 4 & 1) << 1 | byte4 >> 5 & 1) <<\n                                1 | byte4 >> 6 & 1) << 1 | byte4 >> 7) << 8 |\n                  (uint)(byte)((((((((byte1 & 1) << 1 | byte1 >> 1 & 1) << 1 | byte1 >> 2 & 1) << 1\n                                  | byte1 >> 3 & 1) << 1 | byte1 >> 4 & 1) << 1 | byte1 >> 5 & 1) <<\n                                1 | byte1 >> 6 & 1) << 1 | byte1 >> 7));\n  if (value == 0) {\n    result = -1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00000566": "convert_byte_to_int_00000566",
                "param_1": "value",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "bVar3": "byte3",
                "bVar4": "byte4",
                "iVar5": "result"
            },
            "calling": [
                "FUN_00000610"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000058e": {
            "entrypoint": "0x0000058e",
            "current_name": "update_pointer_0000058e",
            "code": "\nvoid updatePointer_0000058e(int *pointerValue,undefined4 *newValue)\n\n{\n  if (*pointerValue == 0) {\n    *newValue = newValue;\n  }\n  else {\n    *newValue = *(undefined4 *)*pointerValue;\n    *(undefined4 **)*pointerValue = newValue;\n  }\n  *pointerValue = updatedValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000058e": "update_pointer_0000058e",
                "param_1": "pointerValue",
                "param_2": "newValue",
                "(int)param_2": "updatedValue"
            },
            "calling": [
                "FUN_00000698"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000005ca": {
            "entrypoint": "0x000005ca",
            "current_name": "extract_pointer_000005ca",
            "code": "\nundefined4 * extractPointer_000005ca(int *ptr)\n\n{\n  undefined4 *pointer;\n  \n  if (*ptr == 0) {\n    pointer = (undefined4 *)0x0;\n  }\n  else {\n    pointer = *(undefined4 **)*ptr;\n    if (pointer == (undefined4 *)*ptr) {\n      *ptr = 0;\n    }\n    else {\n      *(undefined4 *)*ptr = *pointer;\n    }\n  }\n  return pointer;\n}\n\n",
            "renaming": {
                "FUN_000005ca": "extract_pointer_000005ca",
                "param_1": "ptr",
                "puVar1": "pointer"
            },
            "calling": [
                "FUN_00000698"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000610": {
            "entrypoint": "0x00000610",
            "current_name": "convert_data_00000610",
            "code": "\nundefined4 convertData_00000610(void)\n\n{\n  int dataPointer;\n  int convertedValue;\n  undefined4 returnValue;\n  \n  dataPointer = DAT_1fff03dc;\n  DAT_1fff0354 = 0;\n  convertedValue = convert_byte_to_int_00000566(DAT_1fff0424);\n  convertedValue = **(int **)(&DAT_1fff03e4 + convertedValue * 4);\n  if (dataPointer == convertedValue + -8) {\n    returnValue = 0;\n  }\n  else {\n    if ((dataPointer != 0) && (*(char *)(dataPointer + 4) == '\\t')) {\n      *(undefined *)(dataPointer + 4) = 10;\n    }\n    *(undefined *)(convertedValue + -4) = 9;\n    DAT_1fff03e0 = *(undefined2 *)(convertedValue + -2);\n    returnValue = 1;\n    DAT_1fff03dc = convertedValue + -8;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00000610": "convert_data_00000610",
                "iVar1": "dataPointer",
                "iVar2": "convertedValue",
                "uVar3": "returnValue"
            },
            "calling": [],
            "called": [
                "FUN_00000566"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000698": {
            "entrypoint": "0x00000698",
            "current_name": "update_pointer_and_value_00000698",
            "code": "\nvoid updatePointerAndValue_00000698(int inputIndex,uint newValue)\n\n{\n  if (newValue < 9) {\n    if ((8 < *(byte *)(inputIndex + 4)) &&\n       (extract_pointer_000005ca(&DAT_1fff03e4 + (uint)*(byte *)(inputIndex + 5) * 4),\n       *(int *)(&DAT_1fff03e4 + (uint)*(byte *)(inputIndex + 5) * 4) == 0)) {\n      DAT_1fff0424 = DAT_1fff0424 & ~(1 << *(sbyte *)(inputIndex + 5));\n    }\n  }\n  else if (*(byte *)(inputIndex + 4) < 9) {\n    update_pointer_0000058e(&DAT_1fff03e4 + (uint)*(byte *)(inputIndex + 5) * 4,inputIndex + 8);\n    DAT_1fff0424 = DAT_1fff0424 | 1 << *(sbyte *)(inputIndex + 5);\n  }\n  *(char *)(inputIndex + 4) = (char)newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000698": "update_pointer_and_value_00000698",
                "param_1": "inputIndex",
                "param_2": "newValue"
            },
            "calling": [
                "FUN_00000794",
                "FUN_00002434",
                "FUN_000010d4",
                "FUN_000024bc"
            ],
            "called": [
                "FUN_000005ca",
                "FUN_0000058e"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000738": {
            "entrypoint": "0x00000738",
            "current_name": "check_exception_and_set_flag_00000738",
            "code": "\nvoid checkExceptionAndSetFlag_00000738(ushort exceptionNumber)\n\n{\n  int exceptionFlag;\n  \n  if ((*(byte *)(DAT_1fff03dc + 4) < 9) || (exceptionNumber < *(byte *)(DAT_1fff03dc + 5))) {\n    exceptionFlag = get_exception_number_00000d2a();\n    if (exceptionFlag == 0) {\n      set_e000ed04_bit_0000093c();\n    }\n    else {\n      DAT_1fff0354 = 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000738": "check_exception_and_set_flag_00000738",
                "param_1": "exceptionNumber",
                "iVar1": "exceptionFlag"
            },
            "calling": [
                "FUN_000010d4",
                "FUN_000024bc"
            ],
            "called": [
                "FUN_0000093c",
                "FUN_00000d2a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000794": {
            "entrypoint": "0x00000794",
            "current_name": "initialize_data_00000794",
            "code": "\nint * initializeData_00000794(void)\n\n{\n  int returnValue;\n  int counter;\n  undefined4 *dataPointer;\n  uint alignedDataPointer;\n  int loopCounter1;\n  int loopCounter2;\n  int *stackPointer;\n  \n  checkIRQInterruptsEnabled();\n  *(undefined4 *)(&DAT_1fff0358 + DAT_1fff03e0 * 4) = 0;\n  DAT_1fff0350 = DAT_1fff0350 + -1;\n  updatePointerAndValue(DAT_1fff03dc,0);\n  dataPointer = &DAT_1fff03dc;\n  counter = 0;\n  DAT_1fff03dc = 0;\n  runInfiniteLoop();\n  alignedDataPointer = (int)dataPointer + counter & 0xfffffffc;\n  stackPointer = (int *)(alignedDataPointer - 4);\n  *stackPointer = 0x77777777;\n  if (((uint)stackPointer & 7) != 0) {\n    stackPointer = (int *)(alignedDataPointer - 8);\n    *stackPointer = 0x88888888;\n  }\n  stackPointer[-1] = 0x1000000;\n  stackPointer[-2] = counter << 0xd;\n  stackPointer[-3] = 0x795;\n  stackPointer = stackPointer + -4;\n  *stackPointer = 0;\n  for (loopCounter2 = 3; 0 < loopCounter2; loopCounter2 = loopCounter2 + -1) {\n    stackPointer = stackPointer + -1;\n    *stackPointer = loopCounter2;\n  }\n  stackPointer = stackPointer + -1;\n  *stackPointer = returnValue;\n  for (loopCounter1 = 0xb; 3 < loopCounter1; loopCounter1 = loopCounter1 + -1) {\n    stackPointer = stackPointer + -1;\n    *stackPointer = loopCounter1;\n  }\n  stackPointer[-1] = -3;\n  return stackPointer + -1;\n}\n\n",
            "renaming": {
                "FUN_00000794": "initialize_data_00000794",
                "extraout_r1": "returnValue",
                "iVar1": "counter",
                "puVar2": "dataPointer",
                "uVar3": "alignedDataPointer",
                "iStack_1c": "loopCounter1",
                "iStack_18": "loopCounter2",
                "piStack_14": "stackPointer",
                "check_irq_interrupts_enabled_00000cd0": "checkIRQInterruptsEnabled",
                "update_pointer_and_value_00000698": "updatePointerAndValue",
                "run_infinite_loop_00000930": "runInfiniteLoop"
            },
            "calling": [],
            "called": [
                "FUN_00000cd0",
                "FUN_00000698",
                "FUN_00000930"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000007dc": {
            "entrypoint": "0x000007dc",
            "current_name": "initialize_memory_000007dc",
            "code": "\nint * initializeMemory_000007dc(undefined4 param1,int param2,int size1,int size2)\n\n{\n  uint alignedSize;\n  int i;\n  int j;\n  int *ptr;\n  \n  alignedSize = size2 + size1 & 0xfffffffc;\n  ptr = (int *)(alignedSize - 4);\n  *ptr = 0x77777777;\n  if (((uint)ptr & 7) != 0) {\n    ptr = (int *)(alignedSize - 8);\n    *ptr = 0x88888888;\n  }\n  ptr[-1] = 0x1000000;\n  ptr[-2] = param1;\n  ptr[-3] = 0x795;\n  ptr = ptr + -4;\n  *ptr = 0;\n  for (j = 3; 0 < j; j = j + -1) {\n    ptr = ptr + -1;\n    *ptr = j;\n  }\n  ptr = ptr + -1;\n  *ptr = param2;\n  for (i = 0xb; 3 < i; i = i + -1) {\n    ptr = ptr + -1;\n    *ptr = i;\n  }\n  ptr[-1] = -3;\n  return ptr + -1;\n}\n\n",
            "renaming": {
                "FUN_000007dc": "initialize_memory_000007dc",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "size1",
                "param_4": "size2",
                "uVar1": "alignedSize",
                "local_14": "i",
                "local_10": "j",
                "local_c": "ptr",
                "local_c[-1]": "ptr[-1]",
                "local_c[-2]": "ptr[-2]",
                "local_c[-3]": "ptr[-3]"
            },
            "calling": [
                "FUN_000010d4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000008b8": {
            "entrypoint": "0x000008b8",
            "current_name": "count_valid_offsets_000008b8",
            "code": "\nint countValidOffsets_000008b8(void)\n\n{\n  Elf32_Rel *currentOffset;\n  \n  for (currentOffset = (Elf32_Rel *)&DAT_1fff0000;\n      (currentOffset->r_offset == 0xe7fee7fe && (currentOffset < Elf32_Rel_ARRAY_1fff0200));\n      currentOffset = (Elf32_Rel *)&currentOffset->r_info) {\n  }\n  return ((int)Elf32_Rel_ARRAY_1fff0200 - (int)currentOffset >> 2) << 2;\n}\n\n",
            "renaming": {
                "FUN_000008b8": "count_valid_offsets_000008b8",
                "local_c": "currentOffset"
            },
            "calling": [
                "FUN_0000211c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000900": {
            "entrypoint": "0x00000900",
            "current_name": "get_main_stack_pointer_00000900",
            "code": "\nundefined4 getMainStackPointer_00000900(void)\n\n{\n  undefined4 mainStackPointer;\n  \n  mainStackPointer = getMainStackPointer_00000900();\n  return mainStackPointer;\n}\n\n",
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "uVar1": "mainStackPointer"
            },
            "calling": [
                "FUN_0000211c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000091c": {
            "entrypoint": "0x0000091c",
            "current_name": "get_starting_address_0000091c",
            "code": "\nuint32_t getStartingAddress_0000091c(void)\n\n{\n  return 0x1fff0000;\n}\n\n",
            "renaming": {
                "FUN_0000091c": "get_starting_address_0000091c",
                "undefined4": "uint32_t"
            },
            "calling": [
                "FUN_0000211c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000930": {
            "entrypoint": "0x00000930",
            "current_name": "run_infinite_loop_00000930",
            "code": "\nvoid run_infinite_loop_00000930(void)\n\n{\n  check_irq_interrupts();\n  trigger_interrupt(1);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000930": "run_infinite_loop_00000930",
                "check_irq_interrupts_00000cf0": "check_irq_interrupts",
                "software_interrupt": "trigger_interrupt"
            },
            "calling": [
                "FUN_00000794",
                "FUN_00000f8c"
            ],
            "called": [
                "FUN_00000cf0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000093c": {
            "entrypoint": "0x0000093c",
            "current_name": "set_e000ed04_bit_0000093c",
            "code": "\n\n\nvoid set_e000ed04_bit_0000093c(void)\n\n{\n  _DAT_e000ed04 = _DAT_e000ed04 | 0x10000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000093c": "set_e000ed04_bit_0000093c"
            },
            "calling": [
                "FUN_00000738",
                "FUN_00001348",
                "FUN_00002798",
                "FUN_00001cf0",
                "FUN_00002434"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000990": {
            "entrypoint": "0x00000990",
            "current_name": "FUNC_00000990",
            "code": "\nvoid FUNC_00000990(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000990": "FUNC_00000990"
            },
            "calling": [
                "entry"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "entry": {
            "entrypoint": "0x0000099c",
            "current_name": "entry",
            "code": "\nvoid entry(void)\n\n{\n  undefined4 uStack_18;\n  undefined4 *local_14;\n  dword *local_10;\n  Elf32_Rel *local_c;\n  \n  local_14 = &uStack_18;\n  local_10 = (dword *)&DAT_00007c60;\n  initialize_and_clear_registers_00000db0();\n  local_c = (Elf32_Rel *)&DAT_1fff0000;\n  while (local_c < &uStack_18) {\n    local_c->r_offset = 0xe7fee7fe;\n    local_c = (Elf32_Rel *)((int)local_c + 4);\n  }\n  local_c = Elf32_Rel_ARRAY_1fff0200;\n  while (local_c < (Elf32_Rel *)&DAT_1fff0350) {\n    local_c->r_offset = *local_10;\n    local_10 = local_10 + 1;\n    local_c = (Elf32_Rel *)&local_c->r_info;\n  }\n  local_c = (Elf32_Rel *)&DAT_1fff0350;\n  while (local_c < (undefined4 *)0x1fff0df0) {\n    local_c->r_offset = 0;\n    local_c = (Elf32_Rel *)((int)local_c + 4);\n  }\n  FUNC_00000990();\n  initialize_and_update_memory_00000e64();\n  execute_function_pointers_0000459c();\n  initialize_memory_and_assert_00000f8c();\n  return;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "FUN_00000db0",
                "FUN_0000459c",
                "FUN_00000e64",
                "FUN_00000990",
                "FUN_00000f8c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a30": {
            "entrypoint": "0x00000a30",
            "current_name": "handle_nmi_interrupt_00000a30",
            "code": "\nundefined * handle_nmi_interrupt_00000a30(void)\n\n{\n  int reg_value;\n  \n  kernel_panic_handler_00000f04(4,\"NMI HANDLER\");\n  return &stack0xe000ffe0 + -*(int *)(reg_value + 0x4c);\n}\n\n",
            "renaming": {
                "FUN_00000a30": "handle_nmi_interrupt_00000a30",
                "in_r3": "reg_value"
            },
            "calling": [],
            "called": [
                "FUN_00000f04"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cc0": {
            "entrypoint": "0x00000cc0",
            "current_name": "disable_irq_interrupts_with_handler_00000cc0",
            "code": "\nundefined4 disableIRQInterruptsWithHandler_00000cc0(void)\n\n{\n  bool isPrivilegedMode;\n  undefined4 interruptsWereEnabled;\n  \n  kernel_panic_handler_00000f04(10,\"DUMMY HANDLER\");\n  interruptsWereEnabled = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    interruptsWereEnabled = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return interruptsWereEnabled;\n}\n\n",
            "renaming": {
                "FUN_00000cc0": "disable_irq_interrupts_with_handler_00000cc0",
                "bVar1": "isPrivilegedMode",
                "uVar2": "interruptsWereEnabled"
            },
            "calling": [
                "FUN_00000dc0"
            ],
            "called": [
                "FUN_00000f04"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cd0": {
            "entrypoint": "0x00000cd0",
            "current_name": "check_irq_interrupts_enabled_00000cd0",
            "code": "\nundefined4 checkIRQInterruptsEnabled_00000cd0(void)\n\n{\n  bool isPrivilegedMode;\n  undefined4 interruptsEnabled;\n  \n  interruptsEnabled = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    interruptsEnabled = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return interruptsEnabled;\n}\n\n",
            "renaming": {
                "FUN_00000cd0": "check_irq_interrupts_enabled_00000cd0",
                "bVar1": "isPrivilegedMode",
                "uVar2": "interruptsEnabled"
            },
            "calling": [
                "FUN_00000e58",
                "FUN_00001c84",
                "FUN_00000794",
                "FUN_00000f04",
                "FUN_00002434",
                "FUN_000010d4",
                "FUN_00000428",
                "FUN_000024bc",
                "FUN_00000f8c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cf0": {
            "entrypoint": "0x00000cf0",
            "current_name": "check_irq_interrupts_00000cf0",
            "code": "\nundefined4 checkIRQInterrupts_00000cf0(void)\n\n{\n  bool isPrivilegedMode;\n  undefined4 interruptsEnabled;\n  \n  enableIRQinterrupts();\n  interruptsEnabled = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    interruptsEnabled = isIRQinterruptsEnabled();\n  }\n  return interruptsEnabled;\n}\n\n",
            "renaming": {
                "FUN_00000cf0": "check_irq_interrupts_00000cf0",
                "bVar1": "isPrivilegedMode",
                "uVar2": "interruptsEnabled"
            },
            "calling": [
                "FUN_00000930"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d0c": {
            "entrypoint": "0x00000d0c",
            "current_name": "configure_ir_qinterrupts_00000d0c",
            "code": "\nvoid configureIRQinterrupts_00000d0c(uint interruptBitmask)\n\n{\n  bool isPrivilegedMode;\n  \n  isPrivilegedMode = (bool)checkPrivilegedMode();\n  if (isPrivilegedMode) {\n    toggleInterrupts((interruptBitmask & 1) == 1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d0c": "configure_ir_qinterrupts_00000d0c",
                "param_1": "interruptBitmask",
                "bVar1": "isPrivilegedMode",
                "isCurrentModePrivileged": "checkPrivilegedMode",
                "enableIRQinterrupts": "toggleInterrupts"
            },
            "calling": [
                "FUN_00001c84",
                "FUN_00002434",
                "FUN_000010d4",
                "FUN_00000428",
                "FUN_000024bc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d2a": {
            "entrypoint": "0x00000d2a",
            "current_name": "get_exception_number_00000d2a",
            "code": "\nuint getExceptionNumber_00000d2a(void)\n\n{\n  bool isPrivilegedMode;\n  uint exceptionNumber;\n  \n  exceptionNumber = 0;\n  isPrivilegedMode = (bool)checkPrivilegedMode();\n  if (isPrivilegedMode) {\n    exceptionNumber = fetchCurrentExceptionNumber();\n    exceptionNumber = exceptionNumber & 0x1f;\n  }\n  return exceptionNumber;\n}\n\n",
            "renaming": {
                "FUN_00000d2a": "get_exception_number_00000d2a",
                "uVar2": "exceptionNumber",
                "bVar1": "isPrivilegedMode",
                "isCurrentModePrivileged": "checkPrivilegedMode",
                "getCurrentExceptionNumber": "fetchCurrentExceptionNumber"
            },
            "calling": [
                "FUN_00000738"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d44": {
            "entrypoint": "0x00000d44",
            "current_name": "multiply_and_shift_00000d44",
            "code": "\nint multiplyAndShift_00000d44(uint value1,int value2)\n\n{\n  return value2 * 4 + (value1 & 0xf0000000 | (value1 & 0xfffff) << 5) + 0x2000000;\n}\n\n",
            "renaming": {
                "FUN_00000d44": "multiply_and_shift_00000d44",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "FUN_00000d76"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d76": {
            "entrypoint": "0x00000d76",
            "current_name": "clear_result_00000d76",
            "code": "\nvoid clearResult_00000d76(undefined4 input1,undefined input2)\n\n{\n  undefined4 *resultPointer;\n  \n  resultPointer = (undefined4 *)multiply_and_shift_00000d44(input1,input2);\n  *resultPointer = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d76": "clear_result_00000d76",
                "param_1": "input1",
                "param_2": "input2",
                "puVar1": "resultPointer"
            },
            "calling": [
                "FUN_00000d9c"
            ],
            "called": [
                "FUN_00000d44"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d9c": {
            "entrypoint": "0x00000d9c",
            "current_name": "clear_result_00000d9c",
            "code": "\nvoid clearResult_00000d9c(void)\n\n{\n  clear_result_00000d76(0x40048040,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d9c": "clear_result_00000d9c"
            },
            "calling": [
                "FUN_00000db0"
            ],
            "called": [
                "FUN_00000d76"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000db0": {
            "entrypoint": "0x00000db0",
            "current_name": "initialize_and_clear_registers_00000db0",
            "code": "\nvoid initialize_and_clear_registers_00000db0(void)\n\n{\n  initialize_registers();\n  clear_result();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000db0": "initialize_and_clear_registers_00000db0",
                "initialize_registers_00000dcc": "initialize_registers",
                "clear_result_00000d9c": "clear_result"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_00000d9c",
                "FUN_00000dcc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000dc0": {
            "entrypoint": "0x00000dc0",
            "current_name": "disable_interrupts_00000dc0",
            "code": "\nvoid disable_interrupts_00000dc0(void)\n\n{\n  disable_irq_interrupts_with_handler();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000dc0": "disable_interrupts_00000dc0",
                "disable_irq_interrupts_with_handler_00000cc0": "disable_irq_interrupts_with_handler"
            },
            "calling": [],
            "called": [
                "FUN_00000cc0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000dcc": {
            "entrypoint": "0x00000dcc",
            "current_name": "initialize_registers_00000dcc",
            "code": "\n\n\nvoid initializeRegisters_00000dcc(void)\n\n{\n  _DAT_4005200e = 0xd928;\n  _DAT_40052000 = 0xd2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000dcc": "initialize_registers_00000dcc"
            },
            "calling": [
                "FUN_00000db0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000df4": {
            "entrypoint": "0x00000df4",
            "current_name": "initialize_memory_structure_00000df4",
            "code": "\nvoid initializeMemoryStructure_00000df4(void)\n\n{\n  initialize_memory_structure_000013b8(0,0x1c200,0x12b5,0x1fff0204);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000df4": "initialize_memory_structure_00000df4"
            },
            "calling": [
                "FUN_00000410"
            ],
            "called": [
                "FUN_000013b8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e14": {
            "entrypoint": "0x00000e14",
            "current_name": "process_with_interrupt_handling_00000e14",
            "code": "\nundefined4 process_with_interrupt_handling_00000e14(undefined4 input_param,undefined4 output_param)\n\n{\n  undefined4 result;\n  \n  result = process_with_interrupt_handling_00000e14_000012e2(0x1fff0204,input_param,output_param);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00000e14": "process_with_interrupt_handling_00000e14",
                "param_1": "input_param",
                "param_2": "output_param",
                "uVar1": "result"
            },
            "calling": [
                "FUN_00000490"
            ],
            "called": [
                "FUN_000012e2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e38": {
            "entrypoint": "0x00000e38",
            "current_name": "copy_data_and_return_00000e38",
            "code": "\nundefined4 copyDataAndReturn_00000e38(undefined4 source,undefined4 dest)\n\n{\n  copy_data_000015d0(0,source,dest);\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_00000e38": "copy_data_and_return_00000e38",
                "param_1": "source",
                "param_2": "dest"
            },
            "calling": [
                "FUN_00004dee"
            ],
            "called": [
                "FUN_000015d0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e58": {
            "entrypoint": "0x00000e58",
            "current_name": "infinite_loop_00000e58",
            "code": "\nvoid infiniteLoop_00000e58(void)\n\n{\n  checkIRQInterruptsEnabled();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000e58": "infinite_loop_00000e58",
                "check_irq_interrupts_enabled_00000cd0": "checkIRQInterruptsEnabled"
            },
            "calling": [
                "FUN_00000f04"
            ],
            "called": [
                "FUN_00000cd0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e64": {
            "entrypoint": "0x00000e64",
            "current_name": "initialize_and_update_memory_00000e64",
            "code": "\n\n\nvoid initialize_and_update_memory_00000e64(void)\n\n{\n  _DAT_40048038 = _DAT_40048038 | 0x200;\n  _DAT_40049048 = _DAT_40049048 & 0xfefff8ff;\n  initialize_main_function();\n  update_memory_value(0x2056,0x80);\n  update_memory_value(0x511a,0x80);\n  update_memory_value(0x2055,0x80);\n  set_modified_value(0x2056);\n  set_modified_value(0x511a);\n  set_modified_value(0x2055);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000e64": "initialize_and_update_memory_00000e64",
                "initialize_main_function_00001274": "initialize_main_function",
                "update_memory_value_00001eea": "update_memory_value",
                "set_modified_value_00001ff6": "set_modified_value"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_00001ff6",
                "FUN_00001eea",
                "FUN_00001274"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ed8": {
            "entrypoint": "0x00000ed8",
            "current_name": "initialize_data_00000ed8",
            "code": "\nvoid initializeData_00000ed8(void)\n\n{\n  undefined4 stackFramePointer;\n  \n  initialize_and_process_data_00004c84(&DAT_00006f58,stackFramePointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000ed8": "initialize_data_00000ed8",
                "in_lr": "stackFramePointer"
            },
            "calling": [
                "FUN_00000f04"
            ],
            "called": [
                "FUN_00004c84"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": [],
            "code_backup": "\nvoid FUN_00000ed8(void)\n\n{\n  undefined4 in_lr;\n  \n  FUNC_00004c84(&DAT_00006f58,in_lr);\n  return;\n}\n\n"
        },
        "FUN_00000ef8": {
            "entrypoint": "0x00000ef8",
            "current_name": "FUNC_00000ef8",
            "code": "\nvoid FUNC_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000ef8": "FUNC_00000ef8"
            },
            "calling": [
                "FUN_00000f04"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00000f04": {
            "entrypoint": "0x00000f04",
            "current_name": "kernel_panic_handler_00000f04",
            "code": "\nvoid kernel_panic_handler_00000f04(char panic_code,undefined4 panic_message)\n\n{\n  undefined4 stack_variable;\n  code *jumptable_function;\n  undefined4 panic_message_length;\n  char panic_code_char;\n  \n  panic_message_length = panic_message;\n  panic_code_char = panic_code;\n  if (DAT_1fff0468 == 0) {\n    DAT_1fff0468 = 1;\n    if (panic_code == '\\x03') {\n      initialize_data_00000ed8();\n    }\n    initialize_and_process_data_00004c84(\"*** RIOT kernel panic:\\n%s\\n\\n\",panic_message_length);\n    print_stack_info_0000211c();\n    initialize_and_process_data_00004c84(&DAT_00006f78);\n    initialize_and_process_data_00004c84(\"*** halted.\\n\\n\");\n  }\n  check_irq_interrupts_enabled_00000cd0();\n  FUNC_00000ef8();\n  jumptable_function = (code *)0xf4d;\n  infinite_loop_00000e58();\n  stack_variable = (int)&stack_variable + 1;\n  FUNC_00002400();\n  initialize_and_process_data_00004c84(\"main(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  initialize_system_000023a4();\n                    /* WARNING: Could not recover jumptable at 0x00000f7a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptable_function)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000f04": "kernel_panic_handler_00000f04",
                "param_1": "panic_code",
                "param_2": "panic_message",
                "uStack_18": "stack_variable",
                "UNRECOVERED_JUMPTABLE": "jumptable_function",
                "local_10": "panic_message_length",
                "local_9": "panic_code_char"
            },
            "calling": [
                "FUN_00000fec",
                "FUN_00000cc0",
                "FUN_00003ec4",
                "FUN_000013b8",
                "FUN_00001034",
                "FUN_00000a30"
            ],
            "called": [
                "FUN_0000211c",
                "FUN_00000e58",
                "FUN_00000ed8",
                "FUN_00002400",
                "FUN_00000cd0",
                "FUN_00004c84",
                "FUN_00000ef8",
                "FUN_000023a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f8c": {
            "entrypoint": "0x00000f8c",
            "current_name": "initialize_memory_and_assert_00000f8c",
            "code": "\nvoid initializeMemoryAndAssert_00000f8c(void)\n\n{\n  uint shiftedValue;\n  undefined4 *pointer;\n  uint loopCount;\n  int shiftedIndex;\n  int *pointerToShiftedIndex;\n  undefined4 loopValue;\n  undefined4 constantValue1;\n  undefined4 constantValue2;\n  dword offsetValue;\n  \n  check_irq_interrupts_enabled_00000cd0();\n  offsetValue = Elf32_Rel_ARRAY_1fff0200[3].r_info;\n  constantValue2 = 0;\n  constantValue1 = 0xf81;\n  initialize_memory_000010d4(&DAT_1fff0a6c,0x100,0xf,0xc);\n  offsetValue = Elf32_Rel_ARRAY_1fff0200[3].r_offset;\n  constantValue2 = 0;\n  constantValue1 = 0xf5d;\n  loopCount = 0xc;\n  initialize_memory_000010d4(&DAT_1fff046c,0x600,7);\n  loopValue = 0xfd3;\n  shiftedValue = run_infinite_loop_00000930();\n  shiftedValue = shiftedValue >> 0x1e;\n  pointer = (undefined4 *)(loopCount * 0x100);\n  shiftedIndex = (loopCount >> 0x1d) << 0x11;\n  pointerToShiftedIndex = &shiftedIndex;\n  if ((shiftedValue & shiftedValue - 1) != 0) {\n    kernel_panic_handler_00000f04(3,\"FAILED ASSERTION.\");\n  }\n  *pointer = 0;\n  pointer[1] = 0;\n  pointer[2] = shiftedValue - 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000f8c": "initialize_memory_and_assert_00000f8c",
                "uVar1": "shiftedValue",
                "puVar2": "pointer",
                "uVar3": "loopCount",
                "iStack_24": "shiftedIndex",
                "piStack_20": "pointerToShiftedIndex",
                "uStack_1c": "loopValue",
                "local_18": "constantValue1",
                "local_14": "constantValue2",
                "local_10": "offsetValue"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_00000cd0",
                "FUN_000010d4",
                "FUN_00000930"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000fec": {
            "entrypoint": "0x00000fec",
            "current_name": "initialize_memory_00000fec",
            "code": "\nvoid initializeMemory_00000fec(undefined4 *memoryPointer,uint memorySize)\n\n{\n  if ((memorySize & memorySize - 1) != 0) {\n    kernel_panic_handler_00000f04(3,\"FAILED ASSERTION.\");\n  }\n  *memoryPointer = 0;\n  memoryPointer+4 = 0;\n  memoryPointer+8 = memorySize - 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000fec": "initialize_memory_00000fec",
                "param_1": "memoryPointer",
                "param_2": "memorySize",
                "param_1[1]": "memoryPointer+4",
                "param_1[2]": "memoryPointer+8"
            },
            "calling": [
                "FUN_000010d4"
            ],
            "called": [
                "FUN_00000f04"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001034": {
            "entrypoint": "0x00001034",
            "current_name": "find_matching_entry_00001034",
            "code": "\nvoid find_matching_entry_00001034(int **entry_list,int entry_length)\n\n{\n  int **current_entry;\n  \n  if (8 < *(byte *)(entry_length + 4)) {\n    kernel_panic_handler_00000f04(3,\"FAILED ASSERTION.\");\n  }\n  for (current_entry = entry_list;\n      (*current_entry != (int *)0x0 && (*(byte *)((int)*current_entry + -3) <= *(byte *)(entry_length + 5)));\n      current_entry = (int **)*current_entry) {\n  }\n  *(int **)(entry_length + 8) = *current_entry;\n  *current_entry = (int *)(int **)(entry_length + 8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001034": "find_matching_entry_00001034",
                "param_1": "entry_list",
                "param_2": "entry_length",
                "local_1c": "current_entry"
            },
            "calling": [
                "FUN_00002434"
            ],
            "called": [
                "FUN_00000f04"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000010a0": {
            "entrypoint": "0x000010a0",
            "current_name": "calculate_distance_000010a0",
            "code": "\nint calculate_distance_000010a0(int *data_array)\n\n{\n  int *current_ptr;\n  \n  for (current_ptr = data_array; (int *)*current_ptr == current_ptr; current_ptr = current_ptr + 1) {\n  }\n  return (int)current_ptr - (int)data_array;\n}\n\n",
            "renaming": {
                "FUN_000010a0": "calculate_distance_000010a0",
                "param_1": "data_array",
                "local_c": "current_ptr"
            },
            "calling": [
                "FUN_0000211c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000010d4": {
            "entrypoint": "0x000010d4",
            "current_name": "initialize_memory_000010d4",
            "code": "\nint initializeMemory_000010d4(uint address,int size,byte byteCount,uint flags,undefined4 param5,\n                undefined4 param6,undefined4 param7)\n\n{\n  undefined4 irqInterruptsEnabled;\n  undefined4 memory;\n  int result;\n  uint alignedSize;\n  undefined4 *pointer;\n  int adjustedSize;\n  uint alignedAddress;\n  uint loopVariable;\n  short index;\n  short availableIndex;\n  \n  if (byteCount < 0x10) {\n    adjustedSize = size;\n    alignedAddress = address;\n    if ((address & 3) != 0) {\n      adjustedSize = 4 - (address & 3);\n      alignedAddress = adjustedSize + address;\n      adjustedSize = size - adjustedSize;\n    }\n    alignedSize = adjustedSize - 0x30U & 0xfffffffc;\n    pointer = (undefined4 *)(alignedSize + alignedAddress);\n    if ((flags & 8) == 0) {\n      *(uint *)alignedAddress = alignedAddress;\n    }\n    else {\n      for (loopVariable = alignedAddress; loopVariable < alignedSize + alignedAddress; loopVariable = loopVariable + 4) {\n        *(uint *)loopVariable = loopVariable;\n      }\n    }\n    irqInterruptsEnabled = check_irq_interrupts_enabled_00000cd0();\n    availableIndex = 0;\n    for (index = 1; index < 0x21; index = index + 1) {\n      if (*(int *)(&DAT_1fff0358 + index * 4) == 0) {\n        availableIndex = index;\n        break;\n      }\n    }\n    if (availableIndex == 0) {\n      configure_ir_qinterrupts_00000d0c(irqInterruptsEnabled);\n      result = -0x8b;\n    }\n    else {\n      *(undefined4 **)(&DAT_1fff0358 + availableIndex * 4) = pointer;\n      *(short *)((int)pointer + 6) = availableIndex;\n      memory = initialize_memory_000007dc(param5,param6,alignedAddress,alignedSize);\n      *pointer = memory;\n      pointer[9] = alignedAddress;\n      pointer[0xb] = size;\n      pointer[10] = param7;\n      *(byte *)((int)pointer + 5) = byteCount;\n      *(undefined *)(pointer + 1) = 0;\n      pointer[2] = 0;\n      pointer[3] = 0;\n      pointer[4] = 0;\n      initialize_memory_00000fec(pointer + 5,0);\n      pointer[8] = 0;\n      DAT_1fff0350 = DAT_1fff0350 + 1;\n      if ((flags & 1) == 0) {\n        update_pointer_and_value_00000698(pointer,10);\n        if ((flags & 4) == 0) {\n          configure_ir_qinterrupts_00000d0c(irqInterruptsEnabled);\n          check_exception_and_set_flag_00000738(byteCount);\n          return (int)availableIndex;\n        }\n      }\n      else {\n        update_pointer_and_value_00000698(pointer,1);\n      }\n      configure_ir_qinterrupts_00000d0c(irqInterruptsEnabled);\n      result = (int)availableIndex;\n    }\n  }\n  else {\n    result = -0x16;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000010d4": "initialize_memory_000010d4",
                "param_1": "address",
                "param_2": "size",
                "param_3": "byteCount",
                "param_4": "flags",
                "param_5": "param5",
                "param_6": "param6",
                "param_7": "param7",
                "uVar1": "irqInterruptsEnabled",
                "uVar2": "memory",
                "iVar3": "result",
                "uVar4": "alignedSize",
                "puVar5": "pointer",
                "local_30": "adjustedSize",
                "local_2c": "alignedAddress",
                "local_10": "loopVariable",
                "local_c": "index",
                "local_a": "availableIndex"
            },
            "calling": [
                "FUN_00000f8c"
            ],
            "called": [
                "FUN_00000d0c",
                "FUN_00000fec",
                "FUN_00000738",
                "FUN_00000cd0",
                "FUN_000007dc",
                "FUN_00000698"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001274": {
            "entrypoint": "0x00001274",
            "current_name": "initialize_main_function_00001274",
            "code": "\nvoid initialize_main_function_00001274(void)\n\n{\n  initialize_data();\n  DAT_4007e000 = DAT_4007e000 | 0x28;\n  initialize_system_1();\n  initialize_system_2();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001274": "initialize_main_function_00001274",
                "initialize_data_0000258c": "initialize_data",
                "initialize_system_00001c84": "initialize_system_1",
                "initialize_system_00002396": "initialize_system_2"
            },
            "calling": [
                "FUN_00000e64"
            ],
            "called": [
                "FUN_00001c84",
                "FUN_00002396",
                "FUN_0000258c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000129c": {
            "entrypoint": "0x0000129c",
            "current_name": "handle_interrupt_0000129c",
            "code": "\nvoid handle_interrupt_0000129c(undefined4 interrupt_handle)\n\n{\n  process_interrupt(interrupt_handle,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000129c": "handle_interrupt_0000129c",
                "param_1": "interrupt_handle",
                "handle_interrupt_00002434": "process_interrupt"
            },
            "calling": [
                "FUN_000012e2"
            ],
            "called": [
                "FUN_00002434"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000012b4": {
            "entrypoint": "0x000012b4",
            "current_name": "handle_irq_interrupts_and_write_value_000012b4",
            "code": "\nundefined4 handle_irq_interrupts_and_write_value_000012b4(int data_offset,undefined data_value)\n\n{\n  undefined4 write_result;\n  \n  write_result = write_value_if_difference_is_zero_00002364(data_offset + 4,data_value);\n  handle_irq_interrupts_000024bc(data_offset);\n  return write_result;\n}\n\n",
            "renaming": {
                "FUN_000012b4": "handle_irq_interrupts_and_write_value_000012b4",
                "param_1": "data_offset",
                "param_2": "data_value",
                "uVar1": "write_result"
            },
            "calling": [],
            "called": [
                "FUN_00002364",
                "FUN_000024bc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000012e2": {
            "entrypoint": "0x000012e2",
            "current_name": "process_with_interrupt_handling_000012e2",
            "code": "\nint process_with_interrupt_handling_000012e2(int input,undefined4 size,undefined4 count)\n\n{\n  int error_code;\n  \n  while( true ) {\n    error_code = copy_and_count_0000231c(input + 4,size,count);\n    if (error_code != 0) break;\n    handle_interrupt_0000129c(input);\n  }\n  return error_code;\n}\n\n",
            "renaming": {
                "FUN_000012e2": "process_with_interrupt_handling_000012e2",
                "param_1": "input",
                "param_2": "size",
                "param_3": "count",
                "iVar1": "error_code"
            },
            "calling": [
                "FUN_00000e14"
            ],
            "called": [
                "FUN_0000129c",
                "FUN_0000231c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001318": {
            "entrypoint": "0x00001318",
            "current_name": "set_bit_in_memory_00001318",
            "code": "\nvoid setBitInMemory_00001318(byte byteToSet)\n\n{\n  *(int *)(((uint)(int)(char)byteToSet >> 5) * 4 + -0x1fff1f00) = 1 << (byteToSet & 0x1f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001318": "set_bit_in_memory_00001318",
                "param_1": "byteToSet"
            },
            "calling": [
                "FUN_000014c4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001348": {
            "entrypoint": "0x00001348",
            "current_name": "check_and_set_bit_00001348",
            "code": "\nvoid checkAndSetBit_00001348(void)\n\n{\n  if (DAT_1fff0354 != 0) {\n    setBitAt93c();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001348": "check_and_set_bit_00001348",
                "set_e000ed04_bit_0000093c": "setBitAt93c"
            },
            "calling": [
                "FUN_00001628"
            ],
            "called": [
                "FUN_0000093c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001360": {
            "entrypoint": "0x00001360",
            "current_name": "calculate_shifted_sum_00001360",
            "code": "\nint calculateShiftedSum_00001360(uint inputNumber,int multiplier)\n\n{\n  return multiplier * 4 + (inputNumber & 0xf0000000 | (inputNumber & 0xfffff) << 5) + 0x2000000;\n}\n\n",
            "renaming": {
                "FUN_00001360": "calculate_shifted_sum_00001360",
                "param_1": "inputNumber",
                "param_2": "multiplier"
            },
            "calling": [
                "FUN_00001392"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001392": {
            "entrypoint": "0x00001392",
            "current_name": "initialize_memory_00001392",
            "code": "\nvoid initializeMemory_00001392(undefined4 input1,undefined input2)\n\n{\n  undefined4 *resultPtr;\n  \n  resultPtr = (undefined4 *)calculate_shifted_sum_00001360(input1,input2);\n  *resultPtr = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001392": "initialize_memory_00001392",
                "param_1": "input1",
                "param_2": "input2",
                "puVar1": "resultPtr"
            },
            "calling": [
                "FUN_000013b8"
            ],
            "called": [
                "FUN_00001360"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000013b8": {
            "entrypoint": "0x000013b8",
            "current_name": "initialize_memory_structure_000013b8",
            "code": "\nundefined4 initialize_memory_structure_000013b8(int index,undefined4 flag,undefined4 value1,undefined4 value2)\n\n{\n  undefined4 result;\n  \n  if (index != 0) {\n    handle_panic(3,\"FAILED ASSERTION.\");\n  }\n  *(undefined4 *)(&DAT_1fff0b6c + index * 8) = value1;\n  *(undefined4 *)(&DAT_1fff0b70 + index * 8) = value2;\n  update_memory_values(index);\n  initialize_memory(*(undefined4 *)(&DAT_00006ffc + index * 0x20),\n               *(undefined *)(index * 0x20 + 0x7000));\n  if ((&DAT_00007002)[index * 0x20] == '\\0') {\n    initialize_data_structure(index,flag);\n    result = 0;\n  }\n  else {\n    result = 0xffffffff;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000013b8": "initialize_memory_structure_000013b8",
                "param_1": "index",
                "param_2": "flag",
                "param_3": "value1",
                "param_4": "value2",
                "uVar1": "result",
                "kernel_panic_handler_00000f04": "handle_panic",
                "update_memory_values_00001448": "update_memory_values",
                "initialize_memory_00001392": "initialize_memory",
                "initialize_data_structure_000014c4": "initialize_data_structure"
            },
            "calling": [
                "FUN_00000df4"
            ],
            "called": [
                "FUN_000014c4",
                "FUN_00000f04",
                "FUN_00001392",
                "FUN_00001448"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001448": {
            "entrypoint": "0x00001448",
            "current_name": "update_memory_values_00001448",
            "code": "\nvoid updateMemoryValues_00001448(int index)\n\n{\n  if (*(short *)(&DAT_00006fec + index * 0x20) != -1) {\n    update_memory_value_00001f80(*(undefined2 *)(&DAT_00006fec + index * 0x20),\n                 *(undefined4 *)(&DAT_00006ff0 + index * 0x20));\n  }\n  if (*(short *)(&DAT_00006fee + index * 0x20) != -1) {\n    update_memory_value_00001f80(*(undefined2 *)(&DAT_00006fee + index * 0x20),\n                 *(undefined4 *)(&DAT_00006ff4 + index * 0x20));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001448": "update_memory_values_00001448",
                "param_1": "index"
            },
            "calling": [
                "FUN_000013b8"
            ],
            "called": [
                "FUN_00001f80"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000014c4": {
            "entrypoint": "0x000014c4",
            "current_name": "initialize_data_structure_000014c4",
            "code": "\nvoid initializeDataStructure_000014c4(int index,uint value)\n\n{\n  byte *dataPtr;\n  uint dataValue;\n  uint calculatedValue;\n  \n  dataPtr = *(byte **)(&DAT_00006fe4 + index * 0x20);\n  dataValue = *(uint *)(&DAT_00006fe8 + index * 0x20);\n  dataPtr[3] = dataPtr[3] & 0xf3;\n  dataPtr[2] = (&DAT_00007001)[index * 0x20];\n  calculatedValue = dataValue / (value << 4);\n  *dataPtr = (byte)(calculatedValue >> 8) & 0x1f;\n  dataPtr[1] = (byte)calculatedValue;\n  dataPtr[10] = (byte)((dataValue << 2) / value + 1 >> 1) & 0x1f;\n  dataPtr[0x10] = dataPtr[0x10] | 0x88;\n  if ((dataPtr[0x10] & 0x70) == 0) {\n    dataPtr[0x13] = 0;\n  }\n  else {\n    dataPtr[0x13] = (char)(2 << (dataPtr[0x10] >> 4 & 7)) - 1;\n  }\n  dataPtr[0x15] = 1;\n  dataPtr[0x11] = 0xc0;\n  dataPtr[3] = dataPtr[3] | 0x2c;\n  set_bit_in_memory_00001318((int)(char)(&DAT_00006ff8)[index * 0x20]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000014c4": "initialize_data_structure_000014c4",
                "param_1": "index",
                "param_2": "value",
                "pbVar1": "dataPtr",
                "uVar2": "dataValue",
                "uVar3": "calculatedValue"
            },
            "calling": [
                "FUN_000013b8"
            ],
            "called": [
                "FUN_00001318"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000015d0": {
            "entrypoint": "0x000015d0",
            "current_name": "copy_data_000015d0",
            "code": "\nvoid copyData_000015d0(int index,int source,uint length)\n\n{\n  int dataPointer;\n  uint counter;\n  \n  dataPointer = *(int *)(&DAT_00006fe4 + index * 0x20);\n  for (counter = 0; counter < length; counter = counter + 1) {\n    do {\n    } while (-1 < *(char *)(dataPointer + 4));\n    *(undefined *)(dataPointer + 7) = *(undefined *)(counter + source);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000015d0": "copy_data_000015d0",
                "param_1": "index",
                "param_2": "source",
                "param_3": "length",
                "iVar1": "dataPointer",
                "local_c": "counter"
            },
            "calling": [
                "FUN_00000e38"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001628": {
            "entrypoint": "0x00001628",
            "current_name": "execute_special_function_00001628",
            "code": "\nvoid executeSpecialFunction_00001628(int index)\n\n{\n  if (((*(byte *)(*(int *)(&DAT_00006fe4 + index * 0x20) + 4) & 0x20) != 0) &&\n     (*(int *)(&DAT_1fff0b6c + index * 8) != 0)) {\n    (**(code **)(&DAT_1fff0b6c + index * 8))\n              (*(undefined4 *)(&DAT_1fff0b70 + index * 8),\n               *(undefined *)(*(int *)(&DAT_00006fe4 + index * 0x20) + 7));\n  }\n  performBitOperation();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001628": "execute_special_function_00001628",
                "param_1": "index",
                "check_and_set_bit_00001348": "performBitOperation"
            },
            "calling": [
                "FUN_00001688"
            ],
            "called": [
                "FUN_00001348"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001688": {
            "entrypoint": "0x00001688",
            "current_name": "execute_special_function_00001688",
            "code": "\nvoid execute_special_function_00001688(void)\n\n{\n  execute_special_function_00001688_00001628(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001688": "execute_special_function_00001688"
            },
            "calling": [],
            "called": [
                "FUN_00001628"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001696": {
            "entrypoint": "0x00001696",
            "current_name": "calculate_offset_00001696",
            "code": "\nint calculateOffset_00001696(uint inputValue,int multiplier)\n\n{\n  return multiplier * 4 + (inputValue & 0xf0000000 | (inputValue & 0xfffff) << 5) + 0x2000000;\n}\n\n",
            "renaming": {
                "FUN_00001696": "calculate_offset_00001696",
                "param_1": "inputValue",
                "param_2": "multiplier"
            },
            "calling": [
                "FUN_000016ec",
                "FUN_00001710",
                "FUN_000016c8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000016c8": {
            "entrypoint": "0x000016c8",
            "current_name": "set_offset_to_value_000016c8",
            "code": "\nvoid setOffsetToValue_000016c8(undefined4 offset,undefined value)\n\n{\n  undefined4 *offsetPtr;\n  \n  offsetPtr = (undefined4 *)calculate_offset_00001696(offset,value);\n  *offsetPtr = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000016c8": "set_offset_to_value_000016c8",
                "param_1": "offset",
                "param_2": "value",
                "puVar1": "offsetPtr"
            },
            "calling": [
                "FUN_000017dc"
            ],
            "called": [
                "FUN_00001696"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000016ec": {
            "entrypoint": "0x000016ec",
            "current_name": "initialize_offset_000016ec",
            "code": "\nvoid initializeOffset_000016ec(undefined4 offsetAddress,undefined data)\n\n{\n  undefined *targetAddress;\n  \n  targetAddress = (undefined *)calculate_offset_00001696(offsetAddress,data);\n  *targetAddress = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000016ec": "initialize_offset_000016ec",
                "param_1": "offsetAddress",
                "param_2": "data",
                "puVar1": "targetAddress"
            },
            "calling": [
                "FUN_00001a18",
                "FUN_0000182c",
                "FUN_00001778",
                "FUN_00001a3c",
                "FUN_00001a60"
            ],
            "called": [
                "FUN_00001696"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001710": {
            "entrypoint": "0x00001710",
            "current_name": "initialize_to_zero_00001710",
            "code": "\nvoid initializeToZero_00001710(undefined4 inputParam1,undefined inputParam2)\n\n{\n  undefined *targetPointer;\n  \n  targetPointer = (undefined *)calculate_offset_00001696(inputParam1,inputParam2);\n  *targetPointer = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001710": "initialize_to_zero_00001710",
                "param_1": "inputParam1",
                "param_2": "inputParam2",
                "puVar1": "targetPointer"
            },
            "calling": [
                "FUN_00001960",
                "FUN_00001bb8",
                "FUN_0000182c",
                "FUN_00001778",
                "FUN_00001a60",
                "FUN_000018bc",
                "FUN_000019c0",
                "FUN_00001734"
            ],
            "called": [
                "FUN_00001696"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001734": {
            "entrypoint": "0x00001734",
            "current_name": "initialize_data_array_00001734",
            "code": "\nvoid initializeDataArray_00001734(void)\n\n{\n  initializeArrayToZero(&DAT_40064005,6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001734": "initialize_data_array_00001734",
                "initialize_to_zero_00001710": "initializeArrayToZero"
            },
            "calling": [
                "FUN_00001a18",
                "FUN_00001a3c",
                "FUN_000019c0"
            ],
            "called": [
                "FUN_00001710"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001748": {
            "entrypoint": "0x00001748",
            "current_name": "set_bits_in_variable_00001748",
            "code": "\nvoid setBitsInVariable_00001748(byte inputByte)\n\n{\n  DAT_40064003 = inputByte | DAT_40064003 & 0x1f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001748": "set_bits_in_variable_00001748",
                "param_1": "inputByte"
            },
            "calling": [
                "FUN_0000191c",
                "FUN_00001960",
                "FUN_00001bb8",
                "FUN_000018bc",
                "FUN_000019c0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001778": {
            "entrypoint": "0x00001778",
            "current_name": "initialize_and_set_bit_mask_00001778",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000179c) */\n/* WARNING: Removing unreachable block (ram,0x000017b2) */\n/* WARNING: Removing unreachable block (ram,0x000017c0) */\n\nvoid initializeAndSetBitMask_00001778(void)\n\n{\n  DAT_40064001 = DAT_40064001 & 0xcf | 0x20;\n  initialize_to_zero_00001710(&DAT_40064001,2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001778": "initialize_and_set_bit_mask_00001778"
            },
            "calling": [
                "FUN_0000191c",
                "FUN_000019c0"
            ],
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000017dc": {
            "entrypoint": "0x000017dc",
            "current_name": "set_offset_and_value_000017dc",
            "code": "\n\n\nvoid setOffsetAndValue_000017dc(void)\n\n{\n  setOffsetToValue(&DAT_4004803c,0x1d);\n  if ((_DAT_4003d010 & 0x100) == 0) {\n    _DAT_4003d010 = 0x104;\n  }\n  _DAT_40047000 = _DAT_40047000 & 0xfff3ffff | 0x80000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000017dc": "set_offset_and_value_000017dc",
                "set_offset_to_value_000016c8": "setOffsetToValue"
            },
            "calling": [
                "FUN_00001c84"
            ],
            "called": [
                "FUN_000016c8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000182c": {
            "entrypoint": "0x0000182c",
            "current_name": "initialize_data_0000182c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000187c) */\n/* WARNING: Removing unreachable block (ram,0x0000186a) */\n/* WARNING: Removing unreachable block (ram,0x00001898) */\n\nvoid initialize_data_0000182c(void)\n\n{\n  DAT_40064008 = DAT_40064008 & 0xd0;\n  set_offset(&DAT_40064001,0);\n  set_to_zero(&DAT_40064000,1);\n  set_to_zero(&DAT_40064000,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000182c": "initialize_data_0000182c",
                "initialize_offset_000016ec": "set_offset",
                "initialize_to_zero_00001710": "set_to_zero"
            },
            "calling": [
                "FUN_00001c84"
            ],
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000018bc": {
            "entrypoint": "0x000018bc",
            "current_name": "initialize_system_000018bc",
            "code": "\nvoid initializeSystem_000018bc(void)\n\n{\n  setVariableBits(0xa0);\n  DAT_40064000 = DAT_40064000 & 0x3b | 4;\n  initializeMemory(&DAT_40064001,1);\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  DAT_1fff0b74 = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000018bc": "initialize_system_000018bc",
                "set_bits_in_variable_00001748": "setVariableBits",
                "initialize_to_zero_00001710": "initializeMemory"
            },
            "calling": [
                "FUN_00001b10"
            ],
            "called": [
                "FUN_00001710",
                "FUN_00001748"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000191c": {
            "entrypoint": "0x0000191c",
            "current_name": "initialize_and_set_bit_mask_0000191c",
            "code": "\nvoid initializeAndSetBitMask_0000191c(void)\n\n{\n  initialize_and_set_bit_mask_00001778();\n  setBitsInVariable(0x40);\n  DAT_40064000 = DAT_40064000 & 0x3b;\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  DAT_1fff0b74 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000191c": "initialize_and_set_bit_mask_0000191c",
                "set_bits_in_variable_00001748": "setBitsInVariable"
            },
            "calling": [
                "FUN_00001b10"
            ],
            "called": [
                "FUN_00001778",
                "FUN_00001748"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001960": {
            "entrypoint": "0x00001960",
            "current_name": "initialize_and_set_bits_00001960",
            "code": "\nvoid initializeAndSetBits_00001960(void)\n\n{\n  set_bits_in_variable_00001748(0xa0);\n  initialize_to_zero_00001710(&DAT_40064001,1);\n  DAT_40064000 = DAT_40064000 & 0x3b | 0x44;\n  do {\n  } while ((DAT_40064006 & 0xc) != 4);\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  DAT_1fff0b74 = 2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001960": "initialize_and_set_bits_00001960"
            },
            "calling": [
                "FUN_00001b10"
            ],
            "called": [
                "FUN_00001710",
                "FUN_00001748"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000019c0": {
            "entrypoint": "0x000019c0",
            "current_name": "initialize_and_set_bitmask_000019c0",
            "code": "\nvoid initialize_and_set_bitmask_000019c0(void)\n\n{\n  initialize_and_set_bit_mask_00001778();\n  set_bits_in_variable(0x40);\n  initialize_to_zero(&DAT_40064001,1);\n  DAT_40064000 = DAT_40064000 & 0x3b | 0x80;\n  do {\n  } while ((DAT_40064006 & 0xc) != 8);\n  initialize_data_array();\n  DAT_1fff0b74 = 3;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000019c0": "initialize_and_set_bitmask_000019c0",
                "set_bits_in_variable_00001748": "set_bits_in_variable",
                "initialize_to_zero_00001710": "initialize_to_zero",
                "initialize_data_array_00001734": "initialize_data_array"
            },
            "calling": [
                "FUN_00001b10"
            ],
            "called": [
                "FUN_00001710",
                "FUN_00001778",
                "FUN_00001748",
                "FUN_00001734"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a18": {
            "entrypoint": "0x00001a18",
            "current_name": "initialize_data_00001a18",
            "code": "\nvoid initialize_data_00001a18(void)\n\n{\n  initialize_offset_000016ec(&DAT_40064001,1);\n  initialize_data_00001a18_array_00001734();\n  DAT_1fff0b74 = 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a18": "initialize_data_00001a18"
            },
            "calling": [
                "FUN_00001b10"
            ],
            "called": [
                "FUN_000016ec",
                "FUN_00001734"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a3c": {
            "entrypoint": "0x00001a3c",
            "current_name": "initialize_data_00001a3c",
            "code": "\nvoid initializeData_00001a3c(void)\n\n{\n  initializeOffset(&DAT_40064001,1);\n  initializeData_00001a3cArray();\n  DAT_1fff0b74 = 5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a3c": "initialize_data_00001a3c",
                "initialize_offset_000016ec": "initializeOffset",
                "initialize_data_array_00001734": "initializeDataArray"
            },
            "calling": [
                "FUN_00001b10"
            ],
            "called": [
                "FUN_000016ec",
                "FUN_00001734"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a60": {
            "entrypoint": "0x00001a60",
            "current_name": "initialize_and_wait_00001a60",
            "code": "\nvoid initialize_and_wait_00001a60(void)\n\n{\n  initialize_to_zero_00001710(&DAT_40064001,1);\n  DAT_40064000 = DAT_40064000 & 0x3f | 0x80;\n  do {\n  } while ((DAT_40064006 & 0xc) != 8);\n  initialize_offset_000016ec(&DAT_40064005,6);\n  do {\n  } while ((DAT_40064006 & 0x20) == 0);\n  do {\n  } while ((DAT_40064006 & 0x40) == 0);\n  DAT_1fff0b74 = 6;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a60": "initialize_and_wait_00001a60"
            },
            "calling": [
                "FUN_00001b10"
            ],
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ad4": {
            "entrypoint": "0x00001ad4",
            "current_name": "initialize_data_00001ad4",
            "code": "\nvoid initializeData_00001ad4(void)\n\n{\n  DAT_40064000 = DAT_40064000 & 0x3f;\n  do {\n  } while ((DAT_40064006 & 0xc) != 0xc);\n  DAT_1fff0b74 = 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ad4": "initialize_data_00001ad4"
            },
            "calling": [
                "FUN_00001b10"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001b10": {
            "entrypoint": "0x00001b10",
            "current_name": "initialize_functions_00001b10",
            "code": "\nundefined4 initializeFunctions_00001b10(byte index)\n\n{\n  undefined4 returnValue;\n  \n  if (index < 8) {\n    do {\n      switch((&DAT_00007004)[(uint)index + (uint)DAT_1fff0b74 * 8]) {\n      case 0:\n        initialize_system_000018bc();\n        break;\n      case 1:\n        initialize_and_set_bit_mask_0000191c();\n        break;\n      case 2:\n        initialize_and_set_bits_00001960();\n        break;\n      case 3:\n        initialize_and_set_bitmask_000019c0();\n        break;\n      case 4:\n        initialize_data_00001a18();\n        break;\n      case 5:\n        initialize_data_00001a3c();\n        break;\n      case 6:\n        initialize_and_wait_00001a60();\n        break;\n      case 7:\n        initialize_data_00001ad4();\n        break;\n      default:\n        return 0xffffffff;\n      }\n    } while (index != DAT_1fff0b74);\n    returnValue = 0;\n  }\n  else {\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00001b10": "initialize_functions_00001b10",
                "param_1": "index",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_00001c84"
            ],
            "called": [
                "FUN_00001a18",
                "FUN_0000191c",
                "FUN_00001ad4",
                "FUN_00001960",
                "FUN_00001a3c",
                "FUN_00001a60",
                "FUN_000019c0",
                "FUN_000018bc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001bb8": {
            "entrypoint": "0x00001bb8",
            "current_name": "initialize_and_reset_00001bb8",
            "code": "\nvoid initializeAndReset_00001bb8(void)\n\n{\n  if ((DAT_40064001 & 2) != 0) {\n    initializeToZero(&DAT_40064001,1);\n  }\n  if ((DAT_40064005 & 0x40) != 0) {\n    if ((DAT_40064000 & 0xc0) == 0) {\n      DAT_40064000 = DAT_40064000 & 0x3f | 0x80;\n      do {\n      } while ((DAT_40064006 & 0xc) != 8);\n    }\n    initializeToZero(&DAT_40064005,6);\n    do {\n    } while ((DAT_40064006 & 0x20) != 0);\n  }\n  setBitsInVariable(0);\n  DAT_40064000 = DAT_40064000 & 0x3b | 4;\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  DAT_1fff0b74 = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001bb8": "initialize_and_reset_00001bb8",
                "initialize_to_zero_00001710": "initializeToZero",
                "set_bits_in_variable_00001748": "setBitsInVariable"
            },
            "calling": [
                "FUN_00001c84"
            ],
            "called": [
                "FUN_00001710",
                "FUN_00001748"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001c84": {
            "entrypoint": "0x00001c84",
            "current_name": "initialize_system_00001c84",
            "code": "\n\n\nvoid initialize_system_00001c84(void)\n\n{\n  undefined4 irq_int_enabled;\n  \n  irq_int_enabled = check_irq_interrupts_enabled_00000cd0();\n  initialize_and_reset();\n  _DAT_40048044 = 0x220000;\n  DAT_4006400c = 0;\n  DAT_40064000 = DAT_40064000 & 199 | 0x38;\n  DAT_40064004 = 0x13;\n  DAT_40064005 = 0;\n  initialize_data();\n  set_offset_and_value();\n  initialize_functions(7);\n  configure_irq_interrupts(irq_int_enabled);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001c84": "initialize_system_00001c84",
                "uVar1": "irq_int_enabled",
                "initialize_and_reset_00001bb8": "initialize_and_reset",
                "initialize_data_0000182c": "initialize_data",
                "set_offset_and_value_000017dc": "set_offset_and_value",
                "initialize_functions_00001b10": "initialize_functions",
                "configure_ir_qinterrupts_00000d0c": "configure_irq_interrupts"
            },
            "calling": [
                "FUN_00001274"
            ],
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_00001bb8",
                "FUN_0000182c",
                "FUN_000017dc",
                "FUN_00001b10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001cf0": {
            "entrypoint": "0x00001cf0",
            "current_name": "check_and_set_bit_00001cf0",
            "code": "\nvoid check_and_set_bit_00001cf0(void)\n\n{\n  if (DAT_1fff0354 != 0) {\n    set_bit();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001cf0": "check_and_set_bit_00001cf0",
                "set_e000ed04_bit_0000093c": "set_bit"
            },
            "calling": [
                "FUN_00002028"
            ],
            "called": [
                "FUN_0000093c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d08": {
            "entrypoint": "0x00001d08",
            "current_name": "calculate_offset_00001d08",
            "code": "\nint calculate_offset_00001d08(uint input_value,int multiplier)\n\n{\n  return multiplier * 4 + (input_value & 0xf0000000 | (input_value & 0xfffff) << 5) + 0x2000000;\n}\n\n",
            "renaming": {
                "FUN_00001d08": "calculate_offset_00001d08",
                "param_1": "input_value",
                "param_2": "multiplier"
            },
            "calling": [
                "FUN_00001d3a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d3a": {
            "entrypoint": "0x00001d3a",
            "current_name": "set_offset_to_one_00001d3a",
            "code": "\nvoid setOffsetToOne_00001d3a(undefined4 offset,undefined inputParam)\n\n{\n  undefined4 *offsetPtr;\n  \n  offsetPtr = (undefined4 *)calculate_offset_00001d08(offset,inputParam);\n  *offsetPtr = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001d3a": "set_offset_to_one_00001d3a",
                "param_1": "offset",
                "param_2": "inputParam",
                "puVar1": "offsetPtr"
            },
            "calling": [
                "FUN_00001ddc"
            ],
            "called": [
                "FUN_00001d08"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d5e": {
            "entrypoint": "0x00001d5e",
            "current_name": "apply_bit_mask_00001d5e",
            "code": "\nuint applyBitMask_00001d5e(ushort input)\n\n{\n  return input & 0x7000 | 0x40048000;\n}\n\n",
            "renaming": {
                "FUN_00001d5e": "apply_bit_mask_00001d5e",
                "param_1": "input"
            },
            "calling": [
                "FUN_00001eea",
                "FUN_00001f80"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d80": {
            "entrypoint": "0x00001d80",
            "current_name": "calculate_modified_value_00001d80",
            "code": "\nuint calculateModifiedValue_00001d80(ushort inputValue)\n\n{\n  return inputValue & 0x1c0 | 0x400ff000;\n}\n\n",
            "renaming": {
                "FUN_00001d80": "calculate_modified_value_00001d80",
                "param_1": "inputValue"
            },
            "calling": [
                "FUN_00001ff6",
                "FUN_00001eea"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001da2": {
            "entrypoint": "0x00001da2",
            "current_name": "extract_bits_00001da2",
            "code": "\nushort extractBits_00001da2(ushort value)\n\n{\n  return value >> 6 & 7;\n}\n\n",
            "renaming": {
                "FUN_00001da2": "extract_bits_00001da2",
                "param_1": "value"
            },
            "calling": [
                "FUN_00001f80",
                "FUN_00001ddc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001dc0": {
            "entrypoint": "0x00001dc0",
            "current_name": "truncate_to_six_bits_00001dc0",
            "code": "\nushort truncateToSixBits_00001dc0(ushort inputValue)\n\n{\n  return inputValue & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_00001dc0": "truncate_to_six_bits_00001dc0",
                "param_1": "inputValue"
            },
            "calling": [
                "FUN_00001ff6",
                "FUN_00001eea",
                "FUN_00001f80"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ddc": {
            "entrypoint": "0x00001ddc",
            "current_name": "set_offset_to_one_00001ddc",
            "code": "\nvoid setOffsetToOne_00001ddc(undefined2 input)\n\n{\n  char extractedBits;\n  \n  extractedBits = extract_bits_00001da2(input);\n  set_offset_to_one_00001d3a(&DAT_40048038,extractedBits + '\\t');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ddc": "set_offset_to_one_00001ddc",
                "param_1": "input",
                "cVar1": "extractedBits"
            },
            "calling": [
                "FUN_00001f80"
            ],
            "called": [
                "FUN_00001da2",
                "FUN_00001d3a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001e0c": {
            "entrypoint": "0x00001e0c",
            "current_name": "extract_bits_00001e0c",
            "code": "\nuint extract_bits_00001e0c(int offset,uint number)\n\n{\n  return *(uint *)(&DAT_1fff0bd8 + (((int)number >> 3) + offset * 4) * 4) >> ((number & 7) << 2)\n         & 0xf;\n}\n\n",
            "renaming": {
                "FUN_00001e0c": "extract_bits_00001e0c",
                "param_1": "offset",
                "param_2": "number"
            },
            "calling": [
                "FUN_00002028",
                "FUN_00001ec4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001e44": {
            "entrypoint": "0x00001e44",
            "current_name": "update_bits_at_position_00001e44",
            "code": "\nvoid updateBitsAtPosition_00001e44(int index,uint bitPosition,int newValue)\n\n{\n  int shiftedIndex;\n  \n  shiftedIndex = (int)bitPosition >> 3;\n  *(uint *)(&DAT_1fff0bd8 + (shiftedIndex + index * 4) * 4) =\n       *(uint *)(&DAT_1fff0bd8 + (shiftedIndex + index * 4) * 4) & ~(0xf << ((bitPosition & 7) << 2));\n  *(uint *)(&DAT_1fff0bd8 + (shiftedIndex + index * 4) * 4) =\n       *(uint *)(&DAT_1fff0bd8 + (shiftedIndex + index * 4) * 4) | newValue << ((bitPosition & 7) << 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001e44": "update_bits_at_position_00001e44",
                "param_1": "index",
                "param_2": "bitPosition",
                "param_3": "newValue",
                "iVar1": "shiftedIndex"
            },
            "calling": [
                "FUN_00001ec4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ec4": {
            "entrypoint": "0x00001ec4",
            "current_name": "update_bits_00001ec4",
            "code": "\nvoid update_bits_00001ec4(undefined4 data1,undefined4 data2)\n\n{\n  undefined4 extractedBits;\n  \n  extractedBits = extract_bits_00001e0c(data1,data2);\n  update_bits_00001ec4_at_position_00001e44(data1,data2,extractedBits);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ec4": "update_bits_00001ec4",
                "param_1": "data1",
                "param_2": "data2",
                "uVar1": "extractedBits"
            },
            "calling": [
                "FUN_00001f80"
            ],
            "called": [
                "FUN_00001e0c",
                "FUN_00001e44"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001eea": {
            "entrypoint": "0x00001eea",
            "current_name": "update_memory_value_00001eea",
            "code": "\nundefined4 updateMemoryValue_00001eea(undefined2 value,byte byteVal)\n\n{\n  uint truncatedValue;\n  int modifiedValue;\n  int bitOffset;\n  \n  update_memory_value_00001f80(value,0);\n  if ((char)byteVal < '\\0') {\n    truncatedValue = truncate_to_six_bits_00001dc0(value);\n    modifiedValue = calculate_modified_value_00001d80(value);\n    *(uint *)(modifiedValue + 0x14) = *(uint *)(modifiedValue + 0x14) | 1 << (truncatedValue & 0xff);\n  }\n  else {\n    truncatedValue = truncate_to_six_bits_00001dc0(value);\n    modifiedValue = calculate_modified_value_00001d80(value);\n    *(uint *)(modifiedValue + 0x14) = *(uint *)(modifiedValue + 0x14) & ~(1 << (truncatedValue & 0xff));\n  }\n  modifiedValue = apply_bit_mask_00001d5e(value);\n  bitOffset = truncate_to_six_bits_00001dc0(value);\n  *(uint *)(modifiedValue + bitOffset * 4) = byteVal & 0x23 | 0x100;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00001eea": "update_memory_value_00001eea",
                "param_1": "value",
                "param_2": "byteVal",
                "uVar1": "truncatedValue",
                "iVar2": "modifiedValue",
                "iVar3": "bitOffset"
            },
            "calling": [
                "FUN_00000e64"
            ],
            "called": [
                "FUN_00001d80",
                "FUN_00001f80",
                "FUN_00001d5e",
                "FUN_00001dc0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001f80": {
            "entrypoint": "0x00001f80",
            "current_name": "update_memory_value_00001f80",
            "code": "\nvoid updateMemoryValue_00001f80(undefined2 inputValue,undefined4 newValue)\n\n{\n  int offset;\n  int truncatedIndex;\n  undefined4 extractedBits;\n  undefined4 truncatedIndex2;\n  uint originalValue;\n  \n  set_offset_to_one_00001ddc(inputValue);\n  offset = apply_bit_mask_00001d5e(inputValue);\n  truncatedIndex = truncate_to_six_bits_00001dc0(inputValue);\n  originalValue = *(uint *)(offset + truncatedIndex * 4);\n  offset = apply_bit_mask_00001d5e(inputValue);\n  truncatedIndex = truncate_to_six_bits_00001dc0(inputValue);\n  *(undefined4 *)(offset + truncatedIndex * 4) = newValue;\n  if ((originalValue & 0xf0000) != 0) {\n    extractedBits = extract_bits_00001da2(inputValue);\n    truncatedIndex2 = truncate_to_six_bits_00001dc0(inputValue);\n    update_bits_00001ec4(extractedBits,truncatedIndex2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001f80": "update_memory_value_00001f80",
                "param_1": "inputValue",
                "param_2": "newValue",
                "iVar1": "offset",
                "iVar2": "truncatedIndex",
                "uVar3": "extractedBits",
                "uVar4": "truncatedIndex2",
                "uVar5": "originalValue"
            },
            "calling": [
                "FUN_00001eea",
                "FUN_00001448"
            ],
            "called": [
                "FUN_00001da2",
                "FUN_00001ec4",
                "FUN_00001dc0",
                "FUN_00001d5e",
                "FUN_00001ddc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ff6": {
            "entrypoint": "0x00001ff6",
            "current_name": "set_modified_value_00001ff6",
            "code": "\nvoid setModifiedValue_00001ff6(undefined2 inputValue)\n\n{\n  uint truncatedValue;\n  int modifiedValue;\n  \n  truncatedValue = truncateToSixBits(inputValue);\n  modifiedValue = calculateModifiedValue(inputValue);\n  *(int *)(modifiedValue + 4) = 1 << (truncatedValue & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ff6": "set_modified_value_00001ff6",
                "param_1": "inputValue",
                "uVar1": "truncatedValue",
                "iVar2": "modifiedValue",
                "calculate_modified_value_00001d80": "calculateModifiedValue",
                "truncate_to_six_bits_00001dc0": "truncateToSixBits"
            },
            "calling": [
                "FUN_00000e64"
            ],
            "called": [
                "FUN_00001d80",
                "FUN_00001dc0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002028": {
            "entrypoint": "0x00002028",
            "current_name": "process_data_00002028",
            "code": "\nvoid processData_00002028(int dataPtr,undefined4 value)\n\n{\n  int result;\n  uint mask;\n  uint index;\n  \n  mask = *(uint *)(dataPtr + 0xa0);\n  for (index = 0; (int)index < 0x20; index = index + 1) {\n    if (((mask & 1 << (index & 0xff)) != 0) &&\n       ((*(uint *)(dataPtr + index * 4) & 0xf0000) != 0)) {\n      *(int *)(dataPtr + 0xa0) = 1 << (index & 0xff);\n      result = extract_bits_00001e0c(value,index);\n      (**(code **)(&DAT_1fff0b78 + result * 0xc))(*(undefined4 *)(&DAT_1fff0b7c + result * 0xc));\n    }\n  }\n  check_and_set_bit_00001cf0();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002028": "process_data_00002028",
                "param_1": "dataPtr",
                "param_2": "value",
                "iVar1": "result",
                "uVar2": "mask",
                "local_c": "index"
            },
            "calling": [
                "FUN_000020b8",
                "FUN_00002108",
                "FUN_000020cc",
                "FUN_000020e0",
                "FUN_000020f4"
            ],
            "called": [
                "FUN_00001e0c",
                "FUN_00001cf0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020b8": {
            "entrypoint": "0x000020b8",
            "current_name": "initialize_data_processing_000020b8",
            "code": "\nvoid initializeDataProcessing_000020b8(void)\n\n{\n  processData(0x40049000,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020b8": "initialize_data_processing_000020b8",
                "process_data_00002028": "processData"
            },
            "calling": [],
            "called": [
                "FUN_00002028"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020cc": {
            "entrypoint": "0x000020cc",
            "current_name": "initialize_data_processing_000020cc",
            "code": "\nvoid initializeDataProcessing_000020cc(void)\n\n{\n  processData(0x4004a000,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020cc": "initialize_data_processing_000020cc",
                "process_data_00002028": "processData"
            },
            "calling": [],
            "called": [
                "FUN_00002028"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020e0": {
            "entrypoint": "0x000020e0",
            "current_name": "initialize_data_processing_000020e0",
            "code": "\nvoid initializeDataProcessing_000020e0(void)\n\n{\n  processData(0x4004b000,2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020e0": "initialize_data_processing_000020e0",
                "process_data_00002028": "processData"
            },
            "calling": [],
            "called": [
                "FUN_00002028"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020f4": {
            "entrypoint": "0x000020f4",
            "current_name": "initialize_data_processing_000020f4",
            "code": "\nvoid initializeDataProcessing_000020f4(void)\n\n{\n  processData(0x4004c000,3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020f4": "initialize_data_processing_000020f4",
                "process_data_00002028": "processData"
            },
            "calling": [],
            "called": [
                "FUN_00002028"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002108": {
            "entrypoint": "0x00002108",
            "current_name": "initialize_data_processing_00002108",
            "code": "\nvoid initializeDataProcessing_00002108(void)\n\n{\n  processData(0x4004d000,4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002108": "initialize_data_processing_00002108",
                "process_data_00002028": "processData"
            },
            "calling": [],
            "called": [
                "FUN_00002028"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000211c": {
            "entrypoint": "0x0000211c",
            "current_name": "print_stack_info_0000211c",
            "code": "\nvoid printStackInfo_0000211c(void)\n\n{\n  int iVar1;\n  undefined2 padding;\n  int offset;\n  int nextOffset;\n  dword relOffset;\n  uint relIndex;\n  undefined4 *currentEntry;\n  undefined4 mainStackAddr;\n  undefined4 startAddr;\n  int validOffsetsCount;\n  short index;\n  int totalOffset;\n  int stackSize;\n  \n  padding = 0x515f;\n  stackSize = 0;\n  totalOffset = 0;\n  initialize_and_process_data_00004c84(\"\\tpid | %-21s| %-9sQ | pri | stack  ( used) | base addr  | current     \\n\",\n               &DAT_000070b8,\"state\");\n  validOffsetsCount = count_valid_offsets_000008b8();\n  startAddr = get_starting_address_0000091c();\n  mainStackAddr = get_main_stack_pointer_00000900();\n  initialize_and_process_data_00004c84(\"\\t  - | isr_stack            | -        - |   - | %6i (%5i) | %10p | %10p\\n\",0x200,\n               validOffsetsCount,startAddr,mainStackAddr);\n  stackSize = stackSize + 0x200;\n  if (0 < validOffsetsCount) {\n    totalOffset = validOffsetsCount + totalOffset;\n  }\n  for (index = 1; index < 0x21; index = index + 1) {\n    currentEntry = *(undefined4 **)(&DAT_1fff0358 + index * 4);\n    if (currentEntry != (undefined4 *)0x0) {\n      relIndex = (uint)*(byte *)(currentEntry + 1);\n      relOffset = (&Elf32_Rel_ARRAY_1fff0200[4].r_offset)[relIndex];\n      nextOffset = (int)&padding + (uint)(8 < relIndex);\n      offset = currentEntry[0xb];\n      stackSize = offset + stackSize;\n      iVar1 = calculate_distance_000010a0(currentEntry[9]);\n      offset = offset - iVar1;\n      totalOffset = offset + totalOffset;\n      initialize_and_process_data_00004c84(\"\\t%3hi | %-20s | %-8s %.1s | %3i | %6i (%5i) | %10p | %10p \\n\",\n                   (int)*(short *)((int)currentEntry + 6),currentEntry[10],relOffset,nextOffset,\n                   *(undefined *)((int)currentEntry + 5),currentEntry[0xb],offset,currentEntry[9],*currentEntry);\n    }\n  }\n  initialize_and_process_data_00004c84(\"\\t%5s %-21s|%13s%6s %6i (%5i)\\n\",&DAT_00007190,&DAT_00007194,&DAT_00007190,\n               &DAT_00007190,stackSize,totalOffset);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000211c": "print_stack_info_0000211c",
                "local_40": "padding",
                "local_3c": "offset",
                "local_38": "nextOffset",
                "local_34": "relOffset",
                "local_30": "relIndex",
                "local_2c": "currentEntry",
                "local_28": "mainStackAddr",
                "local_24": "startAddr",
                "local_20": "validOffsetsCount",
                "local_1a": "index",
                "local_18": "totalOffset",
                "local_14": "stackSize"
            },
            "calling": [
                "FUN_00002eb4",
                "FUN_00000f04"
            ],
            "called": [
                "FUN_000010a0",
                "FUN_00004c84",
                "FUN_000008b8",
                "FUN_00000900",
                "FUN_0000091c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": [],
            "code_backup": "\nvoid FUN_0000211c(void)\n\n{\n  int iVar1;\n  undefined2 local_40;\n  int local_3c;\n  int local_38;\n  dword local_34;\n  uint local_30;\n  undefined4 *local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  int local_20;\n  short local_1a;\n  int local_18;\n  int local_14;\n  \n  local_40 = 0x515f;\n  local_14 = 0;\n  local_18 = 0;\n  FUNC_00004c84(\"\\tpid | %-21s| %-9sQ | pri | stack  ( used) | base addr  | current     \\n\",\n               &DAT_000070b8,\"state\");\n  local_20 = count_valid_offsets_000008b8();\n  local_24 = get_starting_address_0000091c();\n  local_28 = get_main_stack_pointer_00000900();\n  FUNC_00004c84(\"\\t  - | isr_stack            | -        - |   - | %6i (%5i) | %10p | %10p\\n\",0x200,\n               local_20,local_24,local_28);\n  local_14 = local_14 + 0x200;\n  if (0 < local_20) {\n    local_18 = local_20 + local_18;\n  }\n  for (local_1a = 1; local_1a < 0x21; local_1a = local_1a + 1) {\n    local_2c = *(undefined4 **)(&DAT_1fff0358 + local_1a * 4);\n    if (local_2c != (undefined4 *)0x0) {\n      local_30 = (uint)*(byte *)(local_2c + 1);\n      local_34 = (&Elf32_Rel_ARRAY_1fff0200[4].r_offset)[local_30];\n      local_38 = (int)&local_40 + (uint)(8 < local_30);\n      local_3c = local_2c[0xb];\n      local_14 = local_3c + local_14;\n      iVar1 = calculate_distance_000010a0(local_2c[9]);\n      local_3c = local_3c - iVar1;\n      local_18 = local_3c + local_18;\n      FUNC_00004c84(\"\\t%3hi | %-20s | %-8s %.1s | %3i | %6i (%5i) | %10p | %10p \\n\",\n                   (int)*(short *)((int)local_2c + 6),local_2c[10],local_34,local_38,\n                   *(undefined *)((int)local_2c + 5),local_2c[0xb],local_3c,local_2c[9],*local_2c);\n    }\n  }\n  FUNC_00004c84(\"\\t%5s %-21s|%13s%6s %6i (%5i)\\n\",&DAT_00007190,&DAT_00007194,&DAT_00007190,\n               &DAT_00007190,local_14,local_18);\n  return;\n}\n\n"
        },
        "FUN_00002270": {
            "entrypoint": "0x00002270",
            "current_name": "check_equality_00002270",
            "code": "\nundefined checkEquality_00002270(int input)\n\n{\n  undefined result;\n  int value;\n  bool isMatch;\n  \n  value = *(int *)(input + 0xc);\n  isMatch = *(int *)(input + 8) == value;\n  if (isMatch) {\n    value = 1;\n  }\n  result = (undefined)value;\n  if (!isMatch) {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00002270": "check_equality_00002270",
                "param_1": "input",
                "iVar2": "value",
                "bVar3": "isMatch",
                "uVar1": "result"
            },
            "calling": [
                "FUN_0000231c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002294": {
            "entrypoint": "0x00002294",
            "current_name": "check_difference_00002294",
            "code": "\nundefined checkDifference_00002294(int input)\n\n{\n  undefined result;\n  int difference;\n  bool hasCorrectDifference;\n  \n  difference = *(int *)(input + 4);\n  hasCorrectDifference = *(int *)(input + 0xc) - *(int *)(input + 8) == difference;\n  if (hasCorrectDifference) {\n    difference = 1;\n  }\n  result = (undefined)difference;\n  if (!hasCorrectDifference) {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00002294": "check_difference_00002294",
                "param_1": "input",
                "iVar2": "difference",
                "bVar3": "hasCorrectDifference",
                "uVar1": "result"
            },
            "calling": [
                "FUN_00002364"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000022be": {
            "entrypoint": "0x000022be",
            "current_name": "write_value_to_address_000022be",
            "code": "\nvoid writeValueToAddress_000022be(int *array,undefined value)\n\n{\n  uint currentIndex;\n  \n  currentIndex = array[3];\n  array[3] = currentIndex + 1;\n  *(undefined *)((currentIndex & array[1] - 1U) + *array) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000022be": "write_value_to_address_000022be",
                "param_1": "array",
                "param_2": "value",
                "uVar1": "currentIndex"
            },
            "calling": [
                "FUN_00002364"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000022f0": {
            "entrypoint": "0x000022f0",
            "current_name": "increment_and_return_000022f0",
            "code": "\nundefined incrementAndReturn_000022f0(int *array)\n\n{\n  uint value;\n  \n  value = array[2];\n  array[2] = value + 1;\n  return *(undefined *)((value & array[1] - 1U) + *array);\n}\n\n",
            "renaming": {
                "FUN_000022f0": "increment_and_return_000022f0",
                "param_1": "array",
                "uVar1": "value",
                "param_1[2]": "array[2]"
            },
            "calling": [
                "FUN_0000231c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000231c": {
            "entrypoint": "0x0000231c",
            "current_name": "copy_and_count_0000231c",
            "code": "\nint copyAndCount_0000231c(undefined4 inputValue,undefined *destinationBuffer,int bufferSize)\n\n{\n  undefined newValue;\n  int equalityCheckResult;\n  undefined *currentDestination;\n  int remainingSize;\n  \n  currentDestination = destinationBuffer;\n  remainingSize = bufferSize;\n  while ((remainingSize != 0 && (equalityCheckResult = check_equality_00002270(inputValue), equalityCheckResult == 0))) {\n    newValue = increment_and_return_000022f0(inputValue);\n    *currentDestination = newValue;\n    remainingSize = remainingSize + -1;\n    currentDestination = currentDestination + 1;\n  }\n  return bufferSize - remainingSize;\n}\n\n",
            "renaming": {
                "FUN_0000231c": "copy_and_count_0000231c",
                "param_1": "inputValue",
                "param_2": "destinationBuffer",
                "param_3": "bufferSize",
                "uVar1": "newValue",
                "iVar2": "equalityCheckResult",
                "local_20": "currentDestination",
                "local_14": "remainingSize"
            },
            "calling": [
                "FUN_000012e2"
            ],
            "called": [
                "FUN_00002270",
                "FUN_000022f0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002364": {
            "entrypoint": "0x00002364",
            "current_name": "write_value_if_difference_is_zero_00002364",
            "code": "\nundefined4 write_value_if_difference_is_zero_00002364(undefined4 address,undefined value)\n\n{\n  int difference;\n  undefined4 result;\n  \n  difference = check_difference_00002294(address);\n  if (difference == 0) {\n    write_value_to_address_000022be(address,value);\n    result = 0;\n  }\n  else {\n    result = 0xffffffff;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00002364": "write_value_if_difference_is_zero_00002364",
                "param_1": "address",
                "param_2": "value",
                "iVar1": "difference",
                "uVar2": "result"
            },
            "calling": [
                "FUN_000012b4"
            ],
            "called": [
                "FUN_000022be",
                "FUN_00002294"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002396": {
            "entrypoint": "0x00002396",
            "current_name": "initialize_system_00002396",
            "code": "\nvoid initialize_system_00002396(void)\n\n{\n  initialize_system_00002396_000025f4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002396": "initialize_system_00002396"
            },
            "calling": [
                "FUN_00001274"
            ],
            "called": [
                "FUN_000025f4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023a4": {
            "entrypoint": "0x000023a4",
            "current_name": "initialize_system_000023a4",
            "code": "\nundefined4 initializeSystem_000023a4(void)\n\n{\n  undefined4 status;\n  undefined buffer [128];\n  \n  execute_or_return_interrupt_000023d0(0);\n  process_data_00004db8(\"Welcome to RIOT!\");\n  status = process_input_loop_00002e6c(0,buffer,0x80);\n  software_interrupt(0x3f);\n  return status;\n}\n\n",
            "renaming": {
                "FUN_000023a4": "initialize_system_000023a4",
                "uVar1": "status",
                "auStack_88": "buffer"
            },
            "calling": [
                "FUN_00000f04"
            ],
            "called": [
                "FUN_00004db8",
                "FUN_00002e6c",
                "FUN_000023d0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023c8": {
            "entrypoint": "0x000023c8",
            "current_name": "execute_software_interrupt_000023c8",
            "code": "\nvoid executeSoftwareInterrupt_000023c8(void)\n\n{\n  triggerInterrupt(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000023c8": "execute_software_interrupt_000023c8",
                "software_interrupt": "triggerInterrupt"
            },
            "calling": [
                "FUN_000023d0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023d0": {
            "entrypoint": "0x000023d0",
            "current_name": "execute_or_return_interrupt_000023d0",
            "code": "\nundefined4 execute_or_return_interrupt_000023d0(undefined4 input_value)\n\n{\n  undefined4 output_value;\n  \n  if (DAT_1fff0d98 == 0) {\n    output_value = execute_software_interrupt_000023c8(1,input_value,0);\n  }\n  else {\n    output_value = 0;\n  }\n  return output_value;\n}\n\n",
            "renaming": {
                "FUN_000023d0": "execute_or_return_interrupt_000023d0",
                "param_1": "input_value",
                "uVar1": "output_value"
            },
            "calling": [
                "FUN_000023a4"
            ],
            "called": [
                "FUN_000023c8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002400": {
            "entrypoint": "0x00002400",
            "current_name": "FUNC_00002400",
            "code": "\nvoid FUNC_00002400(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002400": "FUNC_00002400"
            },
            "calling": [
                "FUN_00000f04"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0000240c": {
            "entrypoint": "0x0000240c",
            "current_name": "extract_and_assign_next_value_0000240c",
            "code": "\nundefined4 * extractAndAssignNextValue_0000240c(undefined4 *inputPointer)\n\n{\n  undefined4 *nextValuePointer;\n  \n  nextValuePointer = (undefined4 *)*inputPointer;\n  if (nextValuePointer != (undefined4 *)0x0) {\n    *inputPointer = *nextValuePointer;\n  }\n  return nextValuePointer;\n}\n\n",
            "renaming": {
                "FUN_0000240c": "extract_and_assign_next_value_0000240c",
                "param_1": "inputPointer",
                "puVar1": "nextValuePointer"
            },
            "calling": [
                "FUN_000024bc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002434": {
            "entrypoint": "0x00002434",
            "current_name": "handle_interrupt_00002434",
            "code": "\nundefined4 handleInterrupt_00002434(int *interruptStatus,int flag)\n\n{\n  int savedValue;\n  undefined4 interruptEnabled;\n  \n  interruptEnabled = check_irq_interrupts_enabled_00000cd0();\n  savedValue = DAT_1fff03dc;\n  if (*interruptStatus == 0) {\n    *interruptStatus = -1;\n    configureInterrupts(interruptEnabled);\n    interruptEnabled = 1;\n  }\n  else if (flag == 0) {\n    configureInterrupts(interruptEnabled);\n    interruptEnabled = 0;\n  }\n  else {\n    updatePointerAndValue(DAT_1fff03dc,2);\n    if (*interruptStatus == -1) {\n      *interruptStatus = savedValue + 8;\n      *(undefined4 *)*interruptStatus = 0;\n    }\n    else {\n      findMatchingEntry(interruptStatus,savedValue);\n    }\n    configureInterrupts(interruptEnabled);\n    setBit();\n    interruptEnabled = 1;\n  }\n  return interruptEnabled;\n}\n\n",
            "renaming": {
                "FUN_00002434": "handle_interrupt_00002434",
                "param_1": "interruptStatus",
                "param_2": "flag",
                "iVar1": "savedValue",
                "uVar2": "interruptEnabled",
                "configure_ir_qinterrupts_00000d0c": "configureInterrupts",
                "update_pointer_and_value_00000698": "updatePointerAndValue",
                "find_matching_entry_00001034": "findMatchingEntry",
                "set_e000ed04_bit_0000093c": "setBit"
            },
            "calling": [
                "FUN_0000129c"
            ],
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_00001034",
                "FUN_0000093c",
                "FUN_00000698"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000024bc": {
            "entrypoint": "0x000024bc",
            "current_name": "handle_irq_interrupts_000024bc",
            "code": "\nvoid handleIRQInterrupts_000024bc(int *irqStatus)\n\n{\n  undefined interruptFlag;\n  undefined4 irqEnabled;\n  int value;\n  \n  irqEnabled = checkIRQInterruptsEnabled();\n  if (*irqStatus == 0) {\n    configureIRQInterrupts(irqEnabled);\n  }\n  else if (*irqStatus == -1) {\n    *irqStatus = 0;\n    configureIRQInterrupts(irqEnabled);\n  }\n  else {\n    value = extractAndAssignNextValue(irqStatus);\n    updatePointerAndValue(value + -8,10);\n    if (*irqStatus == 0) {\n      *irqStatus = -1;\n    }\n    interruptFlag = *(undefined *)(value + -3);\n    configureIRQInterrupts(irqEnabled);\n    checkExceptionAndSetFlag(interruptFlag);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000024bc": "handle_irq_interrupts_000024bc",
                "param_1": "irqStatus",
                "uVar1": "interruptFlag",
                "uVar2": "irqEnabled",
                "iVar3": "value",
                "configure_ir_qinterrupts_00000d0c": "configureIRQInterrupts",
                "check_irq_interrupts_enabled_00000cd0": "checkIRQInterruptsEnabled",
                "extract_and_assign_next_value_0000240c": "extractAndAssignNextValue",
                "update_pointer_and_value_00000698": "updatePointerAndValue",
                "check_exception_and_set_flag_00000738": "checkExceptionAndSetFlag"
            },
            "calling": [
                "FUN_000012b4"
            ],
            "called": [
                "FUN_00000d0c",
                "FUN_00000738",
                "FUN_00000cd0",
                "FUN_0000240c",
                "FUN_00000698"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002538": {
            "entrypoint": "0x00002538",
            "current_name": "update_data_00002538",
            "code": "\nvoid updateData_00002538(byte dataIndex,uint value)\n\n{\n  if ((char)dataIndex < '\\0') {\n    (&DAT_e000ed14)[dataIndex & 0xf] = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)dataIndex + -0x1fff1c00) = (char)((value & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002538": "update_data_00002538",
                "param_1": "dataIndex",
                "param_2": "value"
            },
            "calling": [
                "FUN_0000258c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000258c": {
            "entrypoint": "0x0000258c",
            "current_name": "initialize_data_0000258c",
            "code": "\n\n\nvoid initializeData_0000258c(void)\n\n{\n  uint counter;\n  \n  _DAT_e000ed08 = 0;\n  updateData(0xfffffffe,1);\n  updateData(0xfffffffb,1);\n  for (counter = 0; counter < 0x66; counter = counter + 1) {\n    updateData((int)(char)counter,1);\n  }\n  _DAT_e000ed10 = _DAT_e000ed10 | 0x10;\n  _DAT_e000ed14 = _DAT_e000ed14 | 0x200;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000258c": "initialize_data_0000258c",
                "local_c": "counter",
                "update_data_00002538": "updateData"
            },
            "calling": [
                "FUN_00001274"
            ],
            "called": [
                "FUN_00002538"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000025f4": {
            "entrypoint": "0x000025f4",
            "current_name": "initialize_system_000025f4",
            "code": "\nvoid initialize_system_000025f4(void)\n\n{\n  initialize_system_000025f4_000027b0();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000025f4": "initialize_system_000025f4"
            },
            "calling": [
                "FUN_00002396"
            ],
            "called": [
                "FUN_000027b0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002600": {
            "entrypoint": "0x00002600",
            "current_name": "update_system_flags_00002600",
            "code": "\nundefined4 updateSystemFlags_00002600(undefined4 inputDate)\n\n{\n  undefined4 updatedDate;\n  \n  updatedDate = calculate_updated_date_000047e4(inputDate);\n  set_system_flags_0000285c(updatedDate);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002600": "update_system_flags_00002600",
                "param_1": "inputDate",
                "uVar1": "updatedDate"
            },
            "calling": [
                "FUN_00003478"
            ],
            "called": [
                "FUN_0000285c",
                "FUN_000047e4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002624": {
            "entrypoint": "0x00002624",
            "current_name": "process_data_00002624",
            "code": "\nundefined4 processData_00002624(undefined4 inputData)\n\n{\n  undefined4 baseAddress;\n  undefined4 someValue;\n  \n  baseAddress = get_base_address_0000281c();\n  someValue = 0;\n  calculate_date_time_0000443c(&baseAddress,inputData);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002624": "process_data_00002624",
                "param_1": "inputData",
                "local_10": "baseAddress",
                "uStack_c": "someValue"
            },
            "calling": [
                "FUN_00003444"
            ],
            "called": [
                "FUN_0000443c",
                "FUN_0000281c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002654": {
            "entrypoint": "0x00002654",
            "current_name": "update_data_00002654",
            "code": "\nundefined4 updateData_00002654(undefined4 inputParam,undefined4 dataParam,undefined4 configParam)\n\n{\n  undefined4 updatedDate;\n  \n  updatedDate = calculate_updated_date_000047e4(inputParam);\n  DAT_1fff0d9c = dataParam;\n  initialize_data_00002894(updatedDate,0x26f1,configParam);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002654": "update_data_00002654",
                "param_1": "inputParam",
                "param_2": "dataParam",
                "param_3": "configParam",
                "uVar1": "updatedDate"
            },
            "calling": [
                "FUN_000033f4"
            ],
            "called": [
                "FUN_000047e4",
                "FUN_00002894"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002690": {
            "entrypoint": "0x00002690",
            "current_name": "initialize_and_calculate_date_time_00002690",
            "code": "\nundefined4 initialize_and_calculate_date_time_00002690(undefined4 input_param)\n\n{\n  undefined4 data_pointer;\n  undefined4 stack_variable;\n  \n  data_pointer = increment_data_pointer_000028f0();\n  stack_variable = 0;\n  calculate_date_time_0000443c(&data_pointer,input_param);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002690": "initialize_and_calculate_date_time_00002690",
                "param_1": "input_param",
                "local_10": "data_pointer",
                "uStack_c": "stack_variable"
            },
            "calling": [
                "FUN_000033c0"
            ],
            "called": [
                "FUN_0000443c",
                "FUN_000028f0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026c0": {
            "entrypoint": "0x000026c0",
            "current_name": "initialize_configurations_000026c0",
            "code": "\nvoid initialize_configurations_000026c0(void)\n\n{\n  clear_configuration_00002910();\n  DAT_1fff0d9c = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026c0": "initialize_configurations_000026c0"
            },
            "calling": [
                "FUN_00003524"
            ],
            "called": [
                "FUN_00002910"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026d8": {
            "entrypoint": "0x000026d8",
            "current_name": "initialize_flag_000026d8",
            "code": "\nvoid initialize_flag_000026d8(void)\n\n{\n  set_flag();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026d8": "initialize_flag_000026d8",
                "set_flag_0000294c": "set_flag"
            },
            "calling": [
                "FUN_00003524"
            ],
            "called": [
                "FUN_0000294c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026e4": {
            "entrypoint": "0x000026e4",
            "current_name": "initialize_hardware_000026e4",
            "code": "\nvoid initialize_hardware_000026e4(void)\n\n{\n  clear_hardware_flag();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026e4": "initialize_hardware_000026e4",
                "clear_hardware_flag_00002970": "clear_hardware_flag"
            },
            "calling": [
                "FUN_00003524"
            ],
            "called": [
                "FUN_00002970"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026f0": {
            "entrypoint": "0x000026f0",
            "current_name": "execute_callback_function_000026f0",
            "code": "\nvoid executeCallbackFunction_000026f0(undefined4 inputParameter)\n\n{\n  if (DAT_1fff0d9c != (code *)0x0) {\n    (*DAT_1fff0d9c)(inputParameter);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026f0": "execute_callback_function_000026f0",
                "param_1": "inputParameter"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002714": {
            "entrypoint": "0x00002714",
            "current_name": "set_bit_at_offset_00002714",
            "code": "\nvoid setBitAtOffset_00002714(byte inputByte)\n\n{\n  *(int *)(((uint)(int)(char)inputByte >> 5) * 4 + -0x1fff1f00) = 1 << (inputByte & 0x1f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002714": "set_bit_at_offset_00002714",
                "param_1": "inputByte"
            },
            "calling": [
                "FUN_00002894"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002744": {
            "entrypoint": "0x00002744",
            "current_name": "store_byte_00002744",
            "code": "\nvoid storeByte_00002744(byte index,uint value)\n\n{\n  if ((char)index < '\\0') {\n    (&DAT_e000ed14)[index & 0xf] = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)index + -0x1fff1c00) = (char)((value & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002744": "store_byte_00002744",
                "param_1": "index",
                "param_2": "value"
            },
            "calling": [
                "FUN_00002894"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002798": {
            "entrypoint": "0x00002798",
            "current_name": "check_and_set_flag_00002798",
            "code": "\nvoid checkAndSetFlag_00002798(void)\n\n{\n  if (DAT_1fff0354 != 0) {\n    setFlagBit();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002798": "check_and_set_flag_00002798",
                "set_e000ed04_bit_0000093c": "setFlagBit"
            },
            "calling": [
                "FUN_00002994"
            ],
            "called": [
                "FUN_0000093c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000027b0": {
            "entrypoint": "0x000027b0",
            "current_name": "initialize_system_000027b0",
            "code": "\n\n\nvoid initializeSystem_000027b0(void)\n\n{\n  _DAT_4004803c = _DAT_4004803c | 0x20000000;\n  if ((_DAT_4003d014 & 1) != 0) {\n    _DAT_4003d000 = 0;\n  }\n  _DAT_4003d010 = 0x104;\n  _DAT_4003d008 = 0xffffff42;\n  _DAT_4003d01c = 0;\n  set_flag_0000294c();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000027b0": "initialize_system_000027b0"
            },
            "calling": [
                "FUN_000025f4"
            ],
            "called": [
                "FUN_0000294c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000281c": {
            "entrypoint": "0x0000281c",
            "current_name": "get_base_address_0000281c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00002840) */\n/* WARNING: Removing unreachable block (ram,0x0000284c) */\n\n\nundefined4 getBaseAddress_0000281c(void)\n\n{\n  return _DAT_4003d000;\n}\n\n",
            "renaming": {
                "FUN_0000281c": "get_base_address_0000281c"
            },
            "calling": [
                "FUN_00002624"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000285c": {
            "entrypoint": "0x0000285c",
            "current_name": "set_system_flags_0000285c",
            "code": "\n\n\nvoid setSystemFlags_0000285c(undefined4 value)\n\n{\n  _DAT_4003d000 = value;\n  _DAT_4003d014 = _DAT_4003d014 & 0xffffffef | 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000285c": "set_system_flags_0000285c",
                "param_1": "value"
            },
            "calling": [
                "FUN_00002600"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002894": {
            "entrypoint": "0x00002894",
            "current_name": "initialize_data_00002894",
            "code": "\n\n\nvoid initializeData_00002894(int dataSize,undefined4 value1,undefined4 value2)\n\n{\n  _DAT_4003d008 = dataSize + -1;\n  _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb | 4;\n  DAT_1fff0da0 = value1;\n  DAT_1fff0da4 = value2;\n  store_byte_00002744(0x2e,10);\n  set_bit_at_offset_00002714(0x2e);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002894": "initialize_data_00002894",
                "param_1": "dataSize",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "FUN_00002654"
            ],
            "called": [
                "FUN_00002714",
                "FUN_00002744"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000028f0": {
            "entrypoint": "0x000028f0",
            "current_name": "increment_data_pointer_000028f0",
            "code": "\n\n\nint incrementDataPointer_000028f0(void)\n\n{\n  return _DAT_4003d008 + 1;\n}\n\n",
            "renaming": {
                "FUN_000028f0": "increment_data_pointer_000028f0"
            },
            "calling": [
                "FUN_00002690"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002910": {
            "entrypoint": "0x00002910",
            "current_name": "clear_configuration_00002910",
            "code": "\n\n\nvoid clearConfiguration_00002910(void)\n\n{\n  _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb;\n  _DAT_4003d008 = 0;\n  DAT_1fff0da0 = 0;\n  DAT_1fff0da4 = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002910": "clear_configuration_00002910"
            },
            "calling": [
                "FUN_000026c0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000294c": {
            "entrypoint": "0x0000294c",
            "current_name": "set_flag_0000294c",
            "code": "\n\n\nvoid setFlag_0000294c(void)\n\n{\n  _DAT_4003d014 = _DAT_4003d014 | 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000294c": "set_flag_0000294c"
            },
            "calling": [
                "FUN_000026d8",
                "FUN_000027b0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002970": {
            "entrypoint": "0x00002970",
            "current_name": "clear_hardware_flag_00002970",
            "code": "\n\n\nvoid clearHardwareFlag_00002970(void)\n\n{\n  _DAT_4003d014 = _DAT_4003d014 & 0xffffffef;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002970": "clear_hardware_flag_00002970"
            },
            "calling": [
                "FUN_000026e4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002994": {
            "entrypoint": "0x00002994",
            "current_name": "perform_actions_00002994",
            "code": "\n\n\nvoid perform_actions_00002994(void)\n\n{\n  if (((_DAT_4003d014 & 4) != 0) && (DAT_1fff0da0 != (code *)0x0)) {\n    _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb;\n    (*DAT_1fff0da0)(DAT_1fff0da4);\n  }\n  if (((_DAT_4003d014 & 2) != 0) && (DAT_1fff0da8 != (code *)0x0)) {\n    (*DAT_1fff0da8)(DAT_1fff0dac);\n  }\n  check_and_set_flag_00002798();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002994": "perform_actions_00002994"
            },
            "calling": [],
            "called": [
                "FUN_00002798"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a00": {
            "entrypoint": "0x00002a00",
            "current_name": "process_data_00002a00",
            "code": "\nvoid processData_00002a00(undefined4 param)\n\n{\n  processData_00002a00Helper(param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002a00": "process_data_00002a00",
                "param_1": "param",
                "process_data_00004cb4": "processDataHelper"
            },
            "calling": [
                "FUN_00002d94",
                "FUN_00002e48"
            ],
            "called": [
                "FUN_00004cb4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a18": {
            "entrypoint": "0x00002a18",
            "current_name": "find_match_00002a18",
            "code": "\nint findMatch_00002a18(int *arrayOfArrays,undefined4 targetArray)\n\n{\n  int iVar1;\n  int *currentArray;\n  undefined **rebootPtr;\n  uint arrayIndex;\n  int *currentValue;\n  \n  currentArray = arrayOfArrays;\n  rebootPtr = &PTR_s_reboot_00007300;\n  arrayIndex = 0;\n  do {\n    if (1 < arrayIndex) {\n      return 0;\n    }\n    currentValue = (&currentArray)[arrayIndex];\n    if (currentValue != (int *)0x0) {\n      for (; *currentValue != 0; currentValue = currentValue + 3) {\n        iVar1 = compare_byte_arrays_00004e52(*currentValue,targetArray);\n        if (iVar1 == 0) {\n          return currentValue[2];\n        }\n      }\n    }\n    arrayIndex = arrayIndex + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00002a18": "find_match_00002a18",
                "param_1": "arrayOfArrays",
                "param_2": "targetArray",
                "local_18": "currentArray",
                "local_14": "rebootPtr",
                "local_10": "arrayIndex",
                "local_c": "currentValue"
            },
            "calling": [
                "FUN_00002b10"
            ],
            "called": [
                "FUN_00004e52"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a88": {
            "entrypoint": "0x00002a88",
            "current_name": "print_command_descriptions_00002a88",
            "code": "\nvoid printCommandDescriptions_00002a88(int *commandList)\n\n{\n  int *currentCommand;\n  undefined **commandNames;\n  uint index;\n  int *currentCommandInfo;\n  \n  initialize_and_process_data_00004c84(\"%-20s %s\\n\",\"Command\",\"Description\");\n  process_data_00004db8(\"---------------------------------------\");\n  currentCommand = commandList;\n  commandNames = &PTR_s_reboot_00007300;\n  for (index = 0; index < 2; index = index + 1) {\n    currentCommandInfo = (&currentCommand)[index];\n    if (currentCommandInfo != (int *)0x0) {\n      for (; *currentCommandInfo != 0; currentCommandInfo = currentCommandInfo + 3) {\n        initialize_and_process_data_00004c84(\"%-20s %s\\n\",*currentCommandInfo,currentCommandInfo[1]);\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002a88": "print_command_descriptions_00002a88",
                "param_1": "commandList",
                "local_18": "currentCommand",
                "local_14": "commandNames",
                "local_10": "index",
                "local_c": "currentCommandInfo"
            },
            "calling": [
                "FUN_00002b10"
            ],
            "called": [
                "FUN_00004db8",
                "FUN_00004c84"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002b10": {
            "entrypoint": "0x00002b10",
            "current_name": "process_shell_command_00002b10",
            "code": "\nvoid processShellCommand_00002b10(undefined4 commandSize,byte *command)\n\n{\n  int comparisonResult;\n  byte *nextCharPointer;\n  byte *commandPointerArray [3];\n  code *commandMatchFunction;\n  char **commandArray;\n  uint commandArraySize;\n  byte quoteSymbol;\n  char *escapeSeqPtr;\n  char *currentCommand;\n  char **commandPtrArray;\n  uint commandIndex;\n  int escapeSeqCount;\n  uint quoteCount;\n  byte *currentChar;\n  \n  quoteCount = 0;\n  escapeSeqCount = 0;\n  currentChar = command;\n  while( true ) {\n    commandPointerArray[0] = command;\n    commandPointerArray[1] = (byte *)commandSize;\n    if (0x20 < *currentChar) {\n      if ((*currentChar == 0x22) || (*currentChar == 0x27)) {\n        quoteSymbol = *currentChar;\n        do {\n          nextCharPointer = currentChar + 1;\n          if (*nextCharPointer == 0) {\n            currentChar = nextCharPointer;\n            process_data_00004db8(Elf32_Rel_ARRAY_1fff0200[9].r_info);\n            return;\n          }\n          if (*nextCharPointer == 0x5c) {\n            escapeSeqCount = escapeSeqCount + 1;\n            currentChar = currentChar + 2;\n            nextCharPointer = currentChar;\n            if (*currentChar == 0) {\n              process_data_00004db8(Elf32_Rel_ARRAY_1fff0200[9].r_info);\n              return;\n            }\n          }\n          currentChar = nextCharPointer;\n        } while (quoteSymbol != *currentChar);\n        if (0x20 < currentChar[1]) {\n          process_data_00004db8(Elf32_Rel_ARRAY_1fff0200[9].r_info);\n          return;\n        }\n      }\n      else {\n        do {\n          if (*currentChar == 0x5c) {\n            escapeSeqCount = escapeSeqCount + 1;\n            currentChar = currentChar + 1;\n            if (*currentChar == 0) {\n              process_data_00004db8(Elf32_Rel_ARRAY_1fff0200[9].r_info);\n              return;\n            }\n          }\n          currentChar = currentChar + 1;\n          if (*currentChar == 0x22) {\n            process_data_00004db8(Elf32_Rel_ARRAY_1fff0200[9].r_info);\n            return;\n          }\n        } while (0x20 < *currentChar);\n      }\n      quoteCount = quoteCount + 1;\n    }\n    if (*currentChar == 0) break;\n    *currentChar = 0;\n    currentChar = currentChar + 1;\n  }\n  if (quoteCount != 0) {\n    commandArraySize = quoteCount;\n    commandArray = (char **)((int)commandPointerArray - ((quoteCount + 1) * 4 + 7 & 0xfffffff8));\n    commandArray[quoteCount] = (char *)0x0;\n    currentChar = command;\n    for (commandIndex = 0; commandPtrArray = commandArray, commandIndex < quoteCount; commandIndex = commandIndex + 1) {\n      for (; *currentChar == 0; currentChar = currentChar + 1) {\n      }\n      if ((*currentChar == 0x22) || (*currentChar == 0x27)) {\n        currentChar = currentChar + 1;\n      }\n      commandArray[commandIndex] = (char *)currentChar;\n      for (; *currentChar != 0; currentChar = currentChar + 1) {\n      }\n    }\n    for (; (escapeSeqCount != 0 && (*commandPtrArray != (char *)0x0)); commandPtrArray = commandPtrArray + 1) {\n      for (currentCommand = *commandPtrArray; *currentCommand != '\\0'; currentCommand = currentCommand + 1) {\n        if (*currentCommand == '\\') {\n          for (escapeSeqPtr = currentCommand; *escapeSeqPtr != '\\0'; escapeSeqPtr = escapeSeqPtr + 1) {\n            *escapeSeqPtr = escapeSeqPtr[1];\n          }\n          escapeSeqCount = escapeSeqCount + -1;\n          if (escapeSeqCount == 0) break;\n        }\n      }\n    }\n    commandMatchFunction = (code *)find_match_00002a18(commandSize,*commandArray);\n    if (commandMatchFunction == (code *)0x0) {\n      comparisonResult = compare_byte_arrays_00004e52(&DAT_00007214,*commandArray);\n      if (comparisonResult == 0) {\n        print_command_descriptions_00002a88(commandPointerArray[1]);\n      }\n      else {\n        initialize_and_process_data_00004c84(\"shell: command not found: %s\\n\",*commandArray);\n      }\n    }\n    else {\n      (*commandMatchFunction)(quoteCount,commandArray);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002b10": "process_shell_command_00002b10",
                "param_1": "commandSize",
                "param_2": "command",
                "local_48": "commandPointerArray",
                "local_3c": "commandMatchFunction",
                "local_38": "commandArray",
                "local_34": "commandArraySize",
                "local_2d": "quoteSymbol",
                "local_2c": "escapeSeqPtr",
                "local_28": "currentCommand",
                "local_24": "commandPtrArray",
                "local_20": "commandIndex",
                "local_1c": "escapeSeqCount",
                "local_18": "quoteCount",
                "local_14": "currentChar",
                "pbVar2": "nextCharPointer",
                "iVar1": "comparisonResult"
            },
            "calling": [
                "FUN_00002e6c"
            ],
            "called": [
                "FUN_00004db8",
                "FUN_00002a18",
                "FUN_00004e52",
                "FUN_00004c84",
                "FUN_00002a88"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002d94": {
            "entrypoint": "0x00002d94",
            "current_name": "process_input_00002d94",
            "code": "\nuint process_input_00002d94(undefined *input_buffer,int buffer_length)\n\n{\n  int result;\n  byte byte_result;\n  bool is_input_buffer_first;\n  undefined *current_position;\n  \n  current_position = input_buffer;\n  while( true ) {\n    if (buffer_length + -1 <= (int)current_position - (int)input_buffer) {\n      return 0xffffffff;\n    }\n    result = execute_and_process_00004418();\n    if (result < 0) break;\n    if ((result == 0xd) || (result == 10)) {\n      *current_position = 0;\n      process_data_00002a00(0xd);\n      process_data_00002a00(10);\n      is_input_buffer_first = current_position == input_buffer;\n      if (is_input_buffer_first) {\n        input_buffer = (undefined *)0x1;\n      }\n      byte_result = (byte)input_buffer;\n      if (!is_input_buffer_first) {\n        byte_result = 0;\n      }\n      return (uint)byte_result;\n    }\n    if ((result == 8) || (result == 0x7f)) {\n      if (current_position != input_buffer) {\n        current_position = current_position + -1;\n        *current_position = 0;\n        process_data_00002a00(8);\n        process_data_00002a00(0x20);\n        process_data_00002a00(8);\n      }\n    }\n    else {\n      *current_position = (char)result;\n      process_data_00002a00(result);\n      current_position = current_position + 1;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00002d94": "process_input_00002d94",
                "param_1": "input_buffer",
                "param_2": "buffer_length",
                "iVar1": "result",
                "bVar2": "byte_result",
                "bVar3": "is_input_buffer_first",
                "local_c": "current_position"
            },
            "calling": [
                "FUN_00002e6c"
            ],
            "called": [
                "FUN_00004418",
                "FUN_00002a00"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e48": {
            "entrypoint": "0x00002e48",
            "current_name": "initialize_data_processing_00002e48",
            "code": "\nvoid initializeDataProcessing_00002e48(void)\n\n{\n  processData(0x3e);\n  processData(0x20);\n  processRelArray(*(undefined4 *)(rOffsetArray[16].r_offset + 8));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002e48": "initialize_data_processing_00002e48",
                "Elf32_Rel_ARRAY_1fff0200": "rOffsetArray",
                "process_data_00002a00": "processData",
                "process_rel_array_000041d0": "processRelArray"
            },
            "calling": [
                "FUN_00002e6c"
            ],
            "called": [
                "FUN_000041d0",
                "FUN_00002a00"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e6c": {
            "entrypoint": "0x00002e6c",
            "current_name": "process_input_loop_00002e6c",
            "code": "\nvoid process_input_loop_00002e6c(undefined4 ptr_arg_1,undefined4 ptr_arg_2,undefined4 ptr_arg_3)\n\n{\n  int result;\n  \n  initialize_data_processing();\n  do {\n    result = process_input(ptr_arg_2,ptr_arg_3);\n    if (result == 0) {\n      process_shell_command(ptr_arg_1,ptr_arg_2);\n    }\n    initialize_data_processing();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00002e6c": "process_input_loop_00002e6c",
                "param_1": "ptr_arg_1",
                "param_2": "ptr_arg_2",
                "param_3": "ptr_arg_3",
                "iVar1": "result",
                "initialize_data_processing_00002e48": "initialize_data_processing",
                "process_input_00002d94": "process_input",
                "process_shell_command_00002b10": "process_shell_command"
            },
            "calling": [
                "FUN_000023a4"
            ],
            "called": [
                "FUN_00002d94",
                "FUN_00002b10",
                "FUN_00002e48"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e9c": {
            "entrypoint": "0x00002e9c",
            "current_name": "initialize_data_synchronization_00002e9c",
            "code": "\nundefined4 initializeDataSynchronization_00002e9c(void)\n\n{\n  initialize_data_synchronization_00003688();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002e9c": "initialize_data_synchronization_00002e9c"
            },
            "calling": [],
            "called": [
                "FUN_00003688"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002eb4": {
            "entrypoint": "0x00002eb4",
            "current_name": "print_stack_information_00002eb4",
            "code": "\nundefined4 print_stack_information_00002eb4(void)\n\n{\n  print_stack_info_0000211c();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002eb4": "print_stack_information_00002eb4"
            },
            "calling": [],
            "called": [
                "FUN_0000211c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002ecc": {
            "entrypoint": "0x00002ecc",
            "current_name": "read_from_device_00002ecc",
            "code": "\nvoid readFromDevice_00002ecc(undefined4 deviceIndex,int deviceDataPointer)\n\n{\n  undefined4 deviceType;\n  undefined4 deviceName;\n  undefined deviceBuffer [8];\n  uint bufferSize;\n  \n  bufferSize = process_function_result_00003d64(deviceDataPointer,deviceBuffer);\n  if ((int)bufferSize < 1) {\n    initialize_and_process_data_00004c84(\"error: failed to read from device #%i\\n\",deviceIndex);\n  }\n  else {\n    deviceName = *(undefined4 *)(deviceDataPointer + 8);\n    deviceType = classify_device_type_000039e8(*(undefined *)(*(int *)(deviceDataPointer + 0xc) + 8));\n    initialize_and_process_data_00004c84(\"Reading from #%i (%s|%s)\\n\",deviceIndex,deviceName,deviceType);\n    display_data_object_00003694(deviceBuffer,bufferSize & 0xff);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002ecc": "read_from_device_00002ecc",
                "param_1": "deviceIndex",
                "param_2": "deviceDataPointer",
                "uVar1": "deviceType",
                "uVar2": "deviceName",
                "auStack_1c": "deviceBuffer",
                "local_14": "bufferSize"
            },
            "calling": [
                "FUN_00002fe0",
                "FUN_00002f30"
            ],
            "called": [
                "FUN_000039e8",
                "FUN_00003694",
                "FUN_00003d64",
                "FUN_00004c84"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002f30": {
            "entrypoint": "0x00002f30",
            "current_name": "process_device_data_00002f30",
            "code": "\nvoid process_device_data_00002f30(void)\n\n{\n  int index;\n  undefined4 *current_ptr;\n  \n  index = 0;\n  for (current_ptr = DAT_1fff0db0; current_ptr != (undefined4 *)0x0; current_ptr = (undefined4 *)*current_ptr) {\n    read_from_device_00002ecc(index,current_ptr);\n    process_data_00004db8(&DAT_00007380);\n    index = index + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002f30": "process_device_data_00002f30",
                "local_10": "index",
                "local_c": "current_ptr"
            },
            "calling": [
                "FUN_00002fe0"
            ],
            "called": [
                "FUN_00004db8",
                "FUN_00002ecc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002f74": {
            "entrypoint": "0x00002f74",
            "current_name": "list_devices_00002f74",
            "code": "\nvoid listDevices_00002f74(void)\n\n{\n  undefined4 deviceType;\n  int deviceCount;\n  undefined4 *deviceList;\n  \n  deviceList = DAT_1fff0db0;\n  deviceCount = 0;\n  if (DAT_1fff0db0 == (undefined4 *)0x0) {\n    printOutput(\"No devices found\");\n  }\n  else {\n    printOutput(\"ID\\tClass\\t\\tName\");\n  }\n  for (; deviceList != (undefined4 *)0x0; deviceList = (undefined4 *)*deviceList) {\n    deviceType = classifyDeviceType(*(undefined *)(deviceList[3] + 8));\n    initializeAndProcessData(\"#%i\\t%s\\t%s\\n\",deviceCount,deviceType,deviceList[2]);\n    deviceCount = deviceCount + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002f74": "list_devices_00002f74",
                "local_18": "deviceCount",
                "local_14": "deviceList",
                "uVar1": "deviceType",
                "process_data_00004db8": "printOutput",
                "classify_device_type_000039e8": "classifyDeviceType",
                "initialize_and_process_data_00004c84": "initializeAndProcessData"
            },
            "calling": [
                "FUN_0000316c"
            ],
            "called": [
                "FUN_00004db8",
                "FUN_000039e8",
                "FUN_00004c84"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002fe0": {
            "entrypoint": "0x00002fe0",
            "current_name": "process_device_data_00002fe0",
            "code": "\nvoid processDeviceData_00002fe0(int argumentCount,undefined4 *arguments)\n\n{\n  int comparisonResult;\n  undefined4 deviceID;\n  \n  if (argumentCount < 3) {\n    printUsage(\"usage: %s %s <device id>|all\\n\",*arguments,arguments[1]);\n  }\n  else {\n    comparisonResult = compareByteArrays(arguments[2],&DAT_000073d4);\n    if (comparisonResult == 0) {\n      processAllDevices();\n    }\n    else {\n      deviceID = convertStringToNumber(arguments[2]);\n      comparisonResult = findDeviceIndex(deviceID);\n      if (comparisonResult == 0) {\n        processError(\"error: undefined device id given\");\n      }\n      else {\n        readFromDevice(deviceID,comparisonResult);\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002fe0": "process_device_data_00002fe0",
                "param_1": "argumentCount",
                "param_2": "arguments",
                "iVar1": "comparisonResult",
                "uVar2": "deviceID",
                "initialize_and_process_data_00004c84": "printUsage",
                "compare_byte_arrays_00004e52": "compareByteArrays",
                "process_device_data_00002f30": "processAllDevices",
                "convert_string_to_number_00004042": "convertStringToNumber",
                "find_element_00003d24": "findDeviceIndex",
                "process_data_00004db8": "processError",
                "read_from_device_00002ecc": "readFromDevice"
            },
            "calling": [
                "FUN_0000316c"
            ],
            "called": [
                "FUN_00004db8",
                "FUN_00004e52",
                "FUN_00003d24",
                "FUN_00002ecc",
                "FUN_00002f30",
                "FUN_00004c84",
                "FUN_00004042"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000305c": {
            "entrypoint": "0x0000305c",
            "current_name": "write_to_device_0000305c",
            "code": "\nvoid writeToDevice_0000305c(int argc,undefined4 *argv)\n\n{\n  undefined2 numValue;\n  undefined2 values [4];\n  uint numValues;\n  int deviceIndex;\n  undefined4 deviceId;\n  int i;\n  \n  if (argc < 4) {\n    initialize_and_process_data_00004c84(\"usage: %s %s <device id> <value 0> [<value 1> [<value 2]]\\n\",*argv,argv[1]);\n  }\n  else {\n    deviceId = convert_string_to_number_00004042(argv[2]);\n    deviceIndex = find_element_00003d24(deviceId);\n    if (deviceIndex == 0) {\n      process_data_00004db8(\"error: undefined device given\");\n    }\n    else {\n      fill_array_with_value_00004622(values,0,8);\n      if (5 < argc) {\n        argc = 6;\n      }\n      numValues = argc - 3;\n      for (i = 0; i < (int)numValues; i = i + 1) {\n        numValue = convert_string_to_number_00004042(argv[i + 3]);\n        values[i] = numValue;\n      }\n      initialize_and_process_data_00004c84(\"Writing to device #%i - %s\\n\",deviceId,*(undefined4 *)(deviceIndex + 8));\n      display_data_object_00003694(values,numValues & 0xff);\n      numValues = execute_function_00003d94(deviceIndex,values);\n      if ((int)numValues < 1) {\n        if (numValues == -0x86) {\n          initialize_and_process_data_00004c84(\"error: device #%i is not writable\\n\",deviceId);\n        }\n        else {\n          initialize_and_process_data_00004c84(\"error: failure to write to device #%i\\n\",deviceId);\n        }\n      }\n      else {\n        initialize_and_process_data_00004c84(\"data successfully written to device #%i\\n\",deviceId);\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000305c": "write_to_device_0000305c",
                "param_1": "argc",
                "param_2": "argv",
                "uVar1": "numValue",
                "auStack_20": "values",
                "local_18": "numValues",
                "local_14": "deviceIndex",
                "local_10": "deviceId",
                "local_c": "i"
            },
            "calling": [
                "FUN_0000316c"
            ],
            "called": [
                "FUN_00004db8",
                "FUN_00003694",
                "FUN_00003d94",
                "FUN_00003d24",
                "FUN_00004622",
                "FUN_00004c84",
                "FUN_00004042"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000316c": {
            "entrypoint": "0x0000316c",
            "current_name": "handle_device_operation_0000316c",
            "code": "\nundefined4 handle_device_operation_0000316c(int device_id,undefined4 *arguments)\n\n{\n  int comparison_result;\n  \n  if (device_id < 2) {\n    list_devices_00002f74();\n  }\n  else {\n    comparison_result = compare_byte_arrays_00004e52(arguments[1],&DAT_000074ec);\n    if (comparison_result == 0) {\n      process_device_data_00002fe0(device_id,arguments);\n    }\n    else {\n      comparison_result = compare_byte_arrays_00004e52(arguments[1],\"write\");\n      if (comparison_result == 0) {\n        write_to_device_0000305c(device_id,arguments);\n      }\n      else {\n        initialize_and_process_data_00004c84(\"usage: %s read|write\\n\",*arguments);\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000316c": "handle_device_operation_0000316c",
                "param_1": "device_id",
                "param_2": "arguments",
                "iVar1": "comparison_result"
            },
            "calling": [],
            "called": [
                "FUN_00002f74",
                "FUN_00002fe0",
                "FUN_00004e52",
                "FUN_00004c84",
                "FUN_0000305c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000031e0": {
            "entrypoint": "0x000031e0",
            "current_name": "ring_alarm_000031e0",
            "code": "\nvoid ringAlarm_000031e0(void)\n\n{\n  process_data_00004db8(\"The alarm rang\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_000031e0": "ring_alarm_000031e0"
            },
            "calling": [],
            "called": [
                "FUN_00004db8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": [],
            "code_backup": "\nvoid FUN_000031e0(void)\n\n{\n  FUNC_00004db8(\"The alarm rang\");\n  return;\n}\n\n"
        },
        "FUN_000031fc": {
            "entrypoint": "0x000031fc",
            "current_name": "calculate_day_of_week_000031fc",
            "code": "\nint calculateDayOfWeek_000031fc(int year,int month,int day)\n\n{\n  byte isLeapYear;\n  int adjustedMonth;\n  \n  adjustedMonth = month;\n  if (month < 3) {\n    adjustedMonth = 1;\n  }\n  isLeapYear = (byte)adjustedMonth;\n  if (2 < month) {\n    isLeapYear = 0;\n  }\n  year = year - (uint)isLeapYear;\n  adjustedMonth = year;\n  if (year < 0) {\n    adjustedMonth = year + 3;\n  }\n  return ((((adjustedMonth >> 2) + year) - year / 100) + year / 400 +\n          *(int *)((int)weekday_offset + (month + -1) * 4 + 0x50) + day) % 7;\n}\n\n",
            "renaming": {
                "FUN_000031fc": "calculate_day_of_week_000031fc",
                "param_1": "year",
                "param_2": "month",
                "param_3": "day",
                "bVar1": "isLeapYear",
                "iVar2": "adjustedMonth",
                "Elf32_Rel_ARRAY_1fff0200": "weekday_offset"
            },
            "calling": [
                "FUN_0000328c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000328c": {
            "entrypoint": "0x0000328c",
            "current_name": "convert_string_to_numbers_and_calculate_day_of_week_0000328c",
            "code": "\nundefined4 convertStringToNumbersAndCalculateDayOfWeek_0000328c(undefined4 *inputStrings,int *outputArray)\n\n{\n  int iVar1;\n  int currentIndex;\n  short convertedValue;\n  \n  convertedValue = convert_string_to_number_00004f84(*inputStrings,&currentIndex,10);\n  outputArray[5] = convertedValue + -0x76c;\n  convertedValue = convert_string_to_number_00004f84(currentIndex + 1,&currentIndex,10);\n  outputArray[4] = convertedValue + -1;\n  convertedValue = convert_string_to_number_00004f84(currentIndex + 1,&currentIndex,10);\n  outputArray[3] = (int)convertedValue;\n  convertedValue = convert_string_to_number_00004f84(inputStrings[1],&currentIndex,10);\n  outputArray[2] = (int)convertedValue;\n  convertedValue = convert_string_to_number_00004f84(currentIndex + 1,&currentIndex,10);\n  outputArray[1] = (int)convertedValue;\n  convertedValue = convert_string_to_number_00004f84(currentIndex + 1,&currentIndex,10);\n  *outputArray = (int)convertedValue;\n  iVar1 = calculate_day_of_week_000031fc(outputArray[5] + 0x76c,outputArray[4] + 1,outputArray[3]);\n  outputArray[6] = iVar1;\n  outputArray[8] = -1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000328c": "convert_string_to_numbers_and_calculate_day_of_week_0000328c",
                "param_1": "inputStrings",
                "param_2": "outputArray",
                "local_10": "currentIndex",
                "local_a": "convertedValue"
            },
            "calling": [
                "FUN_000033f4",
                "FUN_00003478"
            ],
            "called": [
                "FUN_000031fc",
                "FUN_00004f84"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003378": {
            "entrypoint": "0x00003378",
            "current_name": "print_date_time_00003378",
            "code": "\nundefined4 printDateTime_00003378(undefined4 *dateTime)\n\n{\n  initialize_and_process_data_00004c84(\"%04i-%02i-%02i %02i:%02i:%02i\\n\",dateTime[5] + 0x76c,dateTime[4] + 1,dateTime[3],\n               dateTime[2],dateTime[1],*dateTime);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00003378": "print_date_time_00003378",
                "param_1": "dateTime"
            },
            "calling": [
                "FUN_00003444",
                "FUN_000033c0"
            ],
            "called": [
                "FUN_00004c84"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": [],
            "code_backup": "\nundefined4 FUN_00003378(undefined4 *param_1)\n\n{\n  FUNC_00004c84(\"%04i-%02i-%02i %02i:%02i:%02i\\n\",param_1[5] + 0x76c,param_1[4] + 1,param_1[3],\n               param_1[2],param_1[1],*param_1);\n  return 0;\n}\n\n"
        },
        "FUN_000033c0": {
            "entrypoint": "0x000033c0",
            "current_name": "check_and_get_date_time_information_000033c0",
            "code": "\nbool checkAndGetDateTimeInformation_000033c0(void)\n\n{\n  int result;\n  undefined dateTimeInformation [36];\n  \n  result = initialize_and_calculate_date_time_00002690(dateTimeInformation);\n  if (result != 0) {\n    process_data_00004db8(\"rtc: error getting alarm\");\n  }\n  else {\n    print_date_time_00003378(dateTimeInformation);\n  }\n  return result != 0;\n}\n\n",
            "renaming": {
                "FUN_000033c0": "check_and_get_date_time_information_000033c0",
                "auStack_2c": "dateTimeInformation",
                "iVar1": "result"
            },
            "calling": [
                "FUN_00003524"
            ],
            "called": [
                "FUN_00004db8",
                "FUN_00002690",
                "FUN_00003378"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000033f4": {
            "entrypoint": "0x000033f4",
            "current_name": "calculate_day_of_week_000033f4",
            "code": "\nundefined4 calculateDayOfWeek_000033f4(undefined4 inputString)\n\n{\n  int conversionResult;\n  undefined4 returnValue;\n  undefined convertedNumbers [36];\n  \n  conversionResult = convert_string_to_numbers_and_calculate_day_of_week_0000328c(inputString,convertedNumbers);\n  if (conversionResult == 0) {\n    conversionResult = updateData(convertedNumbers,0x31e1,0);\n    if (conversionResult == -1) {\n      process_data_00004db8(\"rtc: error setting alarm\");\n      returnValue = 1;\n    }\n    else {\n      returnValue = 0;\n    }\n  }\n  else {\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_000033f4": "calculate_day_of_week_000033f4",
                "param_1": "inputString",
                "iVar1": "conversionResult",
                "uVar2": "returnValue",
                "auStack_2c": "convertedNumbers",
                "update_data_00002654": "updateData"
            },
            "calling": [
                "FUN_00003524"
            ],
            "called": [
                "FUN_00004db8",
                "FUN_00002654",
                "FUN_0000328c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": [],
            "code_backup": "\nundefined4 FUN_000033f4(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = convert_string_to_numbers_and_calculate_day_of_week_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = update_data_00002654(auStack_2c,0x31e1,0);\n    if (iVar1 == -1) {\n      FUNC_00004db8(\"rtc: error setting alarm\");\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_00003444": {
            "entrypoint": "0x00003444",
            "current_name": "get_and_print_date_time_00003444",
            "code": "\nbool getAndPrintDateTime_00003444(void)\n\n{\n  int errorCode;\n  undefined dataBuffer [36];\n  \n  errorCode = process_data_00002624(dataBuffer);\n  if (errorCode != 0) {\n    process_data_00004db8(\"rtc: error getting time\");\n  }\n  else {\n    print_date_time_00003378(dataBuffer);\n  }\n  return errorCode != 0;\n}\n\n",
            "renaming": {
                "FUN_00003444": "get_and_print_date_time_00003444",
                "auStack_2c": "dataBuffer",
                "iVar1": "errorCode"
            },
            "calling": [
                "FUN_00003524"
            ],
            "called": [
                "FUN_00004db8",
                "FUN_00002624",
                "FUN_00003378"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003478": {
            "entrypoint": "0x00003478",
            "current_name": "calculate_day_of_week_00003478",
            "code": "\nundefined4 calculateDayOfWeek_00003478(undefined4 inputString)\n\n{\n  int conversionResult;\n  undefined4 returnValue;\n  undefined convertedString [36];\n  \n  conversionResult = convert_string_to_numbers_and_calculate_day_of_week_0000328c(inputString,convertedString);\n  if (conversionResult == 0) {\n    conversionResult = update_system_flags_00002600(convertedString);\n    if (conversionResult == -1) {\n      process_data_00004db8(\"rtc: error setting time\");\n      returnValue = 1;\n    }\n    else {\n      returnValue = 0;\n    }\n  }\n  else {\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00003478": "calculate_day_of_week_00003478",
                "param_1": "inputString",
                "iVar1": "conversionResult",
                "uVar2": "returnValue",
                "auStack_2c": "convertedString"
            },
            "calling": [
                "FUN_00003524"
            ],
            "called": [
                "FUN_00004db8",
                "FUN_00002600",
                "FUN_0000328c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": [],
            "code_backup": "\nundefined4 FUN_00003478(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = convert_string_to_numbers_and_calculate_day_of_week_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = update_system_flags_00002600(auStack_2c);\n    if (iVar1 == -1) {\n      FUNC_00004db8(\"rtc: error setting time\");\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_000034c0": {
            "entrypoint": "0x000034c0",
            "current_name": "print_usage_000034c0",
            "code": "\nundefined4 printUsage_000034c0(void)\n\n{\n  process_data_00004db8(\"usage: rtc <command> [arguments]\");\n  process_data_00004db8(\"commands:\");\n  process_data_00004db8(\"\\tpoweron\\t\\tpower the interface on\");\n  process_data_00004db8(\"\\tpoweroff\\tpower the interface off\");\n  process_data_00004db8(\"\\tclearalarm\\tdeactivate the current alarm\");\n  process_data_00004db8(\"\\tgetalarm\\tprint the currently alarm time\");\n  process_data_00004db8(\"\\tsetalarm YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset an alarm for the specified time\");\n  process_data_00004db8(\"\\tgettime\\t\\tprint the current time\");\n  process_data_00004db8(\"\\tsettime YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset the current time\");\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000034c0": "print_usage_000034c0"
            },
            "calling": [
                "FUN_00003524"
            ],
            "called": [
                "FUN_00004db8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": [],
            "code_backup": "\nundefined4 FUN_000034c0(void)\n\n{\n  FUNC_00004db8(\"usage: rtc <command> [arguments]\");\n  FUNC_00004db8(\"commands:\");\n  FUNC_00004db8(\"\\tpoweron\\t\\tpower the interface on\");\n  FUNC_00004db8(\"\\tpoweroff\\tpower the interface off\");\n  FUNC_00004db8(\"\\tclearalarm\\tdeactivate the current alarm\");\n  FUNC_00004db8(\"\\tgetalarm\\tprint the currently alarm time\");\n  FUNC_00004db8(\"\\tsetalarm YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset an alarm for the specified time\");\n  FUNC_00004db8(\"\\tgettime\\t\\tprint the current time\");\n  FUNC_00004db8(\"\\tsettime YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset the current time\");\n  return 0;\n}\n\n"
        },
        "FUN_00003524": {
            "entrypoint": "0x00003524",
            "current_name": "handle_command_00003524",
            "code": "\nundefined4 handleCommand_00003524(int numParams,int commandParams)\n\n{\n  int result;\n  undefined4 status;\n  \n  if (numParams < 2) {\n    print_usage_000034c0();\n    status = 1;\n  }\n  else {\n    result = compare_and_subtract_00004e66(*(undefined4 *)(commandParams + 4),\"poweron\",7);\n    if (result == 0) {\n      initialize_flag_000026d8();\n    }\n    else {\n      result = compare_and_subtract_00004e66(*(undefined4 *)(commandParams + 4),\"poweroff\",8);\n      if (result == 0) {\n        initialize_hardware_000026e4();\n      }\n      else {\n        result = compare_and_subtract_00004e66(*(undefined4 *)(commandParams + 4),\"clearalarm\",8);\n        if (result == 0) {\n          initialize_configurations_000026c0();\n        }\n        else {\n          result = compare_and_subtract_00004e66(*(undefined4 *)(commandParams + 4),\"getalarm\",8);\n          if (result == 0) {\n            check_and_get_date_time_information_000033c0();\n          }\n          else {\n            result = compare_and_subtract_00004e66(*(undefined4 *)(commandParams + 4),\"setalarm\",8);\n            if ((result == 0) && (numParams == 4)) {\n              calculate_day_of_week_000033f4(commandParams + 8);\n            }\n            else {\n              result = compare_and_subtract_00004e66(*(undefined4 *)(commandParams + 4),\"gettime\",7);\n              if (result == 0) {\n                get_and_print_date_time_00003444();\n              }\n              else {\n                result = compare_and_subtract_00004e66(*(undefined4 *)(commandParams + 4),\"settime\",7);\n                if ((result != 0) || (numParams != 4)) {\n                  initialize_and_process_data_00004c84(\"unknown command or missing parameters: %s\\n\\n\",\n                               *(undefined4 *)(commandParams + 4));\n                  print_usage_000034c0();\n                  return 1;\n                }\n                calculate_day_of_week_00003478(commandParams + 8);\n              }\n            }\n          }\n        }\n      }\n    }\n    status = 0;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_00003524": "handle_command_00003524",
                "param_1": "numParams",
                "param_2": "commandParams",
                "iVar1": "result",
                "uVar2": "status"
            },
            "calling": [],
            "called": [
                "FUN_000034c0",
                "FUN_000033f4",
                "FUN_00003478",
                "FUN_00003444",
                "FUN_00004e66",
                "FUN_00004c84",
                "FUN_000026d8",
                "FUN_000026e4",
                "FUN_000033c0",
                "FUN_000026c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003658": {
            "entrypoint": "0x00003658",
            "current_name": "wait_for_data_synchronization_00003658",
            "code": "\nvoid waitForDataSynchronization_00003658(void)\n\n{\n  syncBarrier(0xf);\n  syncBarrier(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00003658": "wait_for_data_synchronization_00003658",
                "DataSynchronizationBarrier": "syncBarrier"
            },
            "calling": [
                "FUN_00003688"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003688": {
            "entrypoint": "0x00003688",
            "current_name": "initialize_data_synchronization_00003688",
            "code": "\nvoid initializeDataSynchronization_00003688(void)\n\n{\n  waitForDataSynchronization();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00003688": "initialize_data_synchronization_00003688",
                "wait_for_data_synchronization_00003658": "waitForDataSynchronization"
            },
            "calling": [
                "FUN_00002e9c"
            ],
            "called": [
                "FUN_00003658"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003694": {
            "entrypoint": "0x00003694",
            "current_name": "display_data_object_00003694",
            "code": "\nvoid displayDataObject_00003694(int dataObjectPointer,byte dataSize)\n\n{\n  undefined4 address;\n  char bitValue;\n  uint bitMask;\n  bool bitSet;\n  undefined numberText [8];\n  int textLength;\n  char character;\n  byte index;\n  \n  if ((dataObjectPointer == 0) || (3 < dataSize)) {\n    process_data_00004db8(\"Unable to display data object\");\n  }\n  else {\n    initialize_and_process_data_00004c84(\"Data:\");\n    for (index = 0; index < dataSize; index = index + 1) {\n      if (*(byte *)(dataObjectPointer + 6) < 0x14) {\n        bitMask = 1 << (uint)*(byte *)(dataObjectPointer + 6) & 0x8018f;\n        bitSet = bitMask != 0;\n        if (bitSet) {\n          bitMask = 1;\n        }\n        bitValue = (char)bitMask;\n        if (!bitSet) {\n          bitValue = '\\0';\n        }\n        if (bitValue == '\\0') goto LAB_000036ee;\n        character = '\\0';\n      }\n      else {\nLAB_000036ee:\n        character = get_value_from_param_00003918((int)*(char *)(dataObjectPointer + 7));\n      }\n      initialize_and_process_data_00004c84(&DAT_000077bc);\n      if (dataSize < 2) {\n        initialize_and_process_data_00004c84(\"     \");\n      }\n      else {\n        initialize_and_process_data_00004c84(\"[%u] \",index);\n      }\n      if (character == '\\0') {\n        if (*(char *)(dataObjectPointer + 7) == '\\0') {\n          initialize_and_process_data_00004c84(&DAT_000077d8,(int)*(short *)(dataObjectPointer + (uint)index * 2));\n        }\n        else if ((*(char *)(dataObjectPointer + 7) + 4 < 0 == SCARRY4((int)*(char *)(dataObjectPointer + 7),4)) &&\n                (*(char *)(dataObjectPointer + 7) < '\\0')) {\n          textLength = convert_number_to_text_00003e9e(numberText,(int)*(short *)(dataObjectPointer + (uint)index * 2),\n                                  (int)*(char *)(dataObjectPointer + 7));\n          numberText[textLength] = 0;\n          initialize_and_process_data_00004c84(&DAT_000077dc,numberText);\n        }\n        else {\n          initialize_and_process_data_00004c84(\"%iE%i\",(int)*(short *)(dataObjectPointer + (uint)index * 2),\n                       (int)*(char *)(dataObjectPointer + 7));\n        }\n      }\n      else {\n        initialize_and_process_data_00004c84(\"%6d %c\",(int)*(short *)(dataObjectPointer + (uint)index * 2),character);\n      }\n      address = get_memory_address_00003810(*(undefined *)(dataObjectPointer + 6));\n      initialize_and_process_data_00004c84(&DAT_000077e8,address);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00003694": "display_data_object_00003694",
                "param_1": "dataObjectPointer",
                "param_2": "dataSize",
                "uVar1": "address",
                "cVar2": "bitValue",
                "uVar3": "bitMask",
                "bVar4": "bitSet",
                "auStack_18": "numberText",
                "local_10": "textLength",
                "local_a": "character",
                "local_9": "index"
            },
            "calling": [
                "FUN_00002ecc",
                "FUN_0000305c"
            ],
            "called": [
                "FUN_00004db8",
                "FUN_00003e9e",
                "FUN_00003918",
                "FUN_00003810",
                "FUN_00004c84"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003810": {
            "entrypoint": "0x00003810",
            "current_name": "get_memory_address_00003810",
            "code": "\nundefined * getMemoryAddress_00003810(undefined input)\n\n{\n  undefined *resultAddress;\n  \n  switch(input) {\n  case 2:\n    resultAddress = &DAT_000077ec;\n    break;\n  case 3:\n    resultAddress = &DAT_000077f0;\n    break;\n  case 4:\n    resultAddress = &DAT_000077f4;\n    break;\n  case 5:\n    resultAddress = &DAT_000077f8;\n    break;\n  case 6:\n    resultAddress = &DAT_000077fc;\n    break;\n  case 7:\n    resultAddress = (undefined *)0x7800;\n    break;\n  case 8:\n    resultAddress = &DAT_00007804;\n    break;\n  case 9:\n    resultAddress = &DAT_00007808;\n    break;\n  case 10:\n    resultAddress = &DAT_0000780c;\n    break;\n  case 0xb:\n    resultAddress = &DAT_00007810;\n    break;\n  case 0xc:\n    resultAddress = &DAT_00007814;\n    break;\n  case 0xd:\n    resultAddress = &DAT_00007818;\n    break;\n  case 0xe:\n    resultAddress = &DAT_0000781c;\n    break;\n  case 0xf:\n    resultAddress = &DAT_00007820;\n    break;\n  case 0x10:\n    resultAddress = &DAT_00007824;\n    break;\n  case 0x11:\n    resultAddress = &DAT_0000782c;\n    break;\n  default:\n    resultAddress = &DAT_00007834;\n    break;\n  case 0x13:\n    resultAddress = &DAT_00007830;\n    break;\n  case 0x15:\n    resultAddress = &DAT_00007828;\n  }\n  return resultAddress;\n}\n\n",
            "renaming": {
                "FUN_00003810": "get_memory_address_00003810",
                "param_1": "input",
                "puVar1": "resultAddress"
            },
            "calling": [
                "FUN_00003694"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003918": {
            "entrypoint": "0x00003918",
            "current_name": "get_value_from_param_00003918",
            "code": "\nundefined4 getValueFromParam_00003918(undefined input)\n\n{\n  undefined4 result;\n  \n  switch(input) {\n  case 2:\n    result = 0x68;\n    break;\n  case 3:\n    result = 0x6b;\n    break;\n  case 6:\n    result = 0x4d;\n    break;\n  case 9:\n    result = 0x47;\n    break;\n  case 0xc:\n    result = 0x54;\n    break;\n  case 0xf:\n    result = 0x50;\n    break;\n  case 0xf1:\n    result = 0x66;\n    break;\n  default:\n    result = 0;\n    break;\n  case 0xf4:\n    result = 0x70;\n    break;\n  case 0xf7:\n    result = 0x6e;\n    break;\n  case 0xfa:\n    result = 0x75;\n    break;\n  case 0xfd:\n    result = 0x6d;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003918": "get_value_from_param_00003918",
                "param_1": "input",
                "uVar1": "result"
            },
            "calling": [
                "FUN_00003694"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000039e8": {
            "entrypoint": "0x000039e8",
            "current_name": "classify_device_type_000039e8",
            "code": "\nchar * classifyDeviceType_000039e8(char deviceType)\n\n{\n  char *deviceTypeName;\n  \n  switch(deviceType) {\n  case '\\0':\n    deviceTypeName = \"CLASS_UNDEF\";\n    break;\n  case '@':\n    deviceTypeName = \"ACT_ANY\";\n    break;\n  case 'B':\n    deviceTypeName = \"ACT_LED_RGB\";\n    break;\n  case 'C':\n    deviceTypeName = \"ACT_SERVO\";\n    break;\n  case 'D':\n    deviceTypeName = \"ACT_MOTOR\";\n    break;\n  case 'E':\n    deviceTypeName = \"ACT_SWITCH\";\n    break;\n  case 'F':\n    deviceTypeName = \"ACT_DIMMER\";\n    break;\n  case -0x80:\n    deviceTypeName = \"SENSE_ANY\";\n    break;\n  case -0x7f:\n    deviceTypeName = \"SENSE_BTN\";\n    break;\n  case -0x7e:\n    deviceTypeName = \"SENSE_TEMP\";\n    break;\n  case -0x7d:\n    deviceTypeName = \"SENSE_HUM\";\n    break;\n  case -0x7c:\n    deviceTypeName = \"SENSE_LIGHT\";\n    break;\n  case -0x7b:\n    deviceTypeName = \"SENSE_ACCEL\";\n    break;\n  case -0x7a:\n    deviceTypeName = \"SENSE_MAG\";\n    break;\n  case -0x79:\n    deviceTypeName = \"SENSE_GYRO\";\n    break;\n  case -0x78:\n    deviceTypeName = \"SENSE_COLOR\";\n    break;\n  case -0x77:\n    deviceTypeName = \"SENSE_PRESS\";\n    break;\n  case -0x76:\n    deviceTypeName = \"SENSE_ANALOG\";\n    break;\n  case -0x75:\n    deviceTypeName = \"SENSE_UV\";\n    break;\n  case -0x74:\n    deviceTypeName = \"SENSE_OBJTEMP\";\n    break;\n  case -0x73:\n    deviceTypeName = \"SENSE_PULSE_COUNT\";\n    break;\n  case -0x72:\n    deviceTypeName = \"SENSE_DISTANCE\";\n    break;\n  case -0x71:\n    deviceTypeName = \"SENSE_CO2\";\n    break;\n  default:\n    if (deviceType == -1) {\n      return \"CLASS_ANY\";\n    }\n  case '\\x01':\n  case '\\x02':\n  case '\\x03':\n  case '\\x04':\n  case '\\x05':\n  case '\\x06':\n  case '\\a':\n  case '\\b':\n  case '\\t':\n  case '\\n':\n  case '\\v':\n  case '\\f':\n  case '\\r':\n  case '\\x0e':\n  case '\\x0f':\n  case '\\x10':\n  case '\\x11':\n  case '\\x12':\n  case '\\x13':\n  case '\\x14':\n  case '\\x15':\n  case '\\x16':\n  case '\\x17':\n  case '\\x18':\n  case '\\x19':\n  case '\\x1a':\n  case '\\x1b':\n  case '\\x1c':\n  case '\\x1d':\n  case '\\x1e':\n  case '\\x1f':\n  case ' ':\n  case '!':\n  case '\\\"':\n  case '#':\n  case '$':\n  case '%':\n  case '&':\n  case '\\'':\n  case '(':\n  case ')':\n  case '*':\n  case '+':\n  case ',':\n  case '-':\n  case '.':\n  case '/':\n  case '0':\n  case '1':\n  case '2':\n  case '3':\n  case '4':\n  case '5':\n  case '6':\n  case '7':\n  case '8':\n  case '9':\n  case ':':\n  case ';':\n  case '<':\n  case '=':\n  case '>':\n  case '?':\n  case 'A':\n  case 'G':\n  case 'H':\n  case 'I':\n  case 'J':\n  case 'K':\n  case 'L':\n  case 'M':\n  case 'N':\n  case 'O':\n  case 'P':\n  case 'Q':\n  case 'R':\n  case 'S':\n  case 'T':\n  case 'U':\n  case 'V':\n  case 'W':\n  case 'X':\n  case 'Y':\n  case 'Z':\n  case '[':\n  case '\\':\n  case ']':\n  case '^':\n  case '_':\n  case '`':\n  case 'a':\n  case 'b':\n  case 'c':\n  case 'd':\n  case 'e':\n  case 'f':\n  case 'g':\n  case 'h':\n  case 'i':\n  case 'j':\n  case 'k':\n  case 'l':\n  case 'm':\n  case 'n':\n  case 'o':\n  case 'p':\n  case 'q':\n  case 'r':\n  case 's':\n  case 't':\n  case 'u':\n  case 'v':\n  case 'w':\n  case 'x':\n  case 'y':\n  case 'z':\n  case '{':\n  case '|':\n  case '}':\n  case '~':\n  case '\\x7f':\n    deviceTypeName = \"CLASS_UNKNOWN\";\n  }\n  return deviceTypeName;\n}\n\n",
            "renaming": {
                "FUN_000039e8": "classify_device_type_000039e8",
                "param_1": "deviceType",
                "pcVar1": "deviceTypeName"
            },
            "calling": [
                "FUN_00002f74",
                "FUN_00002ecc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d24": {
            "entrypoint": "0x00003d24",
            "current_name": "find_element_00003d24",
            "code": "\nundefined4 * findElement_00003d24(int numElements)\n\n{\n  int count;\n  undefined4 *currentElement;\n  \n  count = 0;\n  for (currentElement = DAT_1fff0db0; (count < numElements && (currentElement != (undefined4 *)0x0));\n      currentElement = (undefined4 *)*currentElement) {\n    count = count + 1;\n  }\n  return currentElement;\n}\n\n",
            "renaming": {
                "FUN_00003d24": "find_element_00003d24",
                "param_1": "numElements",
                "local_10": "count",
                "local_c": "currentElement"
            },
            "calling": [
                "FUN_00002fe0",
                "FUN_0000305c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d64": {
            "entrypoint": "0x00003d64",
            "current_name": "process_function_result_00003d64",
            "code": "\nundefined4 processFunctionResult_00003d64(int inputValue,undefined4 param)\n\n{\n  undefined4 returnValue;\n  \n  if (inputValue == 0) {\n    returnValue = 0xffffffed;\n  }\n  else {\n    returnValue = (***(code ***)(inputValue + 0xc))(*(undefined4 *)(inputValue + 4),param);\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00003d64": "process_function_result_00003d64",
                "param_1": "inputValue",
                "param_2": "param",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_00002ecc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d94": {
            "entrypoint": "0x00003d94",
            "current_name": "execute_function_00003d94",
            "code": "\nundefined4 executeFunction_00003d94(int inputParam,undefined4 anotherParam)\n\n{\n  undefined4 returnValue;\n  \n  if (inputParam == 0) {\n    returnValue = 0xffffffed;\n  }\n  else {\n    returnValue = (**(code **)(*(int *)(inputParam + 0xc) + 4))(*(undefined4 *)(inputParam + 4),anotherParam);\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00003d94": "execute_function_00003d94",
                "param_1": "inputParam",
                "param_2": "anotherParam",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_0000305c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003dc4": {
            "entrypoint": "0x00003dc4",
            "current_name": "count_digits_in_range_00003dc4",
            "code": "\nint countDigitsInRange_00003dc4(int startDigit,uint endNumber)\n\n{\n  uint remainder;\n  char *currentDigitPtr;\n  uint powerOfTen;\n  int digitCount;\n  \n  digitCount = 1;\n  if (endNumber < 1000000000) {\n    for (powerOfTen = 10; powerOfTen <= endNumber; powerOfTen = powerOfTen * 10) {\n      digitCount = digitCount + 1;\n    }\n  }\n  else {\n    digitCount = 10;\n  }\n  if (startDigit != 0) {\n    currentDigitPtr = (char *)(digitCount + startDigit);\n    remainder = endNumber;\n    do {\n      currentDigitPtr = currentDigitPtr + -1;\n      *currentDigitPtr = (char)(remainder % 10) + '0';\n      remainder = remainder / 10;\n    } while (remainder != 0);\n  }\n  return digitCount;\n}\n\n",
            "renaming": {
                "FUN_00003dc4": "count_digits_in_range_00003dc4",
                "param_1": "startDigit",
                "param_2": "endNumber",
                "local_20": "remainder",
                "local_14": "currentDigitPtr",
                "local_10": "powerOfTen",
                "local_c": "digitCount"
            },
            "calling": [
                "FUN_00003e58"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003e58": {
            "entrypoint": "0x00003e58",
            "current_name": "count_digits_and_sign_00003e58",
            "code": "\nint count_digits_and_sign_00003e58(undefined *input_string,int input_number)\n\n{\n  int digit_count;\n  int absolute_value;\n  undefined *modified_string;\n  \n  absolute_value = input_number;\n  modified_string = input_string;\n  if (-(input_number >> 0x1f) != 0) {\n    if (input_string != (undefined *)0x0) {\n      modified_string = input_string + 1;\n      *input_string = 0x2d;\n    }\n    absolute_value = -input_number;\n  }\n  digit_count = count_digits_in_range_00003dc4(modified_string,absolute_value);\n  return -(input_number >> 0x1f) + digit_count;\n}\n\n",
            "renaming": {
                "FUN_00003e58": "count_digits_and_sign_00003e58",
                "param_1": "input_string",
                "param_2": "input_number",
                "iVar1": "digit_count",
                "local_18": "absolute_value",
                "local_14": "modified_string"
            },
            "calling": [
                "FUN_00003ec4"
            ],
            "called": [
                "FUN_00003dc4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003e9e": {
            "entrypoint": "0x00003e9e",
            "current_name": "convert_number_to_text_00003e9e",
            "code": "\nundefined4 convertNumberToText_00003e9e(undefined4 number,short shortNumber,undefined4 conversionParam)\n\n{\n  undefined4 result;\n  \n  result = convert_number_to_text_00003ec4(number,(int)shortNumber,conversionParam);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003e9e": "convert_number_to_text_00003e9e",
                "param_1": "number",
                "param_2": "shortNumber",
                "param_3": "conversionParam",
                "uVar1": "result"
            },
            "calling": [
                "FUN_00003694"
            ],
            "called": [
                "FUN_00003ec4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003ec4": {
            "entrypoint": "0x00003ec4",
            "current_name": "convert_number_to_text_00003ec4",
            "code": "\nint convertNumberToText_00003ec4(undefined *outputBuffer,uint inputNumber,int numDigits)\n\n{\n  int digitCount;\n  undefined4 numDigitsAfterDecimal;\n  uint quotient;\n  int remainder;\n  int totalDigitsCount;\n  \n  if (numDigits + 7 < 0 != SCARRY4(numDigits,7)) {\n    kernel_panic_handler_00000f04(3,\"FAILED ASSERTION.\");\n  }\n  totalDigitsCount = 0;\n  if (numDigits == 0) {\n    totalDigitsCount = count_digits_and_sign_00003e58(outputBuffer,inputNumber);\n  }\n  else if (numDigits < 1) {\n    quotient = inputNumber / *(uint *)(&DAT_00007978 + numDigits * -4);\n    remainder = inputNumber - *(uint *)(&DAT_00007978 + numDigits * -4) * quotient;\n    if (remainder < 0) {\n      remainder = -remainder;\n    }\n    if ((quotient == 0) && ((int)inputNumber < 0)) {\n      if (outputBuffer != (undefined *)0x0) {\n        *outputBuffer = 0x2d;\n      }\n      totalDigitsCount = 1;\n    }\n    if (outputBuffer == (undefined *)0x0) {\n      digitCount = count_digits_and_sign_00003e58(0,quotient);\n      totalDigitsCount = digitCount + 1 + totalDigitsCount;\n    }\n    else {\n      digitCount = count_digits_and_sign_00003e58(outputBuffer + totalDigitsCount,quotient);\n      digitCount = totalDigitsCount + digitCount;\n      totalDigitsCount = digitCount + 1;\n      outputBuffer[digitCount] = 0x2e;\n      numDigitsAfterDecimal = count_digits_and_sign_00003e58(outputBuffer + totalDigitsCount,remainder);\n      copy_and_fill_range_00003ff4(outputBuffer + totalDigitsCount,numDigitsAfterDecimal,-numDigits,0x30);\n    }\n    totalDigitsCount = -numDigits + totalDigitsCount;\n  }\n  else {\n    totalDigitsCount = count_digits_and_sign_00003e58(outputBuffer,inputNumber);\n    if (outputBuffer != (undefined *)0x0) {\n      fill_array_with_value_00004622(outputBuffer + totalDigitsCount,0x30,numDigits);\n    }\n    totalDigitsCount = numDigits + totalDigitsCount;\n  }\n  return totalDigitsCount;\n}\n\n",
            "renaming": {
                "FUN_00003ec4": "convert_number_to_text_00003ec4",
                "param_1": "outputBuffer",
                "param_2": "inputNumber",
                "param_3": "numDigits",
                "iVar1": "digitCount",
                "uVar2": "numDigitsAfterDecimal",
                "uVar3": "quotient",
                "local_10": "remainder",
                "local_c": "totalDigitsCount"
            },
            "calling": [
                "FUN_00003e9e"
            ],
            "called": [
                "FUN_00003e58",
                "FUN_00004622",
                "FUN_00000f04",
                "FUN_00003ff4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003ff4": {
            "entrypoint": "0x00003ff4",
            "current_name": "copy_and_fill_range_00003ff4",
            "code": "\nuint copy_and_fill_range_00003ff4(int size,uint start,uint end,undefined value)\n\n{\n  uint new_end;\n  \n  new_end = start;\n  if ((start < end) && (new_end = end, size != 0)) {\n    copy_in_range_000045ee((end - start) + size,size,start);\n    fill_array_with_value_00004622(size,value,end - start);\n  }\n  return new_end;\n}\n\n",
            "renaming": {
                "FUN_00003ff4": "copy_and_fill_range_00003ff4",
                "param_1": "size",
                "param_2": "start",
                "param_3": "end",
                "param_4": "value",
                "uVar1": "new_end"
            },
            "calling": [
                "FUN_00003ec4"
            ],
            "called": [
                "FUN_000045ee",
                "FUN_00004622"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004042": {
            "entrypoint": "0x00004042",
            "current_name": "convert_string_to_number_00004042",
            "code": "\nvoid convertStringToNumber_00004042(undefined4 inputString)\n\n{\n  convert_string_to_number_00004f84(inputString,0,10);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004042": "convert_string_to_number_00004042",
                "param_1": "inputString"
            },
            "calling": [
                "FUN_00002fe0",
                "FUN_0000305c"
            ],
            "called": [
                "FUN_00004f84"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000404c": {
            "entrypoint": "0x0000404c",
            "current_name": "process_data_0000404c",
            "code": "\nundefined4 processData_0000404c(uint *data,int *param)\n\n{\n  int tempVar1;\n  int *tempVar2;\n  uint value;\n  ushort flags;\n  int tempVar3;\n  code *functionPtr;\n  int tempVar4;\n  uint originalValue;\n  bool isZero;\n  \n  flags = *(ushort *)(param + 3);\n  value = (uint)flags;\n  if ((int)(value << 0x1c) < 0) {\n    tempVar1 = param[4];\n    if (tempVar1 != 0) {\n      tempVar3 = value << 0x1e;\n      isZero = tempVar3 == 0;\n      tempVar4 = *param;\n      if (isZero) {\n        tempVar3 = param[5];\n      }\n      *param = tempVar1;\n      if (!isZero) {\n        tempVar3 = 0;\n      }\n      param[2] = tempVar3;\n      for (tempVar4 = tempVar4 - tempVar1; 0 < tempVar4; tempVar4 = tempVar4 - tempVar3) {\n        tempVar3 = (*(code *)param[10])(data,param[8],tempVar1,tempVar4);\n        if (tempVar3 < 1) {\n          *(ushort *)(param + 3) = *(ushort *)(param + 3) | 0x40;\n          return 0xffffffff;\n        }\n        tempVar1 = tempVar1 + tempVar3;\n      }\n    }\n  }\n  else {\n    if ((param[1] < 1) && (param[0x10] < 1)) {\n      return 0;\n    }\n    functionPtr = (code *)param[0xb];\n    if (functionPtr == (code *)0x0) {\n      return 0;\n    }\n    originalValue = *data;\n    *data = 0;\n    if ((flags & 0x1000) == 0) {\n      tempVar1 = (*functionPtr)(data,param[8],value & 0x1000,1);\n      if ((tempVar1 == -1) && (value = *data, value != 0)) {\n        if ((value == 0x1d) || (value == 0x16)) {\n          *data = originalValue;\n          return 0;\n        }\n        flags = *(ushort *)(param + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      tempVar1 = param[0x15];\n    }\n    if (((int)((uint)*(ushort *)(param + 3) << 0x1d) < 0) &&\n       (tempVar1 = tempVar1 - param[1], param[0xd] != 0)) {\n      tempVar1 = tempVar1 - param[0x10];\n    }\n    tempVar1 = (*(code *)param[0xb])(data,param[8],tempVar1,0);\n    flags = *(ushort *)(param + 3);\n    if ((tempVar1 == -1) &&\n       ((0x1d < *data || (-1 < (int)((0x20400001U >> (*data & 0xff)) << 0x1f))))) {\nLAB_00004104:\n      *(ushort *)(param + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n    param[1] = 0;\n    *param = param[4];\n    if (((int)((uint)flags << 0x13) < 0) && ((tempVar1 != -1 || (*data == 0)))) {\n      param[0x15] = tempVar1;\n    }\n    tempVar2 = (int *)param[0xd];\n    *data = originalValue;\n    if (tempVar2 != (int *)0x0) {\n      if (tempVar2 != param + 0x11) {\n        initialize_data_and_process_00004b34(data);\n      }\n      param[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000404c": "process_data_0000404c",
                "param_1": "data",
                "param_2": "param",
                "iVar1": "tempVar1",
                "piVar2": "tempVar2",
                "uVar3": "value",
                "uVar4": "flags",
                "iVar5": "tempVar3",
                "pcVar6": "functionPtr",
                "iVar7": "tempVar4",
                "uVar8": "originalValue",
                "bVar9": "isZero"
            },
            "calling": [
                "FUN_00004158",
                "FUN_00006768"
            ],
            "called": [
                "FUN_00004b34"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004158": {
            "entrypoint": "0x00004158",
            "current_name": "process_data_00004158",
            "code": "\nundefined4 processData_00004158(int inputParam,undefined4 *outputParam)\n\n{\n  undefined4 returnValue;\n  \n  if (outputParam[4] != 0) {\n    if ((inputParam != 0) && (*(int *)(inputParam + 0x18) == 0)) {\n      initialize_data_structures_000042a4();\n    }\n    if (outputParam == &DAT_000079b8) {\n      outputParam = *(undefined4 **)(inputParam + 4);\n    }\n    else if (outputParam == (undefined4 *)&DAT_000079d8) {\n      outputParam = *(undefined4 **)(inputParam + 8);\n    }\n    else if (outputParam == (undefined4 *)&DAT_00007998) {\n      outputParam = *(undefined4 **)(inputParam + 0xc);\n    }\n    if (*(short *)(outputParam + 3) != 0) {\n      if ((-1 < (int)(outputParam[0x19] << 0x1f)) && (-1 < (int)*(short *)(outputParam + 3) << 0x16)) {\n        FUNC_000045e8(outputParam[0x16]);\n      }\n      returnValue = process_data_0000404c(inputParam,outputParam);\n      if ((int)(outputParam[0x19] << 0x1f) < 0) {\n        return returnValue;\n      }\n      if ((int)((uint)*(ushort *)(outputParam + 3) << 0x16) < 0) {\n        return returnValue;\n      }\n      FUNC_000045ec(outputParam[0x16]);\n      return returnValue;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004158": "process_data_00004158",
                "param_1": "inputParam",
                "param_2": "outputParam",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_000041d0",
                "FUN_00005404",
                "FUN_00006768"
            ],
            "called": [
                "FUN_000042a4",
                "FUN_0000404c",
                "FUN_000045ec",
                "FUN_000045e8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": [],
            "code_backup": "\nundefined4 FUN_00004158(int param_1,undefined4 *param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_2[4] != 0) {\n    if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n      FUNC_000042a4();\n    }\n    if (param_2 == &DAT_000079b8) {\n      param_2 = *(undefined4 **)(param_1 + 4);\n    }\n    else if (param_2 == (undefined4 *)&DAT_000079d8) {\n      param_2 = *(undefined4 **)(param_1 + 8);\n    }\n    else if (param_2 == (undefined4 *)&DAT_00007998) {\n      param_2 = *(undefined4 **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 3) != 0) {\n      if ((-1 < (int)(param_2[0x19] << 0x1f)) && (-1 < (int)*(short *)(param_2 + 3) << 0x16)) {\n        FUNC_000045e8(param_2[0x16]);\n      }\n      uVar1 = process_data_0000404c(param_1,param_2);\n      if ((int)(param_2[0x19] << 0x1f) < 0) {\n        return uVar1;\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 3) << 0x16) < 0) {\n        return uVar1;\n      }\n      FUNC_000045ec(param_2[0x16]);\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n"
        },
        "FUN_000041d0": {
            "entrypoint": "0x000041d0",
            "current_name": "process_rel_array_000041d0",
            "code": "\nuint process_rel_array_000041d0(int offset,undefined4 param_2,undefined4 param_3)\n\n{\n  uint result;\n  int count;\n  dword *rel_entry;\n  int data_entry;\n  uint combined_result;\n  int loop_count;\n  undefined4 *data_ptr;\n  \n  if (offset == 0) {\n    data_ptr = &DAT_000079f8;\n    rel_entry = &Elf32_Rel_ARRAY_1fff0200[0x19].r_info;\n    combined_result = 0;\n    do {\n      loop_count = rel_entry[1];\n      data_entry = rel_entry[2];\n      while (loop_count = loop_count + -1, -1 < loop_count) {\n        if ((1 < *(ushort *)(data_entry + 0xc)) && (count = *(short *)(data_entry + 0xe) + 1, count != 0)) {\n          result = process_data_00004158(0x1fff0284,data_entry,param_3,count,data_ptr);\n          combined_result = combined_result | result;\n        }\n        data_entry = data_entry + 0x68;\n      }\n      rel_entry = (dword *)*rel_entry;\n    } while (rel_entry != (dword *)0x0);\n    return combined_result;\n  }\n  combined_result = process_data_00004158(Elf32_Rel_ARRAY_1fff0200[16].r_offset,offset);\n  return combined_result;\n}\n\n",
            "renaming": {
                "FUN_000041d0": "process_rel_array_000041d0",
                "param_1": "offset",
                "uVar1": "result",
                "iVar2": "count",
                "pdVar3": "rel_entry",
                "iVar4": "data_entry",
                "uVar5": "combined_result",
                "iVar6": "loop_count",
                "puVar7": "data_ptr"
            },
            "calling": [
                "FUN_00002e48"
            ],
            "called": [
                "FUN_00004158"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000041f4": {
            "entrypoint": "0x000041f4",
            "current_name": "initialize_data_structure_000041f4",
            "code": "\nvoid initializeDataStructure_000041f4(undefined4 *dataStructure,undefined2 value1,undefined2 value2)\n\n{\n  *dataStructure = 0;\n  dataStructure[1] = 0;\n  dataStructure[4] = 0;\n  dataStructure[5] = 0;\n  dataStructure[2] = 0;\n  *(undefined2 *)(dataStructure + 3) = value1;\n  dataStructure[0x19] = 0;\n  *(undefined2 *)((int)dataStructure + 0xe) = value2;\n  dataStructure[6] = 0;\n  fillArrayWithValue(dataStructure + 0x17,0,8);\n  dataStructure[9] = 0x4dc9;\n  dataStructure[10] = 0x4def;\n  dataStructure[0xb] = 0x4e27;\n  dataStructure[8] = dataStructure;\n  dataStructure[0xc] = &label;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000041f4": "initialize_data_structure_000041f4",
                "param_1": "dataStructure",
                "param_2": "value1",
                "param_3": "value2",
                "fill_array_with_value_00004622": "fillArrayWithValue",
                "LAB_00004e4a_1": "label"
            },
            "calling": [
                "FUN_000042a4"
            ],
            "called": [
                "FUN_00004622"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004248": {
            "entrypoint": "0x00004248",
            "current_name": "allocate_and_initialize_array_00004248",
            "code": "\nundefined4 * allocateAndInitializeArray_00004248(undefined4 memorySize,int numElements)\n\n{\n  undefined4 *arrayPointer;\n  int arraySize;\n  \n  arraySize = (numElements + -1) * 0x68;\n  arrayPointer = (undefined4 *)allocate_memory_00004bd0(memorySize,arraySize + 0x74);\n  if (arrayPointer != (undefined4 *)0x0) {\n    *arrayPointer = 0;\n    arrayPointer[1] = numElements;\n    arrayPointer[2] = arrayPointer + 3;\n    fill_array_with_value_00004622(arrayPointer + 3,0,arraySize + 0x68);\n  }\n  return arrayPointer;\n}\n\n",
            "renaming": {
                "FUN_00004248": "allocate_and_initialize_array_00004248",
                "param_1": "memorySize",
                "param_2": "numElements",
                "puVar1": "arrayPointer",
                "iVar2": "arraySize"
            },
            "calling": [
                "FUN_00004314"
            ],
            "called": [
                "FUN_00004bd0",
                "FUN_00004622"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004274": {
            "entrypoint": "0x00004274",
            "current_name": "initialize_data_00004274",
            "code": "\nvoid initializeData_00004274(void)\n\n{\n  FUNC_000045e8(&DAT_1fff0dec);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004274": "initialize_data_00004274"
            },
            "calling": [
                "FUN_00004314"
            ],
            "called": [
                "FUN_000045e8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004280": {
            "entrypoint": "0x00004280",
            "current_name": "initialize_data_00004280",
            "code": "\nvoid initializeData_00004280(void)\n\n{\n  FUNC_000045ec(&DAT_1fff0dec);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004280": "initialize_data_00004280"
            },
            "calling": [
                "FUN_00004314"
            ],
            "called": [
                "FUN_000045ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000428c": {
            "entrypoint": "0x0000428c",
            "current_name": "initialize_function_0000428c",
            "code": "\nvoid initializeFunction_0000428c(void)\n\n{\n  FUNC_000045e8(0x1fff0de7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000428c": "initialize_function_0000428c"
            },
            "calling": [
                "FUN_000042a4"
            ],
            "called": [
                "FUN_000045e8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000042a4": {
            "entrypoint": "0x000042a4",
            "current_name": "initialize_data_structures_000042a4",
            "code": "\nvoid initializeDataStructures_000042a4(int functionParameter)\n\n{\n  undefined4 returnValue;\n  \n  initializeFunction();\n  if (*(int *)(functionParameter + 0x18) == 0) {\n    *(undefined4 *)(functionParameter + 0x48) = 0;\n    *(undefined4 *)(functionParameter + 0x4c) = 0;\n    *(undefined4 *)(functionParameter + 0x50) = 0;\n    returnValue = 0x1fff0284;\n    *(undefined **)(functionParameter + 0x28) = &DAT_0000423d;\n    if (functionParameter == 0x1fff0284) {\n      returnValue = 1;\n    }\n    if (functionParameter == 0x1fff0284) {\n      *(undefined4 *)(functionParameter + 0x18) = returnValue;\n    }\n    returnValue = findValidPointer(functionParameter);\n    *(undefined4 *)(functionParameter + 4) = returnValue;\n    returnValue = findValidPointer(functionParameter);\n    *(undefined4 *)(functionParameter + 8) = returnValue;\n    returnValue = findValidPointer(functionParameter);\n    *(undefined4 *)(functionParameter + 0xc) = returnValue;\n    initializeDataStructure(*(undefined4 *)(functionParameter + 4),4,0);\n    initializeDataStructure(*(undefined4 *)(functionParameter + 8),9,1);\n    initializeDataStructure(*(undefined4 *)(functionParameter + 0xc),0x12,2);\n    *(undefined4 *)(functionParameter + 0x18) = 1;\n  }\n  FUNC_000045ec(0x1fff0de7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000042a4": "initialize_data_structures_000042a4",
                "param_1": "functionParameter",
                "uVar1": "returnValue",
                "find_valid_pointer_00004314": "findValidPointer",
                "initialize_function_0000428c": "initializeFunction",
                "initialize_data_structure_000041f4": "initializeDataStructure"
            },
            "calling": [
                "FUN_00004418",
                "FUN_00004db8",
                "FUN_00004158",
                "FUN_00005404",
                "FUN_00005e10",
                "FUN_000054a8",
                "FUN_00006768",
                "FUN_00004c84",
                "FUN_00004cb4",
                "FUN_00004314",
                "FUN_000057f8"
            ],
            "called": [
                "FUN_000041f4",
                "FUN_000045ec",
                "FUN_0000428c",
                "FUN_00004314"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004314": {
            "entrypoint": "0x00004314",
            "current_name": "find_valid_pointer_00004314",
            "code": "\nundefined4 * findValidPointer_00004314(undefined4 *result)\n\n{\n  dword allocatedArray;\n  int count;\n  undefined4 *currentPointer;\n  dword *ptrToRelArray;\n  \n  initialize_data_00004274();\n  if (Elf32_Rel_ARRAY_1fff0200[19].r_info == 0) {\n    initialize_data_structures_000042a4(0x1fff0284);\n  }\n  ptrToRelArray = &Elf32_Rel_ARRAY_1fff0200[0x19].r_info;\n  do {\n    count = ptrToRelArray[1];\n    currentPointer = (undefined4 *)ptrToRelArray[2];\n    while (count = count + -1, -1 < count) {\n      if (*(short *)(currentPointer + 3) == 0) {\n        currentPointer[3] = 0xffff0001;\n        currentPointer[0x19] = 0;\n        FUNC_000045e4(currentPointer + 0x16);\n        initialize_data_00004280();\n        currentPointer[1] = 0;\n        currentPointer[2] = 0;\n        currentPointer[4] = 0;\n        currentPointer[5] = 0;\n        *currentPointer = 0;\n        currentPointer[6] = 0;\n        fill_array_with_value_00004622(currentPointer + 0x17,0,8);\n        currentPointer[0xd] = 0;\n        currentPointer[0xe] = 0;\n        currentPointer[0x12] = 0;\n        currentPointer[0x13] = 0;\n        return currentPointer;\n      }\n      currentPointer = currentPointer + 0x1a;\n    }\n    if (*ptrToRelArray == 0) {\n      allocatedArray = allocate_and_initialize_array_00004248(result,4);\n      *ptrToRelArray = allocatedArray;\n      if (allocatedArray == 0) {\n        initialize_data_00004280();\n        *result = 0xc;\n        return (undefined4 *)0x0;\n      }\n    }\n    ptrToRelArray = (dword *)*ptrToRelArray;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00004314": "find_valid_pointer_00004314",
                "param_1": "result",
                "dVar1": "allocatedArray",
                "iVar2": "count",
                "puVar3": "currentPointer",
                "pdVar4": "ptrToRelArray"
            },
            "calling": [
                "FUN_000042a4"
            ],
            "called": [
                "FUN_000042a4",
                "FUN_00004622",
                "FUN_000045e4",
                "FUN_00004280",
                "FUN_00004248",
                "FUN_00004274"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": [],
            "code_backup": "\nundefined4 * FUN_00004314(undefined4 *param_1)\n\n{\n  dword dVar1;\n  int iVar2;\n  undefined4 *puVar3;\n  dword *pdVar4;\n  \n  initialize_data_00004274();\n  if (Elf32_Rel_ARRAY_1fff0200[19].r_info == 0) {\n    FUNC_000042a4(0x1fff0284);\n  }\n  pdVar4 = &Elf32_Rel_ARRAY_1fff0200[0x19].r_info;\n  do {\n    iVar2 = pdVar4[1];\n    puVar3 = (undefined4 *)pdVar4[2];\n    while (iVar2 = iVar2 + -1, -1 < iVar2) {\n      if (*(short *)(puVar3 + 3) == 0) {\n        puVar3[3] = 0xffff0001;\n        puVar3[0x19] = 0;\n        FUNC_000045e4(puVar3 + 0x16);\n        initialize_data_00004280();\n        puVar3[1] = 0;\n        puVar3[2] = 0;\n        puVar3[4] = 0;\n        puVar3[5] = 0;\n        *puVar3 = 0;\n        puVar3[6] = 0;\n        fill_array_with_value_00004622(puVar3 + 0x17,0,8);\n        puVar3[0xd] = 0;\n        puVar3[0xe] = 0;\n        puVar3[0x12] = 0;\n        puVar3[0x13] = 0;\n        return puVar3;\n      }\n      puVar3 = puVar3 + 0x1a;\n    }\n    if (*pdVar4 == 0) {\n      dVar1 = allocate_and_initialize_array_00004248(param_1,4);\n      *pdVar4 = dVar1;\n      if (dVar1 == 0) {\n        initialize_data_00004280();\n        *param_1 = 0xc;\n        return (undefined4 *)0x0;\n      }\n    }\n    pdVar4 = (dword *)*pdVar4;\n  } while( true );\n}\n\n"
        },
        "FUN_000043a0": {
            "entrypoint": "0x000043a0",
            "current_name": "execute_callbacks_000043a0",
            "code": "\nuint executeCallbacks_000043a0(int baseAddress,code *callbackFunction)\n\n{\n  uint callbackResult;\n  int *currentPointer;\n  int currentOffset;\n  uint combinedResults;\n  int iterationCount;\n  \n  currentPointer = (int *)(baseAddress + 0x48);\n  combinedResults = 0;\n  do {\n    iterationCount = currentPointer[1];\n    currentOffset = currentPointer[2];\n    while (iterationCount = iterationCount + -1, -1 < iterationCount) {\n      if ((1 < *(ushort *)(currentOffset + 0xc)) && (*(short *)(currentOffset + 0xe) != -1)) {\n        callbackResult = (*callbackFunction)(currentOffset);\n        combinedResults = combinedResults | callbackResult;\n      }\n      currentOffset = currentOffset + 0x68;\n    }\n    currentPointer = (int *)*currentPointer;\n  } while (currentPointer != (int *)0x0);\n  return combinedResults;\n}\n\n",
            "renaming": {
                "FUN_000043a0": "execute_callbacks_000043a0",
                "param_1": "baseAddress",
                "param_2": "callbackFunction",
                "piVar2": "currentPointer",
                "iVar3": "currentOffset",
                "uVar1": "callbackResult",
                "uVar4": "combinedResults",
                "iVar5": "iterationCount"
            },
            "calling": [
                "FUN_00006768"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004418": {
            "entrypoint": "0x00004418",
            "current_name": "execute_and_process_00004418",
            "code": "\nuint execute_and_process_00004418(void)\n\n{\n  dword rel_offset;\n  uint result;\n  byte **data_ptr;\n  byte *byte_ptr;\n  \n  rel_offset = rel_array[16].r_offset;\n  if ((rel_array[16].r_offset != 0) &&\n     (*(int *)(rel_array[16].r_offset + 0x18) == 0)) {\n    initialize_data_structures_000042a4(rel_array[16].r_offset);\n  }\n  data_ptr = *(byte ***)(rel_offset + 4);\n  if ((rel_offset != 0) && (*(int *)(rel_offset + 0x18) == 0)) {\n    initialize_data_structures_000042a4();\n  }\n  if (data_ptr == (byte **)&DAT_000079b8) {\n    data_ptr = *(byte ***)(rel_offset + 4);\n  }\n  else if (data_ptr == (byte **)&DAT_000079d8) {\n    data_ptr = *(byte ***)(rel_offset + 8);\n  }\n  else if (data_ptr == (byte **)&DAT_00007998) {\n    data_ptr = *(byte ***)(rel_offset + 0xc);\n  }\n  if ((-1 < (int)data_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(data_ptr + 3) << 0x16))) {\n    FUNC_000045e8(data_ptr[0x16]);\n  }\n  byte_ptr = data_ptr[1];\n  data_ptr[1] = byte_ptr + -1;\n  if ((int)(byte_ptr + -1) < 0) {\n    result = process_and_execute_callbacks_00005e10(rel_offset,data_ptr);\n  }\n  else {\n    byte_ptr = *data_ptr;\n    *data_ptr = byte_ptr + 1;\n    result = (uint)*byte_ptr;\n  }\n  if ((-1 < (int)data_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(data_ptr + 3) << 0x16))) {\n    FUNC_000045ec(data_ptr[0x16]);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004418": "execute_and_process_00004418",
                "Elf32_Rel_ARRAY_1fff0200": "rel_array",
                "dVar1": "rel_offset",
                "uVar2": "result",
                "ppbVar3": "data_ptr",
                "pbVar4": "byte_ptr"
            },
            "calling": [
                "FUN_00002d94"
            ],
            "called": [
                "FUN_000042a4",
                "FUN_00005e10",
                "FUN_000045ec",
                "FUN_000045e8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000443c": {
            "entrypoint": "0x0000443c",
            "current_name": "calculate_date_time_0000443c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000044a8) */\n\nuint * calculateDateTime_0000443c(undefined4 *dateTimeParams,uint *dateTimeResult)\n\n{\n  int tempVariable;\n  uint totalMinutes;\n  uint totalSeconds;\n  uint totalDays;\n  uint leapYearPeriods;\n  undefined4 firstParam;\n  undefined4 secondParam;\n  uint tempValue;\n  bool isNegative;\n  \n  firstParam = *dateTimeParams;\n  secondParam = dateTimeParams[1];\n  tempVariable = range_to_00006974(firstParam,secondParam,0x15180,0);\n  totalSeconds = 0x15180;\n  range_to_00006974(firstParam,secondParam,0x15180,0);\n  isNegative = (int)totalSeconds < 0;\n  if (isNegative) {\n    totalSeconds = totalSeconds + 0x15180;\n  }\n  if (isNegative) {\n    totalMinutes = tempVariable + 0xafa6b;\n  }\n  else {\n    totalMinutes = tempVariable + 0xafa6c;\n  }\n  dateTimeResult[2] = totalSeconds / 0xe10;\n  dateTimeResult[1] = (totalSeconds % 0xe10) / 0x3c;\n  *dateTimeResult = (totalSeconds % 0xe10) % 0x3c;\n  dateTimeResult[6] = (totalMinutes + 3) % 7;\n  totalSeconds = totalMinutes;\n  if ((int)totalMinutes < 0) {\n    totalSeconds = totalMinutes - 0x23ab0;\n  }\n  totalMinutes = (totalSeconds / 0x23ab1) * -0x23ab1 + totalMinutes;\n  totalDays = ((totalMinutes / 0x8eac + totalMinutes) - totalMinutes / 0x5b4) - totalMinutes / 0x23ab0;\n  leapYearPeriods = totalDays / 0x16d;\n  totalMinutes = (leapYearPeriods / 100 - totalDays / 0x5b4) + totalMinutes + leapYearPeriods * -0x16d;\n  tempValue = totalMinutes * 5 + 2;\n  totalDays = tempValue / 0x99;\n  if (tempValue < 0x5fa) {\n    tempVariable = 2;\n  }\n  else {\n    tempVariable = -10;\n  }\n  tempValue = totalDays + tempVariable;\n  tempVariable = (totalSeconds / 0x23ab1) * 400 + leapYearPeriods;\n  if (tempValue < 2) {\n    tempVariable = tempVariable + 1;\n  }\n  if (totalMinutes < 0x132) {\n    if (((leapYearPeriods & 3) == 0) && (leapYearPeriods != (leapYearPeriods / 100) * 100)) {\n      totalSeconds = 1;\n    }\n    else {\n      totalSeconds = (uint)(leapYearPeriods % 400 == 0);\n    }\n    totalSeconds = totalMinutes + 0x3b + totalSeconds;\n  }\n  else {\n    totalSeconds = totalMinutes - 0x132;\n  }\n  dateTimeResult[7] = totalSeconds;\n  dateTimeResult[3] = (totalMinutes + 1) - (totalDays * 0x99 + 2) / 5;\n  dateTimeResult[4] = tempValue;\n  dateTimeResult[5] = tempVariable - 0x76c;\n  dateTimeResult[8] = 0;\n  return dateTimeResult;\n}\n\n",
            "renaming": {
                "FUN_0000443c": "calculate_date_time_0000443c",
                "param_1": "dateTimeParams",
                "param_2": "dateTimeResult",
                "uVar2": "totalMinutes",
                "uVar3": "totalSeconds",
                "uVar4": "totalDays",
                "uVar5": "leapYearPeriods",
                "uVar6": "firstParam",
                "uVar7": "secondParam",
                "uVar8": "tempValue",
                "bVar9": "isNegative",
                "iVar1": "tempVariable"
            },
            "calling": [
                "FUN_00002624",
                "FUN_00002690"
            ],
            "called": [
                "FUN_00006974"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000459c": {
            "entrypoint": "0x0000459c",
            "current_name": "execute_function_pointers_0000459c",
            "code": "\nvoid executeFunctionPointers_0000459c(void)\n\n{\n  code **functionPointerArray;\n  int iterationCount;\n  \n  functionPointerArray = (code **)&DAT_00007c58;\n  for (iterationCount = 0; iterationCount != 0; iterationCount = iterationCount + 1) {\n    (**functionPointerArray)();\n    functionPointerArray = functionPointerArray + 1;\n  }\n  initialize_memory_structure_00000410();\n  functionPointerArray = (code **)&DAT_00007c58;\n  for (iterationCount = 0; iterationCount != 0; iterationCount = iterationCount + 1) {\n    (**functionPointerArray)();\n    functionPointerArray = functionPointerArray + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000459c": "execute_function_pointers_0000459c",
                "ppcVar1": "functionPointerArray",
                "iVar2": "iterationCount"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_00000410"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000045e4": {
            "entrypoint": "0x000045e4",
            "current_name": "FUNC_000045e4",
            "code": "\nvoid FUNC_000045e4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e4": "FUNC_000045e4"
            },
            "calling": [
                "FUN_00004314"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045e8": {
            "entrypoint": "0x000045e8",
            "current_name": "FUNC_000045e8",
            "code": "\nvoid FUNC_000045e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e8": "FUNC_000045e8"
            },
            "calling": [
                "FUN_00004418",
                "FUN_00004db8",
                "FUN_00004158",
                "FUN_00005790",
                "FUN_00004cb4",
                "FUN_0000428c",
                "FUN_00005fec",
                "FUN_000057f8",
                "FUN_00004274"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ec": {
            "entrypoint": "0x000045ec",
            "current_name": "FUNC_000045ec",
            "code": "\nvoid FUNC_000045ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045ec": "FUNC_000045ec"
            },
            "calling": [
                "FUN_00004418",
                "FUN_00004db8",
                "FUN_000042a4",
                "FUN_00004158",
                "FUN_00005ff8",
                "FUN_00004cb4",
                "FUN_00004280",
                "FUN_000057f8",
                "FUN_0000579c"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ee": {
            "entrypoint": "0x000045ee",
            "current_name": "copy_in_range_000045ee",
            "code": "\nvoid copyInRange_000045ee(undefined *destination,undefined *source,int length)\n\n{\n  undefined *dstPtr;\n  undefined *srcPtr;\n  \n  srcPtr = source + length;\n  if ((source < destination) && (destination < srcPtr)) {\n    dstPtr = destination + length;\n    while (dstPtr != destination) {\n      srcPtr = srcPtr + -1;\n      dstPtr = dstPtr + -1;\n      *dstPtr = *srcPtr;\n    }\n  }\n  else {\n    destination = destination + -1;\n    for (; source != srcPtr; source = source + 1) {\n      destination = destination + 1;\n      *destination = *source;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045ee": "copy_in_range_000045ee",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "length",
                "puVar1": "dstPtr",
                "puVar2": "srcPtr"
            },
            "calling": [
                "FUN_00003ff4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004622": {
            "entrypoint": "0x00004622",
            "current_name": "fill_array_with_value_00004622",
            "code": "\nvoid fillArrayWithValue_00004622(undefined *array,undefined value,int length)\n\n{\n  undefined *endPointer;\n  \n  endPointer = array + length;\n  for (; array != endPointer; array = array + 1) {\n    *array = value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004622": "fill_array_with_value_00004622",
                "param_1": "array",
                "param_2": "value",
                "param_3": "length",
                "puVar1": "endPointer"
            },
            "calling": [
                "FUN_00003ec4",
                "FUN_000041f4",
                "FUN_00003ff4",
                "FUN_0000305c",
                "FUN_00004314",
                "FUN_00004248"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004634": {
            "entrypoint": "0x00004634",
            "current_name": "update_date_00004634",
            "code": "\nvoid updateDate_00004634(uint *dateArray,uint numDays,undefined4 stackVar)\n\n{\n  int daysInMonth;\n  uint days;\n  uint temp;\n  int daysInYear;\n  bool isNegative;\n  uint *quotientAndRemainder;\n  uint currentDay;\n  undefined4 uStack_18;\n  \n  quotientAndRemainder = dateArray;\n  currentDay = numDays;\n  uStack_18 = stackVar;\n  if (0x3b < *dateArray) {\n    calculate_remainder_and_quotient_00005584(&quotientAndRemainder,*dateArray,0x3c);\n    days = dateArray[1] + (int)quotientAndRemainder;\n    dateArray[1] = days;\n    if ((int)currentDay < 0) {\n      days = days - 1;\n      *dateArray = currentDay + 0x3c;\n    }\n    else {\n      *dateArray = currentDay;\n    }\n    if ((int)currentDay < 0) {\n      dateArray[1] = days;\n    }\n  }\n  if (0x3b < dateArray[1]) {\n    calculate_remainder_and_quotient_00005584(&quotientAndRemainder,dateArray[1],0x3c);\n    isNegative = (int)currentDay < 0;\n    temp = dateArray[2] + (int)quotientAndRemainder;\n    dateArray[2] = temp;\n    days = currentDay;\n    if (isNegative) {\n      days = currentDay + 0x3c;\n      temp = temp - 1;\n    }\n    if (!isNegative) {\n      dateArray[1] = days;\n    }\n    if (isNegative) {\n      dateArray[1] = days;\n    }\n    if (isNegative) {\n      dateArray[2] = temp;\n    }\n  }\n  if (0x17 < dateArray[2]) {\n    calculate_remainder_and_quotient_00005584(&quotientAndRemainder,dateArray[2],0x18);\n    isNegative = (int)currentDay < 0;\n    temp = dateArray[3] + (int)quotientAndRemainder;\n    dateArray[3] = temp;\n    days = currentDay;\n    if (isNegative) {\n      days = currentDay + 0x18;\n      temp = temp - 1;\n    }\n    if (!isNegative) {\n      dateArray[2] = days;\n    }\n    if (isNegative) {\n      dateArray[2] = days;\n    }\n    if (isNegative) {\n      dateArray[3] = temp;\n    }\n  }\n  if (0xb < dateArray[4]) {\n    calculate_remainder_and_quotient_00005584(&quotientAndRemainder,dateArray[4],0xc);\n    isNegative = (int)currentDay < 0;\n    days = dateArray[5] + (int)quotientAndRemainder;\n    dateArray[5] = days;\n    if (isNegative) {\n      currentDay = currentDay + 0xc;\n      days = days - 1;\n    }\n    if (!isNegative) {\n      dateArray[4] = currentDay;\n    }\n    if (isNegative) {\n      dateArray[4] = currentDay;\n    }\n    if (isNegative) {\n      dateArray[5] = days;\n    }\n  }\n  days = dateArray[5];\n  if ((days & 3) == 0) {\n    if (days == (days / 100) * 100) {\n      if ((days + 0x76c) % 400 == 0) {\n        daysInYear = 0x1d;\n      }\n      else {\n        daysInYear = 0x1c;\n      }\n    }\n    else {\n      daysInYear = 0x1d;\n    }\n  }\n  else {\n    daysInYear = 0x1c;\n  }\n  if ((int)dateArray[3] < 1) {\n    while ((int)dateArray[3] < 1) {\n      days = dateArray[4];\n      dateArray[4] = days - 1;\n      if (days - 1 == 0xffffffff) {\n        temp = dateArray[5];\n        days = temp - 1;\n        dateArray[4] = 0xb;\n        dateArray[5] = days;\n        if ((days & 3) == 0) {\n          if (days == (days / 100) * 100) {\n            if ((temp + 0x76b) % 400 == 0) {\n              daysInYear = 0x1d;\n            }\n            else {\n              daysInYear = 0x1c;\n            }\n          }\n          else {\n            daysInYear = 0x1d;\n          }\n        }\n        else {\n          daysInYear = 0x1c;\n        }\n      }\n      daysInMonth = daysInYear;\n      if (dateArray[4] != 1) {\n        daysInMonth = (&DAT_000079fc)[dateArray[4]];\n      }\n      dateArray[3] = daysInMonth + dateArray[3];\n    }\n  }\n  else {\n    while( true ) {\n      days = dateArray[4];\n      daysInMonth = daysInYear;\n      if (days != 1) {\n        daysInMonth = (&DAT_000079fc)[days];\n      }\n      if ((int)dateArray[3] <= daysInMonth) break;\n      dateArray[3] = dateArray[3] - daysInMonth;\n      dateArray[4] = days + 1;\n      if (days + 1 == 0xc) {\n        temp = dateArray[5];\n        days = temp + 1;\n        dateArray[4] = 0;\n        dateArray[5] = days;\n        if ((days & 3) == 0) {\n          if (days % 100 == 0) {\n            if ((temp + 0x76d) % 400 == 0) {\n              daysInYear = 0x1d;\n            }\n            else {\n              daysInYear = 0x1c;\n            }\n          }\n          else {\n            daysInYear = 0x1d;\n          }\n        }\n        else {\n          daysInYear = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004634": "update_date_00004634",
                "param_1": "dateArray",
                "param_2": "numDays",
                "param_3": "stackVar",
                "iVar1": "daysInMonth",
                "uVar2": "days",
                "uVar3": "temp",
                "iVar4": "daysInYear",
                "bVar5": "isNegative",
                "local_20": "quotientAndRemainder",
                "local_1c": "currentDay"
            },
            "calling": [
                "FUN_000047e4"
            ],
            "called": [
                "FUN_00005584"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000047e4": {
            "entrypoint": "0x000047e4",
            "current_name": "calculate_updated_date_000047e4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\nundefined8 calculateUpdatedDate_000047e4(int *inputParameters)\n\n{\n  longlong totalSeconds;\n  longlong updatedTotalSeconds;\n  int *addressPtr;\n  uint tempVar1;\n  int tempVar2;\n  int tempVar3;\n  int tempVar4;\n  uint tempVar5;\n  uint tempVar6;\n  uint tempVar7;\n  int tempVar8;\n  uint tempVar9;\n  uint tempVar10;\n  uint tempVar11;\n  uint tempVar12;\n  bool tempVar13;\n  \n  addressPtr = (int *)get_memory_address_000056b0();\n  update_date_00004634(inputParameters);\n  tempVar9 = inputParameters[5];\n  tempVar8 = inputParameters[3] + -1 + *(int *)(&DAT_00007a2c + inputParameters[4] * 4);\n  if (((1 < inputParameters[4]) && ((tempVar9 & 3) == 0)) &&\n     ((tempVar9 != (tempVar9 / 100) * 100 || (tempVar9 + 0x76c == ((tempVar9 + 0x76c) / 400) * 400)))) {\n    tempVar8 = tempVar8 + 1;\n  }\n  inputParameters[7] = tempVar8;\n  if (20000 < (int)&DAT_00002710 + tempVar9) {\n    tempVar4 = -1;\n    tempVar2 = -1;\n    goto LAB_00004aba;\n  }\n  if ((int)tempVar9 < 0x47) {\n    if (tempVar9 != 0x46) {\n      for (tempVar6 = 0x45; (int)tempVar9 < (int)tempVar6; tempVar6 = tempVar6 - 1) {\n        if ((tempVar6 & 3) == 0) {\n          if (tempVar6 == (tempVar6 / 100) * 100) {\n            if ((tempVar6 + 0x76c) % 400 == 0) {\n              tempVar4 = 0x16e;\n            }\n            else {\n              tempVar4 = 0x16d;\n            }\n          }\n          else {\n            tempVar4 = 0x16e;\n          }\n        }\n        else {\n          tempVar4 = 0x16d;\n        }\n        tempVar8 = tempVar8 - tempVar4;\n      }\n      if ((tempVar6 & 3) == 0) {\n        if (tempVar9 == (tempVar9 / 100) * 100) {\n          tempVar4 = 0x16d;\n          if ((tempVar9 + 0x76c) % 400 == 0) {\n            tempVar4 = 0x16e;\n          }\n        }\n        else {\n          tempVar4 = 0x16e;\n        }\n      }\n      else {\n        tempVar4 = 0x16d;\n      }\n      tempVar8 = tempVar8 - tempVar4;\n    }\n  }\n  else {\n    tempVar6 = 0x46;\n    do {\n      if ((tempVar6 & 3) == 0) {\n        if (tempVar6 % 100 == 0) {\n          if ((tempVar6 + 0x76c) % 400 == 0) {\n            tempVar4 = 0x16e;\n          }\n          else {\n            tempVar4 = 0x16d;\n          }\n        }\n        else {\n          tempVar4 = 0x16e;\n        }\n      }\n      else {\n        tempVar4 = 0x16d;\n      }\n      tempVar6 = tempVar6 + 1;\n      tempVar8 = tempVar8 + tempVar4;\n    } while (tempVar9 != tempVar6);\n  }\n  totalSeconds = (longlong)tempVar8 * 0x15180 + (longlong)(inputParameters[2] * 0xe10 + inputParameters[1] * 0x3c + *inputParameters)\n  ;\n  tempVar12 = (uint)totalSeconds;\n  tempVar4 = (int)((ulonglong)totalSeconds >> 0x20);\n  get_memory_address_000050e8();\n  parse_data_and_update_00005100();\n  tempVar6 = DAT_1fff0dd8;\n  if (DAT_1fff0dd8 == 0) {\nLAB_00004934:\n    tempVar9 = addressPtr[10];\n    tempVar4 = (uint)totalSeconds + tempVar9;\n    tempVar2 = (int)((ulonglong)totalSeconds >> 0x20) +\n            ((int)tempVar9 >> 0x1f) + (uint)CARRY4((uint)totalSeconds,tempVar9);\n  }\n  else {\n    tempVar11 = inputParameters[8];\n    tempVar10 = tempVar11;\n    if (0 < (int)tempVar11) {\n      tempVar10 = 1;\n    }\n    if ((addressPtr[1] == inputParameters[5] + 0x76c) || (tempVar2 = calculate_date_offset_00004f98(), tempVar2 != 0)) {\n      tempVar7 = addressPtr[0x14];\n      tempVar1 = addressPtr[0x12];\n      tempVar5 = addressPtr[10];\n      tempVar6 = tempVar1 - tempVar5;\n      tempVar2 = (addressPtr[0x13] - ((int)tempVar5 >> 0x1f)) - (uint)(tempVar1 < tempVar5);\n      if (((int)((tempVar4 - tempVar2) - (uint)(tempVar12 < tempVar6)) < 0 ==\n           (SBORROW4(tempVar4,tempVar2) != SBORROW4(tempVar4 - tempVar2,(uint)(tempVar12 < tempVar6)))) &&\n         (tempVar3 = (addressPtr[0x13] - ((int)tempVar7 >> 0x1f)) - (uint)(tempVar1 < tempVar7),\n         tempVar13 = tempVar12 < tempVar1 - tempVar7,\n         (int)((tempVar4 - tempVar3) - (uint)tempVar13) < 0 !=\n         (SBORROW4(tempVar4,tempVar3) != SBORROW4(tempVar4 - tempVar3,(uint)tempVar13)))) goto LAB_00004a88;\n      tempVar1 = addressPtr[8] - tempVar7;\n      tempVar3 = (addressPtr[9] - ((int)tempVar7 >> 0x1f)) - (uint)((uint)addressPtr[8] < tempVar7);\n      if (*addressPtr != 0) {\n        if ((int)((tempVar4 - tempVar3) - (uint)(tempVar12 < tempVar1)) < 0 ==\n            (SBORROW4(tempVar4,tempVar3) != SBORROW4(tempVar4 - tempVar3,(uint)(tempVar12 < tempVar1))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        tempVar6 = 0;\n        if ((int)tempVar11 < 0) goto LAB_00004934;\nLAB_00004a14:\n        tempVar12 = tempVar10 ^ tempVar6;\n        tempVar10 = tempVar6;\n        if (tempVar12 == 1) {\n          if (tempVar6 == 0) {\n            tempVar4 = tempVar7 - tempVar5;\n          }\n          else {\n            tempVar4 = tempVar5 - tempVar7;\n          }\n          tempVar2 = inputParameters[3];\n          *inputParameters = *inputParameters + tempVar4;\n          updatedTotalSeconds = totalSeconds + tempVar4;\n          update_date_00004634(inputParameters);\n          tempVar2 = inputParameters[3] - tempVar2;\n          totalSeconds = totalSeconds + tempVar4;\n          if (tempVar2 != 0) {\n            if (tempVar2 < 2) {\n              if (tempVar2 == -2 || tempVar2 + 2 < 0 != SCARRY4(tempVar2,2)) {\n                tempVar2 = 1;\n              }\n            }\n            else {\n              tempVar2 = -1;\n            }\n            tempVar4 = tempVar2 + inputParameters[7];\n            tempVar8 = tempVar8 + tempVar2;\n            if (tempVar4 < 0) {\n              tempVar6 = tempVar9 - 1;\n              if ((tempVar6 & 3) == 0) {\n                if (tempVar6 == (tempVar6 / 100) * 100) {\n                  tempVar4 = 0x16d;\n                  if ((tempVar9 + 0x76b) % 400 != 0) {\n                    tempVar4 = 0x16c;\n                  }\n                }\n                else {\n                  tempVar4 = 0x16d;\n                }\n              }\n              else {\n                tempVar4 = 0x16c;\n              }\n            }\n            else {\n              if ((tempVar9 & 3) == 0) {\n                if (tempVar9 == (tempVar9 / 100) * 100) {\n                  tempVar2 = 0x16d;\n                  if ((tempVar9 + 0x76c) % 400 == 0) {\n                    tempVar2 = 0x16e;\n                  }\n                }\n                else {\n                  tempVar2 = 0x16e;\n                }\n              }\n              else {\n                tempVar2 = 0x16d;\n              }\n              if (tempVar2 <= tempVar4) {\n                tempVar4 = tempVar4 - tempVar2;\n              }\n            }\n            inputParameters[7] = tempVar4;\n            totalSeconds = updatedTotalSeconds;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((tempVar4 - tempVar3) - (uint)(tempVar12 < tempVar1)) < 0 !=\n          (SBORROW4(tempVar4,tempVar3) != SBORROW4(tempVar4 - tempVar3,(uint)(tempVar12 < tempVar1)))) {\nLAB_0000491e:\n        if ((int)((tempVar4 - tempVar2) - (uint)(tempVar12 < tempVar6)) < 0 ==\n            (SBORROW4(tempVar4,tempVar2) != SBORROW4(tempVar4 - tempVar2,(uint)(tempVar12 < tempVar6))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)tempVar11) {\n        tempVar6 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      tempVar6 = tempVar10;\n      if (tempVar10 != 1) goto LAB_00004934;\n    }\n    tempVar9 = addressPtr[0x14];\n    tempVar4 = (uint)totalSeconds + tempVar9;\n    tempVar2 = (int)((ulonglong)totalSeconds >> 0x20) +\n            ((int)tempVar9 >> 0x1f) + (uint)CARRY4((uint)totalSeconds,tempVar9);\n    tempVar6 = 1;\n  }\n  get_start_address_000050f4();\n  inputParameters[8] = tempVar6;\n  inputParameters[6] = (tempVar8 + 4U) % 7;\nLAB_00004aba:\n  return CONCAT44(tempVar2,tempVar4);\n}\n\n",
            "renaming": {
                "FUN_000047e4": "calculate_updated_date_000047e4",
                "param_1": "inputParameters",
                "lVar1": "totalSeconds",
                "lVar2": "updatedTotalSeconds",
                "piVar3": "addressPtr",
                "uVar4": "tempVar1",
                "iVar5": "tempVar2",
                "iVar6": "tempVar3",
                "iVar7": "tempVar4",
                "uVar8": "tempVar5",
                "uVar9": "tempVar6",
                "uVar10": "tempVar7",
                "iVar11": "tempVar8",
                "uVar12": "tempVar9",
                "uVar13": "tempVar10",
                "uVar14": "tempVar11",
                "uVar15": "tempVar12",
                "bVar16": "tempVar13"
            },
            "calling": [
                "FUN_00002600",
                "FUN_00002654"
            ],
            "called": [
                "FUN_00005100",
                "FUN_000050e8",
                "FUN_00004f98",
                "FUN_000050f4",
                "FUN_00004634",
                "FUN_000056b0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004b34": {
            "entrypoint": "0x00004b34",
            "current_name": "initialize_data_and_process_00004b34",
            "code": "\nvoid initializeDataAndProcess_00004b34(undefined4 *outputArray,int arrayLength,undefined4 param3,undefined4 param4)\n\n{\n  int *tempPtr1;\n  int **extraOutputPtr1;\n  int **currentPtr1;\n  int **currentPtr2;\n  int **nextPtr1;\n  int **inputPtr1;\n  bool isEqual;\n  \n  if (arrayLength == 0) {\n    return;\n  }\n  inputPtr1 = (int **)(arrayLength + -4);\n  if (*(int *)(arrayLength + -4) < 0) {\n    inputPtr1 = (int **)((int)inputPtr1 + *(int *)(arrayLength + -4));\n  }\n  initialize_data_00005790();\n  currentPtr2 = (int **)&DAT_1fff0db4;\n  if (DAT_1fff0db4 == (int **)0x0) {\n    inputPtr1[1] = (int *)0x0;\n    currentPtr1 = extraOutputPtr1;\n    DAT_1fff0db4 = inputPtr1;\n  }\n  else {\n    nextPtr1 = DAT_1fff0db4;\n    if (inputPtr1 < DAT_1fff0db4) {\n      currentPtr1 = (int **)*inputPtr1;\n      currentPtr2 = (int **)((int)inputPtr1 + (int)currentPtr1);\n      isEqual = DAT_1fff0db4 == currentPtr2;\n      if (isEqual) {\n        currentPtr2 = (int **)*DAT_1fff0db4;\n        DAT_1fff0db4 = (int **)DAT_1fff0db4[1];\n      }\n      inputPtr1[1] = (int *)DAT_1fff0db4;\n      DAT_1fff0db4 = inputPtr1;\n      if (isEqual) {\n        currentPtr2 = (int **)((int)currentPtr2 + (int)currentPtr1);\n        *inputPtr1 = (int *)currentPtr2;\n      }\n    }\n    else {\n      do {\n        currentPtr2 = nextPtr1;\n        nextPtr1 = (int **)currentPtr2[1];\n        if (nextPtr1 == (int **)0x0) break;\n      } while (nextPtr1 <= inputPtr1);\n      currentPtr1 = (int **)*currentPtr2;\n      if ((int **)((int)currentPtr2 + (int)currentPtr1) == inputPtr1) {\n        currentPtr1 = (int **)((int)currentPtr1 + (int)*inputPtr1);\n        *currentPtr2 = (int *)currentPtr1;\n        if (nextPtr1 == (int **)((int)currentPtr2 + (int)currentPtr1)) {\n          tempPtr1 = *nextPtr1;\n          currentPtr2[1] = nextPtr1[1];\n          currentPtr1 = (int **)((int)currentPtr1 + (int)tempPtr1);\n          *currentPtr2 = (int *)currentPtr1;\n        }\n      }\n      else if (inputPtr1 < (int **)((int)currentPtr2 + (int)currentPtr1)) {\n        *outputArray = 0xc;\n      }\n      else {\n        currentPtr1 = (int **)((int)inputPtr1 + (int)*inputPtr1);\n        isEqual = nextPtr1 == currentPtr1;\n        if (isEqual) {\n          currentPtr1 = (int **)*nextPtr1;\n          nextPtr1 = (int **)nextPtr1[1];\n        }\n        inputPtr1[1] = (int *)nextPtr1;\n        if (isEqual) {\n          currentPtr1 = (int **)((int)currentPtr1 + (int)*inputPtr1);\n          *inputPtr1 = (int *)currentPtr1;\n        }\n        currentPtr2[1] = (int *)inputPtr1;\n      }\n    }\n  }\n  initialize_data_0000579c(outputArray,currentPtr1,currentPtr2,param4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004b34": "initialize_data_and_process_00004b34",
                "param_1": "outputArray",
                "param_2": "arrayLength",
                "param_3": "param3",
                "param_4": "param4",
                "piVar1": "tempPtr1",
                "extraout_r1": "extraOutputPtr1",
                "ppiVar2": "currentPtr1",
                "ppiVar3": "currentPtr2",
                "ppiVar4": "nextPtr1",
                "ppiVar5": "inputPtr1",
                "bVar6": "isEqual"
            },
            "calling": [
                "FUN_0000404c",
                "FUN_00006192",
                "FUN_00005780",
                "FUN_000054a8",
                "FUN_00006768",
                "FUN_000060cc"
            ],
            "called": [
                "FUN_00005790",
                "FUN_0000579c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004bd0": {
            "entrypoint": "0x00004bd0",
            "current_name": "allocate_memory_00004bd0",
            "code": "\nuint allocate_memory_00004bd0(undefined4 *result,uint size,undefined4 arg_3,undefined4 arg_4)\n\n{\n  uint *current_node;\n  int difference;\n  uint remaining_space;\n  uint *previous_node;\n  uint adjusted_size;\n  \n  adjusted_size = (size + 3 & 0xfffffffc) + 8;\n  if (adjusted_size < 0xc) {\n    adjusted_size = 0xc;\n  }\n  if (((int)adjusted_size < 0) || (adjusted_size < size)) {\n    *result = 0xc;\n  }\n  else {\n    initialize_data_00005790();\n    current_node = DAT_1fff0db4;\n    for (previous_node = DAT_1fff0db4; previous_node != (uint *)0x0; previous_node = (uint *)previous_node[1]) {\n      remaining_space = *previous_node - adjusted_size;\n      if (-1 < (int)remaining_space) {\n        if (0xb < remaining_space) {\n          *previous_node = remaining_space;\n          previous_node = (uint *)((int)previous_node + remaining_space);\n          goto LAB_00004c34;\n        }\n        if (current_node == previous_node) {\n          DAT_1fff0db4 = (uint *)previous_node[1];\n        }\n        if (current_node != previous_node) {\n          current_node[1] = (uint)(uint *)previous_node[1];\n        }\n        goto LAB_00004c42;\n      }\n      current_node = previous_node;\n    }\n    if (DAT_1fff0db8 == 0) {\n      DAT_1fff0db8 = get_offset_and_update_00000428(result,0,current_node,0,arg_4);\n    }\n    current_node = (uint *)get_offset_and_update_00000428(result,adjusted_size);\n    if ((current_node != (uint *)0xffffffff) &&\n       ((previous_node = (uint *)((int)current_node + 3U & 0xfffffffc), current_node == previous_node ||\n        (difference = get_offset_and_update_00000428(result,(int)previous_node - (int)current_node), difference != -1)))) {\nLAB_00004c34:\n      *previous_node = adjusted_size;\nLAB_00004c42:\n      initialize_data_0000579c(result);\n      adjusted_size = (int)previous_node + 0xbU & 0xfffffff8;\n      difference = adjusted_size - (int)(previous_node + 1);\n      if (difference == 0) {\n        return adjusted_size;\n      }\n      *(uint *)((int)previous_node + difference) = (int)(previous_node + 1) - adjusted_size;\n      return adjusted_size;\n    }\n    *result = 0xc;\n    initialize_data_0000579c(result);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "param_1": "result",
                "param_2": "size",
                "param_3": "arg_3",
                "param_4": "arg_4",
                "puVar1": "current_node",
                "iVar2": "difference",
                "uVar3": "remaining_space",
                "puVar4": "previous_node",
                "uVar5": "adjusted_size"
            },
            "calling": [
                "FUN_00005100",
                "FUN_000068f0",
                "FUN_000060cc",
                "FUN_00005700",
                "FUN_00004248"
            ],
            "called": [
                "FUN_00005790",
                "FUN_00000428",
                "FUN_0000579c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004c84": {
            "entrypoint": "0x00004c84",
            "current_name": "initialize_and_process_data_00004c84",
            "code": "\nvoid initialize_and_process_data_00004c84(undefined4 input_param,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  dword r_offset;\n  undefined4 input_copy;\n  undefined4 param_2_copy;\n  undefined4 param_3_copy;\n  undefined4 param_4_copy;\n  \n  r_offset = Elf32_Rel_ARRAY_1fff0200[16].r_offset;\n  input_copy = input_param;\n  param_2_copy = param_2;\n  param_3_copy = param_3;\n  param_4_copy = param_4;\n  if ((Elf32_Rel_ARRAY_1fff0200[16].r_offset != 0) &&\n     (*(int *)(Elf32_Rel_ARRAY_1fff0200[16].r_offset + 0x18) == 0)) {\n    initialize_data_structures_000042a4(Elf32_Rel_ARRAY_1fff0200[16].r_offset);\n  }\n  parse_and_process_data_000057f8(r_offset,*(undefined4 *)(r_offset + 8),input_param,&param_2_copy,input_copy,&param_2_copy);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004c84": "initialize_and_process_data_00004c84",
                "param_1": "input_param",
                "dVar1": "r_offset",
                "uVar2": "input_copy",
                "uStack_c": "param_2_copy",
                "uStack_8": "param_3_copy",
                "uStack_4": "param_4_copy"
            },
            "calling": [
                "FUN_00000ed8",
                "FUN_00003694",
                "FUN_00002fe0",
                "FUN_00002b10",
                "FUN_00002a88",
                "FUN_0000211c",
                "FUN_00002f74",
                "FUN_00003524",
                "FUN_00002ecc",
                "FUN_0000316c",
                "FUN_00000f04",
                "FUN_00003378",
                "FUN_0000305c"
            ],
            "called": [
                "FUN_000042a4",
                "FUN_000057f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004cb4": {
            "entrypoint": "0x00004cb4",
            "current_name": "process_data_00004cb4",
            "code": "\nuint process_data_00004cb4(uint input_value)\n\n{\n  dword offset;\n  undefined4 *pointer;\n  uint counter;\n  undefined *data_puvar4;\n  undefined4 unaffected_register4;\n  undefined4 unaffected_register5;\n  \n  offset = Elf32_Rel_ARRAY_1fff0200[16].r_offset;\n  if ((Elf32_Rel_ARRAY_1fff0200[16].r_offset != 0) &&\n     (*(int *)(Elf32_Rel_ARRAY_1fff0200[16].r_offset + 0x18) == 0)) {\n    initialize_data_structures_000042a4(Elf32_Rel_ARRAY_1fff0200[16].r_offset);\n  }\n  pointer = *(undefined4 **)(offset + 8);\n  if ((offset != 0) && (*(int *)(offset + 0x18) == 0)) {\n    initialize_data_structures_000042a4();\n  }\n  if (pointer == &DAT_000079b8) {\n    pointer = *(undefined4 **)(offset + 4);\n  }\n  else if (pointer == (undefined4 *)&DAT_000079d8) {\n    pointer = *(undefined4 **)(offset + 8);\n  }\n  else if (pointer == (undefined4 *)&DAT_00007998) {\n    pointer = *(undefined4 **)(offset + 0xc);\n  }\n  if ((-1 < (int)(pointer[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(pointer + 3) << 0x16))) {\n    FUNC_000045e8(pointer[0x16]);\n  }\n  counter = pointer[2] - 1;\n  pointer[2] = counter;\n  if (((int)counter < 0) && (((int)counter < (int)pointer[6] || (counter = input_value & 0xff, counter == 10))))\n  {\n    input_value = process_and_update_data_00005404(offset,input_value,pointer,counter,unaffected_register4,unaffected_register5);\n  }\n  else {\n    data_puvar4 = (undefined *)*pointer;\n    *pointer = data_puvar4 + 1;\n    *data_puvar4 = (char)input_value;\n    input_value = input_value & 0xff;\n  }\n  if ((-1 < (int)(pointer[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(pointer + 3) << 0x16))) {\n    FUNC_000045ec(pointer[0x16]);\n  }\n  return input_value;\n}\n\n",
            "renaming": {
                "FUN_00004cb4": "process_data_00004cb4",
                "param_1": "input_value",
                "dVar1": "offset",
                "puVar2": "pointer",
                "uVar3": "counter",
                "puVar4": "data_puvar4",
                "unaff_r4": "unaffected_register4",
                "unaff_r5": "unaffected_register5"
            },
            "calling": [
                "FUN_00002a00"
            ],
            "called": [
                "FUN_000042a4",
                "FUN_00005404",
                "FUN_000045ec",
                "FUN_000045e8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004db8": {
            "entrypoint": "0x00004db8",
            "current_name": "process_data_00004db8",
            "code": "\nundefined4 processData_00004db8(int input)\n\n{\n  char character;\n  dword offset;\n  int result;\n  char *strPtr;\n  char **dataPtr;\n  undefined4 returnValue;\n  char *currentChar;\n  \n  offset = Elf32_Rel_ARRAY_1fff0200[16].r_offset;\n  if ((Elf32_Rel_ARRAY_1fff0200[16].r_offset != 0) &&\n     (*(int *)(Elf32_Rel_ARRAY_1fff0200[16].r_offset + 0x18) == 0)) {\n    initialize_data_structures_000042a4();\n  }\n  dataPtr = *(char ***)(offset + 8);\n  if (*(int *)(offset + 0x18) == 0) {\n    initialize_data_structures_000042a4(offset);\n  }\n  if (dataPtr == (char **)&DAT_000079b8) {\n    dataPtr = *(char ***)(offset + 4);\n  }\n  else if (dataPtr == (char **)&DAT_000079d8) {\n    dataPtr = *(char ***)(offset + 8);\n  }\n  else if (dataPtr == (char **)&DAT_00007998) {\n    dataPtr = *(char ***)(offset + 0xc);\n  }\n  if ((-1 < (int)dataPtr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(dataPtr + 3) << 0x16))) {\n    FUNC_000045e8(dataPtr[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(dataPtr + 3) << 0x1c) < 0) && (dataPtr[4] != (char *)0x0)) ||\n     (result = process_data_000054a8(offset,dataPtr), result == 0)) {\n    currentChar = (char *)(input + -1);\n    do {\n      while( true ) {\n        currentChar = currentChar + 1;\n        character = *currentChar;\n        strPtr = dataPtr[2] + -1;\n        dataPtr[2] = strPtr;\n        if (character == '\\0') {\n          if (-1 < (int)strPtr) {\n            currentChar = *dataPtr;\n            returnValue = 10;\n            *dataPtr = currentChar + 1;\n            *currentChar = '\\n';\n            goto LAB_00004d64;\n          }\n          result = process_and_update_data_00005404(offset,10,dataPtr);\n          if (result != -1) {\n            returnValue = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)strPtr < 0) && (((int)strPtr < (int)dataPtr[6] || (character == '\\n')))) break;\n        strPtr = *dataPtr;\n        *dataPtr = strPtr + 1;\n        *strPtr = character;\n      }\n      result = process_and_update_data_00005404(offset,character,dataPtr);\n    } while (result != -1);\n  }\nLAB_00004d60:\n  returnValue = 0xffffffff;\nLAB_00004d64:\n  if ((-1 < (int)dataPtr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(dataPtr + 3) << 0x16))) {\n    FUNC_000045ec(dataPtr[0x16]);\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00004db8": "process_data_00004db8",
                "param_1": "input",
                "cVar1": "character",
                "dVar2": "offset",
                "iVar3": "result",
                "pcVar4": "strPtr",
                "ppcVar5": "dataPtr",
                "uVar6": "returnValue",
                "pcVar7": "currentChar"
            },
            "calling": [
                "FUN_00003694",
                "FUN_00003478",
                "FUN_00002fe0",
                "FUN_000031e0",
                "FUN_00002b10",
                "FUN_00002a88",
                "FUN_000033f4",
                "FUN_00002f74",
                "FUN_000034c0",
                "FUN_00003444",
                "FUN_00002f30",
                "FUN_0000305c",
                "FUN_000033c0",
                "FUN_000023a4"
            ],
            "called": [
                "FUN_000042a4",
                "FUN_00005404",
                "FUN_000054a8",
                "FUN_000045ec",
                "FUN_000045e8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dc8": {
            "entrypoint": "0x00004dc8",
            "current_name": "handle_interrupt_00004dc8",
            "code": "\nvoid handle_interrupt_00004dc8(undefined4 interrupt_handler,int data_ptr)\n\n{\n  int interrupt_result;\n  uint updated_value;\n  bool is_interrupt_valid;\n  \n  interrupt_result = handle_interrupt_00004dc8s_00000490(interrupt_handler,(int)*(short *)(data_ptr + 0xe));\n  is_interrupt_valid = -1 < interrupt_result;\n  if (is_interrupt_valid) {\n    updated_value = *(int *)(data_ptr + 0x54) + interrupt_result;\n  }\n  else {\n    updated_value = *(ushort *)(data_ptr + 0xc) & 0xffffefff;\n  }\n  if (is_interrupt_valid) {\n    *(uint *)(data_ptr + 0x54) = updated_value;\n  }\n  if (!is_interrupt_valid) {\n    *(short *)(data_ptr + 0xc) = (short)updated_value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004dc8": "handle_interrupt_00004dc8",
                "param_1": "interrupt_handler",
                "param_2": "data_ptr",
                "iVar1": "interrupt_result",
                "uVar2": "updated_value",
                "bVar3": "is_interrupt_valid"
            },
            "calling": [],
            "called": [
                "FUN_00000490"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dee": {
            "entrypoint": "0x00004dee",
            "current_name": "process_data_00004dee",
            "code": "\nundefined4 processData_00004dee(undefined4 dataBuffer,int dataAddress,undefined4 sourceData,undefined4 destinationData)\n\n{\n  undefined4 returnValue;\n  \n  if ((int)((uint)*(ushort *)(dataAddress + 0xc) << 0x17) < 0) {\n    initialize_value_and_return_000004f2(dataBuffer,(int)*(short *)(dataAddress + 0xe),0,2);\n  }\n  *(ushort *)(dataAddress + 0xc) = *(ushort *)(dataAddress + 0xc) & 0xefff;\n  returnValue = copy_data_and_return_00000e38(sourceData,destinationData);\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00004dee": "process_data_00004dee",
                "param_1": "dataBuffer",
                "param_2": "dataAddress",
                "param_3": "sourceData",
                "param_4": "destinationData",
                "uVar1": "returnValue"
            },
            "calling": [],
            "called": [
                "FUN_000004f2",
                "FUN_00000e38"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e26": {
            "entrypoint": "0x00004e26",
            "current_name": "update_parameter_00004e26",
            "code": "\nvoid updateParameter_00004e26(undefined4 data,int offset)\n\n{\n  int value;\n  ushort updatedValue;\n  bool isInvalid;\n  \n  value = initialize_value_and_return_000004f2(data,(int)*(short *)(offset + 0xe));\n  isInvalid = value == -1;\n  if (isInvalid) {\n    updatedValue = *(ushort *)(offset + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(offset + 0x54) = value;\n    updatedValue = *(ushort *)(offset + 0xc) | 0x1000;\n  }\n  if (isInvalid) {\n    *(ushort *)(offset + 0xc) = updatedValue;\n  }\n  if (!isInvalid) {\n    *(ushort *)(offset + 0xc) = updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004e26": "update_parameter_00004e26",
                "param_1": "data",
                "param_2": "offset",
                "iVar1": "value",
                "uVar2": "updatedValue",
                "bVar3": "isInvalid"
            },
            "calling": [],
            "called": [
                "FUN_000004f2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e52": {
            "entrypoint": "0x00004e52",
            "current_name": "compare_byte_arrays_00004e52",
            "code": "\nint compareByteArrays_00004e52(byte *array1,byte *array2)\n\n{\n  byte byte2;\n  uint byte1;\n  bool isMatch;\n  \n  do {\n    byte1 = (uint)*array1;\n    byte2 = *array2;\n    isMatch = byte1 == 1;\n    if (byte1 != 0) {\n      isMatch = byte1 == byte2;\n    }\n    array1 = array1 + 1;\n    array2 = array2 + 1;\n  } while (isMatch);\n  return byte1 - byte2;\n}\n\n",
            "renaming": {
                "FUN_00004e52": "compare_byte_arrays_00004e52",
                "param_1": "array1",
                "param_2": "array2",
                "bVar1": "byte2",
                "uVar2": "byte1",
                "bVar3": "isMatch"
            },
            "calling": [
                "FUN_00005100",
                "FUN_00002a18",
                "FUN_00004e52",
                "FUN_00002fe0",
                "FUN_0000316c",
                "FUN_00002b10"
            ],
            "called": [
                "FUN_00004e52"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e66": {
            "entrypoint": "0x00004e66",
            "current_name": "compare_and_subtract_00004e66",
            "code": "\nint compare_and_subtract_00004e66(byte *data,int offset,int length)\n\n{\n  byte *data_ptr;\n  int result;\n  byte *compare_ptr;\n  uint compare_value;\n  \n  if (length == 0) {\n    result = 0;\n  }\n  else {\n    compare_ptr = (byte *)(offset + -1);\n    data_ptr = data;\n    do {\n      compare_value = (uint)*data_ptr;\n      compare_ptr = compare_ptr + 1;\n      if ((compare_value != *compare_ptr) || (data_ptr + 1 == data + length)) break;\n      data_ptr = data_ptr + 1;\n    } while (compare_value != 0);\n    result = compare_value - *compare_ptr;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004e66": "compare_and_subtract_00004e66",
                "param_1": "data",
                "param_2": "offset",
                "param_3": "length",
                "pbVar1": "data_ptr",
                "iVar2": "result",
                "pbVar3": "compare_ptr",
                "uVar4": "compare_value"
            },
            "calling": [
                "FUN_00003524",
                "FUN_0000562c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f84": {
            "entrypoint": "0x00004f84",
            "current_name": "convert_string_to_number_00004f84",
            "code": "\nuint convertStringToNumber_00004f84(byte *inputString,byte **outputPointer,uint base)\n\n{\n  uint result;\n  uint currentChar;\n  uint isNegative;\n  uint digitValue;\n  int comparisonResult;\n  uint maxValue;\n  uint quotient;\n  byte *currentPointer;\n  byte *nextPointer;\n  \n  nextPointer = inputString;\n  do {\n    currentPointer = nextPointer;\n    nextPointer = currentPointer + 1;\n    currentChar = (uint)*currentPointer;\n    isNegative = (byte)(&DAT_00007a99)[currentChar] & 8;\n  } while (((&DAT_00007a99)[currentChar] & 8) != 0);\n  if (currentChar == 0x2d) {\n    currentChar = (uint)*nextPointer;\n    isNegative = 1;\n    nextPointer = currentPointer + 2;\n  }\n  else if (currentChar == 0x2b) {\n    currentChar = (uint)*nextPointer;\n    nextPointer = currentPointer + 2;\n  }\n  if (base == 0) {\n    if (currentChar != 0x30) {\n      base = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((base != 0x10) || (currentChar != 0x30)) goto LAB_00004ed6;\n  if ((*nextPointer & 0xdf) == 0x58) {\n    currentChar = (uint)nextPointer[1];\n    base = 0x10;\n    nextPointer = nextPointer + 2;\n  }\n  else {\n    currentChar = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00004ed6:\n  maxValue = isNegative + 0x7fffffff;\n  comparisonResult = 0;\n  quotient = maxValue / base;\n  result = 0;\n  do {\n    digitValue = currentChar - 0x30;\n    if (9 < digitValue) {\n      if (currentChar - 0x41 < 0x1a) {\n        digitValue = currentChar - 0x37;\n      }\n      else {\n        if (0x19 < currentChar - 0x61) break;\n        digitValue = currentChar - 0x57;\n      }\n    }\n    if ((int)base <= (int)digitValue) break;\n    if (comparisonResult != -1) {\n      if ((quotient < result) || ((quotient == result && ((int)(maxValue - base * quotient) < (int)digitValue)))) {\n        comparisonResult = -1;\n      }\n      else {\n        result = result * base + digitValue;\n        comparisonResult = 1;\n      }\n    }\n    currentChar = (uint)*nextPointer;\n    nextPointer = nextPointer + 1;\n  } while( true );\n  if (comparisonResult == -1) {\n    *(undefined4 *)Elf32_Rel_ARRAY_1fff0200[16].r_offset = 0x22;\n    result = maxValue;\n    if (outputPointer == (byte **)0x0) {\n      return maxValue;\n    }\n  }\n  else {\n    if (isNegative != 0) {\n      result = -result;\n    }\n    if (outputPointer == (byte **)0x0) {\n      return result;\n    }\n    if (comparisonResult == 0) goto LAB_00004f64;\n  }\n  inputString = nextPointer + -1;\nLAB_00004f64:\n  *outputPointer = inputString;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004f84": "convert_string_to_number_00004f84",
                "param_1": "inputString",
                "param_2": "outputPointer",
                "param_3": "base",
                "uVar1": "result",
                "uVar2": "currentChar",
                "uVar3": "isNegative",
                "uVar4": "digitValue",
                "iVar5": "comparisonResult",
                "uVar6": "maxValue",
                "uVar7": "quotient",
                "pbVar8": "currentPointer",
                "pbVar9": "nextPointer"
            },
            "calling": [
                "FUN_00004042",
                "FUN_0000328c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f98": {
            "entrypoint": "0x00004f98",
            "current_name": "calculate_date_offset_00004f98",
            "code": "\nundefined4 calculate_date_offset_00004f98(uint year)\n\n{\n  uint *date_info;\n  undefined4 is_leap_year;\n  uint days_offset;\n  int calculation_result;\n  uint *current_date_info;\n  int total_offset;\n  uint is_leap_year_check;\n  int month_index;\n  int day_offset;\n  uint is_leap_year_multiplier;\n  \n  date_info = (uint *)get_memory_address_000056b0();\n  if ((int)year < 0x7b2) {\n    is_leap_year = 0;\n  }\n  else {\n    total_offset = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) +\n            (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n    date_info[1] = year;\n    is_leap_year_multiplier = (uint)(year % 400 == 0);\n    current_date_info = date_info;\n    do {\n      days_offset = current_date_info[5];\n      if (*(char *)(current_date_info + 2) == 'J') {\n        if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n          if ((int)days_offset < 0x3c) {\n            calculation_result = 0;\n          }\n          else {\n            calculation_result = 1;\n          }\n        }\n        else {\n          calculation_result = 0;\n        }\n        calculation_result = calculation_result + total_offset + days_offset + -1;\n      }\n      else if (*(char *)(current_date_info + 2) == 'D') {\n        calculation_result = total_offset + days_offset;\n      }\n      else {\n        is_leap_year_check = is_leap_year_multiplier;\n        if (((year & 3) == 0) && (year % 100 != 0)) {\n          is_leap_year_check = 1;\n        }\n        month_index = 0;\n        calculation_result = total_offset;\n        while( true ) {\n          month_index = month_index + 1;\n          if ((int)current_date_info[3] <= month_index) break;\n          calculation_result = calculation_result + *(int *)(&UNK_00007b98 + month_index * 4 + is_leap_year_check * 0x30);\n        }\n        day_offset = days_offset - (calculation_result + 4U) % 7;\n        if (day_offset < 0) {\n          day_offset = day_offset + 7;\n        }\n        for (day_offset = (current_date_info[4] - 1) * 7 + day_offset;\n            *(int *)(&UNK_00007b98 + month_index * 4 + is_leap_year_check * 0x30) <= day_offset; day_offset = day_offset + -7) {\n        }\n        calculation_result = calculation_result + day_offset;\n      }\n      days_offset = current_date_info[10] + calculation_result * 0x15180 + current_date_info[6];\n      current_date_info[8] = days_offset;\n      current_date_info[9] = (int)days_offset >> 0x1f;\n      current_date_info = current_date_info + 10;\n    } while (date_info + 0x14 != current_date_info);\n    days_offset = date_info[9];\n    is_leap_year_multiplier = date_info[0x13];\n    *date_info = (uint)((int)((days_offset - is_leap_year_multiplier) - (uint)(date_info[8] < date_info[0x12])) < 0 !=\n                    (SBORROW4(days_offset,is_leap_year_multiplier) !=\n                    SBORROW4(days_offset - is_leap_year_multiplier,(uint)(date_info[8] < date_info[0x12]))));\n    is_leap_year = 1;\n  }\n  return is_leap_year;\n}\n\n",
            "renaming": {
                "FUN_00004f98": "calculate_date_offset_00004f98",
                "param_1": "year",
                "puVar1": "date_info",
                "uVar2": "is_leap_year",
                "uVar3": "days_offset",
                "iVar4": "calculation_result",
                "puVar5": "current_date_info",
                "iVar6": "total_offset",
                "uVar7": "is_leap_year_check",
                "iVar8": "month_index",
                "iVar9": "day_offset",
                "uVar10": "is_leap_year_multiplier"
            },
            "calling": [
                "FUN_00005100",
                "FUN_000047e4"
            ],
            "called": [
                "FUN_000056b0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000050e8": {
            "entrypoint": "0x000050e8",
            "current_name": "get_memory_address_000050e8",
            "code": "\nundefined * get_memory_address_000050e8(void)\n\n{\n  return &DAT_1fff0deb;\n}\n\n",
            "renaming": {
                "FUN_000050e8": "get_memory_address_000050e8"
            },
            "calling": [
                "FUN_000047e4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000050f4": {
            "entrypoint": "0x000050f4",
            "current_name": "get_start_address_000050f4",
            "code": "\nundefined * getStartAddress_000050f4(void)\n\n{\n  return &DAT_1fff0deb;\n}\n\n",
            "renaming": {
                "FUN_000050f4": "get_start_address_000050f4"
            },
            "calling": [
                "FUN_000047e4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005100": {
            "entrypoint": "0x00005100",
            "current_name": "parse_data_and_update_00005100",
            "code": "\nvoid parseDataAndUpdate_00005100(void)\n\n{\n  dword offset;\n  int memoryAddress;\n  char *stringValue;\n  int comparisonResult;\n  int processResult;\n  undefined dataType;\n  char *pointerValue;\n  bool isFirstIteration;\n  ushort *ptrValue1;\n  int *pointerIndex1;\n  ushort *ptrValue2;\n  int *pointerIndex2;\n  ushort parsedValue1;\n  ushort parsedValue2;\n  ushort parsedValue3;\n  ushort parsedValue4;\n  ushort parsedValue5;\n  ushort parsedValue6;\n  int parsedValueOffset;\n  char *localArray [2];\n  \n  offset = Elf32_Rel_ARRAY_1fff0200[16].r_offset;\n  memoryAddress = get_memory_address_000056b0();\n  stringValue = (char *)find_and_update_variable_000056a0(offset,&DAT_00007a5c);\n  if (stringValue == (char *)0x0) {\n    Elf32_Rel_ARRAY_1fff0200[28].r_info = (dword)&DAT_00007a5f;\n    Elf32_Rel_ARRAY_1fff0200[29].r_offset = (dword)&DAT_00007a5f;\n    DAT_1fff0dd8 = stringValue;\n    DAT_1fff0ddc = stringValue;\n    initialize_data_and_process_00005780(DAT_1fff0dd4);\n    DAT_1fff0dd4 = 0;\n  }\n  else if ((DAT_1fff0dd4 == 0) || (comparisonResult = compare_byte_arrays_00004e52(), comparisonResult != 0)) {\n    initialize_data_and_process_00005780(DAT_1fff0dd4);\n    comparisonResult = find_string_length_00005ecc(stringValue);\n    DAT_1fff0dd4 = allocate_memory_00004bd0(offset,comparisonResult + 1);\n    if (DAT_1fff0dd4 != 0) {\n      copy_string_00005ebc(DAT_1fff0dd4,stringValue);\n    }\n    if (*stringValue == ':') {\n      stringValue = stringValue + 1;\n    }\n    comparisonResult = process_data_00005e68(stringValue,\"%10[^0-9,+-]%n\",&DAT_1fff0dc7,&parsedValueOffset);\n    if (0 < comparisonResult) {\n      pointerValue = stringValue + parsedValueOffset;\n      if (stringValue[parsedValueOffset] == '-') {\n        pointerValue = pointerValue + 1;\n        comparisonResult = -1;\n      }\n      else {\n        if (stringValue[parsedValueOffset] == '+') {\n          pointerValue = pointerValue + 1;\n        }\n        comparisonResult = 1;\n      }\n      parsedValue2 = 0;\n      parsedValue3 = 0;\n      ptrValue1 = &parsedValue2;\n      pointerIndex1 = &parsedValueOffset;\n      ptrValue2 = &parsedValue3;\n      pointerIndex2 = &parsedValueOffset;\n      processResult = process_data_00005e68(pointerValue,\"%hu%n:%hu%n:%hu%n\",&parsedValue1,&parsedValueOffset,&parsedValue2,&parsedValueOffset,\n                           &parsedValue3,&parsedValueOffset);\n      if (0 < processResult) {\n        *(uint *)(memoryAddress + 0x28) =\n             ((uint)parsedValue1 * 0xe10 + (uint)parsedValue2 * 0x3c + (uint)parsedValue3) * comparisonResult;\n        Elf32_Rel_ARRAY_1fff0200[28].r_info = (dword)&DAT_1fff0dc7;\n        pointerValue = pointerValue + parsedValueOffset;\n        comparisonResult = process_data_00005e68(pointerValue,\"%10[^0-9,+-]%n\",&DAT_1fff0dbc,&parsedValueOffset,ptrValue1,pointerIndex1,ptrValue2,\n                             pointerIndex2);\n        if (comparisonResult < 1) {\n          Elf32_Rel_ARRAY_1fff0200[29].r_offset = Elf32_Rel_ARRAY_1fff0200[28].r_info;\n          DAT_1fff0ddc = *(char **)(memoryAddress + 0x28);\n          DAT_1fff0dd8 = (char *)0x0;\n        }\n        else {\n          Elf32_Rel_ARRAY_1fff0200[29].r_offset = (dword)&DAT_1fff0dbc;\n          stringValue = pointerValue + parsedValueOffset;\n          if (pointerValue[parsedValueOffset] == '-') {\n            stringValue = stringValue + 1;\n            comparisonResult = -1;\n          }\n          else {\n            if (pointerValue[parsedValueOffset] == '+') {\n              stringValue = stringValue + 1;\n            }\n            comparisonResult = 1;\n          }\n          parsedValue1 = 0;\n          parsedValue2 = 0;\n          parsedValue3 = 0;\n          parsedValueOffset = 0;\n          processResult = process_data_00005e68(stringValue,\"%hu%n:%hu%n:%hu%n\",&parsedValue1,&parsedValueOffset,&parsedValue2,&parsedValueOffset,\n                               &parsedValue3,&parsedValueOffset);\n          if (processResult < 1) {\n            comparisonResult = *(int *)(memoryAddress + 0x28) + -0xe10;\n          }\n          else {\n            comparisonResult = ((uint)parsedValue1 * 0xe10 + (uint)parsedValue2 * 0x3c + (uint)parsedValue3) * comparisonResult;\n          }\n          *(int *)(memoryAddress + 0x50) = comparisonResult;\n          stringValue = stringValue + parsedValueOffset;\n          isFirstIteration = false;\n          comparisonResult = memoryAddress;\n          while( true ) {\n            if (*stringValue == ',') {\n              stringValue = stringValue + 1;\n            }\n            if (*stringValue == 'M') {\n              processResult = process_data_00005e68(stringValue,\"M%hu%n.%hu%n.%hu%n\",&parsedValue4,&parsedValueOffset,&parsedValue5,\n                                   &parsedValueOffset,&parsedValue6,&parsedValueOffset);\n              if (processResult != 3) {\n                return;\n              }\n              if (0xb < parsedValue4 - 1) {\n                return;\n              }\n              if (4 < parsedValue5 - 1) {\n                return;\n              }\n              if (6 < parsedValue6) {\n                return;\n              }\n              *(uint *)(comparisonResult + 0xc) = (uint)parsedValue4;\n              *(uint *)(comparisonResult + 0x10) = (uint)parsedValue5;\n              *(undefined *)(comparisonResult + 8) = 0x4d;\n              *(uint *)(comparisonResult + 0x14) = (uint)parsedValue6;\n              pointerValue = stringValue + parsedValueOffset;\n            }\n            else {\n              if (*stringValue == 'J') {\n                stringValue = stringValue + 1;\n                dataType = 0x4a;\n              }\n              else {\n                dataType = 0x44;\n              }\n              parsedValue6 = parse_and_process_number_00005fd8(stringValue,localArray,10);\n              pointerValue = localArray[0];\n              if (localArray[0] == stringValue) {\n                if (isFirstIteration) {\n                  *(undefined *)(memoryAddress + 0x30) = 0x4d;\n                  *(undefined4 *)(memoryAddress + 0x34) = 0xb;\n                  *(undefined4 *)(memoryAddress + 0x38) = 1;\n                  *(undefined4 *)(memoryAddress + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(memoryAddress + 8) = 0x4d;\n                  *(undefined4 *)(memoryAddress + 0xc) = 3;\n                  *(undefined4 *)(memoryAddress + 0x10) = 2;\n                  *(undefined4 *)(memoryAddress + 0x14) = 0;\n                }\n              }\n              else {\n                *(undefined *)(comparisonResult + 8) = dataType;\n                *(uint *)(comparisonResult + 0x14) = (uint)parsedValue6;\n              }\n            }\n            parsedValue1 = 2;\n            parsedValue2 = 0;\n            parsedValue3 = 0;\n            parsedValueOffset = 0;\n            if (*pointerValue == '/') {\n              process_data_00005e68(pointerValue,&DAT_00007a85,&parsedValue1,&parsedValueOffset,&parsedValue2,&parsedValueOffset,&parsedValue3,\n                           &parsedValueOffset);\n            }\n            *(uint *)(comparisonResult + 0x18) =\n                 (uint)parsedValue1 * 0xe10 + (uint)parsedValue2 * 0x3c + (uint)parsedValue3;\n            comparisonResult = comparisonResult + 0x28;\n            stringValue = pointerValue + parsedValueOffset;\n            if (isFirstIteration) break;\n            isFirstIteration = true;\n          }\n          calculate_date_offset_00004f98(*(undefined4 *)(memoryAddress + 4));\n          DAT_1fff0ddc = *(char **)(memoryAddress + 0x28);\n          DAT_1fff0dd8 = (char *)(*(int *)(memoryAddress + 0x50) - (int)DAT_1fff0ddc);\n          if (DAT_1fff0dd8 != (char *)0x0) {\n            DAT_1fff0dd8 = (char *)0x1;\n          }\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005100": "parse_data_and_update_00005100",
                "dVar1": "offset",
                "iVar2": "memoryAddress",
                "pcVar3": "stringValue",
                "iVar4": "comparisonResult",
                "iVar5": "processResult",
                "uVar6": "dataType",
                "pcVar7": "pointerValue",
                "bVar8": "isFirstIteration",
                "puVar9": "ptrValue1",
                "piVar10": "pointerIndex1",
                "puVar11": "ptrValue2",
                "piVar12": "pointerIndex2",
                "local_3c": "parsedValue1",
                "local_3a": "parsedValue2",
                "local_38": "parsedValue3",
                "local_36": "parsedValue4",
                "local_34": "parsedValue5",
                "local_32": "parsedValue6",
                "local_30": "parsedValueOffset",
                "local_2c": "localArray"
            },
            "calling": [
                "FUN_000047e4"
            ],
            "called": [
                "FUN_00005ecc",
                "FUN_00004e52",
                "FUN_00005e68",
                "FUN_00004bd0",
                "FUN_00005780",
                "FUN_00004f98",
                "FUN_00005fd8",
                "FUN_00005ebc",
                "FUN_000056b0",
                "FUN_000056a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005404": {
            "entrypoint": "0x00005404",
            "current_name": "process_and_update_data_00005404",
            "code": "\nuint process_and_update_data_00005404(int arg1,uint arg2,int *arg3,undefined4 arg4)\n\n{\n  int temp1;\n  uint temp2;\n  undefined *ptr;\n  \n  if ((arg1 != 0) && (*(int *)(arg1 + 0x18) == 0)) {\n    initialize_data_structures();\n  }\n  if (arg3 == &DAT_000079b8) {\n    arg3 = *(int **)(arg1 + 4);\n  }\n  else if (arg3 == (int *)&DAT_000079d8) {\n    arg3 = *(int **)(arg1 + 8);\n  }\n  else if (arg3 == (int *)&DAT_00007998) {\n    arg3 = *(int **)(arg1 + 0xc);\n  }\n  arg3[2] = arg3[6];\n  temp2 = (uint)*(ushort *)(arg3 + 3);\n  temp1 = temp2 << 0x1c;\n  if (((temp1 < 0) && (temp2 = arg3[4], temp2 != 0)) ||\n     (temp1 = process_data(arg1,arg3,temp1,temp2,arg4), temp1 == 0)) {\n    temp1 = *arg3 - arg3[4];\n    arg2 = arg2 & 0xff;\n    if ((temp1 < arg3[5]) || (temp1 = process_data(arg1,arg3), temp1 == 0)) {\n      arg3[2] = arg3[2] + -1;\n      ptr = (undefined *)*arg3;\n      *arg3 = (int)(ptr + 1);\n      *ptr = (char)arg2;\n      if (arg3[5] != temp1 + 1) {\n        if (-1 < (int)((uint)*(ushort *)(arg3 + 3) << 0x1f)) {\n          return arg2;\n        }\n        if (arg2 != 10) {\n          return arg2;\n        }\n      }\n      temp1 = process_data(arg1,arg3);\n      if (temp1 == 0) {\n        return arg2;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00005404": "process_and_update_data_00005404",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "iVar1": "temp1",
                "uVar2": "temp2",
                "puVar3": "ptr",
                "initialize_data_structures_000042a4": "initialize_data_structures",
                "process_data_000054a8": "process_data",
                "process_data_00004158": "process_data"
            },
            "calling": [
                "FUN_00004db8",
                "FUN_000057a8",
                "FUN_00004cb4"
            ],
            "called": [
                "FUN_000042a4",
                "FUN_00004158",
                "FUN_000054a8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000054a8": {
            "entrypoint": "0x000054a8",
            "current_name": "process_data_000054a8",
            "code": "\nuint processData_000054a8(undefined4 *output,undefined4 *input)\n\n{\n  ushort value1;\n  dword offset;\n  ushort value2;\n  uint temp1;\n  uint temp2;\n  \n  offset = Elf32_Rel_ARRAY_1fff0200[16].r_offset;\n  if ((Elf32_Rel_ARRAY_1fff0200[16].r_offset != 0) &&\n     (*(int *)(Elf32_Rel_ARRAY_1fff0200[16].r_offset + 0x18) == 0)) {\n    initialize_data_structures_000042a4(Elf32_Rel_ARRAY_1fff0200[16].r_offset);\n  }\n  if (input == &DAT_000079b8) {\n    input = *(undefined4 **)(offset + 4);\n  }\n  else if (input == (undefined4 *)&DAT_000079d8) {\n    input = *(undefined4 **)(offset + 8);\n  }\n  else if (input == (undefined4 *)&DAT_00007998) {\n    input = *(undefined4 **)(offset + 0xc);\n  }\n  temp1 = (uint)*(ushort *)(input + 3);\n  value2 = *(ushort *)(input + 3);\n  if (-1 < (int)(temp1 << 0x1c)) {\n    if (-1 < (int)(temp1 << 0x1b)) {\n      *output = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(temp1 << 0x1d) < 0) {\n      if ((undefined4 *)input[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)input[0xd] != input + 0x11) {\n          initialize_data_and_process_00004b34(output);\n        }\n        input[0xd] = 0;\n      }\n      *(ushort *)(input + 3) = *(ushort *)(input + 3) & 0xffdb;\n      input[1] = 0;\n      *input = input[4];\n    }\n    *(ushort *)(input + 3) = *(ushort *)(input + 3) | 8;\n  }\n  if ((input[4] == 0) && ((*(ushort *)(input + 3) & 0x280) != 0x200)) {\n    validate_and_allocate_memory_00005700(output,input);\n  }\n  value1 = *(ushort *)(input + 3);\n  temp1 = (uint)value1;\n  value2 = *(ushort *)(input + 3);\n  temp2 = temp1 & 1;\n  if ((value1 & 1) == 0) {\n    if (-1 < (int)(temp1 << 0x1e)) {\n      temp2 = input[5];\n    }\n    input[2] = temp2;\n  }\n  else {\n    input[2] = 0;\n    input[6] = -input[5];\n  }\n  if (input[4] != 0) {\n    return 0;\n  }\n  if ((value1 & 0x80) == 0) {\n    return temp1 & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(input + 3) = value2 | 0x40;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000054a8": "process_data_000054a8",
                "param_1": "output",
                "param_2": "input",
                "uVar1": "value1",
                "dVar2": "offset",
                "uVar3": "value2",
                "uVar4": "temp1",
                "uVar5": "temp2"
            },
            "calling": [
                "FUN_00004db8",
                "FUN_00005404",
                "FUN_000057f8"
            ],
            "called": [
                "FUN_000042a4",
                "FUN_00004b34",
                "FUN_00005700"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": [],
            "code_backup": "\nuint FUN_000054a8(undefined4 *param_1,undefined4 *param_2)\n\n{\n  ushort uVar1;\n  dword dVar2;\n  ushort uVar3;\n  uint uVar4;\n  uint uVar5;\n  \n  dVar2 = Elf32_Rel_ARRAY_1fff0200[16].r_offset;\n  if ((Elf32_Rel_ARRAY_1fff0200[16].r_offset != 0) &&\n     (*(int *)(Elf32_Rel_ARRAY_1fff0200[16].r_offset + 0x18) == 0)) {\n    FUNC_000042a4(Elf32_Rel_ARRAY_1fff0200[16].r_offset);\n  }\n  if (param_2 == &DAT_000079b8) {\n    param_2 = *(undefined4 **)(dVar2 + 4);\n  }\n  else if (param_2 == (undefined4 *)&DAT_000079d8) {\n    param_2 = *(undefined4 **)(dVar2 + 8);\n  }\n  else if (param_2 == (undefined4 *)&DAT_00007998) {\n    param_2 = *(undefined4 **)(dVar2 + 0xc);\n  }\n  uVar4 = (uint)*(ushort *)(param_2 + 3);\n  uVar3 = *(ushort *)(param_2 + 3);\n  if (-1 < (int)(uVar4 << 0x1c)) {\n    if (-1 < (int)(uVar4 << 0x1b)) {\n      *param_1 = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(uVar4 << 0x1d) < 0) {\n      if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n          initialize_data_and_process_00004b34(param_1);\n        }\n        param_2[0xd] = 0;\n      }\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xffdb;\n      param_2[1] = 0;\n      *param_2 = param_2[4];\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] == 0) && ((*(ushort *)(param_2 + 3) & 0x280) != 0x200)) {\n    validate_and_allocate_memory_00005700(param_1,param_2);\n  }\n  uVar1 = *(ushort *)(param_2 + 3);\n  uVar4 = (uint)uVar1;\n  uVar3 = *(ushort *)(param_2 + 3);\n  uVar5 = uVar4 & 1;\n  if ((uVar1 & 1) == 0) {\n    if (-1 < (int)(uVar4 << 0x1e)) {\n      uVar5 = param_2[5];\n    }\n    param_2[2] = uVar5;\n  }\n  else {\n    param_2[2] = 0;\n    param_2[6] = -param_2[5];\n  }\n  if (param_2[4] != 0) {\n    return 0;\n  }\n  if ((uVar1 & 0x80) == 0) {\n    return uVar4 & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(param_2 + 3) = uVar3 | 0x40;\n  return 0xffffffff;\n}\n\n"
        },
        "FUN_00005584": {
            "entrypoint": "0x00005584",
            "current_name": "calculate_remainder_and_quotient_00005584",
            "code": "\nvoid calculate_remainder_and_quotient_00005584(uint *quotient_ptr,uint dividend,uint divisor)\n\n{\n  uint remainder;\n  uint quotient;\n  \n  quotient = dividend / divisor;\n  remainder = dividend - divisor * quotient;\n  if ((int)dividend < 0) {\n    if (0 < (int)remainder) {\n      quotient = quotient - 1;\n      remainder = remainder + divisor;\n    }\n  }\n  else if ((int)remainder < 0) {\n    quotient = quotient + 1;\n    remainder = remainder - divisor;\n  }\n  *quotient_ptr = quotient;\n  quotient_ptr[1] = remainder;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005584": "calculate_remainder_and_quotient_00005584",
                "param_1": "quotient_ptr",
                "param_2": "dividend",
                "param_3": "divisor",
                "uVar1": "remainder",
                "uVar2": "quotient"
            },
            "calling": [
                "FUN_00004634"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000562c": {
            "entrypoint": "0x0000562c",
            "current_name": "find_variable_0000562c",
            "code": "\nint findVariable_0000562c(undefined4 memory,char *string,int *resultIndex)\n\n{\n  char currentChar;\n  int *pointerToVariable;\n  int comparisonResult;\n  char *ptr;\n  int *currentPointer;\n  int stringOffset;\n  \n  initialize_memory_00005fec();\n  ptr = string;\n  if (Elf32_Rel_ARRAY_1fff0200[41].r_offset != 0) {\n    do {\n      currentChar = *ptr;\n      if (currentChar == '\\0') {\n        stringOffset = (int)ptr - (int)string;\n        pointerToVariable = (int *)Elf32_Rel_ARRAY_1fff0200[41].r_offset;\n        while( true ) {\n          currentPointer = pointerToVariable;\n          if (*currentPointer == 0) break;\n          comparisonResult = compare_and_subtract_00004e66(*currentPointer,string,stringOffset);\n          pointerToVariable = currentPointer + 1;\n          if ((comparisonResult == 0) && (comparisonResult = *currentPointer, *(char *)(comparisonResult + stringOffset) == '=')) {\n            *resultIndex = (int)((int)currentPointer - Elf32_Rel_ARRAY_1fff0200[41].r_offset) >> 2;\n            initialize_memory_00005ff8(memory);\n            return comparisonResult + stringOffset + 1;\n          }\n        }\n        break;\n      }\n      ptr = ptr + 1;\n    } while (currentChar != '=');\n  }\n  initialize_memory_00005ff8(memory);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000562c": "find_variable_0000562c",
                "param_1": "memory",
                "param_2": "string",
                "param_3": "resultIndex",
                "cVar1": "currentChar",
                "piVar2": "pointerToVariable",
                "iVar3": "comparisonResult",
                "pcVar4": "ptr",
                "piVar5": "currentPointer",
                "iVar6": "stringOffset"
            },
            "calling": [
                "FUN_000056a0"
            ],
            "called": [
                "FUN_00005ff8",
                "FUN_00004e66",
                "FUN_00005fec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056a0": {
            "entrypoint": "0x000056a0",
            "current_name": "find_and_update_variable_000056a0",
            "code": "\nvoid find_and_update_variable_000056a0(undefined4 original_value,undefined4 variable_1,undefined4 variable_2,undefined4 update_value)\n\n{\n  undefined4 variable_3;\n  undefined4 variable_4;\n  \n  variable_3 = variable_1;\n  variable_4 = variable_2;\n  find_variable_0000562c(original_value,variable_1,&variable_3,update_value,original_value);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000056a0": "find_and_update_variable_000056a0",
                "param_1": "original_value",
                "param_2": "variable_1",
                "param_3": "variable_2",
                "param_4": "update_value",
                "uStack_c": "variable_3",
                "uStack_8": "variable_4"
            },
            "calling": [
                "FUN_00005100"
            ],
            "called": [
                "FUN_0000562c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056b0": {
            "entrypoint": "0x000056b0",
            "current_name": "get_memory_address_000056b0",
            "code": "\nuint32_t getMemoryAddress_000056b0(void)\n\n{\n  return 0x1fff02f0;\n}\n\n",
            "renaming": {
                "FUN_000056b0": "get_memory_address_000056b0",
                "undefined4": "uint32_t"
            },
            "calling": [
                "FUN_00005100",
                "FUN_000047e4",
                "FUN_00004f98"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056b8": {
            "entrypoint": "0x000056b8",
            "current_name": "determine_access_permissions_000056b8",
            "code": "\nundefined4 determineAccessPermissions_000056b8(undefined4 inputValue,int dataPointer,undefined4 *outputValue,uint *resultPointer)\n\n{\n  int returnValue;\n  undefined4 accessPermissions;\n  undefined temporaryValue [4];\n  uint flags;\n  \n  if ((*(short *)(dataPointer + 0xe) < 0) ||\n     (returnValue = set_value_and_return_00000514(inputValue,(int)*(short *)(dataPointer + 0xe),temporaryValue), returnValue < 0)) {\n    *resultPointer = 0;\n    if ((int)((uint)*(ushort *)(dataPointer + 0xc) << 0x18) < 0) {\n      accessPermissions = 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    *resultPointer = (uint)((flags & 0xf000) == 0x2000);\n  }\n  accessPermissions = 0x400;\nLAB_000056f8:\n  *outputValue = accessPermissions;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000056b8": "determine_access_permissions_000056b8",
                "param_1": "inputValue",
                "param_2": "dataPointer",
                "param_3": "outputValue",
                "param_4": "resultPointer",
                "iVar1": "returnValue",
                "uVar2": "accessPermissions",
                "auStack_68": "temporaryValue",
                "local_64": "flags"
            },
            "calling": [
                "FUN_00005700"
            ],
            "called": [
                "FUN_00000514"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005700": {
            "entrypoint": "0x00005700",
            "current_name": "validate_and_allocate_memory_00005700",
            "code": "\nvoid validateAndAllocateMemory_00005700(int baseAddress,int *memoryInfo)\n\n{\n  ushort accessPermissions;\n  int allocatedMemory;\n  int allocationSize;\n  int *paramValidity;\n  \n  if (-1 < (int)((uint)*(ushort *)(memoryInfo + 3) << 0x1e)) {\n    allocationSize = baseAddress;\n    paramValidity = memoryInfo;\n    accessPermissions = determineAccessPermissions(baseAddress,memoryInfo,&allocationSize,&paramValidity);\n    allocatedMemory = allocateMemory(baseAddress,allocationSize);\n    if (allocatedMemory != 0) {\n      *(undefined **)(baseAddress + 0x28) = &DAT_0000423d;\n      *memoryInfo = allocatedMemory;\n      *(ushort *)(memoryInfo + 3) = *(ushort *)(memoryInfo + 3) | 0x80;\n      memoryInfo[5] = allocationSize;\n      memoryInfo[4] = allocatedMemory;\n      if ((paramValidity != (int *)0x0) &&\n         (allocatedMemory = checkParameterValidity(baseAddress,(int)*(short *)((int)memoryInfo + 0xe)), allocatedMemory != 0)) {\n        *(ushort *)(memoryInfo + 3) = *(ushort *)(memoryInfo + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(memoryInfo + 3) = accessPermissions | *(ushort *)(memoryInfo + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(memoryInfo + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(memoryInfo + 3) = *(ushort *)(memoryInfo + 3) & 0xfffc | 2;\n  }\n  *memoryInfo = (int)memoryInfo + 0x47;\n  memoryInfo[4] = (int)memoryInfo + 0x47;\n  memoryInfo[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005700": "validate_and_allocate_memory_00005700",
                "param_1": "baseAddress",
                "param_2": "memoryInfo",
                "uVar1": "accessPermissions",
                "iVar2": "allocatedMemory",
                "local_18": "allocationSize",
                "local_14": "paramValidity",
                "determine_access_permissions_000056b8": "determineAccessPermissions",
                "allocate_memory_00004bd0": "allocateMemory",
                "check_param_validity_00000534": "checkParameterValidity"
            },
            "calling": [
                "FUN_000054a8",
                "FUN_00006768"
            ],
            "called": [
                "FUN_00004bd0",
                "FUN_000056b8",
                "FUN_00000534"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005780": {
            "entrypoint": "0x00005780",
            "current_name": "initialize_data_and_process_00005780",
            "code": "\nvoid initializeDataAndProcess_00005780(undefined4 inputParam)\n\n{\n  initialize_data_and_process_00004b34(Elf32_Rel_ARRAY_1fff0200[16].offset,inputParam);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005780": "initialize_data_and_process_00005780",
                "param_1": "inputParam",
                "r_offset": "offset"
            },
            "calling": [
                "FUN_00005100"
            ],
            "called": [
                "FUN_00004b34"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005790": {
            "entrypoint": "0x00005790",
            "current_name": "initialize_data_00005790",
            "code": "\nvoid initializeData_00005790(void)\n\n{\n  FUNC_000045e8(&DAT_1fff0de8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005790": "initialize_data_00005790"
            },
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "called": [
                "FUN_000045e8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000579c": {
            "entrypoint": "0x0000579c",
            "current_name": "initialize_data_0000579c",
            "code": "\nvoid initializeData_0000579c(void)\n\n{\n  FUNC_000045ec(&DAT_1fff0de8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000579c": "initialize_data_0000579c"
            },
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "called": [
                "FUN_000045ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057a8": {
            "entrypoint": "0x000057a8",
            "current_name": "update_data_000057a8",
            "code": "\nint updateData_000057a8(undefined4 arg1,int arg2,undefined4 *data)\n\n{\n  int count;\n  undefined *ptr;\n  \n  count = data[2] + -1;\n  data[2] = count;\n  if ((count < 0) && ((count < (int)data[6] || (arg2 == 10)))) {\n    count = processData();\n    return count;\n  }\n  ptr = (undefined *)*data;\n  *data = ptr + 1;\n  *ptr = (char)arg2;\n  return arg2;\n}\n\n",
            "renaming": {
                "FUN_000057a8": "update_data_000057a8",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "data",
                "iVar1": "count",
                "puVar2": "ptr",
                "process_and_update_data_00005404": "processData"
            },
            "calling": [
                "FUN_000057d2"
            ],
            "called": [
                "FUN_00005404"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057d2": {
            "entrypoint": "0x000057d2",
            "current_name": "update_data_000057d2",
            "code": "\nint update_data_000057d2(undefined4 input_1,undefined4 input_2,undefined *data,int length)\n\n{\n  int updated_length;\n  undefined *end_of_data;\n  int original_length;\n  \n  end_of_data = data + length;\n  original_length = length;\n  do {\n    if (data == end_of_data) {\n      return 0;\n    }\n    updated_length = update_data_000057d2_000057a8(input_1,*data,input_2,length,original_length);\n    length = updated_length + 1;\n    data = data + 1;\n  } while (length != 0);\n  return updated_length;\n}\n\n",
            "renaming": {
                "FUN_000057d2": "update_data_000057d2",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "updated_length",
                "puVar2": "end_of_data",
                "iVar3": "original_length"
            },
            "calling": [
                "FUN_000057f8"
            ],
            "called": [
                "FUN_000057a8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057f8": {
            "entrypoint": "0x000057f8",
            "current_name": "parse_and_process_data_000057f8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000059f0) */\n\nint parseAndProcessData_000057f8(int dataStruct,undefined4 *paramPtr,byte *data,int *intPtr)\n\n{\n  int result;\n  int updateResult;\n  int *intPtr2;\n  bool isNumber;\n  byte *dataPtr;\n  int unused;\n  byte *currentDataPtr;\n  int *intArray;\n  uint flags;\n  int value;\n  undefined4 unusedVar;\n  int count;\n  int totalCount;\n  byte currentChar;\n  undefined unused;\n  undefined unused;\n  undefined conversionChar;\n  undefined4 unusedVar;\n  \n  if ((dataStruct != 0) && (*(int *)(dataStruct + 0x18) == 0)) {\n    initialize_data_structures_000042a4();\n  }\n  if (paramPtr == &DAT_000079b8) {\n    paramPtr = *(undefined4 **)(dataStruct + 4);\n  }\n  else if (paramPtr == (undefined4 *)&DAT_000079d8) {\n    paramPtr = *(undefined4 **)(dataStruct + 8);\n  }\n  else if (paramPtr == (undefined4 *)&DAT_00007998) {\n    paramPtr = *(undefined4 **)(dataStruct + 0xc);\n  }\n  if ((-1 < (int)(paramPtr[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(paramPtr + 3) << 0x16))) {\n    FUNC_000045e8(paramPtr[0x16]);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(paramPtr + 3) << 0x1c)) || (paramPtr[4] == 0)) &&\n     (result = process_data_000054a8(dataStruct,paramPtr), result != 0)) {\n    if ((-1 < (int)(paramPtr[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(paramPtr + 3) << 0x16)))\n    {\n      FUNC_000045ec(paramPtr[0x16]);\n    }\n    return -1;\n  }\n  totalCount = 0;\n  unused = 0x20;\n  unused = 0x30;\n  currentDataPtr = data;\n  intArray = intPtr;\nLAB_0000588e:\n  dataPtr = currentDataPtr;\n  if (*dataPtr != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  currentDataPtr = dataPtr + 1;\n  if (*dataPtr == 0x25) {\nLAB_0000589a:\n    result = (int)dataPtr - (int)data;\n    if (result != 0) {\n      updateResult = update_data_000057d2(dataStruct,paramPtr,data,result);\n      if (updateResult == -1) {\nLAB_00005a06:\n        if ((-1 < (int)(paramPtr[0x19] << 0x1f)) &&\n           (-1 < (int)((uint)*(ushort *)(paramPtr + 3) << 0x16))) {\n          FUNC_000045ec(paramPtr[0x16]);\n        }\n        if ((int)((uint)*(ushort *)(paramPtr + 3) << 0x19) < 0) {\n          return -1;\n        }\n        return totalCount;\n      }\n      totalCount = totalCount + result;\n    }\n    if (*dataPtr == 0) goto LAB_00005a06;\n    value = -1;\n    unusedVar = 0;\n    flags = 0;\n    count = 0;\n    conversionChar = 0;\n    unusedVar = 0;\n    currentDataPtr = dataPtr + 1;\n    while( true ) {\n      dataPtr = currentDataPtr + 1;\n      result = find_byte_sequence_00006010(\"#-0+ \",*currentDataPtr,5);\n      if (result == 0) break;\n      flags = 1 << (result - 0x7bfcU & 0xff) | flags;\n      currentDataPtr = dataPtr;\n    }\n    if ((int)(flags << 0x1b) < 0) {\n      conversionChar = 0x20;\n    }\n    if ((int)(flags << 0x1c) < 0) {\n      conversionChar = 0x2b;\n    }\n    if (*currentDataPtr == 0x2a) {\n      intPtr2 = intArray + 1;\n      count = *intArray;\n      intArray = intPtr2;\n      if (count < 0) {\n        count = -count;\n        flags = flags | 2;\n      }\n    }\n    else {\n      isNumber = false;\n      result = count;\n      dataPtr = currentDataPtr;\n      while( true ) {\n        if (9 < *dataPtr - 0x30) break;\n        result = result * 10 + (*dataPtr - 0x30);\n        isNumber = true;\n        dataPtr = dataPtr + 1;\n      }\n      if (isNumber) {\n        count = result;\n      }\n    }\n    if (*dataPtr == 0x2e) {\n      if (dataPtr[1] == 0x2a) {\n        value = *intArray;\n        if (value < 0) {\n          value = -1;\n        }\n        dataPtr = dataPtr + 2;\n        intArray = intArray + 1;\n      }\n      else {\n        isNumber = false;\n        value = 0;\n        result = 0;\n        while( true ) {\n          dataPtr = dataPtr + 1;\n          if (9 < *dataPtr - 0x30) break;\n          result = result * 10 + (*dataPtr - 0x30);\n          isNumber = true;\n        }\n        if (isNumber) {\n          value = result;\n        }\n      }\n    }\n    result = find_byte_sequence_00006010(&DAT_00007c02,*dataPtr,3);\n    if (result != 0) {\n      flags = flags | 0x40 << (result - 0x7c02U & 0xff);\n      dataPtr = dataPtr + 1;\n    }\n    data = dataPtr + 1;\n    currentChar = *dataPtr;\n    result = find_byte_sequence_00006010(\"efgEFG\",currentChar,6);\n    if (result == 0) {\n      unused = convert_to_string_00005b34(dataStruct,&flags,paramPtr,0x57d3,&intArray);\n      if (unused == -1) goto LAB_00005a06;\n    }\n    else {\n      intArray = (int *)(((int)intArray + 7U & 0xfffffff8) + 8);\n    }\n    totalCount = totalCount + unused;\n    currentDataPtr = data;\n  }\n  goto LAB_0000588e;\n}\n\n",
            "renaming": {
                "FUN_000057f8": "parse_and_process_data_000057f8",
                "param_1": "dataStruct",
                "param_2": "paramPtr",
                "param_3": "data",
                "param_4": "intPtr",
                "iVar1": "result",
                "iVar2": "updateResult",
                "piVar3": "intPtr2",
                "bVar4": "isNumber",
                "pbVar5": "dataPtr",
                "unaff_r7": "unused",
                "pbVar6": "currentDataPtr",
                "local_8c": "intArray",
                "local_88": "flags",
                "local_84": "value",
                "uStack_80": "unusedVar",
                "local_7c": "count",
                "local_74": "totalCount",
                "local_70": "currentChar",
                "local_6f": "unused",
                "local_6e": "unused",
                "local_45": "conversionChar",
                "local_30": "unusedVar"
            },
            "calling": [
                "FUN_00004c84"
            ],
            "called": [
                "FUN_000042a4",
                "FUN_000057d2",
                "FUN_00005b34",
                "FUN_000054a8",
                "FUN_000045ec",
                "FUN_00006010",
                "FUN_000045e8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005a58": {
            "entrypoint": "0x00005a58",
            "current_name": "calculate_data_length_00005a58",
            "code": "\nundefined4\ncalculateDataLength_00005a58(undefined4 param1,uint *data,uint *dataLength,undefined4 param4,code *callbackFunc)\n\n{\n  int i;\n  undefined4 result;\n  int returnValue;\n  uint maxDataLength;\n  uint u;\n  bool isFlagSet;\n  \n  maxDataLength = data[4];\n  if ((int)data[4] < (int)data[2]) {\n    maxDataLength = data[2];\n  }\n  *dataLength = maxDataLength;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *dataLength = maxDataLength + 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *dataLength = *dataLength + 2;\n  }\n  if ((*data & 6) == 0) {\n    for (i = 0; i < (int)(data[3] - *dataLength); i = i + 1) {\n      returnValue = (*callbackFunc)(param1,param4,(int)data + 0x19,1);\n      if (returnValue == -1) goto LAB_00005afc;\n    }\n  }\n  maxDataLength = (uint)*(byte *)((int)data + 0x43);\n  if (maxDataLength != 0) {\n    maxDataLength = 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *(undefined *)((int)data + maxDataLength + 0x43) = 0x30;\n    *(undefined *)((int)data + maxDataLength + 0x44) = *(undefined *)((int)data + 0x45);\n    maxDataLength = maxDataLength + 2;\n  }\n  i = (*callbackFunc)(param1,param4,(int)data + 0x43,maxDataLength);\n  if (i == -1) {\nLAB_00005afc:\n    result = 0xffffffff;\n  }\n  else {\n    maxDataLength = data[3];\n    isFlagSet = (*data & 6) == 4;\n    if (isFlagSet) {\n      maxDataLength = maxDataLength - *dataLength;\n    }\n    if (isFlagSet) {\n      maxDataLength = maxDataLength & ~((int)maxDataLength >> 0x1f);\n    }\n    else {\n      maxDataLength = 0;\n    }\n    if ((int)data[4] < (int)data[2]) {\n      maxDataLength = maxDataLength + (data[2] - data[4]);\n    }\n    for (u = 0; maxDataLength != u; u = u + 1) {\n      i = (*callbackFunc)(param1,param4,(int)data + 0x1a,1);\n      if (i == -1) goto LAB_00005afc;\n    }\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005a58": "calculate_data_length_00005a58",
                "param_1": "param1",
                "param_2": "data",
                "param_3": "dataLength",
                "param_4": "param4",
                "param_5": "callbackFunc",
                "iVar1": "i",
                "uVar2": "result",
                "iVar3": "returnValue",
                "uVar4": "maxDataLength",
                "uVar5": "u",
                "bVar6": "isFlagSet"
            },
            "calling": [
                "FUN_00005b34"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005b34": {
            "entrypoint": "0x00005b34",
            "current_name": "convert_to_string_00005b34",
            "code": "\ncode * convertToString_00005b34(undefined4 input,uint *convertedValue,undefined4 param_3,code *conversionFunc,uint **paramList\n                   )\n\n{\n  bool isLessThan;\n  byte byteVal;\n  int index;\n  code *result;\n  char *hexChars;\n  int returnValue;\n  char *charPtr;\n  uint quotient;\n  uint *ptrValue;\n  uint numberBase;\n  uint **ptrParamList;\n  char **charPtrParamList;\n  uint dataLength;\n  char *outputString;\n  code *tempCodePtr;\n  \n  byteVal = *(byte *)(convertedValue + 6);\n  charPtr = (char *)((int)convertedValue + 0x43);\n  tempCodePtr = conversionFunc;\n  if (0x78 < byteVal) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)convertedValue + 0x42) = byteVal;\nLAB_00005bdc:\n    charPtr = (char *)((int)convertedValue + 0x42);\n    quotient = 1;\nLAB_00005d28:\n    convertedValue[4] = quotient;\n    *(undefined *)((int)convertedValue + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (byteVal < 99) {\n    if (byteVal == 0) goto LAB_00005d06;\n    if (byteVal == 0x58) {\n      hexChars = \"0123456789ABCDEF\";\n      *(undefined *)((int)convertedValue + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(byteVal) {\n  case 99:\n    quotient = **paramList;\n    *paramList = *paramList + 1;\n    *(char *)((int)convertedValue + 0x42) = (char)quotient;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    numberBase = *convertedValue;\n    ptrValue = *paramList;\n    if ((int)(numberBase << 0x18) < 0) {\n      quotient = *ptrValue;\n      *paramList = ptrValue + 1;\n    }\n    else {\n      quotient = *ptrValue;\n      *paramList = ptrValue + 1;\n      if ((numberBase & 0x40) != 0) {\n        quotient = (uint)(short)quotient;\n      }\n    }\n    if ((int)quotient < 0) {\n      quotient = -quotient;\n      *(undefined *)((int)convertedValue + 0x43) = 0x2d;\n    }\n    hexChars = \"0123456789ABCDEF\";\n    numberBase = 10;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ptrParamList = (uint **)*paramList;\n    numberBase = *convertedValue;\n    quotient = convertedValue[5];\n    *paramList = (uint *)(ptrParamList + 1);\n    ptrValue = *ptrParamList;\n    if (((int)(numberBase << 0x18) < 0) || (-1 < (int)(numberBase << 0x19))) {\n      *ptrValue = quotient;\n    }\n    else {\n      *(short *)ptrValue = (short)quotient;\n    }\nLAB_00005d06:\n    convertedValue[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    ptrValue = *paramList;\n    quotient = *convertedValue;\n    *paramList = ptrValue + 1;\n    if (((int)(quotient << 0x18) < 0) || (-1 < (int)(quotient << 0x19))) {\n      quotient = *ptrValue;\n    }\n    else {\n      quotient = (uint)*(ushort *)ptrValue;\n    }\n    hexChars = \"0123456789ABCDEF\";\n    if (byteVal == 0x6f) {\n      numberBase = 8;\n    }\n    else {\n      numberBase = 10;\n    }\n    break;\n  case 0x70:\n    *convertedValue = *convertedValue | 0x20;\n  case 0x78:\n    hexChars = \"0123456789abcdef\";\n    *(undefined *)((int)convertedValue + 0x45) = 0x78;\nLAB_00005ca8:\n    numberBase = *convertedValue;\n    quotient = **paramList;\n    *paramList = *paramList + 1;\n    if ((-1 < (int)(numberBase << 0x18)) && ((int)(numberBase << 0x19) < 0)) {\n      quotient = quotient & 0xffff;\n    }\n    if ((int)(numberBase << 0x1f) < 0) {\n      *convertedValue = numberBase | 0x20;\n    }\n    if (quotient == 0) {\n      *convertedValue = *convertedValue & 0xffffffdf;\n    }\n    numberBase = 0x10;\n    break;\n  case 0x73:\n    charPtrParamList = (char **)*paramList;\n    *paramList = (uint *)(charPtrParamList + 1);\n    charPtr = *charPtrParamList;\n    index = find_byte_sequence_00006010(charPtr,0,convertedValue[1],charPtrParamList,input,convertedValue,param_3);\n    if (index != 0) {\n      convertedValue[1] = index - (int)charPtr;\n    }\n    quotient = convertedValue[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)convertedValue + 0x43) = 0;\nLAB_00005c36:\n  dataLength = convertedValue[1];\n  convertedValue[2] = dataLength;\n  if (-1 < (int)dataLength) {\n    *convertedValue = *convertedValue & 0xfffffffb;\n  }\n  outputString = charPtr;\n  if ((quotient != 0) || (dataLength != 0)) {\n    do {\n      outputString = outputString + -1;\n      *outputString = hexChars[quotient - numberBase * (quotient / numberBase)];\n      isLessThan = numberBase <= quotient;\n      quotient = quotient / numberBase;\n    } while (isLessThan);\n  }\n  if (((numberBase == 8) && ((int)(*convertedValue << 0x1f) < 0)) && ((int)convertedValue[1] <= (int)convertedValue[4])) {\n    outputString[-1] = '0';\n    outputString = outputString + -1;\n  }\n  convertedValue[4] = (int)charPtr - (int)outputString;\n  charPtr = outputString;\nLAB_00005c84:\n  index = calculate_data_length_00005a58(input,convertedValue,&tempCodePtr,param_3,conversionFunc);\n  if ((index == -1) || (index = (*conversionFunc)(input,param_3,charPtr,convertedValue[4]), index == -1)) {\nLAB_00005c98:\n    result = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*convertedValue << 0x1e) < 0) {\n      for (index = 0; index < (int)(convertedValue[3] - (int)tempCodePtr); index = index + 1) {\n        returnValue = (*conversionFunc)(input,param_3,(int)convertedValue + 0x19,1);\n        if (returnValue == -1) goto LAB_00005c98;\n      }\n    }\n    result = (code *)convertedValue[3];\n    if ((int)(code *)convertedValue[3] < (int)tempCodePtr) {\n      result = tempCodePtr;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005b34": "convert_to_string_00005b34",
                "param_1": "input",
                "param_2": "convertedValue",
                "param_4": "conversionFunc",
                "param_5": "paramList",
                "bVar1": "isLessThan",
                "bVar2": "byteVal",
                "iVar3": "index",
                "pcVar4": "result",
                "pcVar5": "hexChars",
                "iVar6": "returnValue",
                "pcVar7": "charPtr",
                "uVar8": "quotient",
                "puVar9": "ptrValue",
                "uVar10": "numberBase",
                "uVar13": "dataLength",
                "pcVar14": "outputString",
                "local_24": "tempCodePtr",
                "ppuVar11": "ptrParamList",
                "ppcVar12": "charPtrParamList"
            },
            "calling": [
                "FUN_000057f8"
            ],
            "called": [
                "FUN_00006010",
                "FUN_00005a58"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005e10": {
            "entrypoint": "0x00005e10",
            "current_name": "process_and_execute_callbacks_00005e10",
            "code": "\nuint processAndExecuteCallbacks_00005e10(int input,byte **data)\n\n{\n  int result;\n  uint returnValue;\n  byte *currentByte;\n  \n  if ((input != 0) && (*(int *)(input + 0x18) == 0)) {\n    initializeDataStructures();\n  }\n  if (data == (byte **)&DAT_000079b8) {\n    data = *(byte ***)(input + 4);\n  }\n  else if (data == (byte **)&DAT_000079d8) {\n    data = *(byte ***)(input + 8);\n  }\n  else if (data == (byte **)&DAT_00007998) {\n    data = *(byte ***)(input + 0xc);\n  }\n  result = processDataAndExecuteCallbacks(input,data);\n  if (result == 0) {\n    data[1] = data[1] + -1;\n    currentByte = *data;\n    *data = currentByte + 1;\n    returnValue = (uint)*currentByte;\n  }\n  else {\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00005e10": "process_and_execute_callbacks_00005e10",
                "param_1": "input",
                "param_2": "data",
                "iVar1": "result",
                "pbVar3": "currentByte",
                "initialize_data_structures_000042a4": "initializeDataStructures",
                "process_data_and_execute_callbacks_00006768": "processDataAndExecuteCallbacks",
                "uVar2": "returnValue"
            },
            "calling": [
                "FUN_00004418"
            ],
            "called": [
                "FUN_000042a4",
                "FUN_00006768"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005e68": {
            "entrypoint": "0x00005e68",
            "current_name": "process_data_00005e68",
            "code": "\nvoid processData_00005e68(undefined4 inputParam,undefined4 outputParam,undefined4 tempParam1,undefined4 tempParam2)\n\n{\n  undefined4 inputData;\n  undefined4 stringLength;\n  undefined2 constantValue;\n  undefined2 constantValue2;\n  undefined4 inputDataCopy;\n  undefined4 stringLengthCopy;\n  undefined *stringPointer;\n  undefined4 counter;\n  undefined4 counterCopy;\n  undefined4 tempVar1;\n  undefined4 tempVar2;\n  \n  constantValue = 0x204;\n  inputData = inputParam;\n  inputDataCopy = inputParam;\n  tempVar1 = tempParam1;\n  tempVar2 = tempParam2;\n  stringLength = find_string_length_00005ecc();\n  stringPointer = &LAB_00004dea_1;\n  counter = 0;\n  counterCopy = 0;\n  constantValue2 = 0xffff;\n  stringLengthCopy = stringLength;\n  process_data_000061cc(Elf32_Rel_ARRAY_1fff0200[16].r_offset,&inputData,outputParam,&tempVar1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005e68": "process_data_00005e68",
                "param_1": "inputParam",
                "param_2": "outputParam",
                "param_3": "tempParam1",
                "param_4": "tempParam2",
                "local_80": "inputData",
                "local_7c": "stringLength",
                "local_74": "constantValue",
                "local_72": "constantValue2",
                "local_70": "inputDataCopy",
                "local_6c": "stringLengthCopy",
                "local_5c": "stringPointer",
                "local_4c": "counter",
                "local_38": "counterCopy",
                "uStack_8": "tempVar1",
                "uStack_4": "tempVar2"
            },
            "calling": [
                "FUN_00005100"
            ],
            "called": [
                "FUN_000061cc",
                "FUN_00005ecc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ebc": {
            "entrypoint": "0x00005ebc",
            "current_name": "copy_string_00005ebc",
            "code": "\nvoid copyString_00005ebc(char *destination,char *source)\n\n{\n  char currentChar;\n  \n  do {\n    currentChar = *source;\n    *destination = currentChar;\n    source = source + 1;\n    destination = destination + 1;\n  } while (currentChar != '\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "param_1": "destination",
                "param_2": "source",
                "cVar1": "currentChar"
            },
            "calling": [
                "FUN_00005100"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ecc": {
            "entrypoint": "0x00005ecc",
            "current_name": "find_string_length_00005ecc",
            "code": "\nchar * find_string_length_00005ecc(char *str)\n\n{\n  char char_value;\n  char *current_char;\n  char *next_char;\n  \n  next_char = str;\n  do {\n    current_char = next_char + 1;\n    char_value = *next_char;\n    next_char = current_char;\n  } while (char_value != '\\0');\n  return current_char + (-1 - (int)str);\n}\n\n",
            "renaming": {
                "FUN_00005ecc": "find_string_length_00005ecc",
                "param_1": "str",
                "pcVar2": "current_char",
                "pcVar3": "next_char",
                "cVar1": "char_value"
            },
            "calling": [
                "FUN_00005100",
                "FUN_00005e68"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005edc": {
            "entrypoint": "0x00005edc",
            "current_name": "parse_number_00005edc",
            "code": "\nuint parse_number_00005edc(undefined4 *result,byte *input_string,byte **output_string,uint base)\n\n{\n  uint parsed_number;\n  uint current_char;\n  byte is_negative;\n  int parse_success;\n  uint parsed_digit;\n  uint max_divisor;\n  byte *current_position;\n  byte *next_position;\n  \n  next_position = input_string;\n  do {\n    current_position = next_position;\n    next_position = current_position + 1;\n    current_char = (uint)*current_position;\n    is_negative = (&DAT_00007a99)[current_char] & 8;\n  } while (((&DAT_00007a99)[current_char] & 8) != 0);\n  if (current_char == 0x2d) {\n    current_char = (uint)*next_position;\n    is_negative = 1;\n    next_position = current_position + 2;\n  }\n  else if (current_char == 0x2b) {\n    current_char = (uint)*next_position;\n    next_position = current_position + 2;\n  }\n  if (base == 0) {\n    if (current_char != 0x30) {\n      base = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((base != 0x10) || (current_char != 0x30)) goto LAB_00005f26;\n  if ((*next_position & 0xdf) == 0x58) {\n    current_char = (uint)next_position[1];\n    base = 0x10;\n    next_position = next_position + 2;\n  }\n  else {\n    current_char = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00005f26:\n  parse_success = 0;\n  max_divisor = 0xffffffff / base;\n  parsed_number = 0;\n  do {\n    parsed_digit = current_char - 0x30;\n    if (9 < parsed_digit) {\n      if (current_char - 0x41 < 0x1a) {\n        parsed_digit = current_char - 0x37;\n      }\n      else {\n        if (0x19 < current_char - 0x61) break;\n        parsed_digit = current_char - 0x57;\n      }\n    }\n    if ((int)base <= (int)parsed_digit) break;\n    if (((parse_success < 0) || (max_divisor < parsed_number)) ||\n       ((max_divisor == parsed_number && ((int)~(base * max_divisor) < (int)parsed_digit)))) {\n      parse_success = -1;\n    }\n    else {\n      parsed_number = parsed_number * base + parsed_digit;\n      parse_success = 1;\n    }\n    current_char = (uint)*next_position;\n    next_position = next_position + 1;\n  } while( true );\n  if (parse_success < 0) {\n    *result = 0x22;\n    parsed_number = 0xffffffff;\n    if (output_string == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (is_negative != 0) {\n      parsed_number = -parsed_number;\n    }\n    if (output_string == (byte **)0x0) {\n      return parsed_number;\n    }\n    if (parse_success == 0) goto LAB_00005fb8;\n  }\n  input_string = next_position + -1;\nLAB_00005fb8:\n  *output_string = input_string;\n  return parsed_number;\n}\n\n",
            "renaming": {
                "FUN_00005edc": "parse_number_00005edc",
                "param_1": "result",
                "param_2": "input_string",
                "param_3": "output_string",
                "param_4": "base",
                "uVar1": "parsed_number",
                "uVar2": "current_char",
                "bVar3": "is_negative",
                "iVar4": "parse_success",
                "uVar5": "parsed_digit",
                "uVar6": "max_divisor",
                "pbVar7": "current_position",
                "pbVar8": "next_position"
            },
            "calling": [
                "FUN_00005fd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fd8": {
            "entrypoint": "0x00005fd8",
            "current_name": "parse_and_process_number_00005fd8",
            "code": "\nvoid parseAndProcessNumber_00005fd8(undefined4 inputParam1,undefined4 inputParam2,undefined4 inputParam3)\n\n{\n  parse_number_00005edc(Elf32_Rel_ARRAY_1fff0200[16].r_offset,inputParam1,inputParam2,inputParam3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005fd8": "parse_and_process_number_00005fd8",
                "param_1": "inputParam1",
                "param_2": "inputParam2",
                "param_3": "inputParam3"
            },
            "calling": [
                "FUN_00005100"
            ],
            "called": [
                "FUN_00005edc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fec": {
            "entrypoint": "0x00005fec",
            "current_name": "initialize_memory_00005fec",
            "code": "\nvoid initializeMemory_00005fec(void)\n\n{\n  FUNC_000045e8(0x1fff0de6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005fec": "initialize_memory_00005fec"
            },
            "calling": [
                "FUN_0000562c"
            ],
            "called": [
                "FUN_000045e8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ff8": {
            "entrypoint": "0x00005ff8",
            "current_name": "initialize_memory_00005ff8",
            "code": "\nvoid initializeMemory_00005ff8(void)\n\n{\n  FUNC_000045ec(0x1fff0de6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005ff8": "initialize_memory_00005ff8"
            },
            "calling": [
                "FUN_0000562c"
            ],
            "called": [
                "FUN_000045ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006010": {
            "entrypoint": "0x00006010",
            "current_name": "find_byte_sequence_00006010",
            "code": "\nbyte * find_byte_sequence_00006010(uint *input,uint byte_to_find,uint size)\n\n{\n  byte byte_val;\n  char bit0_set;\n  char bit8_set;\n  char bit16_set;\n  char bit24_set;\n  byte *next_byte;\n  uint *next_uint;\n  byte *result;\n  uint remainder;\n  uint aligned_size;\n  uint xor_result;\n  uint byte_xor_result;\n  bool byte0_set;\n  bool byte8_set;\n  bool byte16_set;\n  bool byte24_set;\n  \n  byte_to_find = byte_to_find & 0xff;\n  if ((int)size < 0x10) {\njoined_r0x00006070:\n    do {\n      if (size == 0) {\n        return (byte *)0x0;\n      }\n      next_uint = (uint *)((int)input + 1);\n      byte_val = *(byte *)input;\n      size = size - 1;\n      input = next_uint;\n    } while (byte_val != byte_to_find);\n  }\n  else {\n    remainder = (uint)input & 7;\n    while( true ) {\n      if (remainder == 0) {\n        remainder = byte_to_find | byte_to_find << 8;\n        remainder = remainder | remainder << 0x10;\n        aligned_size = size & 0xfffffff8;\n        do {\n          next_uint = input + 2;\n          aligned_size = aligned_size - 8;\n          xor_result = *input ^ remainder;\n          byte_xor_result = input[1] ^ remainder;\n          bit0_set = -((char)xor_result == '\\0');\n          bit8_set = -((char)(xor_result >> 8) == '\\0');\n          bit16_set = -((char)(xor_result >> 0x10) == '\\0');\n          bit24_set = -((char)(xor_result >> 0x18) == '\\0');\n          xor_result = CONCAT13(bit24_set,CONCAT12(bit16_set,CONCAT11(bit8_set,bit0_set)));\n          byte0_set = (char)byte_xor_result != '\\0';\n          byte8_set = (char)(byte_xor_result >> 8) != '\\0';\n          byte16_set = (char)(byte_xor_result >> 0x10) != '\\0';\n          byte24_set = (char)(byte_xor_result >> 0x18) != '\\0';\n          byte_xor_result = CONCAT13(byte24_set * bit24_set - !byte24_set,\n                            CONCAT12(byte16_set * bit16_set - !byte16_set,\n                                     CONCAT11(byte8_set * bit8_set - !byte8_set,byte0_set * bit0_set - !byte0_set)));\n          if (byte_xor_result != 0) {\n            if (xor_result == 0) {\n              result = (byte *)((int)input + 5);\n              xor_result = byte_xor_result;\n            }\n            else {\n              result = (byte *)((int)input + 1);\n            }\n            if ((xor_result & 1) == 0) {\n              byte0_set = (xor_result & 0x100) == 0;\n              next_byte = result + 1;\n              if (byte0_set) {\n                byte0_set = (xor_result & 0x18000) == 0;\n                next_byte = result + 2;\n              }\n              result = next_byte;\n              if (byte0_set) {\n                result = result + 1;\n              }\n            }\n            return result + -1;\n          }\n          input = next_uint;\n        } while (aligned_size != 0);\n        size = size & 7;\n        goto joined_r0x00006070;\n      }\n      next_uint = (uint *)((int)input + 1);\n      size = size - 1;\n      if (*(byte *)input == byte_to_find) break;\n      remainder = (uint)next_uint & 7;\n      input = next_uint;\n      if (size == 0) {\n        return (byte *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)next_uint + -1);\n}\n\n",
            "renaming": {
                "FUN_00006010": "find_byte_sequence_00006010",
                "param_1": "input",
                "param_2": "byte_to_find",
                "param_3": "size",
                "bVar1": "byte_val",
                "cVar2": "bit0_set",
                "cVar3": "bit8_set",
                "cVar4": "bit16_set",
                "cVar5": "bit24_set",
                "pbVar6": "next_byte",
                "puVar7": "next_uint",
                "pbVar8": "result",
                "uVar9": "remainder",
                "uVar10": "aligned_size",
                "uVar11": "xor_result",
                "uVar12": "byte_xor_result",
                "bVar13": "byte0_set",
                "bVar14": "byte8_set",
                "bVar15": "byte16_set",
                "bVar16": "byte24_set"
            },
            "calling": [
                "FUN_000061cc",
                "FUN_00005b34",
                "FUN_0000656c",
                "FUN_000057f8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000060b0": {
            "entrypoint": "0x000060b0",
            "current_name": "copy_array_000060b0",
            "code": "\nvoid copyArray_000060b0(int param_1,undefined *src,int length)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  \n  puVar2 = src + length;\n  puVar3 = (undefined *)(param_1 + -1);\n  if (src != puVar2) {\n    do {\n      puVar1 = src + 1;\n      puVar3 = puVar3 + 1;\n      *puVar3 = *src;\n      src = puVar1;\n    } while (puVar1 != puVar2);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000060b0": "copy_array_000060b0",
                "param_2": "src",
                "param_3": "length"
            },
            "calling": [
                "FUN_000068f0",
                "FUN_000060cc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000060cc": {
            "entrypoint": "0x000060cc",
            "current_name": "process_data_000060cc",
            "code": "\nint processData_000060cc(undefined4 data,int size,uint targetSize,undefined4 param_4)\n\n{\n  int result;\n  uint sum;\n  \n  if (size != 0) {\n    if (targetSize == 0) {\n      initialize_data_and_process_00004b34();\n      result = 0;\n    }\n    else {\n      sum = calculate_sum_00006964();\n      result = size;\n      if ((sum < targetSize) && (result = allocate_memory_00004bd0(data,targetSize), result != 0)) {\n        copy_array_000060b0(result,size,targetSize);\n        initialize_data_and_process_00004b34(data,size);\n      }\n    }\n    return result;\n  }\n  result = allocate_memory_00004bd0(data,targetSize,targetSize,param_4);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000060cc": "process_data_000060cc",
                "param_1": "data",
                "param_2": "size",
                "param_3": "targetSize",
                "iVar1": "result",
                "uVar2": "sum"
            },
            "calling": [
                "FUN_000068f0"
            ],
            "called": [
                "FUN_00004bd0",
                "FUN_00006964",
                "FUN_00004b34",
                "FUN_000060b0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006192": {
            "entrypoint": "0x00006192",
            "current_name": "initialize_and_process_data_00006192",
            "code": "\nundefined4 initialize_and_process_data_00006192(undefined4 arg1,undefined4 *arg2)\n\n{\n  if ((undefined4 *)arg2[13] != (undefined4 *)0x0) {\n    if ((undefined4 *)arg2[13] != arg2 + 0x11) {\n      initialize_data_and_process_00004b34();\n    }\n    arg2[1] = arg2[16];\n    arg2[13] = 0;\n    if (arg2[16] != 0) {\n      *arg2 = arg2[15];\n      return 0;\n    }\n  }\n  *arg2 = arg2[4];\n  arg2[1] = 0;\n  *(ushort *)(arg2 + 3) = *(ushort *)(arg2 + 3) | 0x20;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00006192": "initialize_and_process_data_00006192",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_2[0xd]": "arg2[13]",
                "param_2[1]": "arg2[1]",
                "param_2[0x10]": "arg2[16]",
                "param_2[0xf]": "arg2[15]",
                "param_2[4]": "arg2[4]"
            },
            "calling": [
                "FUN_000061cc"
            ],
            "called": [
                "FUN_00004b34"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000061cc": {
            "entrypoint": "0x000061cc",
            "current_name": "process_data_000061cc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006482) */\n\nint processData_000061cc(undefined4 param1,byte **param2,byte *param3,int **param4)\n\n{\n  int result;\n  uint currentByte;\n  byte *nextByte;\n  uint byteCode;\n  int **outputData;\n  undefined stackBuffer [256];\n  uint flag1;\n  undefined4 flag2;\n  uint tempFlag;\n  int returnValue;\n  int counter;\n  undefined *pointer;\n  int dataType;\n  undefined *functionPointer;\n  code *function;\n  \n  returnValue = 0;\n  counter = 0;\n  functionPointer = &startLabel;\n  function = initializeAndProcessData + 1;\n  outputData = param4;\n  pointer = stackBuffer;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      byteCode = (uint)*param3;\n      if (byteCode == 0) {\n        return returnValue;\n      }\n      currentByte = (byte)(&DAT_00007a99)[byteCode] & 8;\n      nextByte = param3 + 1;\n      if (((&DAT_00007a99)[byteCode] & 8) == 0) break;\n      while (((param3 = nextByte, 0 < (int)param2[1] ||\n              (result = (*function)(param1,param2), result == 0)) &&\n             ((int)((uint)(byte)(&DAT_00007a99)[**param2] << 0x1c) < 0))) {\n        counter = counter + 1;\n        param2[1] = param2[1] + -1;\n        *param2 = *param2 + 1;\n      }\n    }\n    if (byteCode == 0x25) break;\nLAB_00006352:\n    if (((int)param2[1] < 1) && (result = (*function)(param1,param2), result != 0))\n    goto LAB_00006380;\n    if (**param2 != byteCode) {\n      return returnValue;\n    }\n    *param2 = *param2 + 1;\n    counter = counter + 1;\n    param2[1] = param2[1] + -1;\n    param3 = nextByte;\n  }\n  tempFlag = currentByte;\n  flag1 = currentByte;\n  if (param3[1] == 0x2a) {\n    nextByte = param3 + 2;\n    flag1 = 0x10;\n  }\n  while( true ) {\n    currentByte = (uint)*nextByte;\n    if (9 < currentByte - 0x30) break;\n    nextByte = nextByte + 1;\n    tempFlag = (tempFlag * 10 + currentByte) - 0x30;\n  }\n  result = findByteSequence(&DAT_00007c02,currentByte,3);\n  if (result != 0) {\n    flag1 = 1 << (result - 0x7c02U & 0xff) | flag1;\n    nextByte = nextByte + 1;\n  }\n  param3 = nextByte + 1;\n  currentByte = (uint)*nextByte;\n  if (currentByte < 0x79) {\n    if (0x57 < currentByte) {\n      switch(currentByte) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param3 = (byte *)decodeFunction(stackBuffer,param3);\n        flag1 = flag1 | 0x40;\n        dataType = 1;\n        break;\n      case 99:\n        flag1 = flag1 | 0x40;\n        dataType = 0;\n        break;\n      case 100:\n      case 0x75:\n        flag2 = 10;\nLAB_000063a0:\n        if (currentByte < 0x6f) {\n          dataType = 3;\n        }\n        else {\n          dataType = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        dataType = 5;\n        break;\n      case 0x69:\n        flag2 = 0;\n        dataType = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(flag1 << 0x1b)) {\n          if ((int)(flag1 << 0x1f) < 0) {\n            *(short *)*outputData = (short)counter;\n            outputData = outputData + 1;\n          }\n          else {\n            **outputData = counter;\n            outputData = outputData + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        flag2 = 8;\n        dataType = 4;\n        break;\n      case 0x70:\n        flag1 = flag1 | 0x20;\n      case 0x58:\n      case 0x78:\n        flag1 = flag1 | 0x200;\n        flag2 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        dataType = 2;\n      }\nLAB_000063ac:\n      if (((int)param2[1] < 1) && (result = (*function)(param1,param2), result != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(flag1 << 0x19)) {\n        while ((int)((uint)(byte)(&DAT_00007a99)[**param2] << 0x1c) < 0) {\n          counter = counter + 1;\n          nextByte = param2[1];\n          param2[1] = nextByte + -1;\n          if ((int)(nextByte + -1) < 1) {\n            result = (*function)(param1,param2);\n            if (result != 0) goto LAB_00006380;\n          }\n          else {\n            *param2 = *param2 + 1;\n          }\n        }\n      }\n      if (dataType < 3) {\n        result = processData_000061ccInLoop(param1,&flag1,param2,&outputData);\n      }\n      else {\n        if (4 < dataType) goto LAB_000061f6;\n        result = decodeData(param1,&flag1,param2,&outputData);\n      }\n      if (result == 1) {\n        return returnValue;\n      }\n      if (result == 2) {\nLAB_00006380:\n        if (returnValue == 0) {\nLAB_00006388:\n          returnValue = -1;\n        }\n        else if ((*(ushort *)(param2 + 3) & 0x40) != 0) {\n          returnValue = -1;\n        }\n        return returnValue;\n      }\n      goto LAB_000061f6;\n    }\n    nextByte = param3;\n    if (currentByte == 0x25) goto LAB_00006352;\n    if (currentByte < 0x26) {\n      if (currentByte != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (currentByte - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  dataType = 3;\n  flag2 = 10;\n  goto LAB_000063ac;\n}\n\n",
            "renaming": {
                "FUN_000061cc": "process_data_000061cc",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "result",
                "uVar2": "currentByte",
                "pbVar3": "nextByte",
                "uVar4": "byteCode",
                "local_2b0": "outputData",
                "auStack_2ac": "stackBuffer",
                "local_1ac": "flag1",
                "local_1a8": "flag2",
                "local_1a4": "tempFlag",
                "local_1a0": "returnValue",
                "local_19c": "counter",
                "local_198": "pointer",
                "local_194": "dataType",
                "local_30": "functionPointer",
                "local_2c": "function",
                "LAB_00006118_1": "startLabel",
                "initialize_and_process_data_00006192": "initializeAndProcessData",
                "decode_function_0000687c": "decodeFunction",
                "find_byte_sequence_00006010": "findByteSequence",
                "decode_data_0000656c": "decodeData",
                "process_data_000064bc": "processDataInLoop"
            },
            "calling": [
                "FUN_00005e68"
            ],
            "called": [
                "FUN_0000687c",
                "FUN_00006192",
                "FUN_000064bc",
                "FUN_00006010",
                "FUN_0000656c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000064bc": {
            "entrypoint": "0x000064bc",
            "current_name": "process_data_000064bc",
            "code": "\nundefined4 process_data_000064bc(undefined4 input_flag,uint *params,byte **data_ptr,undefined4 *status)\n\n{\n  int result;\n  uint temp;\n  byte **data_ptr_ptr;\n  byte *data_byte_ptr;\n  byte *data_byte_ptr_2;\n  byte *current_byte;\n  int counter;\n  \n  if (params[2] == 0) {\n    if (params[6] == 0) {\n      temp = 1;\n    }\n    else {\n      temp = 0xffffffff;\n    }\n    params[2] = temp;\n  }\n  if (-1 < (int)(*params << 0x1b)) {\n    data_ptr_ptr = (byte **)*status;\n    *status = data_ptr_ptr + 1;\n    data_byte_ptr_2 = *data_ptr_ptr;\n  }\n  counter = 0;\n  do {\n    temp = params[6];\n    if (temp != 0) {\n      if (temp == 1) {\n        if (*(char *)(params[5] + (uint)**data_ptr) == '\\0') {\n          if (counter == 0) {\n            return 1;\n          }\nLAB_0000654a:\n          if (((*params & 0x10) == 0) && (params[3] = params[3] + 1, params[6] != 0)) {\n            *data_byte_ptr_2 = 0;\n          }\n          params[4] = counter + params[4];\n          return 0;\n        }\n      }\n      else if ((temp != 2) || ((int)((uint)(byte)(&DAT_00007a99)[**data_ptr] << 0x1c) < 0))\n      goto LAB_0000654a;\n    }\n    current_byte = data_byte_ptr_2;\n    if (-1 < (int)(*params << 0x1b)) {\n      current_byte = data_byte_ptr_2 + 1;\n      *data_byte_ptr_2 = **data_ptr;\n    }\n    data_byte_ptr = data_ptr[1];\n    *data_ptr = *data_ptr + 1;\n    temp = params[2] - 1;\n    data_ptr[1] = data_byte_ptr + -1;\n    counter = counter + 1;\n    params[2] = temp;\n    data_byte_ptr_2 = current_byte;\n    if ((temp == 0) ||\n       (((int)(data_byte_ptr + -1) < 1 &&\n        (result = (*(code *)params[0x60])(input_flag,data_ptr,temp,(code *)params[0x60],status),\n        result != 0)))) goto LAB_0000654a;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000064bc": "process_data_000064bc",
                "param_1": "input_flag",
                "param_2": "params",
                "param_3": "data_ptr",
                "param_4": "status",
                "iVar1": "result",
                "uVar2": "temp",
                "ppbVar3": "data_ptr_ptr",
                "pbVar4": "data_byte_ptr",
                "unaff_r6": "data_byte_ptr_2",
                "pbVar5": "current_byte",
                "iVar6": "counter"
            },
            "calling": [
                "FUN_000061cc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000656c": {
            "entrypoint": "0x0000656c",
            "current_name": "decode_data_0000656c",
            "code": "\nundefined4 decode_data_0000656c(undefined4 input_param,uint *data_array,byte **byte_array,undefined4 *output_data)\n\n{\n  int index;\n  undefined4 result;\n  code *decode_byte;\n  uint data_length;\n  byte *current_byte;\n  uint original_data_length;\n  undefined4 *output_data_ptr;\n  uint *byte_array_ptr;\n  uint *output_data_ptr_2;\n  uint *data_array_ptr;\n  int unaff_r9;\n  int counter;\n  undefined *symbol_array [4];\n  \n  symbol_array[0] = &DAT_00007c2f;\n  symbol_array[1] = &DAT_00007c32;\n  symbol_array[2] = &DAT_00007c35;\n  decode_byte = (code *)&UNK_00004f81;\n  if (data_array[6] != 3) {\n    decode_byte = (code *)&UNK_00005fd5;\n  }\n  original_data_length = data_array[2];\n  data_length = original_data_length - 1;\n  if (0x15c < data_length) {\n    unaff_r9 = original_data_length - 0x15d;\n    original_data_length = 0x15d;\n  }\n  if (0x15c < data_length) {\n    data_array[2] = original_data_length;\n  }\n  data_array_ptr = data_array + 7;\n  if (data_length < 0x15d) {\n    unaff_r9 = 0;\n  }\n  *data_array = *data_array | 0xd00;\n  counter = 0;\n  output_data_ptr_2 = data_array_ptr;\n  do {\n    index = find_byte_sequence_00006010(symbol_array[counter],**byte_array,2);\n    if (index != 0) {\n      if (counter == 1) {\n        if (data_array[1] == 0) {\n          data_array[1] = 8;\n          *data_array = *data_array | 0x200;\n        }\n        data_length = *data_array & 0xfffffaff;\nLAB_000065f4:\n        *data_array = data_length;\n      }\n      else if (counter == 2) {\n        if ((*data_array & 0x600) != 0x200) goto LAB_00006624;\n        data_array[1] = 0x10;\n        data_length = *data_array | 0x100;\n        goto LAB_000065f4;\n      }\n      data_length = data_array[2];\n      data_array[2] = data_length - 1;\n      if (data_length != 0) {\n        current_byte = *byte_array;\n        *byte_array = current_byte + 1;\n        byte_array_ptr = (uint *)((int)output_data_ptr_2 + 1);\n        *(byte *)output_data_ptr_2 = *current_byte;\n        current_byte = byte_array[1];\n        byte_array[1] = current_byte + -1;\n        output_data_ptr_2 = byte_array_ptr;\n        if (((int)(current_byte + -1) < 1) &&\n           (index = (*(code *)data_array[0x60])(input_param,byte_array), index != 0)) {\n          counter = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    counter = counter + 1;\n  } while (counter != 3);\n  if (data_array[1] == 0) {\n    data_array[1] = 10;\n  }\n  decode_function_0000687c(data_array[5],\"01234567]\" + (8 - data_array[1]));\n  counter = 0;\n  while( true ) {\n    byte_array_ptr = output_data_ptr_2;\n    if (data_array[2] == 0) break;\n    current_byte = *byte_array;\n    data_length = (uint)*current_byte;\n    if (*(char *)(data_array[5] + data_length) == '\\0') break;\n    if ((data_length == 0x30) && ((int)(*data_array << 0x14) < 0)) {\n      counter = counter + 1;\n      if (unaff_r9 != 0) {\n        unaff_r9 = unaff_r9 + -1;\n        data_array[2] = data_array[2] + 1;\n      }\n    }\n    else {\n      *data_array = *data_array & 0xfffff6ff;\n      byte_array_ptr = (uint *)((int)output_data_ptr_2 + 1);\n      *(byte *)output_data_ptr_2 = *current_byte;\n    }\n    current_byte = byte_array[1];\n    byte_array[1] = current_byte + -1;\n    if ((int)(current_byte + -1) < 1) {\n      index = (*(code *)data_array[0x60])(input_param,byte_array);\n      if (index != 0) break;\n    }\n    else {\n      *byte_array = *byte_array + 1;\n    }\n    data_array[2] = data_array[2] - 1;\n    output_data_ptr_2 = byte_array_ptr;\n  }\nLAB_000066ca:\n  if ((int)(*data_array << 0x17) < 0) {\n    if (data_array_ptr < byte_array_ptr) {\n      (*(code *)data_array[0x5f])(input_param,*(byte *)((int)byte_array_ptr + -1),byte_array);\n      byte_array_ptr = (uint *)((int)byte_array_ptr + -1);\n    }\n    if (byte_array_ptr == data_array_ptr) {\n      return 1;\n    }\n  }\n  if ((*data_array & 0x10) == 0) {\n    *(byte *)byte_array_ptr = 0;\n    result = (*decode_byte)(input_param,data_array_ptr,0,data_array[1]);\n    output_data_ptr = (undefined4 *)*output_data;\n    data_length = *data_array;\n    *output_data = output_data_ptr + 1;\n    output_data_ptr = (undefined4 *)*output_data_ptr;\n    if ((data_length & 0x20) == 0) {\n      if ((int)(data_length << 0x1f) < 0) {\n        *(short *)output_data_ptr = (short)result;\n      }\n      else {\n        *output_data_ptr = result;\n      }\n    }\n    else {\n      *output_data_ptr = result;\n    }\n    data_array[3] = data_array[3] + 1;\n  }\n  data_array[4] = (uint)((int)byte_array_ptr + data_array[4] + (counter - (int)data_array_ptr));\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000656c": "decode_data_0000656c",
                "param_1": "input_param",
                "param_2": "data_array",
                "param_3": "byte_array",
                "param_4": "output_data",
                "iVar1": "index",
                "uVar2": "result",
                "pcVar3": "decode_byte",
                "uVar4": "data_length",
                "pbVar5": "current_byte",
                "uVar6": "original_data_length",
                "puVar7": "output_data_ptr",
                "puVar8": "byte_array_ptr",
                "puVar9": "output_data_ptr_2",
                "puVar10": "data_array_ptr",
                "iVar11": "counter",
                "local_34": "symbol_array"
            },
            "calling": [
                "FUN_000061cc"
            ],
            "called": [
                "FUN_0000687c",
                "FUN_00006010"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006768": {
            "entrypoint": "0x00006768",
            "current_name": "process_data_and_execute_callbacks_00006768",
            "code": "\nundefined4\nprocessDataAndExecuteCallbacks_00006768(undefined4 *dataStructures,undefined4 *callbackData,undefined4 param3,undefined4 param4)\n\n{\n  undefined2 variable1;\n  int variable2;\n  undefined4 variable3;\n  ushort variable4;\n  uint variable5;\n  \n  if ((dataStructures != (undefined4 *)0x0) && (dataStructures[6] == 0)) {\n    initializeDataStructures();\n  }\n  if (callbackData == &DAT_000079b8) {\n    callbackData = (undefined4 *)dataStructures[1];\n  }\n  else if (callbackData == (undefined4 *)&DAT_000079d8) {\n    callbackData = (undefined4 *)dataStructures[2];\n  }\n  else if (callbackData == (undefined4 *)&DAT_00007998) {\n    callbackData = (undefined4 *)dataStructures[3];\n  }\n  variable4 = *(ushort *)(callbackData + 3);\n  callbackData[1] = 0;\n  variable5 = (uint)*(ushort *)(callbackData + 3);\n  if ((int)(variable5 << 0x1a) < 0) {\n    return 0xffffffff;\n  }\n  if ((int)(variable5 << 0x1d) < 0) {\n    if ((undefined4 *)callbackData[0xd] != (undefined4 *)0x0) {\n      if ((undefined4 *)callbackData[0xd] != callbackData + 0x11) {\n        initializeDataAndProcess(dataStructures);\n      }\n      callbackData[1] = callbackData[0x10];\n      callbackData[0xd] = 0;\n      if (callbackData[0x10] != 0) {\n        *callbackData = callbackData[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(variable5 << 0x1b)) {\n      *dataStructures = 9;\n      variable4 = variable4 | 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(variable5 << 0x1c) < 0) {\n      variable2 = processData(dataStructures,callbackData,variable5 << 0x1c,variable5,param4);\n      if (variable2 != 0) {\n        return 0xffffffff;\n      }\n      callbackData[2] = 0;\n      *(ushort *)(callbackData + 3) = *(ushort *)(callbackData + 3) & 0xfff7;\n      callbackData[6] = 0;\n    }\n    *(ushort *)(callbackData + 3) = *(ushort *)(callbackData + 3) | 4;\n  }\n  if (callbackData[4] == 0) {\n    validateAndAllocateMemory(dataStructures,callbackData);\n  }\n  variable4 = *(ushort *)(callbackData + 3);\n  variable1 = *(undefined2 *)(callbackData + 3);\n  if ((variable4 & 3) != 0) {\n    *(undefined2 *)(callbackData + 3) = 1;\n    executeCallbacks(0x1fff0284,&label_00006754_1);\n    *(undefined2 *)(callbackData + 3) = variable1;\n    if ((variable4 & 9) == 9) {\n      processData(dataStructures,callbackData);\n    }\n  }\n  variable3 = callbackData[4];\n  *callbackData = variable3;\n  variable2 = (*(functionCode *)callbackData[9])(dataStructures,callbackData[8],variable3,callbackData[5]);\n  callbackData[1] = variable2;\n  if (0 < variable2) {\n    return 0;\n  }\n  variable4 = *(ushort *)(callbackData + 3);\n  if (variable2 != 0) {\n    variable3 = 0;\n  }\n  else {\n    variable4 = variable4 | 0x20;\n  }\n  if (variable2 != 0) {\n    callbackData[1] = variable3;\n    variable4 = variable4 | 0x40;\n  }\nLAB_000067b8:\n  *(ushort *)(callbackData + 3) = variable4;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00006768": "process_data_and_execute_callbacks_00006768",
                "param_1": "dataStructures",
                "param_2": "callbackData",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "variable1",
                "iVar2": "variable2",
                "uVar3": "variable3",
                "uVar4": "variable4",
                "uVar5": "variable5",
                "initialize_data_structures_000042a4": "initializeDataStructures",
                "initialize_data_and_process_00004b34": "initializeDataAndProcess",
                "process_data_00004158": "processData",
                "validate_and_allocate_memory_00005700": "validateAndAllocateMemory",
                "execute_callbacks_000043a0": "executeCallbacks",
                "process_data_0000404c": "processData",
                "LAB_00006754_1": "label_00006754_1",
                "code": "functionCode"
            },
            "calling": [
                "FUN_00005e10"
            ],
            "called": [
                "FUN_000042a4",
                "FUN_0000404c",
                "FUN_00004158",
                "FUN_000043a0",
                "FUN_00004b34",
                "FUN_00005700"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000687c": {
            "entrypoint": "0x0000687c",
            "current_name": "decode_function_0000687c",
            "code": "\nbyte * decodeFunction_0000687c(int inputLength,byte *inputData)\n\n{\n  byte *result;\n  uint tempVar1;\n  int counter;\n  uint currentByte;\n  uint startByte;\n  uint endByte;\n  bool isStartByte;\n  \n  currentByte = (uint)*inputData;\n  isStartByte = currentByte == 0x5e;\n  if (isStartByte) {\n    currentByte = (uint)inputData[1];\n    inputData = inputData + 2;\n  }\n  else {\n    inputData = inputData + 1;\n  }\n  counter = inputLength + -1;\n  do {\n    counter = counter + 1;\n    *(bool *)counter = isStartByte;\n  } while (counter != inputLength + 0xff);\n  if (currentByte == 0) {\n    result = inputData + -1;\n  }\n  else {\nLAB_000068aa:\n    do {\n      startByte = currentByte;\n      *(bool *)(inputLength + startByte) = !isStartByte;\n      inputData = inputData + 1;\n      while( true ) {\n        currentByte = (uint)inputData[-1];\n        if (currentByte != 0x2d) break;\n        endByte = (uint)*inputData;\n        if ((endByte == 0x5d) || (tempVar1 = startByte, (int)endByte < (int)startByte)) goto LAB_000068aa;\n        do {\n          tempVar1 = tempVar1 + 1;\n          *(bool *)(inputLength + tempVar1) = !isStartByte;\n        } while ((int)tempVar1 < (int)endByte);\n        counter = ~startByte + endByte;\n        if ((int)endByte <= (int)startByte) {\n          counter = 0;\n        }\n        startByte = startByte + 1 + counter;\n        inputData = inputData + 2;\n      }\n      result = inputData;\n    } while ((currentByte != 0x5d) && (result = inputData + -1, currentByte != 0));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0000687c": "decode_function_0000687c",
                "param_1": "inputLength",
                "param_2": "inputData",
                "pbVar1": "result",
                "uVar2": "tempVar1",
                "iVar3": "counter",
                "uVar4": "currentByte",
                "uVar5": "startByte",
                "uVar6": "endByte",
                "bVar7": "isStartByte"
            },
            "calling": [
                "FUN_000061cc",
                "FUN_0000656c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000068f0": {
            "entrypoint": "0x000068f0",
            "current_name": "allocate_and_update_memory_000068f0",
            "code": "\nundefined4 allocate_and_update_memory_000068f0(undefined4 param,int *array)\n\n{\n  int new_memory;\n  int array_size;\n  \n  if ((int *)array[0xd] == array + 0x11) {\n    new_memory = allocate_memory(param,0x400);\n    if (new_memory != 0) {\n      array[0xe] = 0x400;\n      array[0xd] = new_memory;\n      *(undefined *)(new_memory + 0x3ff) = *(undefined *)((int)array + 0x46);\n      *(undefined *)(new_memory + 0x3fe) = *(undefined *)((int)array + 0x45);\n      *(undefined *)(new_memory + 0x3fd) = *(undefined *)(array + 0x11);\n      *array = new_memory + 0x3fd;\n      return 0;\n    }\n  }\n  else {\n    array_size = array[0xe];\n    new_memory = process_data(param,(int *)array[0xd],array_size << 1);\n    if (new_memory != 0) {\n      copy_array(new_memory + array_size,new_memory,array_size);\n      array[0xd] = new_memory;\n      array[0xe] = array_size << 1;\n      *array = new_memory + array_size;\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000068f0": "allocate_and_update_memory_000068f0",
                "param_1": "param",
                "param_2": "array",
                "iVar1": "new_memory",
                "iVar2": "array_size",
                "allocate_memory_00004bd0": "allocate_memory",
                "process_data_000060cc": "process_data",
                "copy_array_000060b0": "copy_array"
            },
            "calling": [],
            "called": [
                "FUN_00004bd0",
                "FUN_000060cc",
                "FUN_000060b0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006964": {
            "entrypoint": "0x00006964",
            "current_name": "calculate_sum_00006964",
            "code": "\nint calculateSum_00006964(undefined4 result,int array)\n\n{\n  int index;\n  \n  index = *(int *)(array + -4) + -4;\n  if (*(int *)(array + -4) < 0) {\n    index = index + *(int *)(array + index);\n  }\n  return index;\n}\n\n",
            "renaming": {
                "FUN_00006964": "calculate_sum_00006964",
                "param_1": "result",
                "param_2": "array",
                "iVar1": "index"
            },
            "calling": [
                "FUN_000060cc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006974": {
            "entrypoint": "0x00006974",
            "current_name": "range_to_00006974",
            "code": "\nundefined8 rangeTo_00006974(int startValue,int endValue,int increment,int decrement)\n\n{\n  int negativeEnd;\n  undefined8 result;\n  undefined temp [8];\n  \n  if ((decrement == 0) && (increment == 0)) {\n    if (endValue < 0) {\n      startValue = 0;\n      endValue = -0x80000000;\n    }\n    else if (endValue != 0 || startValue != 0) {\n      endValue = 0x7fffffff;\n      startValue = -1;\n    }\n    return CONCAT44(endValue,startValue);\n  }\n  if (endValue < 0) {\n    negativeEnd = -endValue - (uint)(startValue != 0);\n    if (decrement < 0) {\n      result = div_mod_00006a14(-startValue,negativeEnd,-increment,-decrement - (uint)(increment != 0),temp);\n      return result;\n    }\n    result = div_mod_00006a14(-startValue,negativeEnd,increment,decrement,temp);\n    return CONCAT44(-(int)((ulonglong)result >> 0x20) - (uint)((int)result != 0),-(int)result);\n  }\n  if (decrement < 0) {\n    result = div_mod_00006a14(startValue,endValue,-increment,-decrement - (uint)(increment != 0),temp);\n    return CONCAT44(-(int)((ulonglong)result >> 0x20) - (uint)((int)result != 0),-(int)result);\n  }\n  result = div_mod_00006a14();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00006974": "range_to_00006974",
                "param_1": "startValue",
                "param_2": "endValue",
                "param_3": "increment",
                "param_4": "decrement",
                "iVar1": "negativeEnd",
                "uVar2": "result",
                "local_8": "temp"
            },
            "calling": [
                "FUN_0000443c"
            ],
            "called": [
                "FUN_00006a14"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006a14": {
            "entrypoint": "0x00006a14",
            "current_name": "div_mod_00006a14",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong divMod_00006a14(uint dividend,uint dividend_high,uint divisor,uint divisor_high,uint *remainder)\n\n{\n  code *jumpTable;\n  uint quater_dividend;\n  int shift;\n  uint quo;\n  uint quo_high;\n  uint temp_quo;\n  uint temp_diff;\n  uint divisor_low;\n  uint temp_quo_high;\n  uint temp_quo_low;\n  bool carry;\n  ulonglong result;\n  \n  if (divisor_high == 0) {\n    if (dividend_high < divisor) {\n      shift = LZCOUNT(divisor);\n      temp_quo = divisor;\n      if (shift != 0) {\n        temp_quo = divisor << shift;\n        dividend_high = dividend >> (0x20U - shift & 0xff) | dividend_high << shift;\n        dividend = dividend << shift;\n      }\n      temp_diff = temp_quo >> 0x10;\n      temp_quo_high = dividend_high / temp_diff;\n      quo = dividend >> 0x10 | (dividend_high - temp_diff * temp_quo_high) * 0x10000;\n      quater_dividend = temp_quo_high * (temp_quo & 0xffff);\n      quo_high = temp_quo_high;\n      if (quo <= quater_dividend && quater_dividend - quo != 0) {\n        carry = CARRY4(temp_quo,quo);\n        quo = temp_quo + quo;\n        quo_high = temp_quo_high - 1;\n        if ((carry == false) && (quo <= quater_dividend && quater_dividend - quo != 0)) {\n          quo_high = temp_quo_high - 2;\n          quo = quo + temp_quo;\n        }\n      }\n      temp_quo_high = (quo - quater_dividend) / temp_diff;\n      temp_diff = dividend & 0xffff | ((quo - quater_dividend) - temp_diff * temp_quo_high) * 0x10000;\n      quo = temp_quo_high * (temp_quo & 0xffff);\n      quater_dividend = temp_quo_high;\n      if (temp_diff <= quo && quo - temp_diff != 0) {\n        carry = CARRY4(temp_quo,temp_diff);\n        temp_diff = temp_quo + temp_diff;\n        quater_dividend = temp_quo_high - 1;\n        if ((carry == false) && (temp_diff <= quo && quo - temp_diff != 0)) {\n          quater_dividend = temp_quo_high - 2;\n          temp_diff = temp_diff + temp_quo;\n        }\n      }\n      temp_diff = temp_diff - quo;\n      quater_dividend = quater_dividend | quo_high << 0x10;\n      temp_quo = 0;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        jumpTable = (code *)software_udf(0xff,0x6abc);\n        result = (*jumpTable)();\n        return result;\n      }\n      shift = LZCOUNT(divisor);\n      if (shift == 0) {\n        dividend_high = dividend_high - divisor;\n        temp_quo_low = divisor >> 0x10;\n        divisor_low = divisor & 0xffff;\n        temp_quo = 1;\n        quo_high = divisor;\n      }\n      else {\n        quo_high = divisor << shift;\n        temp_quo_low = quo_high >> 0x10;\n        quater_dividend = dividend_high >> (0x20U - shift & 0xff);\n        temp_quo = dividend >> (0x20U - shift & 0xff) | dividend_high << shift;\n        quo = quater_dividend / temp_quo_low;\n        divisor_low = quo_high & 0xffff;\n        temp_quo_high = temp_quo >> 0x10 | (quater_dividend - temp_quo_low * quo) * 0x10000;\n        temp_diff = quo * divisor_low;\n        dividend = dividend << shift;\n        quater_dividend = quo;\n        if (temp_quo_high <= temp_diff && temp_diff - temp_quo_high != 0) {\n          carry = CARRY4(quo_high,temp_quo_high);\n          temp_quo_high = quo_high + temp_quo_high;\n          quater_dividend = quo - 1;\n          if ((carry == false) && (temp_quo_high <= temp_diff && temp_diff - temp_quo_high != 0)) {\n            quater_dividend = quo - 2;\n            temp_quo_high = temp_quo_high + quo_high;\n          }\n        }\n        quo = (temp_quo_high - temp_diff) / temp_quo_low;\n        dividend_high = temp_quo & 0xffff | ((temp_quo_high - temp_diff) - temp_quo_low * quo) * 0x10000;\n        temp_diff = quo * divisor_low;\n        temp_quo = quo;\n        if (dividend_high <= temp_diff && temp_diff - dividend_high != 0) {\n          carry = CARRY4(quo_high,dividend_high);\n          dividend_high = quo_high + dividend_high;\n          temp_quo = quo - 1;\n          if ((carry == false) && (dividend_high <= temp_diff && temp_diff - dividend_high != 0)) {\n            temp_quo = quo - 2;\n            dividend_high = dividend_high + quo_high;\n          }\n        }\n        dividend_high = dividend_high - temp_diff;\n        temp_quo = temp_quo | quater_dividend << 0x10;\n      }\n      temp_quo_high = dividend_high / temp_quo_low;\n      temp_diff = dividend >> 0x10 | (dividend_high - temp_quo_low * temp_quo_high) * 0x10000;\n      quater_dividend = divisor_low * temp_quo_high;\n      quo = temp_quo_high;\n      if (temp_diff <= quater_dividend && quater_dividend - temp_diff != 0) {\n        carry = CARRY4(quo_high,temp_diff);\n        temp_diff = quo_high + temp_diff;\n        quo = temp_quo_high - 1;\n        if ((carry == false) && (temp_diff <= quater_dividend && quater_dividend - temp_diff != 0)) {\n          quo = temp_quo_high - 2;\n          temp_diff = temp_diff + quo_high;\n        }\n      }\n      temp_quo_high = (temp_diff - quater_dividend) / temp_quo_low;\n      temp_diff = dividend & 0xffff | ((temp_diff - quater_dividend) - temp_quo_low * temp_quo_high) * 0x10000;\n      divisor_low = divisor_low * temp_quo_high;\n      quater_dividend = temp_quo_high;\n      if (temp_diff <= divisor_low && divisor_low - temp_diff != 0) {\n        carry = CARRY4(quo_high,temp_diff);\n        temp_diff = quo_high + temp_diff;\n        quater_dividend = temp_quo_high - 1;\n        if ((carry == false) && (temp_diff <= divisor_low && divisor_low - temp_diff != 0)) {\n          quater_dividend = temp_quo_high - 2;\n          temp_diff = temp_diff + quo_high;\n        }\n      }\n      temp_diff = temp_diff - divisor_low;\n      quater_dividend = quater_dividend | quo << 0x10;\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = temp_diff >> LZCOUNT(divisor);\n      remainder[1] = 0;\n    }\n  }\n  else if (dividend_high < divisor_high) {\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = dividend_high;\n      return 0;\n    }\n    quater_dividend = 0;\n    temp_quo = 0;\n  }\n  else {\n    shift = LZCOUNT(divisor_high);\n    if (shift != 0) {\n      divisor_low = 0x20 - shift;\n      quo = divisor >> (divisor_low & 0xff) | divisor_high << shift;\n      temp_quo_low = quo >> 0x10;\n      quater_dividend = dividend_high >> (divisor_low & 0xff);\n      temp_quo = dividend >> (divisor_low & 0xff) | dividend_high << shift;\n      temp_diff = quater_dividend / temp_quo_low;\n      quo_high = temp_quo >> 0x10 | (quater_dividend - temp_quo_low * temp_diff) * 0x10000;\n      temp_quo_high = temp_diff * (quo & 0xffff);\n      dividend = dividend << shift;\n      quater_dividend = temp_diff;\n      if (quo_high <= temp_quo_high && temp_quo_high - quo_high != 0) {\n        carry = CARRY4(quo,quo_high);\n        quo_high = quo + quo_high;\n        quater_dividend = temp_diff - 1;\n        if ((carry == false) && (quo_high <= temp_quo_high && temp_quo_high - quo_high != 0)) {\n          quater_dividend = temp_diff - 2;\n          quo_high = quo_high + quo;\n        }\n      }\n      temp_diff = (quo_high - temp_quo_high) / temp_quo_low;\n      quo_high = temp_quo & 0xffff | ((quo_high - temp_quo_high) - temp_quo_low * temp_diff) * 0x10000;\n      temp_quo_high = temp_diff * (quo & 0xffff);\n      temp_quo = temp_diff;\n      if (quo_high <= temp_quo_high && temp_quo_high - quo_high != 0) {\n        carry = CARRY4(quo,quo_high);\n        quo_high = quo + quo_high;\n        temp_quo = temp_diff - 1;\n        if ((carry == false) && (quo_high <= temp_quo_high && temp_quo_high - quo_high != 0)) {\n          temp_quo = temp_diff - 2;\n          quo_high = quo_high + quo;\n        }\n      }\n      temp_quo = temp_quo | quater_dividend << 0x10;\n      result = (ulonglong)temp_quo * (ulonglong)(divisor << shift);\n      if (CONCAT44(quo_high - temp_quo_high,dividend) < result) {\n        result = result - CONCAT44(quo,divisor << shift);\n        temp_quo = temp_quo - 1;\n      }\n      if (remainder != (uint *)0x0) {\n        quater_dividend = ((quo_high - temp_quo_high) - (int)(result >> 0x20)) - (uint)(dividend < (uint)result);\n        *remainder = quater_dividend << (divisor_low & 0xff) | dividend - (uint)result >> shift;\n        remainder[1] = quater_dividend >> shift;\n      }\n      return (ulonglong)temp_quo;\n    }\n    if ((divisor_high < dividend_high) || (divisor <= dividend)) {\n      carry = dividend < divisor;\n      dividend = dividend - divisor;\n      dividend_high = (dividend_high - divisor_high) - (uint)carry;\n      quater_dividend = 1;\n    }\n    else {\n      quater_dividend = 0;\n    }\n    temp_quo = 0;\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = dividend_high;\n    }\n  }\n  return CONCAT44(temp_quo,quater_dividend);\n}\n\n",
            "renaming": {
                "FUN_00006a14": "div_mod_00006a14",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor",
                "param_4": "divisor_high",
                "param_5": "remainder",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "uVar1": "quater_dividend",
                "iVar2": "shift",
                "uVar3": "quo",
                "uVar4": "quo_high",
                "uVar5": "temp_quo",
                "uVar6": "temp_diff",
                "uVar7": "divisor_low",
                "uVar8": "temp_quo_high",
                "uVar9": "temp_quo_low",
                "bVar10": "carry",
                "uVar11": "result"
            },
            "calling": [
                "FUN_00006974"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 137508,
    "layers": [
        [
            "FUN_000004f2",
            "FUN_00000514",
            "FUN_00000534",
            "FUN_00000566",
            "FUN_0000058e",
            "FUN_000005ca",
            "FUN_000007dc",
            "FUN_000008b8",
            "FUN_00000900",
            "FUN_0000091c",
            "FUN_0000093c",
            "FUN_00000cd0",
            "FUN_00000cf0",
            "FUN_00000d0c",
            "FUN_00000d2a",
            "FUN_00000d44",
            "FUN_00000dcc",
            "FUN_000010a0",
            "FUN_00001318",
            "FUN_00001360",
            "FUN_000015d0",
            "FUN_00001696",
            "FUN_00001748",
            "FUN_00001ad4",
            "FUN_00001d08",
            "FUN_00001d5e",
            "FUN_00001d80",
            "FUN_00001da2",
            "FUN_00001dc0",
            "FUN_00001e0c",
            "FUN_00001e44",
            "FUN_00002270",
            "FUN_00002294",
            "FUN_000022be",
            "FUN_000022f0",
            "FUN_000023c8",
            "FUN_0000240c",
            "FUN_00002538",
            "FUN_000026f0",
            "FUN_00002714",
            "FUN_00002744",
            "FUN_0000281c",
            "FUN_0000285c",
            "FUN_000028f0",
            "FUN_00002910",
            "FUN_0000294c",
            "FUN_00002970",
            "FUN_000031fc",
            "FUN_00003658",
            "FUN_00003810",
            "FUN_00003918",
            "FUN_000039e8",
            "FUN_00003d24",
            "FUN_00003d64",
            "FUN_00003d94",
            "FUN_00003dc4",
            "FUN_00004274",
            "FUN_00004280",
            "FUN_0000428c",
            "FUN_000043a0",
            "FUN_000045ee",
            "FUN_00004622",
            "FUN_00004e52",
            "FUN_00004e66",
            "FUN_00004f84",
            "FUN_000050e8",
            "FUN_000050f4",
            "FUN_00005584",
            "FUN_000056b0",
            "FUN_00005790",
            "FUN_0000579c",
            "FUN_00005a58",
            "FUN_00005ebc",
            "FUN_00005ecc",
            "FUN_00005edc",
            "FUN_00005fec",
            "FUN_00005ff8",
            "FUN_00006010",
            "FUN_000060b0",
            "FUN_000064bc",
            "FUN_0000687c",
            "FUN_00006964",
            "FUN_00006a14"
        ],
        [
            "FUN_00000428",
            "FUN_00000610",
            "FUN_00000698",
            "FUN_00000738",
            "FUN_00000930",
            "FUN_00000d76",
            "FUN_00000e38",
            "FUN_00000e58",
            "FUN_00001348",
            "FUN_00001392",
            "FUN_000014c4",
            "FUN_000016c8",
            "FUN_000016ec",
            "FUN_00001710",
            "FUN_00001cf0",
            "FUN_00001d3a",
            "FUN_00001ec4",
            "FUN_00001ff6",
            "FUN_0000231c",
            "FUN_00002364",
            "FUN_000023d0",
            "FUN_0000258c",
            "FUN_000026c0",
            "FUN_000026d8",
            "FUN_000026e4",
            "FUN_00002798",
            "FUN_000027b0",
            "FUN_00002894",
            "FUN_00002a18",
            "FUN_0000328c",
            "FUN_00003688",
            "FUN_00003e58",
            "FUN_00003ff4",
            "FUN_00004042",
            "FUN_000041f4",
            "FUN_00004634",
            "FUN_00004b34",
            "FUN_00004e26",
            "FUN_00004f98",
            "FUN_0000562c",
            "FUN_000056b8",
            "FUN_00005b34",
            "FUN_00005fd8",
            "FUN_0000656c",
            "FUN_00006974"
        ],
        [
            "FUN_00000794",
            "FUN_00000d9c",
            "FUN_00001628",
            "FUN_00001734",
            "FUN_00001778",
            "FUN_000017dc",
            "FUN_0000182c",
            "FUN_000018bc",
            "FUN_00001960",
            "FUN_00001a60",
            "FUN_00001bb8",
            "FUN_00001ddc",
            "FUN_00002028",
            "FUN_000024bc",
            "FUN_000025f4",
            "FUN_00002994",
            "FUN_00002e9c",
            "FUN_0000404c",
            "FUN_0000443c",
            "FUN_00004bd0",
            "FUN_00004dee",
            "FUN_000056a0",
            "FUN_00005780",
            "FUN_00006192"
        ],
        [
            "FUN_00000db0",
            "FUN_000012b4",
            "FUN_00001688",
            "FUN_0000191c",
            "FUN_000019c0",
            "FUN_00001a18",
            "FUN_00001a3c",
            "FUN_00001f80",
            "FUN_000020b8",
            "FUN_000020cc",
            "FUN_000020e0",
            "FUN_000020f4",
            "FUN_00002108",
            "FUN_00002396",
            "FUN_00002624",
            "FUN_00002690",
            "FUN_00004248",
            "FUN_00005700",
            "FUN_000060cc",
            "FUN_000061cc"
        ],
        [
            "FUN_00001448",
            "FUN_00001b10",
            "FUN_00001eea",
            "FUN_00005e68",
            "FUN_000068f0"
        ],
        [
            "FUN_00001c84",
            "FUN_00005100"
        ],
        [
            "FUN_00001274",
            "FUN_000047e4"
        ],
        [
            "FUN_00000e64",
            "FUN_00002600",
            "FUN_00002654"
        ],
        [
            "FUN_000031e0",
            "FUN_000033f4",
            "FUN_00003478",
            "FUN_000034c0"
        ],
        [
            "FUN_00000ed8",
            "FUN_0000211c",
            "FUN_00003378"
        ],
        [
            "FUN_00002eb4"
        ],
        [
            "FUN_00004158",
            "FUN_00004314",
            "FUN_000054a8"
        ],
        [
            "FUN_000041d0",
            "FUN_000042a4"
        ],
        [
            "FUN_00005404",
            "FUN_00006768"
        ],
        [
            "FUN_00004cb4",
            "FUN_00004db8",
            "FUN_000057a8",
            "FUN_00005e10"
        ],
        [
            "FUN_00002a00",
            "FUN_000033c0",
            "FUN_00003444",
            "FUN_00004418",
            "FUN_000057d2"
        ],
        [
            "FUN_00002d94",
            "FUN_00002e48",
            "FUN_000057f8"
        ],
        [
            "FUN_00004c84"
        ],
        [
            "FUN_00002a88",
            "FUN_00002f74",
            "FUN_00003524"
        ],
        [
            "FUN_00002b10"
        ],
        [
            "FUN_00002e6c"
        ],
        [
            "FUN_000023a4"
        ],
        [
            "FUN_00000f04"
        ],
        [
            "FUN_00000a30",
            "FUN_00000cc0",
            "FUN_00000fec",
            "FUN_00001034",
            "FUN_000013b8",
            "FUN_00003ec4"
        ],
        [
            "FUN_00000dc0",
            "FUN_00000df4",
            "FUN_000010d4",
            "FUN_00002434",
            "FUN_00003e9e"
        ],
        [
            "FUN_00000410",
            "FUN_00000f8c",
            "FUN_0000129c",
            "FUN_00003694"
        ],
        [
            "FUN_000012e2",
            "FUN_00002ecc",
            "FUN_0000305c",
            "FUN_0000459c"
        ],
        [
            "FUN_00000e14",
            "FUN_00002f30"
        ],
        [
            "FUN_00000490",
            "FUN_00002fe0"
        ],
        [
            "FUN_0000316c",
            "FUN_00004dc8"
        ]
    ],
    "locked_functions": []
}