{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "set_flag_if_zero_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 setFlagIfZero_08000110(undefined4 input)\n\n{\n  if ((char)DAT_200009c8 == '\\0') {\n    DAT_200009c8._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000110": "set_flag_if_zero_08000110",
                "param_1": "input"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_param_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_param_08000134(undefined4 input_param_1,undefined4 input_param_2)\n\n{\n  return CONCAT44(input_param_2,input_param_1);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_param_08000134",
                "param_1": "input_param_1",
                "param_2": "input_param_2"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000158": {
            "entrypoint": "0x08000158",
            "current_name": "calculate_08000158",
            "code": "\nulonglong calculate_08000158(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shift1;\n  byte carry;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  int shift2;\n  uint result1;\n  uint result2;\n  uint result3;\n  uint result4;\n  bool isZero1;\n  bool isZero2;\n  bool isOverflow;\n  \n  temp4 = input4 ^ 0x80000000;\n  result1 = input2 << 1;\n  input4 = input4 << 1;\n  isZero1 = ((input2 ^ temp4) & 0x7fffffff) == 0;\n  isZero2 = isZero1 && input1 == input3;\n  if (!isZero1 || input1 != input3) {\n    isZero2 = (result1 | input1) == 0;\n  }\n  if (!isZero2) {\n    isZero2 = (input4 | input3) == 0;\n  }\n  shift2 = (int)result1 >> 0x15;\n  if (!isZero2) {\n    isZero2 = shift2 == -1;\n  }\n  shift1 = (int)input4 >> 0x15;\n  if (!isZero2) {\n    isZero2 = shift1 == -1;\n  }\n  if (isZero2) {\n    if (shift2 == -1 || shift1 == -1) {\n      result1 = temp4;\n      result3 = input3;\n      if (shift2 == -1) {\n        result1 = input2;\n        result3 = input1;\n      }\n      if (shift2 != -1 || shift1 != -1) {\n        input3 = result3;\n        temp4 = result1;\n      }\n      isZero2 = (result3 | result1 << 0xc) == 0;\n      if (isZero2) {\n        isZero2 = (input3 | temp4 << 0xc) == 0;\n      }\n      if (isZero2) {\n        isZero2 = result1 == temp4;\n      }\n      if (!isZero2) {\n        result1 = result1 | 0x80000;\n      }\n      return CONCAT44(result1,result3);\n    }\n    if (((input2 ^ temp4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((result1 | input1) == 0) {\n        input1 = input3;\n        input2 = temp4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != temp4) {\n      return 0;\n    }\n    if (result1 >> 0x15 == 0) {\n      isZero2 = (input1 & 0x80000000) != 0;\n      temp4 = input2 * 2 + (uint)isZero2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)isZero2)) {\n        temp4 = temp4 | 0x80000000;\n      }\n      return CONCAT44(temp4,input1 << 1);\n    }\n    if (result1 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  result1 = result1 >> 0x15;\n  input4 = input4 >> 0x15;\n  result3 = input4 - result1;\n  isZero2 = result3 != 0;\n  if (input4 < result1) {\n    result3 = -result3;\n  }\n  result2 = input1;\n  temp5 = input2;\n  if (isZero2 && result1 <= input4) {\n    result1 = result1 + result3;\n    result2 = input3;\n    temp5 = temp4;\n    input3 = input1;\n    temp4 = input2;\n  }\n  if (0x36 < result3) {\n    return CONCAT44(temp5,result2);\n  }\n  temp2 = temp5 & 0xfffff | 0x100000;\n  if ((temp5 & 0x80000000) != 0) {\n    isZero2 = result2 != 0;\n    result2 = -result2;\n    temp2 = -temp2 - (uint)isZero2;\n  }\n  temp5 = temp4 & 0xfffff | 0x100000;\n  if ((temp4 & 0x80000000) != 0) {\n    isZero2 = input3 != 0;\n    input3 = -input3;\n    temp5 = -temp5 - (uint)isZero2;\n  }\n  if (result1 == result3) {\n    temp5 = temp5 ^ 0x100000;\n    if (result1 == 0) {\n      temp2 = temp2 ^ 0x100000;\n      result1 = 1;\n    }\n    else {\n      result3 = result3 - 1;\n    }\n  }\n  temp4 = -result3 + 0x20;\n  if ((int)result3 < 0x21) {\n    result4 = input3 << (temp4 & 0xff);\n    input3 = input3 >> (result3 & 0xff);\n    temp1 = result2 + input3;\n    temp3 = temp5 << (temp4 & 0xff);\n    temp4 = temp1 + temp3;\n    temp2 = temp2 + CARRY4(result2,input3) + ((int)temp5 >> (result3 & 0xff)) +\n            (uint)CARRY4(temp1,temp3);\n  }\n  else {\n    result4 = temp5 << (-result3 + 0x40 & 0xff);\n    if (input3 != 0) {\n      result4 = result4 | 2;\n    }\n    temp5 = (int)temp5 >> (result3 - 0x20 & 0xff);\n    temp4 = result2 + temp5;\n    temp2 = temp2 + ((int)temp5 >> 0x1f) + (uint)CARRY4(result2,temp5);\n  }\n  input2 = temp2 & 0x80000000;\n  result3 = temp2;\n  if ((int)temp2 < 0) {\n    isZero2 = result4 == 0;\n    result4 = -result4;\n    result3 = -temp4;\n    temp4 = -(uint)!isZero2 - temp4;\n    result3 = -(uint)(isZero2 <= result3) - temp2;\n  }\n  if (0xfffff < result3) {\n    result2 = result1 - 1;\n    if (0x1fffff < result3) {\n      result2 = result3 & 1;\n      result3 = result3 >> 1;\n      carry = (byte)temp4;\n      temp4 = (uint)(result2 != 0) << 0x1f | temp4 >> 1;\n      result4 = (uint)(carry & 1) << 0x1f | result4 >> 1;\n      result2 = result1;\n      if (0xffbfffff < result1 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    isZero2 = 0x7fffffff < result4;\n    if (result4 == 0x80000000) {\n      isZero2 = (temp4 & 1) != 0;\n    }\n    return CONCAT44(result3 + result2 * 0x100000 + (uint)CARRY4(temp4,(uint)isZero2) | input2,\n                    temp4 + isZero2);\n  }\n  isZero1 = (result4 & 0x80000000) != 0;\n  result4 = result4 << 1;\n  result2 = temp4 * 2;\n  isZero2 = CARRY4(temp4,temp4);\n  temp4 = temp4 * 2 + (uint)isZero1;\n  result3 = result3 * 2 + (uint)(isZero2 || CARRY4(result2,(uint)isZero1));\n  result2 = result1 - 2;\n  if ((result3 & 0x100000) != 0) goto LAB_08000268;\n  temp5 = temp4;\n  result1 = result3;\n  if (result3 == 0) {\n    temp5 = 0;\n    result1 = temp4;\n  }\n  shift2 = LZCOUNT(result1);\n  if (result3 == 0) {\n    shift2 = shift2 + 0x20;\n  }\n  result3 = shift2 - 0xb;\n  isOverflow = SBORROW4(result3,0x20);\n  temp4 = shift2 - 0x2b;\n  isZero2 = (int)temp4 < 0;\n  isZero1 = temp4 == 0;\n  if ((int)result3 < 0x20) {\n    isOverflow = SCARRY4(temp4,0xc);\n    shift2 = shift2 + -0x1f;\n    isZero2 = shift2 < 0;\n    isZero1 = shift2 == 0;\n    temp4 = result3;\n    if (!isZero1 && isZero2 == isOverflow) {\n      temp5 = result1 << (result3 & 0xff);\n      result1 = result1 >> (0xcU - shift2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isZero1 || isZero2 != isOverflow) {\n    result4 = 0x20 - temp4;\n  }\n  result1 = result1 << (temp4 & 0xff);\n  if (isZero1 || isZero2 != isOverflow) {\n    result1 = result1 | temp5 >> (result4 & 0xff);\n  }\n  if (isZero1 || isZero2 != isOverflow) {\n    temp5 = temp5 << (temp4 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)result3 <= (int)result2) {\n    return CONCAT44(result1 + (result2 - result3) * 0x100000 | input2,temp5);\n  }\n  temp4 = ~(result2 - result3);\n  if ((int)temp4 < 0x1f) {\n    shift2 = temp4 - 0x13;\n    if (shift2 != 0 && shift2 < 0 == SCARRY4(temp4 - 0x1f,0xc)) {\n      return CONCAT44(temp2,temp5 >> (0x20 - (0xcU - shift2) & 0xff) | result1 << (0xcU - shift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp4 = temp4 + 1;\n    return CONCAT44(input2 | result1 >> (temp4 & 0xff),\n                    temp5 >> (temp4 & 0xff) | result1 << (0x20 - temp4 & 0xff));\n  }\n  return CONCAT44(temp2,result1 >> (temp4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000158": "calculate_08000158",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shift1",
                "bVar2": "carry",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "temp4",
                "uVar7": "temp5",
                "iVar8": "shift2",
                "uVar9": "result1",
                "uVar10": "result2",
                "uVar11": "result3",
                "uVar12": "result4",
                "bVar13": "isZero1",
                "bVar14": "isZero2",
                "bVar15": "isOverflow"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800015c": {
            "entrypoint": "0x0800015c",
            "current_name": "calculate_value_0800015c",
            "code": "\nulonglong calculateValue_0800015c(uint num1,uint num2,uint num3,uint num4)\n\n{\n  int shift1;\n  byte carry;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shift2;\n  uint var1;\n  uint var2;\n  uint var3;\n  uint var4;\n  uint var5;\n  uint var6;\n  bool bool1;\n  bool bool2;\n  bool bool3;\n  \n  var1 = num2 << 1;\n  var3 = num4 << 1;\n  bool1 = ((num2 ^ num4) & 0x7fffffff) == 0;\n  bool2 = bool1 && num1 == num3;\n  if (!bool1 || num1 != num3) {\n    bool2 = (var1 | num1) == 0;\n  }\n  if (!bool2) {\n    bool2 = (var3 | num3) == 0;\n  }\n  shift2 = (int)var1 >> 0x15;\n  if (!bool2) {\n    bool2 = shift2 == -1;\n  }\n  shift1 = (int)var3 >> 0x15;\n  if (!bool2) {\n    bool2 = shift1 == -1;\n  }\n  if (bool2) {\n    if (shift2 == -1 || shift1 == -1) {\n      var3 = num4;\n      var1 = num3;\n      if (shift2 == -1) {\n        var3 = num2;\n        var1 = num1;\n      }\n      if (shift2 != -1 || shift1 != -1) {\n        num3 = var1;\n        num4 = var3;\n      }\n      bool2 = (var1 | var3 << 0xc) == 0;\n      if (bool2) {\n        bool2 = (num3 | num4 << 0xc) == 0;\n      }\n      if (bool2) {\n        bool2 = var3 == num4;\n      }\n      if (!bool2) {\n        var3 = var3 | 0x80000;\n      }\n      return CONCAT44(var3,var1);\n    }\n    if (((num2 ^ num4) & 0x7fffffff) != 0 || num1 != num3) {\n      if ((var1 | num1) == 0) {\n        num1 = num3;\n        num2 = num4;\n      }\n      return CONCAT44(num2,num1);\n    }\n    if (num2 != num4) {\n      return 0;\n    }\n    if (var1 >> 0x15 == 0) {\n      bool2 = (num1 & 0x80000000) != 0;\n      var3 = num2 * 2 + (uint)bool2;\n      if (CARRY4(num2,num2) || CARRY4(num2 * 2,(uint)bool2)) {\n        var3 = var3 | 0x80000000;\n      }\n      return CONCAT44(var3,num1 << 1);\n    }\n    if (var1 < 0xffc00000) {\n      return CONCAT44(num2 + 0x100000,num1);\n    }\n    num2 = num2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(num2 | 0x7ff00000) << 0x20;\n  }\n  var1 = var1 >> 0x15;\n  var3 = var3 >> 0x15;\n  var4 = var3 - var1;\n  bool2 = var4 != 0;\n  if (var3 < var1) {\n    var4 = -var4;\n  }\n  var2 = num1;\n  temp3 = num2;\n  if (bool2 && var1 <= var3) {\n    var1 = var1 + var4;\n    var2 = num3;\n    temp3 = num4;\n    num3 = num1;\n    num4 = num2;\n  }\n  if (0x36 < var4) {\n    return CONCAT44(temp3,var2);\n  }\n  var3 = temp3 & 0xfffff | 0x100000;\n  if ((temp3 & 0x80000000) != 0) {\n    bool2 = var2 != 0;\n    var2 = -var2;\n    var3 = -var3 - (uint)bool2;\n  }\n  temp3 = num4 & 0xfffff | 0x100000;\n  if ((num4 & 0x80000000) != 0) {\n    bool2 = num3 != 0;\n    num3 = -num3;\n    temp3 = -temp3 - (uint)bool2;\n  }\n  if (var1 == var4) {\n    temp3 = temp3 ^ 0x100000;\n    if (var1 == 0) {\n      var3 = var3 ^ 0x100000;\n      var1 = 1;\n    }\n    else {\n      var4 = var4 - 1;\n    }\n  }\n  var6 = -var4 + 0x20;\n  if ((int)var4 < 0x21) {\n    var5 = num3 << (var6 & 0xff);\n    num3 = num3 >> (var4 & 0xff);\n    temp1 = var2 + num3;\n    temp2 = temp3 << (var6 & 0xff);\n    var6 = temp1 + temp2;\n    var3 = var3 + CARRY4(var2,num3) + ((int)temp3 >> (var4 & 0xff)) +\n            (uint)CARRY4(temp1,temp2);\n  }\n  else {\n    var5 = temp3 << (-var4 + 0x40 & 0xff);\n    if (num3 != 0) {\n      var5 = var5 | 2;\n    }\n    temp3 = (int)temp3 >> (var4 - 0x20 & 0xff);\n    var6 = var2 + temp3;\n    var3 = var3 + ((int)temp3 >> 0x1f) + (uint)CARRY4(var2,temp3);\n  }\n  num2 = var3 & 0x80000000;\n  var4 = var3;\n  if ((int)var3 < 0) {\n    bool2 = var5 == 0;\n    var5 = -var5;\n    var4 = -var6;\n    var6 = -(uint)!bool2 - var6;\n    var4 = -(uint)(bool2 <= var4) - var3;\n  }\n  if (0xfffff < var4) {\n    var2 = var1 - 1;\n    if (0x1fffff < var4) {\n      var3 = var4 & 1;\n      var4 = var4 >> 1;\n      carry = (byte)var6;\n      var6 = (uint)(var3 != 0) << 0x1f | var6 >> 1;\n      var5 = (uint)(carry & 1) << 0x1f | var5 >> 1;\n      var2 = var1;\n      if (0xffbfffff < var1 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    bool2 = 0x7fffffff < var5;\n    if (var5 == 0x80000000) {\n      bool2 = (var6 & 1) != 0;\n    }\n    return CONCAT44(var4 + var2 * 0x100000 + (uint)CARRY4(var6,(uint)bool2) | num2,\n                    var6 + bool2);\n  }\n  bool1 = (var5 & 0x80000000) != 0;\n  var5 = var5 << 1;\n  var2 = var6 * 2;\n  bool2 = CARRY4(var6,var6);\n  var6 = var6 * 2 + (uint)bool1;\n  var4 = var4 * 2 + (uint)(bool2 || CARRY4(var2,(uint)bool1));\n  var2 = var1 - 2;\n  if ((var4 & 0x100000) != 0) goto LAB_08000268;\n  temp3 = var6;\n  var1 = var4;\n  if (var4 == 0) {\n    temp3 = 0;\n    var1 = var6;\n  }\n  shift2 = LZCOUNT(var1);\n  if (var4 == 0) {\n    shift2 = shift2 + 0x20;\n  }\n  var6 = shift2 - 0xb;\n  bool3 = SBORROW4(var6,0x20);\n  var4 = shift2 - 0x2b;\n  bool2 = (int)var4 < 0;\n  bool1 = var4 == 0;\n  if ((int)var6 < 0x20) {\n    bool3 = SCARRY4(var4,0xc);\n    shift2 = shift2 + -0x1f;\n    bool2 = shift2 < 0;\n    bool1 = shift2 == 0;\n    var4 = var6;\n    if (!bool1 && bool2 == bool3) {\n      temp3 = var1 << (var6 & 0xff);\n      var1 = var1 >> (0xcU - shift2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (bool1 || bool2 != bool3) {\n    var5 = 0x20 - var4;\n  }\n  var1 = var1 << (var4 & 0xff);\n  if (bool1 || bool2 != bool3) {\n    var1 = var1 | temp3 >> (var5 & 0xff);\n  }\n  if (bool1 || bool2 != bool3) {\n    temp3 = temp3 << (var4 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)var6 <= (int)var2) {\n    return CONCAT44(var1 + (var2 - var6) * 0x100000 | num2,temp3);\n  }\n  var4 = ~(var2 - var6);\n  if ((int)var4 < 0x1f) {\n    shift2 = var4 - 0x13;\n    if (shift2 != 0 && shift2 < 0 == SCARRY4(var4 - 0x1f,0xc)) {\n      return CONCAT44(var3,temp3 >> (0x20 - (0xcU - shift2) & 0xff) | var1 << (0xcU - shift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    var4 = var4 + 1;\n    return CONCAT44(num2 | var1 >> (var4 & 0xff),\n                    temp3 >> (var4 & 0xff) | var1 << (0x20 - var4 & 0xff));\n  }\n  return CONCAT44(var3,var1 >> (var4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800015c": "calculate_value_0800015c",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "iVar1": "shift1",
                "bVar2": "carry",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "iVar6": "shift2",
                "uVar7": "var1",
                "uVar8": "var2",
                "uVar9": "var3",
                "uVar10": "var4",
                "uVar11": "var5",
                "uVar12": "var6",
                "bVar13": "bool1",
                "bVar14": "bool2",
                "bVar15": "bool3"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003d4": {
            "entrypoint": "0x080003d4",
            "current_name": "shift_and_concat_080003d4",
            "code": "\nulonglong shift_and_concat_080003d4(uint input)\n\n{\n  uint highBits;\n  uint shiftAmount;\n  int bitCount;\n  uint totalBits;\n  uint remainingBits;\n  bool isShiftNegative;\n  bool isShiftZero;\n  bool isTotalBitsNegative;\n  \n  if (input == 0) {\n    return 0;\n  }\n  highBits = 0;\n  bitCount = LZCOUNT(input);\n  totalBits = bitCount + 0x15;\n  isTotalBitsNegative = SBORROW4(totalBits,0x20);\n  shiftAmount = bitCount - 0xb;\n  isShiftNegative = (int)shiftAmount < 0;\n  isShiftZero = shiftAmount == 0;\n  if (totalBits < 0x20) {\n    isTotalBitsNegative = SCARRY4(shiftAmount,0xc);\n    isShiftNegative = false;\n    isShiftZero = bitCount + 1 == 0;\n    shiftAmount = totalBits;\n    if (!isShiftZero && isTotalBitsNegative == false) {\n      highBits = input << totalBits;\n      input = input >> (0xcU - (bitCount + 1) & 0xff);\n      goto shift_helper;\n    }\n  }\n  if (isShiftZero || isShiftNegative != isTotalBitsNegative) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  input = input << (shiftAmount & 0xff);\n  if (isShiftZero || isShiftNegative != isTotalBitsNegative) {\n    input = input | 0U >> (remainingBits & 0xff);\n  }\n  if (isShiftZero || isShiftNegative != isTotalBitsNegative) {\n    highBits = 0 << (shiftAmount & 0xff);\n  }\nshift_helper:\n  if (totalBits < 0x433) {\n    return combine_high_low(input + (0x432 - totalBits) * 0x100000,highBits);\n  }\n  shiftAmount = ~(0x432 - totalBits);\n  if (0x1e < (int)shiftAmount) {\n    return (ulonglong)(input >> (shiftAmount - 0x1f & 0xff));\n  }\n  bitCount = shiftAmount - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return combine_high_low(input >> (shiftAmount & 0xff),\n                    highBits >> (shiftAmount & 0xff) | input << (0x20 - shiftAmount & 0xff));\n  }\n  return (ulonglong)(highBits >> (0x20 - (0xcU - bitCount) & 0xff) | input << (0xcU - bitCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003d4": "shift_and_concat_080003d4",
                "param_1": "input",
                "uVar1": "highBits",
                "uVar2": "shiftAmount",
                "iVar3": "bitCount",
                "uVar4": "totalBits",
                "in_r12": "remainingBits",
                "bVar5": "isShiftNegative",
                "bVar6": "isShiftZero",
                "bVar7": "isTotalBitsNegative",
                "LAB_080002e0": "shift_helper",
                "CONCAT44": "combine_high_low"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003f4": {
            "entrypoint": "0x080003f4",
            "current_name": "compute_shifted_value_080003f4",
            "code": "\nulonglong computeShiftedValue_080003f4(uint inputValue)\n\n{\n  uint shiftedValue;\n  uint absInputValue;\n  uint shiftAmount;\n  int leadingZeros;\n  uint adjustedShiftAmount;\n  uint isNegative;\n  uint remainingBits;\n  bool isNegativeShift;\n  bool isZeroShift;\n  bool carryFlag;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  isNegative = inputValue & 0x80000000;\n  absInputValue = inputValue;\n  if ((int)isNegative < 0) {\n    absInputValue = -inputValue;\n  }\n  shiftedValue = 0;\n  leadingZeros = LZCOUNT(absInputValue);\n  adjustedShiftAmount = leadingZeros + 0x15;\n  carryFlag = SBORROW4(adjustedShiftAmount,0x20);\n  shiftAmount = leadingZeros - 0xb;\n  isNegativeShift = (int)shiftAmount < 0;\n  isZeroShift = shiftAmount == 0;\n  if (adjustedShiftAmount < 0x20) {\n    carryFlag = SCARRY4(shiftAmount,0xc);\n    isNegativeShift = false;\n    isZeroShift = leadingZeros + 1 == 0;\n    shiftAmount = adjustedShiftAmount;\n    if (!isZeroShift && carryFlag == false) {\n      shiftedValue = absInputValue << adjustedShiftAmount;\n      absInputValue = absInputValue >> (0xcU - (leadingZeros + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isZeroShift || isNegativeShift != carryFlag) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  absInputValue = absInputValue << (shiftAmount & 0xff);\n  if (isZeroShift || isNegativeShift != carryFlag) {\n    absInputValue = absInputValue | 0U >> (remainingBits & 0xff);\n  }\n  if (isZeroShift || isNegativeShift != carryFlag) {\n    shiftedValue = 0 << (shiftAmount & 0xff);\n  }\nLAB_080002e0:\n  if (adjustedShiftAmount < 0x433) {\n    return CONCAT44(absInputValue + (0x432 - adjustedShiftAmount) * 0x100000 | isNegative,shiftedValue);\n  }\n  shiftAmount = ~(0x432 - adjustedShiftAmount);\n  if (0x1e < (int)shiftAmount) {\n    return CONCAT44(inputValue,absInputValue >> (shiftAmount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leadingZeros = shiftAmount - 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(isNegative | absInputValue >> (shiftAmount & 0xff),\n                    shiftedValue >> (shiftAmount & 0xff) | absInputValue << (0x20 - shiftAmount & 0xff));\n  }\n  return CONCAT44(inputValue,shiftedValue >> (0x20 - (0xcU - leadingZeros) & 0xff) | absInputValue << (0xcU - leadingZeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080003f4": "compute_shifted_value_080003f4",
                "param_1": "inputValue",
                "uVar1": "shiftedValue",
                "uVar2": "absInputValue",
                "uVar3": "shiftAmount",
                "iVar4": "leadingZeros",
                "uVar5": "adjustedShiftAmount",
                "uVar6": "isNegative",
                "in_r12": "remainingBits",
                "bVar7": "isNegativeShift",
                "bVar8": "isZeroShift",
                "bVar9": "carryFlag"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000418": {
            "entrypoint": "0x08000418",
            "current_name": "reverse_bits_08000418",
            "code": "\nulonglong reverseBits_08000418(uint input,undefined4 unused,undefined4 unused,uint unused)\n\n{\n  uint isNegative;\n  uint temp1;\n  uint resultHigh;\n  uint shiftedInput;\n  uint inputShifted;\n  int bitCount;\n  uint shiftAmount;\n  uint remainingBits;\n  bool isNegativeShift;\n  bool isParamEqualToFF000000;\n  bool carryFlag;\n  \n  inputShifted = input << 1;\n  isParamEqualToFF000000 = inputShifted == 0;\n  isNegative = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shiftedInput = (uint)((int)inputShifted >> 3) >> 1;\n  resultHigh = isNegative | shiftedInput;\n  input = input << 0x1d;\n  if (!isParamEqualToFF000000) {\n    unused = inputShifted & 0xff000000;\n    isParamEqualToFF000000 = unused == 0;\n  }\n  if (!isParamEqualToFF000000) {\n    isParamEqualToFF000000 = unused == 0xff000000;\n  }\n  if (!isParamEqualToFF000000) {\n    return CONCAT44(resultHigh,input) ^ 0x3800000000000000;\n  }\n  if ((inputShifted & 0xffffff) == 0) {\n    return CONCAT44(resultHigh,input);\n  }\n  if (unused == 0xff000000) {\n    return CONCAT44(resultHigh,input) | 0x8000000000000;\n  }\n  temp1 = input;\n  inputShifted = shiftedInput;\n  if (shiftedInput == 0) {\n    temp1 = 0;\n    inputShifted = input;\n  }\n  bitCount = LZCOUNT(inputShifted);\n  if (shiftedInput == 0) {\n    bitCount = bitCount + 0x20;\n  }\n  shiftAmount = bitCount - 0xb;\n  carryFlag = SBORROW4(shiftAmount,0x20);\n  shiftedInput = bitCount - 0x2b;\n  isParamEqualToFF000000 = (int)shiftedInput < 0;\n  isNegativeShift = shiftedInput == 0;\n  if ((int)shiftAmount < 0x20) {\n    carryFlag = SCARRY4(shiftedInput,0xc);\n    bitCount = bitCount + -0x1f;\n    isParamEqualToFF000000 = bitCount < 0;\n    isNegativeShift = bitCount == 0;\n    shiftedInput = shiftAmount;\n    if (!isNegativeShift && isParamEqualToFF000000 == carryFlag) {\n      temp1 = inputShifted << (shiftAmount & 0xff);\n      inputShifted = inputShifted >> (0xcU - bitCount & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isNegativeShift || isParamEqualToFF000000 != carryFlag) {\n    remainingBits = 0x20 - shiftedInput;\n  }\n  inputShifted = inputShifted << (shiftedInput & 0xff);\n  if (isNegativeShift || isParamEqualToFF000000 != carryFlag) {\n    inputShifted = inputShifted | temp1 >> (remainingBits & 0xff);\n  }\n  if (isNegativeShift || isParamEqualToFF000000 != carryFlag) {\n    temp1 = temp1 << (shiftedInput & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shiftAmount < 0x381) {\n    return CONCAT44(inputShifted + (0x380 - shiftAmount) * 0x100000 | isNegative,temp1);\n  }\n  shiftedInput = ~(0x380 - shiftAmount);\n  if (0x1e < (int)shiftedInput) {\n    return CONCAT44(resultHigh,inputShifted >> (shiftedInput - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  bitCount = shiftedInput - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(shiftedInput - 0x1f,0xc)) {\n    shiftedInput = shiftedInput + 1;\n    return CONCAT44(isNegative | inputShifted >> (shiftedInput & 0xff),\n                    temp1 >> (shiftedInput & 0xff) | inputShifted << (0x20 - shiftedInput & 0xff));\n  }\n  return CONCAT44(resultHigh,temp1 >> (0x20 - (0xcU - bitCount) & 0xff) | inputShifted << (0xcU - bitCount & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000418": "reverse_bits_08000418",
                "param_1": "input",
                "param_2": "unused",
                "param_3": "unused",
                "param_4": "unused",
                "uVar1": "isNegative",
                "uVar2": "temp1",
                "uVar3": "resultHigh",
                "uVar4": "shiftedInput",
                "uVar5": "inputShifted",
                "uVar7": "shiftAmount",
                "in_r12": "remainingBits",
                "bVar8": "isNegativeShift",
                "bVar9": "isParamEqualToFF000000",
                "bVar10": "carryFlag",
                "iVar6": "bitCount"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004c8": {
            "entrypoint": "0x080004c8",
            "current_name": "calculate_floating_point_080004c8",
            "code": "\nulonglong calculateFloatingPoint_080004c8(undefined4 value1,uint value2,uint value3,uint value4)\n\n{\n  ulonglong result1;\n  longlong result2;\n  uint temp1;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  uint unaff_r5;\n  uint temp5;\n  uint temp6;\n  bool tempBool1;\n  bool tempBool2;\n  bool tempBool3;\n  ulonglong tempResult;\n  \n  tempResult = CONCAT44(value2,value1);\n  temp5 = 0x7ff;\n  temp2 = value2 >> 0x14 & 0x7ff;\n  tempBool1 = temp2 == 0;\n  if (!tempBool1) {\n    unaff_r5 = value4 >> 0x14 & 0x7ff;\n    tempBool1 = unaff_r5 == 0;\n  }\n  if (!tempBool1) {\n    tempBool1 = temp2 == 0x7ff;\n  }\n  if (!tempBool1) {\n    tempBool1 = unaff_r5 == 0x7ff;\n  }\n  if (tempBool1) {\n    tempResult = reverse_shift_operation_080006a4();\n  }\n  temp1 = (uint)(tempResult >> 0x20);\n  temp3 = temp2 + unaff_r5;\n  temp2 = temp1 ^ value4;\n  temp1 = temp1 & ~(temp5 << 0x15);\n  value4 = value4 & ~(temp5 << 0x15);\n  tempBool1 = ((uint)tempResult | temp1 << 0xc) == 0;\n  if (!tempBool1) {\n    tempBool1 = (value3 | value4 << 0xc) == 0;\n  }\n  temp1 = temp1 | 0x100000;\n  value4 = value4 | 0x100000;\n  if (tempBool1) {\n    value3 = (uint)tempResult | value3;\n    value4 = (temp2 & 0x80000000 | temp1) ^ value4;\n    temp2 = temp5 >> 1;\n    tempBool3 = SBORROW4(temp3,temp2);\n    temp4 = temp3 - temp2;\n    tempBool1 = temp4 == 0;\n    temp1 = temp4;\n    if (!tempBool1 && (int)temp2 <= temp3) {\n      tempBool3 = SBORROW4(temp5,temp4);\n      temp1 = temp5 - temp4;\n      tempBool1 = temp5 == temp4;\n    }\n    if (!tempBool1 && (int)temp1 < 0 == tempBool3) {\n      value4 = value4 | temp4 * 0x100000;\n    }\n    if (!tempBool1 && (int)temp1 < 0 == tempBool3) {\n      return CONCAT44(value4,value3);\n    }\n    value4 = value4 | 0x100000;\n    temp5 = 0;\n    tempBool3 = SBORROW4(temp4,1);\n    temp4 = temp4 - 1;\n    tempBool1 = temp4 == 0;\n    temp2 = temp4;\n  }\n  else {\n    result1 = (tempResult & 0xffffffff) * (ulonglong)value3;\n    tempResult = (tempResult & 0xffffffff) * (ulonglong)value4 +\n             (ulonglong)temp1 * (ulonglong)value3 + (result1 >> 0x20);\n    temp6 = (uint)tempResult;\n    result2 = (ulonglong)temp1 * (ulonglong)value4 + (tempResult >> 0x20);\n    temp5 = (uint)result2;\n    temp1 = (uint)((ulonglong)result2 >> 0x20);\n    if ((int)result1 != 0) {\n      temp6 = temp6 | 1;\n    }\n    temp4 = (temp3 + -0x3ff) - (uint)(temp1 < 0x200);\n    if (temp1 < 0x200) {\n      tempBool1 = (temp6 & 0x80000000) != 0;\n      temp6 = temp6 << 1;\n      result2 = CONCAT44(temp1 * 2 + (uint)(CARRY4(temp5,temp5) || CARRY4(temp5 * 2,(uint)tempBool1)),\n                       temp5 * 2 + (uint)tempBool1);\n    }\n    value4 = temp2 & 0x80000000 | (int)((ulonglong)result2 >> 0x20) << 0xb | (uint)result2 >> 0x15;\n    value3 = (uint)result2 << 0xb | temp6 >> 0x15;\n    temp5 = temp6 * 0x800;\n    tempBool2 = 0xfc < temp4;\n    tempBool3 = SBORROW4(temp4,0xfd);\n    temp1 = temp4 - 0xfd;\n    tempBool1 = temp1 == 0;\n    temp2 = temp1;\n    if (tempBool2 && !tempBool1) {\n      tempBool2 = 0x6ff < temp1;\n      tempBool3 = SBORROW4(temp1,0x700);\n      temp2 = temp4 - 0x7fd;\n      tempBool1 = temp1 == 0x700;\n    }\n    if (!tempBool2 || tempBool1) {\n      tempBool1 = 0x7fffffff < temp5;\n      if (temp5 == 0x80000000) {\n        tempBool1 = (temp6 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(value4 + temp4 * 0x100000 + (uint)CARRY4(value3,(uint)tempBool1),value3 + tempBool1\n                     );\n    }\n  }\n  if (!tempBool1 && (int)temp2 < 0 == tempBool3) {\n    return (ulonglong)(value4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  tempBool2 = SCARRY4(temp4,0x36);\n  tempBool1 = (int)(temp4 + 0x36) < 0;\n  tempBool3 = temp4 == 0xffffffca;\n  if (tempBool3 || tempBool1 != tempBool2) {\n    value3 = 0;\n  }\n  if (tempBool3 || tempBool1 != tempBool2) {\n    value4 = value4 & 0x80000000;\n  }\n  if (tempBool3 || tempBool1 != tempBool2) {\n    return CONCAT44(value4,value3);\n  }\n  temp2 = -temp4;\n  temp1 = temp2 - 0x20;\n  if (0x1f < (int)temp2) {\n    temp4 = value3 >> (temp1 & 0xff) | value4 << (0x20 - temp1 & 0xff);\n    temp2 = (value4 >> (temp1 & 0xff) & ~((value4 & 0x80000000) >> (temp1 & 0xff))) -\n            ((int)temp4 >> 0x1f);\n    if ((temp5 | value3 << (0x20 - temp1 & 0xff) | temp4 << 1) == 0) {\n      temp2 = temp2 & ~(temp4 >> 0x1f);\n    }\n    return CONCAT44(value4,temp2) & 0x80000000ffffffff;\n  }\n  temp3 = temp2 - 0x14;\n  if (temp3 == 0 || temp3 < 0 != SCARRY4(temp1,0xc)) {\n    temp6 = value3 << (temp4 + 0x20 & 0xff);\n    temp1 = value3 >> (temp2 & 0xff) | value4 << (temp4 + 0x20 & 0xff);\n    temp4 = temp1 + -((int)temp6 >> 0x1f);\n    if ((temp5 | temp6 << 1) == 0) {\n      temp4 = temp4 & ~(temp6 >> 0x1f);\n    }\n    return CONCAT44((value4 & 0x80000000) +\n                    ((value4 & 0x7fffffff) >> (temp2 & 0xff)) +\n                    (uint)CARRY4(temp1,-((int)temp6 >> 0x1f)),temp4);\n  }\n  temp2 = 0xc - temp3;\n  temp4 = value3 << (temp2 & 0xff);\n  temp2 = value3 >> (0x20 - temp2 & 0xff) | value4 << (temp2 & 0xff);\n  temp1 = temp2 + -((int)temp4 >> 0x1f);\n  if ((temp5 | temp4 << 1) == 0) {\n    temp1 = temp1 & ~(temp4 >> 0x1f);\n  }\n  return CONCAT44((value4 & 0x80000000) + (uint)CARRY4(temp2,-((int)temp4 >> 0x1f)),temp1);\n}\n\n",
            "renaming": {
                "FUN_080004c8": "calculate_floating_point_080004c8",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result1",
                "lVar2": "result2",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "iVar5": "temp3",
                "uVar6": "temp4",
                "uVar7": "temp5",
                "uVar8": "temp6",
                "bVar9": "tempBool1",
                "bVar10": "tempBool2",
                "bVar11": "tempBool3",
                "uVar12": "tempResult"
            },
            "calling": [
                "frexp",
                "atan",
                "_dtoa_r",
                "mpu6050_calc_pitch",
                "_svfprintf_r",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [
                "FUN_080006a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006a4": {
            "entrypoint": "0x080006a4",
            "current_name": "reverse_shift_operation_080006a4",
            "code": "\nulonglong reverse_shift_operation_080006a4(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  bool isZero;\n  \n  temp3 = temp5 & input4 >> 0x14;\n  if (temp2 != temp5 && temp3 != temp5) {\n    isZero = (input1 | input2 << 1) == 0;\n    if (!isZero) {\n      isZero = (input3 | input4 << 1) == 0;\n    }\n    if (isZero) {\n      return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n    }\n    if (temp2 == 0) {\n      temp4 = input2 & 0x80000000;\n      do {\n        temp1 = input1 & 0x80000000;\n        input1 = input1 << 1;\n        input2 = input2 * 2 + (uint)(temp1 != 0);\n      } while ((input2 & 0x100000) == 0);\n      input2 = input2 | temp4;\n      if (temp3 != 0) {\n        return CONCAT44(input2,input1);\n      }\n    }\n    do {\n      temp3 = input3 & 0x80000000;\n      input3 = input3 << 1;\n      input4 = input4 * 2 + (uint)(temp3 != 0);\n    } while ((input4 & 0x100000) == 0);\n    return CONCAT44(input2,input1);\n  }\n  isZero = (input1 | input2 << 1) == 0;\n  if (isZero) {\n    input2 = input4;\n    input1 = input3;\n  }\n  if (!isZero) {\n    isZero = (input3 | input4 << 1) == 0;\n  }\n  temp4 = input2;\n  if (((!isZero) && ((temp2 != temp5 || ((input1 | input2 << 0xc) == 0)))) &&\n     ((temp3 != temp5 || (input1 = input3, temp4 = input4, (input3 | input4 << 0xc) == 0)))) {\n    return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(temp4,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006a4": "reverse_shift_operation_080006a4",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "temp1",
                "unaff_r4": "temp2",
                "uVar2": "temp3",
                "uVar3": "temp4",
                "in_r12": "temp5",
                "bVar4": "isZero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800071c": {
            "entrypoint": "0x0800071c",
            "current_name": "calculate_floating_point_0800071c",
            "code": "\nulonglong calculate_floating_point_0800071c(undefined4 input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  uint temp_4;\n  uint temp_5;\n  uint temp_6;\n  uint temp_7;\n  int temp_8;\n  uint temp_9;\n  uint unaff_r5;\n  uint temp_10;\n  uint temp_11;\n  uint temp_12;\n  uint temp_13;\n  bool temp_flag1;\n  bool temp_flag2;\n  bool temp_flag3;\n  undefined8 result;\n  \n  result = CONCAT44(input_2,input_1);\n  temp_13 = 0x7ff;\n  temp_7 = input_2 >> 0x14 & 0x7ff;\n  temp_flag1 = temp_7 == 0;\n  if (!temp_flag1) {\n    unaff_r5 = input_4 >> 0x14 & 0x7ff;\n    temp_flag1 = unaff_r5 == 0;\n  }\n  if (!temp_flag1) {\n    temp_flag1 = temp_7 == 0x7ff;\n  }\n  if (!temp_flag1) {\n    temp_flag1 = unaff_r5 == 0x7ff;\n  }\n  if (temp_flag1) {\n    result = calculate_floating_point_0800071c_0800088a();\n  }\n  temp_9 = (uint)((ulonglong)result >> 0x20);\n  temp_11 = (uint)result;\n  temp_8 = temp_7 - unaff_r5;\n  if ((input_3 | input_4 << 0xc) == 0) {\n    temp_7 = (temp_9 ^ input_4) & 0x80000000 | temp_9 & 0xfffff;\n    temp_flag3 = SCARRY4(temp_8,temp_13 >> 1);\n    temp_9 = temp_8 + (temp_13 >> 1);\n    temp_flag1 = (int)temp_9 < 0;\n    temp_flag2 = temp_9 == 0;\n    if (!temp_flag2 && temp_flag1 == temp_flag3) {\n      temp_flag3 = SBORROW4(temp_13,temp_9);\n      temp_flag1 = (int)(temp_13 - temp_9) < 0;\n      temp_flag2 = temp_13 == temp_9;\n    }\n    if (!temp_flag2 && temp_flag1 == temp_flag3) {\n      temp_7 = temp_7 | temp_9 * 0x100000;\n    }\n    if (!temp_flag2 && temp_flag1 == temp_flag3) {\n      return CONCAT44(temp_7,temp_11);\n    }\n    temp_7 = temp_7 | 0x100000;\n    temp_13 = 0;\n    temp_flag2 = SBORROW4(temp_9,1);\n    temp_9 = temp_9 - 1;\n    temp_flag1 = temp_9 == 0;\n    temp_3 = temp_9;\n  }\n  else {\n    temp_3 = (input_4 << 0xc) >> 4 | 0x10000000 | input_3 >> 0x18;\n    temp_13 = input_3 << 8;\n    temp_10 = (temp_9 << 0xc) >> 4 | 0x10000000 | temp_11 >> 0x18;\n    temp_11 = temp_11 * 0x100;\n    temp_7 = (temp_9 ^ input_4) & 0x80000000;\n    temp_flag1 = temp_3 <= temp_10;\n    if (temp_10 == temp_3) {\n      temp_flag1 = temp_13 <= temp_11;\n    }\n    temp_8 = temp_8 + (uint)temp_flag1;\n    temp_9 = temp_8 + 0x3fd;\n    if (temp_flag1 == false) {\n      temp_3 = temp_3 >> 1;\n      temp_13 = (uint)((input_3 >> 0x18 & 1) != 0) << 0x1f | temp_13 >> 1;\n    }\n    temp_12 = temp_11 - temp_13;\n    temp_10 = (temp_10 - temp_3) - (uint)(temp_11 < temp_13);\n    temp_4 = temp_3 >> 1;\n    temp_1 = (uint)((temp_3 & 1) != 0) << 0x1f | temp_13 >> 1;\n    temp_11 = 0x100000;\n    temp_3 = 0x80000;\n    while( true ) {\n      temp_flag1 = temp_1 <= temp_12;\n      if (temp_4 < temp_10 || temp_10 - temp_4 < (uint)temp_flag1) {\n        temp_12 = temp_12 - temp_1;\n        temp_11 = temp_11 | temp_3;\n        temp_10 = (temp_10 - temp_4) - (uint)!temp_flag1;\n      }\n      temp_5 = temp_4 >> 1;\n      temp_1 = (uint)((temp_4 & 1) != 0) << 0x1f | temp_1 >> 1;\n      temp_flag2 = temp_1 <= temp_12;\n      temp_flag1 = temp_10 - temp_5 < (uint)temp_flag2;\n      temp_13 = temp_10;\n      if (temp_5 < temp_10 || temp_flag1) {\n        temp_12 = temp_12 - temp_1;\n        temp_13 = (temp_10 - temp_5) - (uint)!temp_flag2;\n      }\n      if (temp_5 < temp_10 || temp_flag1) {\n        temp_11 = temp_11 | temp_3 >> 1;\n      }\n      temp_10 = temp_4 >> 2;\n      temp_2 = (uint)((temp_5 & 1) != 0) << 0x1f | temp_1 >> 1;\n      temp_flag2 = temp_2 <= temp_12;\n      temp_flag1 = temp_13 - temp_10 < (uint)temp_flag2;\n      temp_5 = temp_13;\n      if (temp_10 < temp_13 || temp_flag1) {\n        temp_12 = temp_12 - temp_2;\n        temp_5 = (temp_13 - temp_10) - (uint)!temp_flag2;\n      }\n      if (temp_10 < temp_13 || temp_flag1) {\n        temp_11 = temp_11 | temp_3 >> 2;\n      }\n      temp_6 = temp_4 >> 3;\n      temp_1 = (uint)((temp_10 & 1) != 0) << 0x1f | temp_2 >> 1;\n      temp_flag2 = temp_1 <= temp_12;\n      temp_flag1 = temp_5 - temp_6 < (uint)temp_flag2;\n      temp_10 = temp_5;\n      if (temp_6 < temp_5 || temp_flag1) {\n        temp_12 = temp_12 - temp_1;\n        temp_10 = (temp_5 - temp_6) - (uint)!temp_flag2;\n      }\n      if (temp_6 < temp_5 || temp_flag1) {\n        temp_11 = temp_11 | temp_3 >> 3;\n      }\n      temp_13 = temp_10 | temp_12;\n      if (temp_13 == 0) break;\n      temp_10 = temp_10 << 4 | temp_12 >> 0x1c;\n      temp_12 = temp_12 << 4;\n      temp_4 = temp_4 & 0xfffffff8 | temp_1 >> 0x1d;\n      temp_1 = (temp_2 >> 1) << 3;\n      temp_3 = temp_3 >> 4;\n      if (temp_3 == 0) {\n        temp_6 = temp_4;\n        if ((temp_7 & 0x100000) != 0) goto LAB_0800083a;\n        temp_7 = temp_7 | temp_11;\n        temp_11 = 0;\n        temp_3 = 0x80000000;\n      }\n    }\n    if ((temp_7 & 0x100000) == 0) {\n      temp_7 = temp_7 | temp_11;\n      temp_11 = 0;\n    }\nLAB_0800083a:\n    temp_flag3 = 0xfc < temp_9;\n    temp_flag2 = SBORROW4(temp_9,0xfd);\n    temp_4 = temp_8 + 0x300;\n    temp_flag1 = temp_4 == 0;\n    temp_3 = temp_4;\n    if (temp_flag3 && !temp_flag1) {\n      temp_flag3 = 0x6ff < temp_4;\n      temp_flag2 = SBORROW4(temp_4,0x700);\n      temp_3 = temp_8 - 0x400;\n      temp_flag1 = temp_4 == 0x700;\n    }\n    if (!temp_flag3 || temp_flag1) {\n      temp_flag1 = temp_6 <= temp_10;\n      if (temp_10 == temp_6) {\n        temp_flag1 = temp_1 <= temp_12;\n      }\n      if (temp_10 == temp_6 && temp_12 == temp_1) {\n        temp_flag1 = (temp_11 & 1) != 0;\n      }\n      return CONCAT44(temp_7 + temp_9 * 0x100000 + (uint)CARRY4(temp_11,(uint)temp_flag1),temp_11 + temp_flag1);\n    }\n  }\n  if (!temp_flag1 && (int)temp_3 < 0 == temp_flag2) {\n    return (ulonglong)(temp_7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  temp_flag3 = SCARRY4(temp_9,0x36);\n  temp_flag1 = (int)(temp_9 + 0x36) < 0;\n  temp_flag2 = temp_9 == 0xffffffca;\n  if (temp_flag2 || temp_flag1 != temp_flag3) {\n    temp_11 = 0;\n  }\n  if (temp_flag2 || temp_flag1 != temp_flag3) {\n    temp_7 = temp_7 & 0x80000000;\n  }\n  if (temp_flag2 || temp_flag1 != temp_flag3) {\n    return CONCAT44(temp_7,temp_11);\n  }\n  temp_3 = -temp_9;\n  temp_10 = temp_3 - 0x20;\n  if (0x1f < (int)temp_3) {\n    temp_3 = temp_11 >> (temp_10 & 0xff) | temp_7 << (0x20 - temp_10 & 0xff);\n    temp_9 = (temp_7 >> (temp_10 & 0xff) & ~((temp_7 & 0x80000000) >> (temp_10 & 0xff))) -\n            ((int)temp_3 >> 0x1f);\n    if ((temp_13 | temp_11 << (0x20 - temp_10 & 0xff) | temp_3 << 1) == 0) {\n      temp_9 = temp_9 & ~(temp_3 >> 0x1f);\n    }\n    return CONCAT44(temp_7,temp_9) & 0x80000000ffffffff;\n  }\n  temp_8 = temp_3 - 0x14;\n  if (temp_8 != 0 && temp_8 < 0 == SCARRY4(temp_10,0xc)) {\n    temp_9 = 0xc - temp_8;\n    temp_3 = temp_11 << (temp_9 & 0xff);\n    temp_11 = temp_11 >> (0x20 - temp_9 & 0xff) | temp_7 << (temp_9 & 0xff);\n    temp_9 = temp_11 + -((int)temp_3 >> 0x1f);\n    if ((temp_13 | temp_3 << 1) == 0) {\n      temp_9 = temp_9 & ~(temp_3 >> 0x1f);\n    }\n    return CONCAT44((temp_7 & 0x80000000) + (uint)CARRY4(temp_11,-((int)temp_3 >> 0x1f)),temp_9);\n  }\n  temp_10 = temp_11 << (temp_9 + 0x20 & 0xff);\n  temp_11 = temp_11 >> (temp_3 & 0xff) | temp_7 << (temp_9 + 0x20 & 0xff);\n  temp_9 = temp_11 + -((int)temp_10 >> 0x1f);\n  if ((temp_13 | temp_10 << 1) == 0) {\n    temp_9 = temp_9 & ~(temp_10 >> 0x1f);\n  }\n  return CONCAT44((temp_7 & 0x80000000) +\n                  ((temp_7 & 0x7fffffff) >> (temp_3 & 0xff)) +\n                  (uint)CARRY4(temp_11,-((int)temp_10 >> 0x1f)),temp_9);\n}\n\n",
            "renaming": {
                "FUN_0800071c": "calculate_floating_point_0800071c",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "temp_1",
                "uVar2": "temp_2",
                "uVar3": "temp_3",
                "uVar4": "temp_4",
                "uVar5": "temp_5",
                "uVar6": "temp_6",
                "uVar7": "temp_7",
                "iVar8": "temp_8",
                "uVar9": "temp_9",
                "uVar10": "temp_10",
                "uVar11": "temp_11",
                "uVar12": "temp_12",
                "uVar13": "temp_13",
                "bVar14": "temp_flag1",
                "bVar15": "temp_flag2",
                "bVar16": "temp_flag3",
                "uVar17": "result"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [
                "FUN_0800088a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800088a": {
            "entrypoint": "0x0800088a",
            "current_name": "calculate_floating_point_0800088a",
            "code": "\nulonglong calculateFloatingPoint_0800088a(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint bit_1;\n  uint bit_2;\n  uint bit_3;\n  uint bit_4;\n  uint bit_5;\n  bool isZero;\n  \n  bit_3 = bit_5 & input_4 >> 0x14;\n  bit_4 = input_2;\n  if (bit_2 != bit_5 || bit_3 != bit_5) {\n    if (bit_2 == bit_5) {\n      if (((input_1 | input_2 << 0xc) == 0) && (input_1 = input_3, bit_4 = input_4, bit_3 != bit_5)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bit_3 == bit_5) {\n      input_1 = input_3;\n      bit_4 = input_4;\n      if ((input_3 | input_4 << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      isZero = (input_1 | input_2 << 1) == 0;\n      if (!isZero) {\n        isZero = (input_3 | input_4 << 1) == 0;\n      }\n      if (!isZero) {\n        if (bit_2 == 0) {\n          bit_4 = input_2 & 0x80000000;\n          do {\n            bit_1 = input_1 & 0x80000000;\n            input_1 = input_1 << 1;\n            input_2 = input_2 * 2 + (uint)(bit_1 != 0);\n          } while ((input_2 & 0x100000) == 0);\n          input_2 = input_2 | bit_4;\n          if (bit_3 != 0) {\n            return CONCAT44(input_2,input_1);\n          }\n        }\n        do {\n          bit_4 = input_3 & 0x80000000;\n          input_3 = input_3 << 1;\n          input_4 = input_4 * 2 + (uint)(bit_4 != 0);\n        } while ((input_4 & 0x100000) == 0);\n        return CONCAT44(input_2,input_1);\n      }\n      if ((input_1 | input_2 << 1) != 0) goto LAB_080006fc;\n      if ((input_3 | input_4 << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(bit_4,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800088a": "calculate_floating_point_0800088a",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "bit_1",
                "unaff_r4": "bit_2",
                "uVar2": "bit_3",
                "uVar3": "bit_4",
                "in_r12": "bit_5",
                "bVar4": "isZero"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_params_and_return_status_080008fc",
            "code": "\nuint check_params_and_return_status_080008fc(uint value_1,uint value_2,uint value_3,uint value_4)\n\n{\n  uint result;\n  bool is_zero_case;\n  bool is_less_than_case;\n  \n  if (((int)(value_2 << 1) >> 0x15 == -1 || (int)(value_4 << 1) >> 0x15 == -1) &&\n     ((((int)(value_2 << 1) >> 0x15 == -1 && ((value_1 | value_2 << 0xc) != 0)) ||\n      (((int)(value_4 << 1) >> 0x15 == -1 && ((value_3 | value_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  is_zero_case = (value_1 | value_2 << 1) == 0;\n  if (is_zero_case) {\n    is_zero_case = (value_3 | value_4 << 1) == 0;\n  }\n  if (!is_zero_case) {\n    is_zero_case = value_2 == value_4;\n  }\n  if (is_zero_case) {\n    is_zero_case = value_1 == value_3;\n  }\n  if (!is_zero_case) {\n    result = value_2 ^ value_4;\n    is_zero_case = result == 0;\n    if (-1 < (int)result) {\n      is_zero_case = value_2 == value_4;\n    }\n    is_less_than_case = -1 < (int)result && value_4 <= value_2;\n    if (is_zero_case) {\n      is_less_than_case = value_3 <= value_1;\n    }\n    value_4 = (int)value_4 >> 0x1f;\n    if (!is_less_than_case) {\n      value_4 = ~value_4;\n    }\n    return value_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_params_and_return_status_080008fc",
                "param_1": "value_1",
                "param_2": "value_2",
                "param_3": "value_3",
                "param_4": "value_4",
                "uVar1": "result",
                "bVar2": "is_zero_case",
                "bVar3": "is_less_than_case"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000978": {
            "entrypoint": "0x08000978",
            "current_name": "compare_and_set_08000978",
            "code": "\nvoid compareAndSet_08000978(undefined4 result,undefined4 value,undefined4 input1,undefined4 input2)\n\n{\n  __aeabi_cdcmpeq(input1,input2,result,value);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000978": "compare_and_set_08000978",
                "param_1": "result",
                "param_2": "value",
                "param_3": "input1",
                "param_4": "input2"
            },
            "calling": [
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000988": {
            "entrypoint": "0x08000988",
            "current_name": "calculate_result_08000988",
            "code": "\nundefined4 calculate_result_08000988(undefined4 input_value)\n\n{\n  __nedf2();\n  return input_value;\n}\n\n",
            "renaming": {
                "FUN_08000988": "calculate_result_08000988",
                "param_1": "input_value"
            },
            "calling": [
                "__aeabi_dcmple",
                "__aeabi_dcmpeq",
                "__aeabi_dcmplt",
                "__aeabi_cdrcmple"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "check_if_not_equal_08000998",
            "code": "\nbool checkIfNotEqual_08000998(void)\n\n{\n  char inputChar;\n  \n  __aeabi_cdcmpeq();\n  return inputChar != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000998": "check_if_not_equal_08000998",
                "in_ZR": "inputChar"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009ac": {
            "entrypoint": "0x080009ac",
            "current_name": "is_string_empty_080009ac",
            "code": "\nbool is_string_empty_080009ac(void)\n\n{\n  char input_char;\n  \n  __aeabi_cdcmpeq();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009ac": "is_string_empty_080009ac",
                "in_CY": "input_char"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c0": {
            "entrypoint": "0x080009c0",
            "current_name": "check_equal_or_zero_080009c0",
            "code": "\nbool check_equal_or_zero_080009c0(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_set;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)is_carry_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009c0": "check_equal_or_zero_080009c0",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_set"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009d4": {
            "entrypoint": "0x080009d4",
            "current_name": "is_less_than_or_equal_to_zero_080009d4",
            "code": "\nbool is_less_than_or_equal_to_zero_080009d4(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_set;\n  \n  __aeabi_cdrcmple();\n  return !(bool)is_carry_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009d4": "is_less_than_or_equal_to_zero_080009d4",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_set"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009e8": {
            "entrypoint": "0x080009e8",
            "current_name": "is_character_null_080009e8",
            "code": "\nbool is_character_null_080009e8(void)\n\n{\n  char character;\n  \n  compare_characters();\n  return character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009e8": "is_character_null_080009e8",
                "in_CY": "character",
                "__aeabi_cdrcmple": "compare_characters"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009fc": {
            "entrypoint": "0x080009fc",
            "current_name": "calculate_normalized_float_080009fc",
            "code": "\nuint calculateNormalizedFloat_080009fc(uint inputValue,uint inputExponent)\n\n{\n  uint result;\n  uint shiftedExponent;\n  uint adjustedExponent;\n  uint roundedExponent;\n  bool isZero;\n  bool isLessThan;\n  \n  shiftedExponent = inputExponent * 2;\n  isLessThan = shiftedExponent < 0x70000000;\n  adjustedExponent = shiftedExponent + 0x90000000;\n  result = adjustedExponent;\n  if (!isLessThan) {\n    roundedExponent = shiftedExponent + 0x8fe00000;\n    result = roundedExponent;\n  }\n  isZero = result == 0;\n  if (!isLessThan && adjustedExponent >= 0x200000) {\n    isZero = roundedExponent == 0x1fc00000;\n  }\n  if (((isLessThan || adjustedExponent < 0x200000) || 0x1fc00000 < roundedExponent) || isZero) {\n    if ((inputExponent & 0x40000000) != 0) {\n      if (((int)shiftedExponent >> 0x15 == -1) && ((inputValue | inputExponent << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return inputExponent & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(shiftedExponent + 0x92e00000) < 0 != isCarry(adjustedExponent,0x2e00000)) {\n      return inputExponent & 0x80000000;\n    }\n    shiftedExponent = 0x18 - (shiftedExponent + 0x92e00000 >> 0x15);\n    result = inputValue >> (shiftedExponent & 0xff);\n    if (inputValue << (0x20 - shiftedExponent & 0xff) != 0) {\n      result = result | 1;\n    }\n    adjustedExponent = inputExponent & 0x1fffff | 0x100000;\n    inputValue = result | adjustedExponent << (0x20 - shiftedExponent & 0xff);\n    adjustedExponent = (adjustedExponent >> (shiftedExponent & 0xff)) << 1;\n  }\n  result = (inputExponent & 0x80000000 | inputValue >> 0x1d) + adjustedExponent * 4 + (uint)(0x7fffffff < inputValue * 8);\n  if (inputValue * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080009fc": "calculate_normalized_float_080009fc",
                "param_1": "inputValue",
                "param_2": "inputExponent",
                "uVar1": "result",
                "uVar2": "shiftedExponent",
                "uVar3": "adjustedExponent",
                "in_r12": "roundedExponent",
                "bVar4": "isZero",
                "bVar5": "isLessThan",
                "SCARRY4": "isCarry"
            },
            "calling": [
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa4": {
            "entrypoint": "0x08000aa4",
            "current_name": "calculate_float_08000aa4",
            "code": "\nuint calculate_float_08000aa4(uint num1,uint num2,undefined4 constant,uint flag)\n\n{\n  int shifted_num1;\n  int shifted_num2;\n  uint bitwise_xor;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint difference;\n  bool is_equal;\n  \n  bitwise_xor = num2 ^ 0x80000000;\n  temp2 = num1 << 1;\n  is_equal = temp2 == 0;\n  if (!is_equal) {\n    flag = num2 << 1;\n    is_equal = flag == 0;\n  }\n  if (!is_equal) {\n    is_equal = temp2 == flag;\n  }\n  shifted_num1 = (int)temp2 >> 0x18;\n  if (!is_equal) {\n    is_equal = shifted_num1 == -1;\n  }\n  if (!is_equal) {\n    is_equal = (int)flag >> 0x18 == -1;\n  }\n  if (is_equal) {\n    shifted_num2 = (int)(num2 << 1) >> 0x18;\n    if (shifted_num1 == -1 || shifted_num2 == -1) {\n      temp2 = bitwise_xor;\n      if (shifted_num1 == -1) {\n        temp2 = num1;\n      }\n      if (shifted_num1 != -1 || shifted_num2 != -1) {\n        bitwise_xor = temp2;\n      }\n      is_equal = (temp2 & 0x7fffff) == 0;\n      if (is_equal) {\n        is_equal = (bitwise_xor & 0x7fffff) == 0;\n      }\n      if (is_equal) {\n        is_equal = temp2 == bitwise_xor;\n      }\n      if (!is_equal) {\n        temp2 = temp2 | 0x400000;\n      }\n      return temp2;\n    }\n    if (((num1 ^ bitwise_xor) & 0x7fffffff) != 0) {\n      if (temp2 == 0) {\n        num1 = bitwise_xor;\n      }\n      return num1;\n    }\n    if (num1 != bitwise_xor) {\n      return 0;\n    }\n    if ((temp2 & 0xff000000) == 0) {\n      bitwise_xor = num1 << 1;\n      if ((num1 & 0x80000000) != 0) {\n        bitwise_xor = bitwise_xor | 0x80000000;\n      }\n      return bitwise_xor;\n    }\n    if (temp2 < 0xfe000000) {\n      return num1 + 0x800000;\n    }\n    num1 = num1 & 0x80000000;\nLAB_08000bde:\n    return num1 | 0x7f800000;\n  }\n  temp2 = temp2 >> 0x18;\n  flag = flag >> 0x18;\n  difference = flag - temp2;\n  is_equal = difference != 0;\n  temp3 = temp2;\n  if (is_equal && temp2 <= flag) {\n    temp3 = temp2 + difference;\n  }\n  if (is_equal && temp2 <= flag) {\n    bitwise_xor = bitwise_xor ^ num1;\n  }\n  if (is_equal && temp2 <= flag) {\n    num1 = num1 ^ bitwise_xor;\n  }\n  if (is_equal && temp2 <= flag) {\n    bitwise_xor = bitwise_xor ^ num1;\n  }\n  if (flag < temp2) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return num1;\n  }\n  temp2 = num1 & 0xffffff | 0x800000;\n  if ((num1 & 0x80000000) != 0) {\n    temp2 = -temp2;\n  }\n  temp1 = bitwise_xor & 0xffffff | 0x800000;\n  if ((bitwise_xor & 0x80000000) != 0) {\n    temp1 = -temp1;\n  }\n  if (temp3 == difference) {\n    temp1 = temp1 ^ 0x800000;\n    if (temp3 == 0) {\n      temp2 = temp2 ^ 0x800000;\n      temp3 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  temp2 = temp2 + ((int)temp1 >> (difference & 0xff));\n  temp1 = temp1 << (0x20 - difference & 0xff);\n  num1 = temp2 & 0x80000000;\n  if ((int)temp2 < 0) {\n    is_equal = temp1 != 0;\n    temp1 = -temp1;\n    temp2 = -temp2 - (uint)is_equal;\n  }\n  if (temp2 < 0x800000) {\n    bitwise_xor = temp1 & 0x80000000;\n    temp1 = temp1 << 1;\n    temp2 = temp2 * 2 + (uint)(bitwise_xor != 0);\n    bitwise_xor = temp3 - 2;\n    if ((temp2 & 0x800000) == 0) {\n      difference = LZCOUNT(temp2) - 8;\n      temp2 = temp2 << (difference & 0xff);\n      if ((int)bitwise_xor < (int)difference) {\n        temp2 = temp2 >> (-(bitwise_xor - difference) & 0xff);\n      }\n      else {\n        temp2 = temp2 + (bitwise_xor - difference) * 0x800000;\n      }\n      return temp2 | num1;\n    }\n  }\n  else {\n    bitwise_xor = temp3 - 1;\n    if (0xffffff < temp2) {\n      bitwise_xor = temp2 & 1;\n      temp2 = temp2 >> 1;\n      temp1 = (uint)(bitwise_xor != 0) << 0x1f | temp1 >> 1;\n      bitwise_xor = temp3;\n      if (0xfd < temp3) goto LAB_08000bde;\n    }\n  }\n  temp2 = temp2 + bitwise_xor * 0x800000 + (uint)(0x7fffffff < temp1);\n  if (temp1 == 0x80000000) {\n    temp2 = temp2 & 0xfffffffe;\n  }\n  return temp2 | num1;\n}\n\n",
            "renaming": {
                "FUN_08000aa4": "calculate_float_08000aa4",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "constant",
                "param_4": "flag",
                "iVar1": "shifted_num1",
                "iVar2": "shifted_num2",
                "uVar3": "bitwise_xor",
                "uVar4": "temp1",
                "uVar5": "temp2",
                "uVar6": "temp3",
                "uVar7": "difference",
                "bVar8": "is_equal"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_floating_point_08000aa8",
            "code": "\nuint calculateFloatingPoint_08000aa8(uint inputFloat1,uint inputFloat2,undefined4 param_3,uint param_4)\n\n{\n  int exponent1;\n  int exponent2;\n  uint mantissa1;\n  uint mantissa2;\n  uint shiftCount;\n  uint difference;\n  bool isEqual;\n  \n  mantissa2 = inputFloat1 << 1;\n  isEqual = mantissa2 == 0;\n  if (!isEqual) {\n    param_4 = inputFloat2 << 1;\n    isEqual = param_4 == 0;\n  }\n  if (!isEqual) {\n    isEqual = mantissa2 == param_4;\n  }\n  exponent1 = (int)mantissa2 >> 0x18;\n  if (!isEqual) {\n    isEqual = exponent1 == -1;\n  }\n  if (!isEqual) {\n    isEqual = (int)param_4 >> 0x18 == -1;\n  }\n  if (isEqual) {\n    exponent2 = (int)(inputFloat2 << 1) >> 0x18;\n    if (exponent1 == -1 || exponent2 == -1) {\n      mantissa2 = inputFloat2;\n      if (exponent1 == -1) {\n        mantissa2 = inputFloat1;\n      }\n      if (exponent1 != -1 || exponent2 != -1) {\n        inputFloat2 = mantissa2;\n      }\n      isEqual = (mantissa2 & 0x7fffff) == 0;\n      if (isEqual) {\n        isEqual = (inputFloat2 & 0x7fffff) == 0;\n      }\n      if (isEqual) {\n        isEqual = mantissa2 == inputFloat2;\n      }\n      if (!isEqual) {\n        mantissa2 = mantissa2 | 0x400000;\n      }\n      return mantissa2;\n    }\n    if (((inputFloat1 ^ inputFloat2) & 0x7fffffff) != 0) {\n      if (mantissa2 == 0) {\n        inputFloat1 = inputFloat2;\n      }\n      return inputFloat1;\n    }\n    if (inputFloat1 != inputFloat2) {\n      return 0;\n    }\n    if ((mantissa2 & 0xff000000) == 0) {\n      mantissa2 = inputFloat1 << 1;\n      if ((inputFloat1 & 0x80000000) != 0) {\n        mantissa2 = mantissa2 | 0x80000000;\n      }\n      return mantissa2;\n    }\n    if (mantissa2 < 0xfe000000) {\n      return inputFloat1 + 0x800000;\n    }\n    inputFloat1 = inputFloat1 & 0x80000000;\nLAB_08000bde:\n    return inputFloat1 | 0x7f800000;\n  }\n  mantissa2 = mantissa2 >> 0x18;\n  param_4 = param_4 >> 0x18;\n  difference = param_4 - mantissa2;\n  isEqual = difference != 0;\n  shiftCount = mantissa2;\n  if (isEqual && mantissa2 <= param_4) {\n    shiftCount = mantissa2 + difference;\n  }\n  if (isEqual && mantissa2 <= param_4) {\n    inputFloat2 = inputFloat2 ^ inputFloat1;\n  }\n  if (isEqual && mantissa2 <= param_4) {\n    inputFloat1 = inputFloat1 ^ inputFloat2;\n  }\n  if (isEqual && mantissa2 <= param_4) {\n    inputFloat2 = inputFloat2 ^ inputFloat1;\n  }\n  if (param_4 < mantissa2) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return inputFloat1;\n  }\n  mantissa2 = inputFloat1 & 0xffffff | 0x800000;\n  if ((inputFloat1 & 0x80000000) != 0) {\n    mantissa2 = -mantissa2;\n  }\n  mantissa1 = inputFloat2 & 0xffffff | 0x800000;\n  if ((inputFloat2 & 0x80000000) != 0) {\n    mantissa1 = -mantissa1;\n  }\n  if (shiftCount == difference) {\n    mantissa1 = mantissa1 ^ 0x800000;\n    if (shiftCount == 0) {\n      mantissa2 = mantissa2 ^ 0x800000;\n      shiftCount = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  mantissa2 = mantissa2 + ((int)mantissa1 >> (difference & 0xff));\n  mantissa1 = mantissa1 << (0x20 - difference & 0xff);\n  inputFloat1 = mantissa2 & 0x80000000;\n  if ((int)mantissa2 < 0) {\n    isEqual = mantissa1 != 0;\n    mantissa1 = -mantissa1;\n    mantissa2 = -mantissa2 - (uint)isEqual;\n  }\n  if (mantissa2 < 0x800000) {\n    difference = mantissa1 & 0x80000000;\n    mantissa1 = mantissa1 << 1;\n    mantissa2 = mantissa2 * 2 + (uint)(difference != 0);\n    difference = shiftCount - 2;\n    if ((mantissa2 & 0x800000) == 0) {\n      shiftCount = LZCOUNT(mantissa2) - 8;\n      mantissa2 = mantissa2 << (shiftCount & 0xff);\n      if ((int)difference < (int)shiftCount) {\n        mantissa2 = mantissa2 >> (-(difference - shiftCount) & 0xff);\n      }\n      else {\n        mantissa2 = mantissa2 + (difference - shiftCount) * 0x800000;\n      }\n      return mantissa2 | inputFloat1;\n    }\n  }\n  else {\n    difference = shiftCount - 1;\n    if (0xffffff < mantissa2) {\n      difference = mantissa2 & 1;\n      mantissa2 = mantissa2 >> 1;\n      mantissa1 = (uint)(difference != 0) << 0x1f | mantissa1 >> 1;\n      difference = shiftCount;\n      if (0xfd < shiftCount) goto LAB_08000bde;\n    }\n  }\n  mantissa2 = mantissa2 + difference * 0x800000 + (uint)(0x7fffffff < mantissa1);\n  if (mantissa1 == 0x80000000) {\n    mantissa2 = mantissa2 & 0xfffffffe;\n  }\n  return mantissa2 | inputFloat1;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_floating_point_08000aa8",
                "param_1": "inputFloat1",
                "param_2": "inputFloat2",
                "iVar1": "exponent1",
                "iVar2": "exponent2",
                "uVar3": "mantissa1",
                "uVar4": "mantissa2",
                "uVar5": "shiftCount",
                "uVar6": "difference",
                "bVar7": "isEqual"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calibrate"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c08": {
            "entrypoint": "0x08000c08",
            "current_name": "reverse_bits_08000c08",
            "code": "\nuint reverseBits_08000c08(uint input)\n\n{\n  uint output;\n  uint temp;\n  int constant;\n  uint mask;\n  \n  if (input == 0) {\n    return 0;\n  }\n  output = LZCOUNT(input);\n  temp = output - 8;\n  constant = temp * -0x800000 + 0x4a800000;\n  if (7 < output) {\n    mask = 0 << (temp & 0xff);\n    output = constant + (input << (temp & 0xff)) +\n            (0U >> (0x20 - temp & 0xff)) + (uint)(0x7fffffff < mask);\n    if (mask == 0x80000000) {\n      output = output & 0xfffffffe;\n    }\n    return output;\n  }\n  temp = input << output + 0x18;\n  output = constant + ((input >> (0x20 - (output + 0x18) & 0xff)) - ((int)temp >> 0x1f));\n  if ((temp & 0x7fffffff) == 0) {\n    output = output & ~(temp >> 0x1f);\n  }\n  return output;\n}\n\n",
            "renaming": {
                "FUN_08000c08": "reverse_bits_08000c08",
                "param_1": "input",
                "uVar1": "output",
                "uVar2": "temp",
                "iVar3": "constant",
                "uVar4": "mask"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c10": {
            "entrypoint": "0x08000c10",
            "current_name": "calculate_shifted_sum_08000c10",
            "code": "\nuint calculate_shifted_sum_08000c10(uint input_number)\n\n{\n  uint leading_zeros;\n  uint shift_amount;\n  uint sign_bit;\n  int sum;\n  \n  sign_bit = input_number & 0x80000000;\n  if ((int)sign_bit < 0) {\n    input_number = -input_number;\n  }\n  if (input_number == 0) {\n    return 0;\n  }\n  leading_zeros = count_leading_zeros(input_number);\n  shift_amount = leading_zeros - 8;\n  sum = ((sign_bit | 0x4b000000) - 0x800000) + shift_amount * -0x800000;\n  if (7 < leading_zeros) {\n    leading_zeros = 0 << (shift_amount & 0xff);\n    sign_bit = sum + (input_number << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < leading_zeros);\n    if (leading_zeros == 0x80000000) {\n      sign_bit = sign_bit & 0xfffffffe;\n    }\n    return sign_bit;\n  }\n  shift_amount = input_number << leading_zeros + 0x18;\n  sign_bit = sum + ((input_number >> (0x20 - (leading_zeros + 0x18) & 0xff)) - ((int)shift_amount >> 0x1f));\n  if ((shift_amount & 0x7fffffff) == 0) {\n    sign_bit = sign_bit & ~(shift_amount >> 0x1f);\n  }\n  return sign_bit;\n}\n\n",
            "renaming": {
                "FUN_08000c10": "calculate_shifted_sum_08000c10",
                "param_1": "input_number",
                "uVar1": "leading_zeros",
                "uVar2": "shift_amount",
                "uVar3": "sign_bit",
                "iVar4": "sum",
                "LZCOUNT": "count_leading_zeros"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_update",
                "mpu6050_calibrate"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cb8": {
            "entrypoint": "0x08000cb8",
            "current_name": "calculate_float_value_08000cb8",
            "code": "\nuint calculateFloatValue_08000cb8(uint input1,uint input2,undefined4 param3,uint param4)\n\n{\n  longlong lVar1;\n  uint result;\n  uint count1;\n  int sum;\n  int diff1;\n  uint count2;\n  int diff2;\n  uint temp;\n  bool isZero;\n  bool isNegative;\n  \n  count1 = input1 >> 0x17 & 0xff;\n  isZero = count1 == 0;\n  if (!isZero) {\n    param4 = input2 >> 0x17 & 0xff;\n    isZero = param4 == 0;\n  }\n  if (!isZero) {\n    isZero = count1 == 0xff;\n  }\n  if (!isZero) {\n    isZero = param4 == 0xff;\n  }\n  if (isZero) {\n    param4 = input2 >> 0x17 & 0xff;\n    if (count1 == 0xff || param4 == 0xff) {\n      isZero = input1 == 0 || input1 == 0x80000000;\n      result = input2;\n      if (input1 != 0 && input1 != 0x80000000) {\n        isZero = input2 == 0;\n        result = input1;\n      }\n      if (!isZero) {\n        isZero = input2 == 0x80000000;\n      }\n      temp = result;\n      if (((isZero) || ((count1 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((param4 == 0xff && (temp = input2, (input2 & 0x7fffff) != 0)))) {\n        return temp | 0x7fc00000;\n      }\n      result = result ^ input2;\n      goto LAB_08000e08;\n    }\n    isZero = (input1 & 0x7fffffff) == 0;\n    if (!isZero) {\n      isZero = (input2 & 0x7fffffff) == 0;\n    }\n    if (isZero) {\n      return (input1 ^ input2) & 0x80000000;\n    }\n    isZero = count1 == 0;\n    result = input1 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        input1 = input1 << 1;\n        isZero = (input1 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      count1 = count1 - 1;\n    }\n    input1 = input1 | result;\n    isZero = param4 == 0;\n    result = input2 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        input2 = input2 << 1;\n        isZero = (input2 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      param4 = param4 - 1;\n    }\n    input2 = input2 | result;\n  }\n  sum = count1 + param4;\n  temp = input1 ^ input2;\n  count1 = input1 << 9;\n  isZero = count1 == 0;\n  if (!isZero) {\n    input2 = input2 << 9;\n    isZero = input2 == 0;\n  }\n  if (isZero) {\n    if (count1 == 0) {\n      input2 = input2 << 9;\n    }\n    result = temp & 0x80000000 | input1 & 0x7fffff | input2 >> 9;\n    isNegative = SBORROW4(sum,0x7f);\n    diff1 = sum + -0x7f;\n    isZero = diff1 == 0;\n    diff2 = diff1;\n    if (!isZero && 0x7e < sum) {\n      isNegative = SBORROW4(0xff,diff1);\n      diff2 = 0xff - diff1;\n      isZero = diff1 == 0xff;\n    }\n    if (!isZero && diff2 < 0 == isNegative) {\n      result = result | diff1 * 0x800000;\n    }\n    if (!isZero && diff2 < 0 == isNegative) {\n      return result;\n    }\n    result = result | 0x800000;\n    count2 = 0;\n    isNegative = SBORROW4(diff1,1);\n    temp = sum - 0x80;\n    isZero = temp == 0;\n    count1 = temp;\n  }\n  else {\n    lVar1 = (ulonglong)(count1 >> 5 | 0x8000000) * (ulonglong)(input2 >> 5 | 0x8000000);\n    count2 = (uint)lVar1;\n    result = (uint)((ulonglong)lVar1 >> 0x20);\n    isZero = result < 0x800000;\n    if (isZero) {\n      result = result << 1;\n    }\n    if (isZero) {\n      result = result | count2 >> 0x1f;\n      count2 = count2 << 1;\n    }\n    result = temp & 0x80000000 | result;\n    temp = (sum + -0x7f) - (uint)isZero;\n    isNegative = SBORROW4(temp,0xfd);\n    isZero = temp == 0xfd;\n    count1 = temp - 0xfd;\n    if (temp < 0xfe) {\n      result = result + temp * 0x800000 + (uint)(0x7fffffff < count2);\n      if (count2 == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isZero || (int)count1 < 0 != isNegative) {\n    isZero = (int)(temp + 0x19) < 0;\n    if (temp == 0xffffffe7 || isZero != SCARRY4(temp,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (temp != 0xffffffe7 && isZero == SCARRY4(temp,0x19)) {\n      count1 = (result << 1) >> (-temp & 0xff);\n      temp = result << (temp + 0x20 & 0xff);\n      count1 = ((uint)((result & 0x80000000) != 0) << 0x1f | count1 >> 1) + (uint)((byte)count1 & 1);\n      if ((count2 | temp << 1) == 0) {\n        count1 = count1 & ~(temp >> 0x1f);\n      }\n      return count1;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cb8": "calculate_float_value_08000cb8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar2": "result",
                "uVar3": "count1",
                "uVar6": "count2",
                "uVar8": "temp",
                "iVar4": "sum",
                "iVar5": "diff1",
                "iVar7": "diff2",
                "bVar9": "isZero",
                "bVar10": "isNegative"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e20": {
            "entrypoint": "0x08000e20",
            "current_name": "calculate_float_08000e20",
            "code": "\nuint calculateFloat_08000e20(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  uint bits1;\n  uint bits2;\n  int difference;\n  uint comparison;\n  int temp1;\n  uint result;\n  bool isZero;\n  bool isNegative;\n  bool carry;\n  \n  bits2 = input1 >> 0x17 & 0xff;\n  isZero = bits2 == 0;\n  if (!isZero) {\n    input4 = input2 >> 0x17 & 0xff;\n    isZero = input4 == 0;\n  }\n  if (!isZero) {\n    isZero = bits2 == 0xff;\n  }\n  if (!isZero) {\n    isZero = input4 == 0xff;\n  }\n  if (isZero) {\n    input4 = input2 >> 0x17 & 0xff;\n    result = input1;\n    if (bits2 == 0xff) {\n      if (((input1 & 0x7fffff) != 0) || (result = input2, input4 == 0xff)) {\nLAB_08000e16:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (input4 == 0xff) {\n        result = input2;\n        if ((input2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (input1 ^ input2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      isZero = (input1 & 0x7fffffff) == 0;\n      if (!isZero) {\n        isZero = (input2 & 0x7fffffff) == 0;\n      }\n      if (!isZero) {\n        isZero = bits2 == 0;\n        result = input1 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            input1 = input1 << 1;\n            isZero = (input1 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          bits2 = bits2 - 1;\n        }\n        input1 = input1 | result;\n        isZero = input4 == 0;\n        result = input2 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            input2 = input2 << 1;\n            isZero = (input2 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          input4 = input4 - 1;\n        }\n        input2 = input2 | result;\n        goto LAB_08000e38;\n      }\n      if ((input1 & 0x7fffffff) == 0) {\n        if ((input2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    input1 = input1 ^ input2;\n  }\n  else {\nLAB_08000e38:\n    difference = bits2 - input4;\n    if (input2 << 9 == 0) {\n      input1 = (input1 ^ input2) & 0x80000000 | input1 & 0x7fffff;\n      carry = SCARRY4(difference,0x7f);\n      temp1 = difference + 0x7f;\n      isZero = temp1 < 0;\n      isNegative = temp1 == 0;\n      if (!isNegative && isZero == carry) {\n        carry = SBORROW4(0xff,temp1);\n        isZero = 0xff - temp1 < 0;\n        isNegative = temp1 == 0xff;\n      }\n      if (!isNegative && isZero == carry) {\n        input1 = input1 | temp1 * 0x800000;\n      }\n      if (!isNegative && isZero == carry) {\n        return input1;\n      }\n      input1 = input1 | 0x800000;\n      bits2 = 0;\n      isNegative = SBORROW4(temp1,1);\n      comparison = difference + 0x7e;\n      isZero = comparison == 0;\n      result = comparison;\n    }\n    else {\n      bits1 = (input2 << 9) >> 4 | 0x10000000;\n      bits2 = (input1 << 9) >> 4 | 0x10000000;\n      input1 = (input1 ^ input2) & 0x80000000;\n      isZero = bits1 <= bits2;\n      if (!isZero) {\n        bits2 = bits2 << 1;\n      }\n      comparison = difference + 0x7d + (uint)isZero;\n      result = 0x800000;\n      do {\n        if (bits1 <= bits2) {\n          bits2 = bits2 - bits1;\n          input1 = input1 | result;\n        }\n        isZero = bits1 >> 1 <= bits2;\n        if (isZero) {\n          bits2 = bits2 - (bits1 >> 1);\n        }\n        if (isZero) {\n          input1 = input1 | result >> 1;\n        }\n        isZero = bits1 >> 2 <= bits2;\n        if (isZero) {\n          bits2 = bits2 - (bits1 >> 2);\n        }\n        if (isZero) {\n          input1 = input1 | result >> 2;\n        }\n        isZero = bits1 >> 3 <= bits2;\n        if (isZero) {\n          bits2 = bits2 - (bits1 >> 3);\n        }\n        if (isZero) {\n          input1 = input1 | result >> 3;\n        }\n        bits2 = bits2 * 0x10;\n        isZero = bits2 == 0;\n        if (!isZero) {\n          result = result >> 4;\n          isZero = result == 0;\n        }\n      } while (!isZero);\n      isNegative = SBORROW4(comparison,0xfd);\n      isZero = comparison == 0xfd;\n      result = comparison - 0xfd;\n      if (comparison < 0xfe) {\n        input1 = input1 + comparison * 0x800000 + (uint)(bits1 <= bits2);\n        if (bits2 - bits1 == 0) {\n          input1 = input1 & 0xfffffffe;\n        }\n        return input1;\n      }\n    }\n    if (isZero || (int)result < 0 != isNegative) {\n      isZero = (int)(comparison + 0x19) < 0;\n      if (comparison == 0xffffffe7 || isZero != SCARRY4(comparison,0x19)) {\n        input1 = input1 & 0x80000000;\n      }\n      if (comparison == 0xffffffe7 || isZero != SCARRY4(comparison,0x19)) {\n        return input1;\n      }\n      result = (input1 << 1) >> (-comparison & 0xff);\n      comparison = input1 << (comparison + 0x20 & 0xff);\n      result = ((uint)((input1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((bits2 | comparison << 1) == 0) {\n        result = result & ~(comparison >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return input1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e20": "calculate_float_08000e20",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bits1",
                "uVar2": "bits2",
                "iVar3": "difference",
                "uVar4": "comparison",
                "iVar5": "temp1",
                "uVar6": "result",
                "bVar7": "isZero",
                "bVar8": "isNegative",
                "bVar9": "carry"
            },
            "calling": [
                "mpu6050_calibrate",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f68": {
            "entrypoint": "0x08000f68",
            "current_name": "multiply_and_check_08000f68",
            "code": "\nuint multiplyAndCheck_08000f68(uint input1,uint input2)\n\n{\n  bool isNegative;\n  uint multipliedInput1;\n  uint multipliedInput2;\n  uint combinedInput;\n  bool isZero;\n  \n  multipliedInput1 = input1 * 2;\n  multipliedInput2 = input2 * 2;\n  if (((int)multipliedInput1 >> 0x18 == -1 || (int)multipliedInput2 >> 0x18 == -1) &&\n     ((((int)multipliedInput1 >> 0x18 == -1 && ((input1 & 0x7fffff) != 0)) ||\n      (((int)multipliedInput2 >> 0x18 == -1 && ((input2 & 0x7fffff) != 0)))))) {\n    result 1;\n  }\n  combinedInput = multipliedInput1 | input2 & 0x7fffffff;\n  isZero = combinedInput == 0;\n  if (!isZero) {\n    combinedInput = input1 ^ input2;\n    isZero = combinedInput == 0;\n  }\n  isNegative = -1 < (int)combinedInput;\n  if (isNegative) {\n    input1 = multipliedInput1 + input2 * -2;\n    isZero = input1 == 0;\n  }\n  if ((isNegative && multipliedInput2 <= multipliedInput1) && !isZero) {\n    input1 = (int)input2 >> 0x1f;\n  }\n  if (!isNegative || multipliedInput2 > multipliedInput1) {\n    input1 = ~((int)input2 >> 0x1f);\n  }\n  if (!isZero) {\n    input1 = input1 | 1;\n  }\n  result input1;\n}\n\n",
            "renaming": {
                "FUN_08000f68": "multiply_and_check_08000f68",
                "param_1": "input1",
                "param_2": "input2",
                "uVar2": "multipliedInput1",
                "uVar3": "multipliedInput2",
                "uVar4": "combinedInput",
                "bVar1": "isNegative",
                "bVar5": "isZero",
                "return": "result"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fc8": {
            "entrypoint": "0x08000fc8",
            "current_name": "compare_floats_08000fc8",
            "code": "\nvoid compareFloats_08000fc8(undefined4 firstFloat,undefined4 secondFloat)\n\n{\n  __aeabi_cfcmpeq(secondFloat,firstFloat);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fc8": "compare_floats_08000fc8",
                "param_1": "firstFloat",
                "param_2": "secondFloat"
            },
            "calling": [
                "__aeabi_fcmpgt"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fd0": {
            "entrypoint": "0x08000fd0",
            "current_name": "concatenate_parameters_08000fd0",
            "code": "\nundefined8 concatenateParameters_08000fd0(undefined4 input1,undefined4 input2)\n\n{\n  __cmpsf2();\n  return CONCAT44(input2,input1);\n}\n\n",
            "renaming": {
                "FUN_08000fd0": "concatenate_parameters_08000fd0",
                "param_1": "input1",
                "param_2": "input2"
            },
            "calling": [
                "__aeabi_cfrcmple",
                "__aeabi_fcmplt"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ff4": {
            "entrypoint": "0x08000ff4",
            "current_name": "is_input_null_08000ff4",
            "code": "\nbool is_input_null_08000ff4(void)\n\n{\n  char input_value;\n  \n  __aeabi_cfcmpeq();\n  return input_value == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000ff4": "is_input_null_08000ff4",
                "in_CY": "input_value"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001030": {
            "entrypoint": "0x08001030",
            "current_name": "is_null_string_08001030",
            "code": "\nbool is_null_string_08001030(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001030": "is_null_string_08001030",
                "in_CY": "input_character"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001044": {
            "entrypoint": "0x08001044",
            "current_name": "check_param_validity_08001044",
            "code": "\nuint checkParamValidity_08001044(uint inputValue)\n\n{\n  uint shiftAmount;\n  \n  if (((inputValue & 0x80000000) != 0) || (inputValue << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shiftAmount = 0x9e - ((inputValue << 1) >> 0x18);\n  if (-1 < (int)shiftAmount) {\n    return (inputValue << 8 | 0x80000000) >> (shiftAmount & 0xff);\n  }\n  if ((shiftAmount == 0xffffff9f) && ((inputValue & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08001044": "check_param_validity_08001044",
                "param_1": "inputValue",
                "uVar1": "shiftAmount"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001084": {
            "entrypoint": "0x08001084",
            "current_name": "copy_memory_08001084",
            "code": "\nundefined4 * copyMemory_08001084(undefined4 *dest,undefined4 *src,uint size)\n\n{\n  undefined4 *destPtr;\n  undefined4 *destEndPtr;\n  undefined4 *srcPtr;\n  uint tempSize;\n  uint tempSize2;\n  bool condition;\n  \n  destEndPtr = dest;\n  if ((((uint)src | (uint)dest) & 3) != 0) {\n    if (size < 8) {\n      tempSize2 = size - 4;\n      if (3 < size) {\n        do {\n          destPtr = src;\n          srcPtr = destEndPtr;\n          condition = tempSize2 != 0;\n          tempSize2 = tempSize2 - 1;\n          *(undefined *)srcPtr = *(undefined *)destPtr;\n          destEndPtr = (undefined4 *)((int)srcPtr + 1);\n          src = (undefined4 *)((int)destPtr + 1);\n        } while (condition);\n        *(undefined *)(undefined4 *)((int)srcPtr + 1) =\n             *(undefined *)(undefined4 *)((int)destPtr + 1);\n        *(undefined *)((int)srcPtr + 2) = *(undefined *)((int)destPtr + 2);\n        *(undefined *)((int)srcPtr + 3) = *(undefined *)((int)destPtr + 3);\n        return dest;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)src & 3) != 0) && (((uint)dest & 3) != 0)) {\n      tempSize2 = 4 - ((uint)dest & 3);\n      size = size - tempSize2;\n      destPtr = dest;\n      srcPtr = src;\n      if (((uint)dest & 1) != 0) {\n        srcPtr = (undefined4 *)((int)src + 1);\n        destPtr = (undefined4 *)((int)dest + 1);\n        *(undefined *)dest = *(undefined *)src;\n      }\n      destEndPtr = destPtr;\n      src = srcPtr;\n      if ((tempSize2 & 2) != 0) {\n        src = (undefined4 *)((int)srcPtr + 2);\n        destEndPtr = (undefined4 *)((int)destPtr + 2);\n        *(undefined2 *)destPtr = *(undefined2 *)srcPtr;\n      }\n    }\n  }\n  while (0x3f < size) {\n    *destEndPtr = *src;\n    destEndPtr[1] = src[1];\n    destEndPtr[2] = src[2];\n    destEndPtr[3] = src[3];\n    destEndPtr[4] = src[4];\n    destEndPtr[5] = src[5];\n    destEndPtr[6] = src[6];\n    destEndPtr[7] = src[7];\n    destEndPtr[8] = src[8];\n    destEndPtr[9] = src[9];\n    destEndPtr[10] = src[10];\n    destEndPtr[0xb] = src[0xb];\n    destEndPtr[0xc] = src[0xc];\n    destEndPtr[0xd] = src[0xd];\n    destEndPtr[0xe] = src[0xe];\n    destEndPtr[0xf] = src[0xf];\n    destEndPtr = destEndPtr + 0x10;\n    src = src + 0x10;\n    size = size - 0x40;\n  }\n  tempSize = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n      *destEndPtr = *src;\n      destEndPtr[1] = src[1];\n      destEndPtr[2] = src[2];\n      destEndPtr[3] = src[3];\n      destEndPtr = destEndPtr + 4;\n      src = src + 4;\n      condition = 0xf < tempSize;\n      tempSize = tempSize - 0x10;\n    } while (condition);\n  }\n  tempSize2 = tempSize + 0xc;\n  srcPtr = destEndPtr;\n  destPtr = src;\n  if (0xfffffff3 < tempSize) {\n    do {\n      src = destPtr + 1;\n      *srcPtr = *destPtr;\n      condition = 3 < tempSize2;\n      tempSize2 = tempSize2 - 4;\n      destEndPtr = srcPtr + 1;\n      srcPtr = srcPtr + 1;\n      destPtr = src;\n    } while (condition);\n  }\nLAB_08001108:\n  if (tempSize2 + 4 != 0) {\n    destPtr = destEndPtr;\n    srcPtr = src;\n    if ((tempSize2 & 1) != 0) {\n      srcPtr = (undefined4 *)((int)src + 1);\n      destPtr = (undefined4 *)((int)destEndPtr + 1);\n      *(undefined *)destEndPtr = *(undefined *)src;\n    }\n    if ((tempSize2 + 4 & 2) != 0) {\n      *(undefined2 *)destPtr = *(undefined2 *)srcPtr;\n    }\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "puVar1": "destPtr",
                "puVar2": "destEndPtr",
                "puVar3": "srcPtr",
                "uVar4": "tempSize",
                "uVar5": "tempSize2",
                "bVar6": "condition"
            },
            "calling": [
                "_dtoa_r",
                "__ssprint_r",
                "__multadd"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "check_params_08001170",
            "code": "\nundefined4 check_params_08001170(uint value_1,int value_2,uint value_3,int value_4)\n\n{\n  if ((((value_2 << 1) >> 0x15 != -1) || ((value_1 | value_2 << 0xc) == 0)) &&\n     (((value_4 << 1) >> 0x15 != -1 || ((value_3 | value_4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001170": "check_params_08001170",
                "param_1": "value_1",
                "param_2": "value_2",
                "param_3": "value_3",
                "param_4": "value_4"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800119c": {
            "entrypoint": "0x0800119c",
            "current_name": "calculate_unsigned_integer_0800119c",
            "code": "\nuint calculateUnsignedInteger_0800119c(uint input1,uint input2)\n\n{\n  uint result1;\n  int result2;\n  uint result3;\n  \n  result2 = input2 * 2 + 0x200000;\n  if (input2 * 2 < 0xffe00000) {\n    if (-1 < result2) {\n      return 0;\n    }\n    result1 = result2 >> 0x15;\n    result3 = -result1 - 0x3e1;\n    if (result1 < 0xfffffc20 && result3 != 0) {\n      result1 = (input2 << 0xb | 0x80000000 | input1 >> 0x15) >> (result3 & 0xff);\n      if ((input2 & 0x80000000) != 0) {\n        result1 = -result1;\n      }\n      return result1;\n    }\n  }\n  else if ((input1 | input2 << 0xc) != 0) {\n    return 0;\n  }\n  input2 = input2 & 0x80000000;\n  if (input2 == 0) {\n    input2 = 0x7fffffff;\n  }\n  return input2;\n}\n\n",
            "renaming": {
                "FUN_0800119c": "calculate_unsigned_integer_0800119c",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result1",
                "iVar2": "result2",
                "uVar3": "result3"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011ec": {
            "entrypoint": "0x080011ec",
            "current_name": "divmod_080011ec",
            "code": "\nundefined8 divmod_080011ec(int dividend,int divisor,int quotient,int remainder)\n\n{\n  undefined8 result;\n  \n  if ((remainder == 0) && (quotient == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      divisor = -1;\n      dividend = -1;\n    }\n    return CONCAT44(divisor,dividend);\n  }\n  result = __udivmod_080011ecdi4();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080011ec": "divmod_080011ec",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "uVar1": "result"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800121c": {
            "entrypoint": "0x0800121c",
            "current_name": "calculate_division_0800121c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 calculateDivision_0800121c(uint dividend,uint divisor,uint numerator,uint denominator,uint *remainder)\n\n{\n  code *jumpTable;\n  ulonglong quotient;\n  uint quotient1;\n  uint quotient2;\n  uint quotient3;\n  int shiftCount;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint *puVar9;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  bool carry;\n  undefined8 result;\n  \n  if (denominator == 0) {\n    if (divisor < numerator) {\n      shiftCount = LZCOUNT(numerator);\n      temp2 = numerator;\n      if (shiftCount != 0) {\n        temp2 = numerator << shiftCount;\n        divisor = dividend >> (0x20U - shiftCount & 0xff) | divisor << shiftCount;\n        dividend = dividend << shiftCount;\n      }\n      temp5 = temp2 >> 0x10;\n      temp3 = divisor / temp5;\n      temp4 = temp3 * (temp2 & 0xffff);\n      temp1 = dividend >> 0x10 | (divisor - temp5 * temp3) * 0x10000;\n      quotient2 = temp3;\n      if (temp1 <= temp4 && temp4 - temp1 != 0) {\n        carry = CARRY4(temp2,temp1);\n        temp1 = temp2 + temp1;\n        quotient2 = temp3 - 1;\n        if ((carry == false) && (temp1 <= temp4 && temp4 - temp1 != 0)) {\n          quotient2 = temp3 - 2;\n          temp1 = temp1 + temp2;\n        }\n      }\n      quotient1 = (temp1 - temp4) / temp5;\n      quotient3 = quotient1 * (temp2 & 0xffff);\n      temp3 = dividend & 0xffff | ((temp1 - temp4) - temp5 * quotient1) * 0x10000;\n      temp1 = quotient1;\n      if (temp3 <= quotient3 && quotient3 - temp3 != 0) {\n        carry = CARRY4(temp2,temp3);\n        temp3 = temp2 + temp3;\n        temp1 = quotient1 - 1;\n        if ((carry == false) && (temp3 <= quotient3 && quotient3 - temp3 != 0)) {\n          temp1 = quotient1 - 2;\n          temp3 = temp3 + temp2;\n        }\n      }\n      temp1 = temp1 | quotient2 << 0x10;\n      puVar9 = (uint *)0x0;\n      temp3 = temp3 - quotient3;\n    }\n    else {\n      if (numerator == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        jumpTable = (code *)software_udf(0xff,0x8001302);\n        result = (*jumpTable)();\n        return result;\n      }\n      shiftCount = LZCOUNT(numerator);\n      if (shiftCount == 0) {\n        puVar9 = (uint *)0x1;\n        divisor = divisor - numerator;\n        temp5 = numerator >> 0x10;\n        quotient1 = numerator & 0xffff;\n        temp2 = numerator;\n      }\n      else {\n        temp2 = numerator << shiftCount;\n        temp1 = divisor >> (0x20U - shiftCount & 0xff);\n        temp5 = temp2 >> 0x10;\n        temp4 = temp1 / temp5;\n        quotient1 = temp2 & 0xffff;\n        quotient3 = temp4 * quotient1;\n        temp3 = dividend >> (0x20U - shiftCount & 0xff) | divisor << shiftCount;\n        quotient2 = temp3 >> 0x10 | (temp1 - temp5 * temp4) * 0x10000;\n        dividend = dividend << shiftCount;\n        temp1 = temp4;\n        if (quotient2 <= quotient3 && quotient3 - quotient2 != 0) {\n          carry = CARRY4(temp2,quotient2);\n          quotient2 = temp2 + quotient2;\n          temp1 = temp4 - 1;\n          if ((carry == false) && (quotient2 <= quotient3 && quotient3 - quotient2 != 0)) {\n            temp1 = temp4 - 2;\n            quotient2 = quotient2 + temp2;\n          }\n        }\n        temp4 = (quotient2 - quotient3) / temp5;\n        temp6 = temp4 * quotient1;\n        divisor = temp3 & 0xffff | ((quotient2 - quotient3) - temp5 * temp4) * 0x10000;\n        quotient2 = temp4;\n        if (divisor <= temp6 && temp6 - divisor != 0) {\n          carry = CARRY4(temp2,divisor);\n          divisor = temp2 + divisor;\n          quotient2 = temp4 - 1;\n          if ((carry == false) && (divisor <= temp6 && temp6 - divisor != 0)) {\n            quotient2 = temp4 - 2;\n            divisor = divisor + temp2;\n          }\n        }\n        divisor = divisor - temp6;\n        puVar9 = (uint *)(quotient2 | temp1 << 0x10);\n      }\n      temp4 = divisor / temp5;\n      temp1 = quotient1 * temp4;\n      temp3 = dividend >> 0x10 | (divisor - temp5 * temp4) * 0x10000;\n      quotient2 = temp4;\n      if (temp3 <= temp1 && temp1 - temp3 != 0) {\n        carry = CARRY4(temp2,temp3);\n        temp3 = temp2 + temp3;\n        quotient2 = temp4 - 1;\n        if ((carry == false) && (temp3 <= temp1 && temp1 - temp3 != 0)) {\n          quotient2 = temp4 - 2;\n          temp3 = temp3 + temp2;\n        }\n      }\n      temp4 = (temp3 - temp1) / temp5;\n      quotient1 = quotient1 * temp4;\n      temp3 = dividend & 0xffff | ((temp3 - temp1) - temp5 * temp4) * 0x10000;\n      temp1 = temp4;\n      if (temp3 <= quotient1 && quotient1 - temp3 != 0) {\n        carry = CARRY4(temp2,temp3);\n        temp3 = temp2 + temp3;\n        temp1 = temp4 - 1;\n        if ((carry == false) && (temp3 <= quotient1 && quotient1 - temp3 != 0)) {\n          temp1 = temp4 - 2;\n          temp3 = temp3 + temp2;\n        }\n      }\n      temp3 = temp3 - quotient1;\n      temp1 = temp1 | quotient2 << 0x10;\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = temp3 >> LZCOUNT(numerator);\n      remainder[1] = 0;\n    }\n  }\n  else {\n    puVar9 = remainder;\n    if (divisor < denominator) {\n      if (remainder != (uint *)0x0) {\n        *remainder = dividend;\n        remainder[1] = divisor;\n        return 0;\n      }\n      temp1 = 0;\n    }\n    else {\n      shiftCount = LZCOUNT(denominator);\n      if (shiftCount == 0) {\n        if ((denominator < divisor) || (numerator <= dividend)) {\n          carry = dividend < numerator;\n          dividend = dividend - numerator;\n          divisor = (divisor - denominator) - (uint)carry;\n          temp1 = 1;\n        }\n        else {\n          temp1 = 0;\n        }\n        puVar9 = (uint *)0x0;\n        if (remainder != (uint *)0x0) {\n          *remainder = dividend;\n          remainder[1] = divisor;\n        }\n      }\n      else {\n        temp3 = 0x20 - shiftCount;\n        quotient1 = numerator >> (temp3 & 0xff) | denominator << shiftCount;\n        temp2 = divisor >> (temp3 & 0xff);\n        quotient3 = quotient1 >> 0x10;\n        temp4 = temp2 / quotient3;\n        temp5 = temp4 * (quotient1 & 0xffff);\n        temp1 = divisor << shiftCount | dividend >> (temp3 & 0xff);\n        quotient2 = temp1 >> 0x10 | (temp2 - quotient3 * temp4) * 0x10000;\n        dividend = dividend << shiftCount;\n        temp2 = temp4;\n        if (quotient2 <= temp5 && temp5 - quotient2 != 0) {\n          carry = CARRY4(quotient1,quotient2);\n          quotient2 = quotient1 + quotient2;\n          temp2 = temp4 - 1;\n          if ((carry == false) && (quotient2 <= temp5 && temp5 - quotient2 != 0)) {\n            temp2 = temp4 - 2;\n            quotient2 = quotient2 + quotient1;\n          }\n        }\n        temp4 = (quotient2 - temp5) / quotient3;\n        temp6 = temp4 * (quotient1 & 0xffff);\n        quotient2 = temp1 & 0xffff | ((quotient2 - temp5) - quotient3 * temp4) * 0x10000;\n        temp1 = temp4;\n        if (quotient2 <= temp6 && temp6 - quotient2 != 0) {\n          carry = CARRY4(quotient1,quotient2);\n          quotient2 = quotient1 + quotient2;\n          temp1 = temp4 - 1;\n          if ((carry == false) && (quotient2 <= temp6 && temp6 - quotient2 != 0)) {\n            temp1 = temp4 - 2;\n            quotient2 = quotient2 + quotient1;\n          }\n        }\n        temp1 = temp1 | temp2 << 0x10;\n        quotient = (ulonglong)temp1 * (ulonglong)(numerator << shiftCount);\n        if (CONCAT44(quotient2 - temp6,dividend) < quotient) {\n          temp1 = temp1 - 1;\n          quotient = quotient - CONCAT44(quotient1,numerator << shiftCount);\n        }\n        if (remainder != (uint *)0x0) {\n          temp2 = ((quotient2 - temp6) - (int)(quotient >> 0x20)) - (uint)(dividend < (uint)quotient);\n          *remainder = temp2 << (temp3 & 0xff) | dividend - (uint)quotient >> shiftCount;\n          remainder[1] = temp2 >> shiftCount;\n          puVar9 = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(puVar9,temp1);\n}\n\n",
            "renaming": {
                "FUN_0800121c": "calculate_division_0800121c",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "numerator",
                "param_4": "denominator",
                "param_5": "remainder",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "uVar1": "quotient",
                "uVar2": "quotient1",
                "uVar3": "quotient2",
                "uVar4": "quotient3",
                "iVar5": "shiftCount",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "uVar8": "temp3",
                "uVar10": "temp4",
                "uVar11": "temp5",
                "uVar12": "temp6",
                "bVar13": "carry",
                "uVar14": "result"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014f0": {
            "entrypoint": "0x080014f0",
            "current_name": "initialize_hardware_080014f0",
            "code": "\n\n\nundefined4 initializeHardware_080014f0(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  configureInterruptPriority(3);\n  initializeTick(0xf);\n  initializeHardware_080014f0Specific();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080014f0": "initialize_hardware_080014f0",
                "HAL_NVIC_SetPriorityGrouping": "configureInterruptPriority",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializeHardwareSpecific"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800151c": {
            "entrypoint": "0x0800151c",
            "current_name": "configure_and_set_systick_priority_0800151c",
            "code": "\nundefined4 configureAndSetSystickPriority_0800151c(uint priorityLevel)\n\n{\n  int configResult;\n  undefined4 returnValue;\n  \n  configResult = HAL_SYSTICK_Config((int)((ulonglong)DAT_20000018 / (1000 / (ulonglong)DAT_20000004)));\n  if (configResult == 0) {\n    if (priorityLevel < 0x10) {\n      HAL_NVIC_SetPriority(0xffffffff,priorityLevel,0);\n      returnValue = 0;\n      DAT_20000000 = priorityLevel;\n    }\n    else {\n      returnValue = 1;\n    }\n  }\n  else {\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800151c": "configure_and_set_systick_priority_0800151c",
                "param_1": "priorityLevel",
                "iVar1": "configResult",
                "uVar2": "returnValue"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "update_variable_0800157c",
            "code": "\nvoid updateVariable_0800157c(void)\n\n{\n  DAT_20000a48 = DAT_20000a48 + (uint)DAT_20000004;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "update_variable_0800157c"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015a0": {
            "entrypoint": "0x080015a0",
            "current_name": "get_global_variable_080015a0",
            "code": "\nundefined4 get_global_variable_080015a0(void)\n\n{\n  return DAT_20000a48;\n}\n\n",
            "renaming": {
                "FUN_080015a0": "get_global_variable_080015a0"
            },
            "calling": [
                "_get_ms_tick",
                "HAL_I2C_Mem_Read",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "HAL_RCC_ClockConfig",
                "I2C_RequestMemoryRead",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_WaitOnBTFFlagUntilTimeout",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_UART_Transmit",
                "HAL_RCC_OscConfig",
                "I2C_RequestMemoryWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b4": {
            "entrypoint": "0x080015b4",
            "current_name": "set_configuration_register_080015b4",
            "code": "\n\n\nvoid setConfigurationRegister_080015b4(uint configurationValue)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (configurationValue & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b4": "set_configuration_register_080015b4",
                "param_1": "configurationValue"
            },
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015fc": {
            "entrypoint": "0x080015fc",
            "current_name": "get_shifted_value_080015fc",
            "code": "\n\n\nuint getShiftedValue_080015fc(void)\n\n{\n  return _DAT_e000ed0c >> 8 bitwiseAnd 7;\n}\n\n",
            "renaming": {
                "FUN_080015fc": "get_shifted_value_080015fc",
                "&": "bitwiseAnd"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001618": {
            "entrypoint": "0x08001618",
            "current_name": "update_memory_08001618",
            "code": "\nvoid updateMemory_08001618(byte byteValue,uint uintValue)\n\n{\n  if ((char)byteValue < '\\0') {\n    *(char *)((byteValue & 0xf) + 0xe000ed14) = (char)((uintValue & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)byteValue + -0x1fff1c00) = (char)((uintValue & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001618": "update_memory_08001618",
                "param_1": "byteValue",
                "param_2": "uintValue"
            },
            "calling": [
                "HAL_NVIC_SetPriority",
                "SysTick_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800166c": {
            "entrypoint": "0x0800166c",
            "current_name": "bitwise_operation_0800166c",
            "code": "\nuint bitwiseOperation_0800166c(uint inputMask,uint inputData,uint temporaryMask)\n\n{\n  uint remainingBits;\n  \n  inputMask = inputMask & 7;\n  remainingBits = 7 - inputMask;\n  if (3 < remainingBits) {\n    remainingBits = 4;\n  }\n  if (inputMask + 4 < 7) {\n    inputMask = 0;\n  }\n  else {\n    inputMask = inputMask - 3;\n  }\n  return temporaryMask & ~(-1 << (inputMask & 0xff)) |\n         (~(-1 << (remainingBits & 0xff)) & inputData) << (inputMask & 0xff);\n}\n\n",
            "renaming": {
                "FUN_0800166c": "bitwise_operation_0800166c",
                "param_1": "inputMask",
                "param_2": "inputData",
                "param_3": "temporaryMask",
                "uVar1": "remainingBits"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016d0": {
            "entrypoint": "0x080016d0",
            "current_name": "check_and_set_priority_080016d0",
            "code": "\n\n\nbool checkAndSetPriority_080016d0(int value)\n\n{\n  bool isInRange;\n  \n  isInRange = value - 1U < 0x1000000;\n  if (isInRange) {\n    _DAT_e000e014 = value + -1;\n    setPriority(0xffffffff,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return !isInRange;\n}\n\n",
            "renaming": {
                "FUN_080016d0": "check_and_set_priority_080016d0",
                "param_1": "value",
                "bVar1": "isInRange",
                "NVIC_SetPriority": "setPriority"
            },
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001714": {
            "entrypoint": "0x08001714",
            "current_name": "set_priority_grouping_08001714",
            "code": "\nvoid setPriorityGrouping_08001714(undefined4 priorityGroup)\n\n{\n  setPriorityGrouping_08001714(priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001714": "set_priority_grouping_08001714",
                "param_1": "priorityGroup",
                "NVIC_SetPriorityGrouping": "setPriorityGrouping"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800172a": {
            "entrypoint": "0x0800172a",
            "current_name": "set_priority_0800172a",
            "code": "\nvoid setPriority_0800172a(char device,undefined4 priorityGroup,undefined4 priorityLevel)\n\n{\n  undefined4 priorityGrouping;\n  \n  priorityGrouping = getPriorityGrouping();\n  priorityGrouping = encodePriority(priorityGrouping,priorityGroup,priorityLevel);\n  setPriority_0800172a((volatileAddress)device,priorityGrouping);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800172a": "set_priority_0800172a",
                "param_1": "device",
                "param_2": "priorityGroup",
                "param_3": "priorityLevel",
                "uVar1": "priorityGrouping",
                "NVIC_GetPriorityGrouping": "getPriorityGrouping",
                "NVIC_EncodePriority": "encodePriority",
                "NVIC_SetPriority": "setPriority",
                "int": "volatileAddress"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "NVIC_SetPriority",
                "NVIC_GetPriorityGrouping",
                "NVIC_EncodePriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001762": {
            "entrypoint": "0x08001762",
            "current_name": "initialize_sys_tick_08001762",
            "code": "\nundefined4 initializeSysTick_08001762(undefined4 configValue)\n\n{\n  undefined4 status;\n  \n  status = SysTick_Config(configValue);\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001762": "initialize_sys_tick_08001762",
                "param_1": "configValue",
                "uVar1": "status"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "SysTick_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800177c": {
            "entrypoint": "0x0800177c",
            "current_name": "set_third_bit_if_four_0800177c",
            "code": "\n\n\nvoid setThirdBitIfFour_0800177c(int value)\n\n{\n  if (value == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800177c": "set_third_bit_if_four_0800177c",
                "param_1": "value"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017b4": {
            "entrypoint": "0x080017b4",
            "current_name": "handle_tim_period_elapsed_080017b4",
            "code": "\nvoid handle_TIM_period_elapsed_080017b4(void)\n\n{\n  handle_TIM_callback(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080017b4": "handle_tim_period_elapsed_080017b4",
                "HAL_TIM_PeriodElapsedCallback": "handle_TIM_callback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017c4": {
            "entrypoint": "0x080017c4",
            "current_name": "update_data_080017c4",
            "code": "\n\n\nvoid updateData_080017c4(uint *data1,uint *data2)\n\n{\n  uint bitMask;\n  uint bitCheck;\n  uint opcode;\n  uint *destPtr;\n  int index;\n  uint newValue;\n  uint counter;\n  \n  newValue = 0;\n  counter = 0;\n  do {\n    if (0xf < counter) {\n      return;\n    }\n    bitMask = 1 << (counter & 0xff);\n    bitCheck = *data2 & bitMask;\n    if (bitCheck == bitMask) {\n      opcode = data2[1];\n      if (opcode == 0x12) {\n        newValue = data2[3] + 0xc;\n      }\n      else if (opcode < 0x13) {\n        if (opcode == 2) {\n          newValue = data2[3] + 8;\n        }\n        else if (opcode < 3) {\n          if (opcode == 0) goto LAB_08001882;\n          if (opcode == 1) {\n            newValue = data2[3];\n          }\n        }\n        else if (opcode == 3) {\n          newValue = 0;\n        }\n        else if (opcode == 0x11) {\n          newValue = data2[3] + 4;\n        }\n      }\n      else if (opcode == 0x10210000) {\nLAB_08001882:\n        if (data2[2] == 0) {\n          newValue = 4;\n        }\n        else if (data2[2] == 1) {\n          newValue = 8;\n          data1[4] = bitMask;\n        }\n        else {\n          newValue = 8;\n          data1[5] = bitMask;\n        }\n      }\n      else if (opcode < 0x10210001) {\n        if ((opcode == 0x10110000) || (opcode == 0x10120000)) goto LAB_08001882;\n      }\n      else if (((opcode == 0x10310000) || (opcode == 0x10320000)) || (opcode == 0x10220000))\n      goto LAB_08001882;\n      if (bitCheck < 0x100) {\n        bitMask = counter << 2;\n        destPtr = data1;\n      }\n      else {\n        destPtr = data1 + 1;\n        bitMask = (counter - 8) * 4;\n      }\n      *destPtr = *destPtr & ~(0xf << (bitMask & 0xff)) | newValue << (bitMask & 0xff);\n      if ((data2[1] & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        if (data1 == (uint *)0x40010800) {\n          index = 0;\n        }\n        else if (data1 == (uint *)0x40010c00) {\n          index = 1;\n        }\n        else if (data1 == (uint *)0x40011000) {\n          index = 2;\n        }\n        else if (data1 == (uint *)0x40011400) {\n          index = 3;\n        }\n        else {\n          index = 4;\n        }\n        *(uint *)(((counter >> 2) + 2) * 4 + 0x40010000) =\n             index << ((counter & 3) << 2) |\n             ~(0xf << ((counter & 3) << 2)) & *(uint *)(((counter >> 2) + 2) * 4 + 0x40010000);\n        if ((data2[1] & 0x10000) == 0) {\n          _DAT_40010400 = ~bitCheck & _DAT_40010400;\n        }\n        else {\n          _DAT_40010400 = bitCheck | _DAT_40010400;\n        }\n        if ((data2[1] & 0x20000) == 0) {\n          _DAT_40010404 = ~bitCheck & _DAT_40010404;\n        }\n        else {\n          _DAT_40010404 = bitCheck | _DAT_40010404;\n        }\n        if ((data2[1] & 0x100000) == 0) {\n          _DAT_40010408 = ~bitCheck & _DAT_40010408;\n        }\n        else {\n          _DAT_40010408 = bitCheck | _DAT_40010408;\n        }\n        if ((data2[1] & 0x200000) == 0) {\n          _DAT_4001040c = ~bitCheck & _DAT_4001040c;\n        }\n        else {\n          _DAT_4001040c = bitCheck | _DAT_4001040c;\n        }\n      }\n    }\n    counter = counter + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080017c4": "update_data_080017c4",
                "param_1": "data1",
                "param_2": "data2",
                "uVar1": "bitMask",
                "uVar2": "bitCheck",
                "uVar3": "opcode",
                "puVar4": "destPtr",
                "iVar5": "index",
                "local_10": "newValue",
                "local_c": "counter"
            },
            "calling": [
                "MX_GPIO_Init",
                "HAL_TIM_MspPostInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a80": {
            "entrypoint": "0x08001a80",
            "current_name": "set_param_value_08001a80",
            "code": "\nvoid setParamValue_08001a80(int paramPtr,ushort value,char isShifted)\n\n{\n  if (isShifted == '\\0') {\n    *(uint *)(paramPtr + 0x10) = (uint)value << 0x10;\n  }\n  else {\n    *(uint *)(paramPtr + 0x10) = (uint)value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a80": "set_param_value_08001a80",
                "param_1": "paramPtr",
                "param_2": "value",
                "param_3": "isShifted"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "MX_GPIO_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_i2_c_08001ab0",
            "code": "\nundefined4 initializeI2C_08001ab0(uint **i2cParams)\n\n{\n  uint pclk1Freq;\n  char isValidFrequency;\n  undefined4 result;\n  uint tempVar;\n  bool isZero;\n  \n  if (i2cParams == (uint **)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)i2cParams + 0x3d) == '\\0') {\n      *(undefined *)(i2cParams + 0xf) = 0;\n      initializeI2C_08001ab0Periph(i2cParams);\n    }\n    *(undefined *)((int)i2cParams + 0x3d) = 0x24;\n    **i2cParams = **i2cParams & 0xfffffffe;\n    pclk1Freq = HAL_RCC_GetPCLK1Freq();\n    if (i2cParams[1] < (uint *)0x186a1) {\n      tempVar = pclk1Freq;\n      if (pclk1Freq < 2000000) {\n        tempVar = 1;\n      }\n      isValidFrequency = (char)tempVar;\n      if (1999999 < pclk1Freq) {\n        isValidFrequency = '\\0';\n      }\n    }\n    else {\n      tempVar = pclk1Freq;\n      if (pclk1Freq < 4000000) {\n        tempVar = 1;\n      }\n      isValidFrequency = (char)tempVar;\n      if (3999999 < pclk1Freq) {\n        isValidFrequency = '\\0';\n      }\n    }\n    if (isValidFrequency == '\\0') {\n      tempVar = pclk1Freq / 1000000;\n      (*i2cParams)[1] = tempVar;\n      if ((uint *)0x186a0 < i2cParams[1]) {\n        tempVar = (tempVar * 300) / 1000;\n      }\n      (*i2cParams)[8] = tempVar + 1;\n      if (i2cParams[1] < (uint *)0x186a1) {\n        pclk1Freq = (pclk1Freq - 1) / (uint)((int)i2cParams[1] << 1) + 1 & 0xfff;\n        if (pclk1Freq < 4) {\n          pclk1Freq = 4;\n        }\n      }\n      else {\n        if (i2cParams[2] == (uint *)0x0) {\n          tempVar = (pclk1Freq - 1) / (uint)((int)i2cParams[1] * 3) + 1 & 0xfff;\n          isZero = tempVar == 0;\n          if (isZero) {\n            tempVar = 1;\n          }\n          isValidFrequency = (char)tempVar;\n          if (!isZero) {\n            isValidFrequency = '\\0';\n          }\n        }\n        else {\n          tempVar = (pclk1Freq - 1) / (uint)((int)i2cParams[1] * 0x19) + 1 & 0xfff;\n          isZero = tempVar == 0;\n          if (isZero) {\n            tempVar = 1;\n          }\n          isValidFrequency = (char)tempVar;\n          if (!isZero) {\n            isValidFrequency = '\\0';\n          }\n        }\n        if (isValidFrequency == '\\0') {\n          if (i2cParams[2] == (uint *)0x0) {\n            pclk1Freq = (pclk1Freq - 1) / (uint)((int)i2cParams[1] * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            pclk1Freq = (pclk1Freq - 1) / (uint)((int)i2cParams[1] * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          pclk1Freq = 1;\n        }\n      }\n      (*i2cParams)[7] = pclk1Freq;\n      **i2cParams = (uint)i2cParams[8] | (uint)i2cParams[7];\n      (*i2cParams)[2] = (uint)i2cParams[3] | (uint)i2cParams[4];\n      (*i2cParams)[3] = (uint)i2cParams[6] | (uint)i2cParams[5];\n      **i2cParams = **i2cParams | 1;\n      i2cParams[0x10] = (uint *)0x0;\n      *(undefined *)((int)i2cParams + 0x3d) = 0x20;\n      i2cParams[0xc] = (uint *)0x0;\n      *(undefined *)((int)i2cParams + 0x3e) = 0;\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "initialize_i2_c_08001ab0",
                "param_1": "i2cParams",
                "uVar1": "pclk1Freq",
                "cVar2": "isValidFrequency",
                "uVar3": "result",
                "uVar4": "tempVar",
                "bVar5": "isZero",
                "HAL_I2C_MspInit": "initializeI2CPeriph"
            },
            "calling": [
                "MX_I2C1_Init"
            ],
            "called": [
                "HAL_I2C_MspInit",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cb8": {
            "entrypoint": "0x08001cb8",
            "current_name": "FUNC_08001cb8",
            "code": "\nvoid FUNC_08001cb8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cb8": "FUNC_08001cb8"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ccc": {
            "entrypoint": "0x08001ccc",
            "current_name": "process_data_08001ccc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001d5e) */\n/* WARNING: Removing unreachable block (ram,0x08001d70) */\n/* WARNING: Removing unreachable block (ram,0x08001d72) */\n/* WARNING: Removing unreachable block (ram,0x08001d74) */\n\nundefined4\nprocessData_08001ccc(uint **data,undefined2 value1,undefined2 value2,undefined2 value3,uint *buffer,\n            undefined2 value4,undefined4 timeout)\n\n{\n  int startTick;\n  int currentTick;\n  undefined4 result;\n  uint *bytePtr;\n  \n  startTick = HAL_GetTick();\n  if (*(char *)((int)data + 0x3d) == ' ') {\n    do {\n      if ((~(*data)[6] & 2) != 0) {\n        currentTick = 0;\n        goto LAB_08001d9c;\n      }\n      currentTick = HAL_GetTick();\n    } while ((uint)(currentTick - startTick) < 0x1a);\n    data[0xc] = (uint *)0x0;\n    *(undefined *)((int)data + 0x3d) = 0x20;\n    *(undefined *)((int)data + 0x3e) = 0;\n    *(undefined *)(data + 0xf) = 0;\n    currentTick = 3;\nLAB_08001d9c:\n    if (currentTick == 0) {\n      if (*(char *)(data + 0xf) == '\\x01') {\n        result = 2;\n      }\n      else {\n        *(undefined *)(data + 0xf) = 1;\n        if ((**data & 1) != 1) {\n          **data = **data | 1;\n        }\n        **data = **data & 0xfffff7ff;\n        *(undefined *)((int)data + 0x3d) = 0x21;\n        *(undefined *)((int)data + 0x3e) = 0x40;\n        data[0x10] = (uint *)0x0;\n        data[9] = buffer;\n        *(undefined2 *)((int)data + 0x2a) = value4;\n        data[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(data + 10) = *(undefined2 *)((int)data + 0x2a);\n        currentTick = I2C_RequestMemoryWrite(data,value1,value2,value3,timeout,startTick);\n        if (currentTick == 0) {\n          while (*(short *)(data + 10) != 0) {\n            currentTick = I2C_WaitOnTXEFlagUntilTimeout(data,timeout,startTick);\n            if (currentTick != 0) {\n              if (data[0x10] == (uint *)0x4) {\n                **data = **data | 0x200;\n                return 1;\n              }\n              return 3;\n            }\n            bytePtr = data[9];\n            data[9] = (uint *)((int)bytePtr + 1);\n            (*data)[4] = (uint)*(byte *)bytePtr;\n            *(short *)(data + 10) = *(short *)(data + 10) + -1;\n            *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n            if ((((*data)[5] & 4) == 4) && (*(short *)(data + 10) != 0)) {\n              bytePtr = data[9];\n              data[9] = (uint *)((int)bytePtr + 1);\n              (*data)[4] = (uint)*(byte *)bytePtr;\n              *(short *)(data + 10) = *(short *)(data + 10) + -1;\n              *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n            }\n          }\n          startTick = I2C_WaitOnBTFFlagUntilTimeout(data,timeout,startTick);\n          if (startTick == 0) {\n            **data = **data | 0x200;\n            *(undefined *)((int)data + 0x3d) = 0x20;\n            *(undefined *)((int)data + 0x3e) = 0;\n            *(undefined *)(data + 0xf) = 0;\n            result = 0;\n          }\n          else if (data[0x10] == (uint *)0x4) {\n            **data = **data | 0x200;\n            result = 1;\n          }\n          else {\n            result = 3;\n          }\n        }\n        else if (data[0x10] == (uint *)0x4) {\n          *(undefined *)(data + 0xf) = 0;\n          result = 1;\n        }\n        else {\n          *(undefined *)(data + 0xf) = 0;\n          result = 3;\n        }\n      }\n    }\n    else {\n      result = 2;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001ccc": "process_data_08001ccc",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3",
                "param_5": "buffer",
                "param_6": "value4",
                "param_7": "timeout",
                "iVar1": "startTick",
                "iVar2": "currentTick",
                "uVar3": "result",
                "puVar4": "bytePtr"
            },
            "calling": [
                "_i2c_write_reg"
            ],
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_WaitOnBTFFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_RequestMemoryWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f6c": {
            "entrypoint": "0x08001f6c",
            "current_name": "perform_i2_c_read_operation_08001f6c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080024e6) */\n/* WARNING: Removing unreachable block (ram,0x080024f8) */\n/* WARNING: Removing unreachable block (ram,0x080024fa) */\n/* WARNING: Removing unreachable block (ram,0x080024fc) */\n/* WARNING: Removing unreachable block (ram,0x08002000) */\n/* WARNING: Removing unreachable block (ram,0x08002012) */\n/* WARNING: Removing unreachable block (ram,0x08002014) */\n/* WARNING: Removing unreachable block (ram,0x08002016) */\n/* WARNING: Removing unreachable block (ram,0x080023f4) */\n/* WARNING: Removing unreachable block (ram,0x08002406) */\n/* WARNING: Removing unreachable block (ram,0x08002408) */\n/* WARNING: Removing unreachable block (ram,0x0800240a) */\n/* WARNING: Removing unreachable block (ram,0x080022d6) */\n/* WARNING: Removing unreachable block (ram,0x080022e8) */\n/* WARNING: Removing unreachable block (ram,0x080022ea) */\n/* WARNING: Removing unreachable block (ram,0x080022ec) */\n\nundefined4\nperformI2CReadOperation_08001f6c(uint **i2cData,undefined2 memoryAddress1,undefined2 memoryAddress2,undefined2 memoryAddress3,uint *dataBuffer,\n            undefined2 param_6,uint timeout)\n\n{\n  int startTick;\n  uint status;\n  int elapsedTime;\n  undefined4 result;\n  uint *dataPtr;\n  \n  startTick = HAL_GetTick();\n  if (*(char *)((int)i2cData + 0x3d) == ' ') {\n    do {\n      if ((~(*i2cData)[6] & 2) != 0) {\n        elapsedTime = 0;\n        goto LAB_08002040;\n      }\n      elapsedTime = HAL_GetTick();\n    } while ((uint)(elapsedTime - startTick) < 0x1a);\n    i2cData[0xc] = (uint *)0x0;\n    *(undefined *)((int)i2cData + 0x3d) = 0x20;\n    *(undefined *)((int)i2cData + 0x3e) = 0;\n    *(undefined *)(i2cData + 0xf) = 0;\n    elapsedTime = 3;\nLAB_08002040:\n    if (elapsedTime == 0) {\n      if (*(char *)(i2cData + 0xf) == '\\x01') {\n        result = 2;\n      }\n      else {\n        *(undefined *)(i2cData + 0xf) = 1;\n        if ((**i2cData & 1) != 1) {\n          **i2cData = **i2cData | 1;\n        }\n        **i2cData = **i2cData & 0xfffff7ff;\n        *(undefined *)((int)i2cData + 0x3d) = 0x22;\n        *(undefined *)((int)i2cData + 0x3e) = 0x40;\n        i2cData[0x10] = (uint *)0x0;\n        i2cData[9] = dataBuffer;\n        *(undefined2 *)((int)i2cData + 0x2a) = param_6;\n        i2cData[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(i2cData + 10) = *(undefined2 *)((int)i2cData + 0x2a);\n        elapsedTime = I2C_RequestMemoryRead(i2cData,memoryAddress1,memoryAddress2,memoryAddress3,timeout,startTick);\n        if (elapsedTime == 0) {\n          if (*(short *)(i2cData + 10) == 0) {\n            **i2cData = **i2cData | 0x200;\n          }\n          else if (*(short *)(i2cData + 10) == 1) {\n            **i2cData = **i2cData & 0xfffffbff;\n            disableIRQinterrupts();\n            **i2cData = **i2cData | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (*(short *)(i2cData + 10) == 2) {\n            **i2cData = **i2cData | 0x800;\n            disableIRQinterrupts();\n            **i2cData = **i2cData & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            **i2cData = **i2cData | 0x400;\n          }\n          while (*(short *)(i2cData + 10) != 0) {\n            if (*(ushort *)(i2cData + 10) < 4) {\n              if (*(short *)(i2cData + 10) == 1) {\n                elapsedTime = I2C_WaitOnRXNEFlagUntilTimeout(i2cData,timeout,startTick);\n                if (elapsedTime != 0) {\n                  if (i2cData[0x10] == (uint *)0x20) {\n                    return 3;\n                  }\n                  return 1;\n                }\n                status = (*i2cData)[4];\n                dataPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)status;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n              }\n              else if (*(short *)(i2cData + 10) == 2) {\n                do {\n                  if ((~(*i2cData)[5] & 4) == 0) {\n                    elapsedTime = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (elapsedTime = HAL_GetTick(), (uint)(elapsedTime - startTick) <= timeout))\n                        ));\n                i2cData[0xc] = (uint *)0x0;\n                *(undefined *)((int)i2cData + 0x3d) = 0x20;\n                *(undefined *)((int)i2cData + 0x3e) = 0;\n                *(undefined *)(i2cData + 0xf) = 0;\n                elapsedTime = 3;\nLAB_080022fa:\n                if (elapsedTime != 0) {\n                  return 3;\n                }\n                disableIRQinterrupts();\n                **i2cData = **i2cData | 0x200;\n                status = (*i2cData)[4];\n                dataPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)status;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n                enableIRQinterrupts();\n                status = (*i2cData)[4];\n                dataPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)status;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n              }\n              else {\n                do {\n                  if ((~(*i2cData)[5] & 4) == 0) {\n                    elapsedTime = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (elapsedTime = HAL_GetTick(), (uint)(elapsedTime - startTick) <= timeout))\n                        ));\n                i2cData[0xc] = (uint *)0x0;\n                *(undefined *)((int)i2cData + 0x3d) = 0x20;\n                *(undefined *)((int)i2cData + 0x3e) = 0;\n                *(undefined *)(i2cData + 0xf) = 0;\n                elapsedTime = 3;\nLAB_08002418:\n                if (elapsedTime != 0) {\n                  return 3;\n                }\n                **i2cData = **i2cData & 0xfffffbff;\n                disableIRQinterrupts();\n                status = (*i2cData)[4];\n                dataPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)status;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n                do {\n                  if ((~(*i2cData)[5] & 4) == 0) {\n                    elapsedTime = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (elapsedTime = HAL_GetTick(), (uint)(elapsedTime - startTick) <= timeout))\n                        ));\n                i2cData[0xc] = (uint *)0x0;\n                *(undefined *)((int)i2cData + 0x3d) = 0x20;\n                *(undefined *)((int)i2cData + 0x3e) = 0;\n                *(undefined *)(i2cData + 0xf) = 0;\n                elapsedTime = 3;\nLAB_0800250a:\n                if (elapsedTime != 0) {\n                  return 3;\n                }\n                **i2cData = **i2cData | 0x200;\n                status = (*i2cData)[4];\n                dataPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)status;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n                enableIRQinterrupts();\n                status = (*i2cData)[4];\n                dataPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)status;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n              }\n            }\n            else {\n              elapsedTime = I2C_WaitOnRXNEFlagUntilTimeout(i2cData,timeout,startTick);\n              if (elapsedTime != 0) {\n                if (i2cData[0x10] == (uint *)0x20) {\n                  return 3;\n                }\n                return 1;\n              }\n              status = (*i2cData)[4];\n              dataPtr = i2cData[9];\n              i2cData[9] = (uint *)((int)dataPtr + 1);\n              *(char *)dataPtr = (char)status;\n              *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n              *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n              if (((*i2cData)[5] & 4) == 4) {\n                status = (*i2cData)[4];\n                dataPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)dataPtr + 1);\n                *(char *)dataPtr = (char)status;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n              }\n            }\n          }\n          *(undefined *)((int)i2cData + 0x3d) = 0x20;\n          *(undefined *)((int)i2cData + 0x3e) = 0;\n          *(undefined *)(i2cData + 0xf) = 0;\n          result = 0;\n        }\n        else if (i2cData[0x10] == (uint *)0x4) {\n          *(undefined *)(i2cData + 0xf) = 0;\n          result = 1;\n        }\n        else {\n          *(undefined *)(i2cData + 0xf) = 0;\n          result = 3;\n        }\n      }\n    }\n    else {\n      result = 2;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001f6c": "perform_i2_c_read_operation_08001f6c",
                "param_1": "i2cData",
                "param_2": "memoryAddress1",
                "param_3": "memoryAddress2",
                "param_4": "memoryAddress3",
                "param_5": "dataBuffer",
                "param_7": "timeout",
                "iVar1": "startTick",
                "uVar2": "status",
                "iVar3": "elapsedTime",
                "uVar4": "result",
                "puVar5": "dataPtr"
            },
            "calling": [
                "_i2c_read_reg"
            ],
            "called": [
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_RequestMemoryRead",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002640": {
            "entrypoint": "0x08002640",
            "current_name": "configure_i2_c_08002640",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nundefined4\nconfigureI2C_08002640(uint **i2cConfig,byte address,undefined2 data,short dataLength,uint timeout,int startTick)\n\n{\n  int status;\n  undefined4 result;\n  \n  **i2cConfig = **i2cConfig | 0x100;\n  do {\n    if ((~(*i2cConfig)[5] & 1) == 0) {\n      status = 0;\n      goto LAB_0800270a;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (status = HAL_GetTick(), (uint)(status - startTick) <= timeout))));\n  i2cConfig[0xc] = (uint *)0x0;\n  *(undefined *)((int)i2cConfig + 0x3d) = 0x20;\n  *(undefined *)((int)i2cConfig + 0x3e) = 0;\n  *(undefined *)(i2cConfig + 0xf) = 0;\n  status = 3;\nLAB_0800270a:\n  if (status == 0) {\n    (*i2cConfig)[4] = address & 0xfe;\n    status = I2C_WaitOnMasterAddressFlagUntilTimeout(i2cConfig,0x10002,timeout,startTick);\n    if (status == 0) {\n      status = I2C_WaitOnTXEFlagUntilTimeout(i2cConfig,timeout,startTick,(*i2cConfig)[6]);\n      if (status == 0) {\n        if (dataLength == 1) {\n          (*i2cConfig)[4] = (uint)(byte)data;\n        }\n        else {\n          (*i2cConfig)[4] = (uint)(byte)((ushort)data >> 8);\n          status = I2C_WaitOnTXEFlagUntilTimeout(i2cConfig,timeout,startTick);\n          if (status != 0) {\n            if (i2cConfig[0x10] == (uint *)0x4) {\n              **i2cConfig = **i2cConfig | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*i2cConfig)[4] = (uint)(byte)data;\n        }\n        result = 0;\n      }\n      else if (i2cConfig[0x10] == (uint *)0x4) {\n        **i2cConfig = **i2cConfig | 0x200;\n        result = 1;\n      }\n      else {\n        result = 3;\n      }\n    }\n    else if (i2cConfig[0x10] == (uint *)0x4) {\n      result = 1;\n    }\n    else {\n      result = 3;\n    }\n  }\n  else {\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002640": "configure_i2_c_08002640",
                "param_1": "i2cConfig",
                "param_2": "address",
                "param_3": "data",
                "param_4": "dataLength",
                "param_5": "timeout",
                "param_6": "startTick",
                "iVar1": "status",
                "uVar2": "result"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f4": {
            "entrypoint": "0x080027f4",
            "current_name": "initialize_i2_c_string_transfer_080027f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nundefined4\ninitializeI2CStringTransfer_080027f4(uint **i2cParams,byte slaveAddress,undefined2 regAddress,short regAddressSize,uint timeout,int startTime)\n\n{\n  int result;\n  undefined4 status;\n  \n  **i2cParams = **i2cParams | 0x400;\n  **i2cParams = **i2cParams | 0x100;\n  do {\n    if ((~(*i2cParams)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_080028d2;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (result = HAL_GetTick(), (uint)(result - startTime) <= timeout))));\n  i2cParams[0xc] = (uint *)0x0;\n  *(undefined *)((int)i2cParams + 0x3d) = 0x20;\n  *(undefined *)((int)i2cParams + 0x3e) = 0;\n  *(undefined *)(i2cParams + 0xf) = 0;\n  result = 3;\nLAB_080028d2:\n  if (result == 0) {\n    (*i2cParams)[4] = slaveAddress & 0xfe;\n    result = I2C_WaitOnMasterAddressFlagUntilTimeout(i2cParams,0x10002,timeout,startTime);\n    if (result == 0) {\n      result = I2C_WaitOnTXEFlagUntilTimeout(i2cParams,timeout,startTime,(*i2cParams)[6]);\n      if (result == 0) {\n        if (regAddressSize == 1) {\n          (*i2cParams)[4] = (uint)(byte)regAddress;\n        }\n        else {\n          (*i2cParams)[4] = (uint)(byte)((ushort)regAddress >> 8);\n          result = I2C_WaitOnTXEFlagUntilTimeout(i2cParams,timeout,startTime);\n          if (result != 0) {\n            if (i2cParams[0x10] == (uint *)0x4) {\n              **i2cParams = **i2cParams | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*i2cParams)[4] = (uint)(byte)regAddress;\n        }\n        result = I2C_WaitOnTXEFlagUntilTimeout(i2cParams,timeout,startTime);\n        if (result == 0) {\n          **i2cParams = **i2cParams | 0x100;\n          do {\n            if ((~(*i2cParams)[5] & 1) == 0) {\n              result = 0;\n              goto LAB_08002a90;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (result = HAL_GetTick(), (uint)(result - startTime) <= timeout))));\n          i2cParams[0xc] = (uint *)0x0;\n          *(undefined *)((int)i2cParams + 0x3d) = 0x20;\n          *(undefined *)((int)i2cParams + 0x3e) = 0;\n          *(undefined *)(i2cParams + 0xf) = 0;\n          result = 3;\nLAB_08002a90:\n          if (result == 0) {\n            (*i2cParams)[4] = (uint)(slaveAddress | 1);\n            result = I2C_WaitOnMasterAddressFlagUntilTimeout(i2cParams,0x10002,timeout,startTime);\n            if (result == 0) {\n              status = 0;\n            }\n            else if (i2cParams[0x10] == (uint *)0x4) {\n              status = 1;\n            }\n            else {\n              status = 3;\n            }\n          }\n          else {\n            status = 3;\n          }\n        }\n        else if (i2cParams[0x10] == (uint *)0x4) {\n          **i2cParams = **i2cParams | 0x200;\n          status = 1;\n        }\n        else {\n          status = 3;\n        }\n      }\n      else if (i2cParams[0x10] == (uint *)0x4) {\n        **i2cParams = **i2cParams | 0x200;\n        status = 1;\n      }\n      else {\n        status = 3;\n      }\n    }\n    else if (i2cParams[0x10] == (uint *)0x4) {\n      status = 1;\n    }\n    else {\n      status = 3;\n    }\n  }\n  else {\n    status = 3;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080027f4": "initialize_i2_c_string_transfer_080027f4",
                "param_1": "i2cParams",
                "param_2": "slaveAddress",
                "param_3": "regAddress",
                "param_4": "regAddressSize",
                "param_5": "timeout",
                "param_6": "startTime",
                "iVar1": "result",
                "uVar2": "status"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "identify_flag_08002ad8",
            "code": "\nundefined4 identify_flag_08002ad8(uint **input_array,uint flags,uint timeout,int start_time)\n\n{\n  int current_time;\n  char flag_result;\n  uint modified_flags;\n  bool is_set;\n  \n  do {\n    if ((flags >> 0x10 & 0xff) == 1) {\n      modified_flags = flags & ~(*input_array)[5] & 0xffff;\n      is_set = modified_flags != 0;\n      if (is_set) {\n        modified_flags = 1;\n      }\n      flag_result = (char)modified_flags;\n      if (!is_set) {\n        flag_result = '\\0';\n      }\n    }\n    else {\n      modified_flags = flags & ~(*input_array)[6] & 0xffff;\n      is_set = modified_flags != 0;\n      if (is_set) {\n        modified_flags = 1;\n      }\n      flag_result = (char)modified_flags;\n      if (!is_set) {\n        flag_result = '\\0';\n      }\n    }\n    if (flag_result == '\\0') {\n      return 0;\n    }\n    if (((*input_array)[5] & 0x400) == 0x400) {\n      **input_array = **input_array | 0x200;\n      (*input_array)[5] = 0xfffffbff;\n      input_array[0x10] = (uint *)0x4;\n      input_array[0xc] = (uint *)0x0;\n      *(undefined *)((int)input_array + 0x3d) = 0x20;\n      *(undefined *)(input_array + 0xf) = 0;\n      return 1;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (current_time = HAL_GetTick(), (uint)(current_time - start_time) <= timeout))));\n  input_array[0xc] = (uint *)0x0;\n  *(undefined *)((int)input_array + 0x3d) = 0x20;\n  *(undefined *)(input_array + 0xf) = 0;\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "identify_flag_08002ad8",
                "param_1": "input_array",
                "param_2": "flags",
                "param_3": "timeout",
                "param_4": "start_time",
                "iVar1": "current_time",
                "cVar2": "flag_result",
                "uVar3": "modified_flags",
                "bVar4": "is_set"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bb4": {
            "entrypoint": "0x08002bb4",
            "current_name": "check_i2_c_status_08002bb4",
            "code": "\nundefined4 checkI2CStatus_08002bb4(int *device,uint elapsedTime,int startTime)\n\n{\n  int isAcknowledgeFailed;\n  \n  while( true ) {\n    if ((*(uint *)(*device + 0x14) & 0x80) == 0x80) {\n      return 0;\n    }\n    isAcknowledgeFailed = I2C_IsAcknowledgeFailed(device);\n    if (isAcknowledgeFailed != 0) break;\n    if ((elapsedTime != 0xffffffff) &&\n       ((elapsedTime == 0 || (isAcknowledgeFailed = HAL_GetTick(), elapsedTime < (uint)(isAcknowledgeFailed - startTime))))) {\n      device[0x10] = device[0x10] | 0x20;\n      device[0xc] = 0;\n      *(undefined *)((int)device + 0x3d) = 0x20;\n      *(undefined *)(device + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002bb4": "check_i2_c_status_08002bb4",
                "param_1": "device",
                "param_2": "elapsedTime",
                "param_3": "startTime",
                "iVar1": "isAcknowledgeFailed"
            },
            "calling": [
                "HAL_I2C_Mem_Write",
                "I2C_RequestMemoryRead",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "I2C_IsAcknowledgeFailed",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2e": {
            "entrypoint": "0x08002c2e",
            "current_name": "check_i2_c_acknowledgement_08002c2e",
            "code": "\nundefined4 checkI2CAcknowledgement_08002c2e(int *devicePtr,uint timeout,int startTick)\n\n{\n  int ackFailed;\n  \n  while( true ) {\n    if ((*(uint *)(*devicePtr + 0x14) & 4) == 4) {\n      return 0;\n    }\n    ackFailed = checkI2CAcknowledgeFailed(devicePtr);\n    if (ackFailed != 0) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (ackFailed = getCurrentTick(), timeout < (uint)(ackFailed - startTick))))) {\n      devicePtr[0x10] = devicePtr[0x10] | 0x20;\n      devicePtr[0xc] = 0;\n      *(undefined *)((int)devicePtr + 0x3d) = 0x20;\n      *(undefined *)(devicePtr + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002c2e": "check_i2_c_acknowledgement_08002c2e",
                "param_1": "devicePtr",
                "param_2": "timeout",
                "param_3": "startTick",
                "iVar1": "ackFailed",
                "I2C_IsAcknowledgeFailed": "checkI2CAcknowledgeFailed",
                "HAL_GetTick": "getCurrentTick"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "I2C_IsAcknowledgeFailed",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca8": {
            "entrypoint": "0x08002ca8",
            "current_name": "check_and_update_status_08002ca8",
            "code": "\nundefined4 checkAndUpdateStatus_08002ca8(int *statusPtr,uint timeLimit,int currentTime)\n\n{\n  int elapsedTime;\n  \n  while( true ) {\n    if ((*(uint *)(*statusPtr + 0x14) & 0x40) == 0x40) {\n      return 0;\n    }\n    if ((*(uint *)(*statusPtr + 0x14) & 0x10) == 0x10) break;\n    if ((timeLimit == 0) || (elapsedTime = HAL_GetTick(), timeLimit < (uint)(elapsedTime - currentTime))) {\n      statusPtr[0x10] = statusPtr[0x10] | 0x20;\n      *(undefined *)((int)statusPtr + 0x3d) = 0x20;\n      *(undefined *)(statusPtr + 0xf) = 0;\n      return 3;\n    }\n  }\n  *(undefined4 *)(*statusPtr + 0x14) = 0xffffffef;\n  statusPtr[0x10] = 0;\n  statusPtr[0xc] = 0;\n  *(undefined *)((int)statusPtr + 0x3d) = 0x20;\n  *(undefined *)(statusPtr + 0xf) = 0;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002ca8": "check_and_update_status_08002ca8",
                "param_1": "statusPtr",
                "param_2": "timeLimit",
                "param_3": "currentTime",
                "iVar1": "elapsedTime"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d3c": {
            "entrypoint": "0x08002d3c",
            "current_name": "check_flag_status_08002d3c",
            "code": "\nbool checkFlagStatus_08002d3c(int *flagPointer)\n\n{\n  bool isFlagSet;\n  \n  isFlagSet = (*(uint *)(*flagPointer + 0x14) & 0x400) == 0x400;\n  if (isFlagSet) {\n    *(undefined4 *)(*flagPointer + 0x14) = 0xfffffbff;\n    flagPointer[0x10] = 4;\n    flagPointer[0xc] = 0;\n    *(undefined *)((int)flagPointer + 0x3d) = 0x20;\n    *(undefined *)(flagPointer + 0xf) = 0;\n  }\n  return isFlagSet;\n}\n\n",
            "renaming": {
                "FUN_08002d3c": "check_flag_status_08002d3c",
                "param_1": "flagPointer",
                "bVar1": "isFlagSet"
            },
            "calling": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_WaitOnBTFFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d8a": {
            "entrypoint": "0x08002d8a",
            "current_name": "FUNC_08002d8a",
            "code": "\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d98": {
            "entrypoint": "0x08002d98",
            "current_name": "improved_code_execution_08002d98",
            "code": "\n\n\nundefined4 improved_code_execution_08002d98(uint *param)\n\n{\n  int startTime;\n  int currentTime;\n  undefined4 result;\n  bool isFlagSet;\n  \n  if ((*param & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0x10000)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (param[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      if (param[1] == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (param[1] == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (param[1] == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (param[1] == 0) {\n        startTime = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTime = HAL_GetTick();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        startTime = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTime = HAL_GetTick();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*param & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (param[4] != 1)) {\n        return 1;\n      }\n      _DAT_40021000 = param[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n    else if (param[4] == 0) {\n      _DAT_42420000 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n      _DAT_40021000 = param[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n  }\n  if ((*param & 8) != 0) {\n    if (param[6] == 0) {\n      _DAT_42420480 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((*param & 4) != 0) {\n    isFlagSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isFlagSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = HAL_GetTick();\n        if (100 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (param[3] == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (param[3] == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (param[3] == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (param[3] == 0) {\n      startTime = HAL_GetTick();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      startTime = HAL_GetTick();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (isFlagSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if (param[7] == 0) {\nLAB_0800324a:\n    result = 0;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    result = 1;\n  }\n  else if (param[7] == 2) {\n    _DAT_42420060 = 0;\n    startTime = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if (param[8] == 0x10000) {\n          _DAT_40021004 = param[2] | _DAT_40021004 & 0xfffdffff;\n        }\n        _DAT_40021004 = param[9] | param[8] | _DAT_40021004 & 0xffc2ffff;\n        _DAT_42420060 = 1;\n        startTime = HAL_GetTick();\n        while ((_DAT_40021000 & 0x2000000) == 0) {\n          currentTime = HAL_GetTick();\n          if (2 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      currentTime = HAL_GetTick();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTime = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) goto LAB_0800324a;\n      currentTime = HAL_GetTick();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002d98": "improved_code_execution_08002d98",
                "param_1": "param",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "result",
                "bVar4": "isFlagSet"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003260": {
            "entrypoint": "0x08003260",
            "current_name": "initialize_system_08003260",
            "code": "\n\n\nundefined4 initializeSystem_08003260(uint *configData,uint configSize)\n\n{\n  int startTickCount;\n  int currentTickCount;\n  uint sysClockFreq;\n  undefined4 initResult;\n  \n  if (((_DAT_40022000 & 7) < configSize) &&\n     (_DAT_40022000 = configSize | _DAT_40022000 & 0xfffffff8, configSize != (configSize & 7))) {\n    initResult = 1;\n  }\n  else {\n    if ((*configData & 2) != 0) {\n      _DAT_40021004 = configData[2] | _DAT_40021004 & 0xffffff0f;\n    }\n    if ((*configData & 1) == 0) {\nLAB_08003394:\n      if ((configSize < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = configSize | _DAT_40022000 & 0xfffffff8, configSize != (configSize & 7))) {\n        initResult = 1;\n      }\n      else {\n        if ((*configData & 4) != 0) {\n          _DAT_40021004 = configData[3] | _DAT_40021004 & 0xfffff8ff;\n        }\n        if ((*configData & 8) != 0) {\n          _DAT_40021004 = configData[4] << 3 | _DAT_40021004 & 0xffffc7ff;\n        }\n        sysClockFreq = HAL_RCC_GetSysClockFreq();\n        DAT_20000018 = sysClockFreq >> (&DAT_08009eb0)[_DAT_40021004 >> 4 & 0xf];\n        HAL_InitTick(0xf);\n        initResult = 0;\n      }\n    }\n    else {\n      if (configData[1] == 1) {\n        if ((_DAT_40021000 & 0x20000) == 0) {\n          return 1;\n        }\n      }\n      else if ((configData[1] != 2) && ((_DAT_40021000 & 2) == 0)) {\n        return 1;\n      }\n      _DAT_40021004 = configData[1] | _DAT_40021004 & 0xfffffffc;\n      startTickCount = HAL_GetTick();\n      if (configData[1] == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_08003394;\n          currentTickCount = HAL_GetTick();\n        } while ((uint)(currentTickCount - startTickCount) < 0x1389);\n        initResult = 3;\n      }\n      else if (configData[1] == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_08003394;\n          currentTickCount = HAL_GetTick();\n        } while ((uint)(currentTickCount - startTickCount) < 0x1389);\n        initResult = 3;\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_08003394;\n          currentTickCount = HAL_GetTick();\n        } while ((uint)(currentTickCount - startTickCount) < 0x1389);\n        initResult = 3;\n      }\n    }\n  }\n  return initResult;\n}\n\n",
            "renaming": {
                "FUN_08003260": "initialize_system_08003260",
                "param_1": "configData",
                "param_2": "configSize",
                "iVar1": "startTickCount",
                "iVar2": "currentTickCount",
                "uVar3": "sysClockFreq",
                "uVar4": "initResult"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003440": {
            "entrypoint": "0x08003440",
            "current_name": "calculate_execution_time_08003440",
            "code": "\n\n\nuint calculateExecutionTime_08003440(void)\n\n{\n  undefined2 byteSize;\n  undefined4 constant1;\n  undefined4 constant2;\n  undefined4 constant3;\n  undefined4 constant4;\n  uint executionTime;\n  undefined4 tempVariable1;\n  uint local_14;\n  uint executionTimeResult;\n  uint tempVariable2;\n  \n  constant1 = 0x5040302;\n  constant2 = 0x9080706;\n  constant3 = 0xd0c0b0a;\n  constant4 = 0x10100f0e;\n  byteSize = 0x201;\n  tempVariable1 = 0;\n  tempVariable2 = 0;\n  executionTime = 0;\n  executionTimeResult = 0;\n  local_14 = _DAT_40021004;\n  if ((_DAT_40021004 & 0xc) == 4) {\n    executionTimeResult = 8000000;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    executionTime = (uint)*(byte *)((int)&constant1 + (_DAT_40021004 >> 0x12 & 0xf));\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      tempVariable2 = executionTime * 4000000;\n    }\n    else {\n      tempVariable2 = (executionTime * 8000000) / (uint)*(byte *)((int)&byteSize + (_DAT_40021004 >> 0x11 & 1))\n      ;\n    }\n    executionTimeResult = tempVariable2;\n  }\n  else {\n    executionTimeResult = 8000000;\n  }\n  return executionTimeResult;\n}\n\n",
            "renaming": {
                "FUN_08003440": "calculate_execution_time_08003440",
                "local_30": "byteSize",
                "local_2c": "constant1",
                "uStack_28": "constant2",
                "uStack_24": "constant3",
                "uStack_20": "constant4",
                "local_1c": "executionTime",
                "local_18": "tempVariable1",
                "local_10": "executionTimeResult",
                "local_c": "tempVariable2"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003504": {
            "entrypoint": "0x08003504",
            "current_name": "get_data_value_08003504",
            "code": "\nundefined4 get_data_value_08003504(void)\n\n{\n  return DAT_20000018;\n}\n\n",
            "renaming": {
                "FUN_08003504": "get_data_value_08003504"
            },
            "calling": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003518": {
            "entrypoint": "0x08003518",
            "current_name": "get_modified_hclk_freq_08003518",
            "code": "\n\n\nuint getModifiedHCLKFreq_08003518(void)\n\n{\n  uint frequency;\n  \n  frequency = HAL_RCC_GetHCLKFreq();\n  return frequency >> *(sbyte *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 8 & 7));\n}\n\n",
            "renaming": {
                "FUN_08003518": "get_modified_hclk_freq_08003518",
                "uVar1": "frequency"
            },
            "calling": [
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003540": {
            "entrypoint": "0x08003540",
            "current_name": "get_adjusted_hclk_freq_08003540",
            "code": "\n\n\nuint getAdjustedHCLKFreq_08003540(void)\n\n{\n  uint hclkFreq;\n  \n  hclkFreq = getHCLKFreq();\n  return hclkFreq >> *(sbyte *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 0xb & 7));\n}\n\n",
            "renaming": {
                "FUN_08003540": "get_adjusted_hclk_freq_08003540",
                "uVar1": "hclkFreq",
                "HAL_RCC_GetHCLKFreq": "getHCLKFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003568": {
            "entrypoint": "0x08003568",
            "current_name": "process_multiplication_08003568",
            "code": "\nvoid processMultiplication_08003568(int inputValue)\n\n{\n  bool isNonZero;\n  int scaledValue;\n  \n  scaledValue = inputValue * (DAT_20000018 / 8000);\n  do {\n    isNonZero = scaledValue != 0;\n    scaledValue = scaledValue + -1;\n  } while (isNonZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003568": "process_multiplication_08003568",
                "param_1": "inputValue",
                "local_c": "scaledValue",
                "bVar1": "isNonZero"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035a4": {
            "entrypoint": "0x080035a4",
            "current_name": "initialize_timer_080035a4",
            "code": "\nundefined4 initializeTimer_080035a4(undefined4 *timerStructPtr)\n\n{\n  undefined4 returnValue;\n  \n  if (timerStructPtr == (undefined4 *)0x0) {\n    returnValue = 1;\n  }\n  else {\n    if (*(char *)((int)timerStructPtr + 0x3d) == '\\0') {\n      *(undefined *)(timerStructPtr + 0xf) = 0;\n      HAL_TIM_Base_MspInit(timerStructPtr);\n    }\n    *(undefined *)((int)timerStructPtr + 0x3d) = 2;\n    TIM_Base_SetConfig(*timerStructPtr,timerStructPtr + 1);\n    *(undefined *)((int)timerStructPtr + 0x3d) = 1;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080035a4": "initialize_timer_080035a4",
                "param_1": "timerStructPtr",
                "uVar1": "returnValue"
            },
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "called": [
                "HAL_TIM_Base_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fa": {
            "entrypoint": "0x080035fa",
            "current_name": "FUNC_080035fa",
            "code": "\nvoid FUNC_080035fa(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fa": "FUNC_080035fa"
            },
            "calling": [
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800360c": {
            "entrypoint": "0x0800360c",
            "current_name": "set_flags_0800360c",
            "code": "\nundefined4 setFlags_0800360c(uint **flags)\n\n{\n  (*flags)[3] = (*flags)[3] | 1;\n  **flags = **flags | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800360c": "set_flags_0800360c",
                "param_1": "flags"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003640": {
            "entrypoint": "0x08003640",
            "current_name": "initialize_pwm_timer_08003640",
            "code": "\nundefined4 initialize_pwm_timer_08003640(undefined4 *timer_ptr)\n\n{\n  undefined4 result;\n  \n  if (timer_ptr == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)timer_ptr + 0x3d) == '\\0') {\n      *(undefined *)(timer_ptr + 0xf) = 0;\n      initialize_pwm_gpio(timer_ptr);\n    }\n    *(undefined *)((int)timer_ptr + 0x3d) = 2;\n    set_timer_config(*timer_ptr,timer_ptr + 1);\n    *(undefined *)((int)timer_ptr + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003640": "initialize_pwm_timer_08003640",
                "param_1": "timer_ptr",
                "uVar1": "result",
                "HAL_TIM_PWM_MspInit": "initialize_pwm_gpio",
                "TIM_Base_SetConfig": "set_timer_config"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003696": {
            "entrypoint": "0x08003696",
            "current_name": "FUNC_08003696",
            "code": "\nvoid FUNC_08003696(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003696": "FUNC_08003696"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080036a8": {
            "entrypoint": "0x080036a8",
            "current_name": "configure_timers_and_channels_080036a8",
            "code": "\nundefined4 configureTimersAndChannels_080036a8(uint **timerConfig,undefined4 channelConfig)\n\n{\n  TIM_CCxChannelCmd(*timerConfig,channelConfig,1);\n  if (*timerConfig == (uint *)0x40012c00) {\n    (*timerConfig)[0x11] = (*timerConfig)[0x11] | 0x8000;\n  }\n  **timerConfig = **timerConfig | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080036a8": "configure_timers_and_channels_080036a8",
                "param_1": "timerConfig",
                "param_2": "channelConfig"
            },
            "calling": [
                "main"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f8": {
            "entrypoint": "0x080036f8",
            "current_name": "update_tim_callback_080036f8",
            "code": "\nvoid update_TIM_callback_080036f8(int *TIM_ptr)\n\n{\n  if (((*(uint *)(*TIM_ptr + 0x10) & 2) == 2) && ((*(uint *)(*TIM_ptr + 0xc) & 2) == 2)) {\n    *(undefined4 *)(*TIM_ptr + 0x10) = 0xfffffffd;\n    *(undefined *)(TIM_ptr + 7) = 1;\n    if ((*(uint *)(*TIM_ptr + 0x18) & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(TIM_ptr);\n      HAL_TIM_PWM_PulseFinishedCallback(TIM_ptr);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(TIM_ptr);\n    }\n    *(undefined *)(TIM_ptr + 7) = 0;\n  }\n  if (((*(uint *)(*TIM_ptr + 0x10) & 4) == 4) && ((*(uint *)(*TIM_ptr + 0xc) & 4) == 4)) {\n    *(undefined4 *)(*TIM_ptr + 0x10) = 0xfffffffb;\n    *(undefined *)(TIM_ptr + 7) = 2;\n    if ((*(uint *)(*TIM_ptr + 0x18) & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(TIM_ptr);\n      HAL_TIM_PWM_PulseFinishedCallback(TIM_ptr);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(TIM_ptr);\n    }\n    *(undefined *)(TIM_ptr + 7) = 0;\n  }\n  if (((*(uint *)(*TIM_ptr + 0x10) & 8) == 8) && ((*(uint *)(*TIM_ptr + 0xc) & 8) == 8)) {\n    *(undefined4 *)(*TIM_ptr + 0x10) = 0xfffffff7;\n    *(undefined *)(TIM_ptr + 7) = 4;\n    if ((*(uint *)(*TIM_ptr + 0x1c) & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(TIM_ptr);\n      HAL_TIM_PWM_PulseFinishedCallback(TIM_ptr);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(TIM_ptr);\n    }\n    *(undefined *)(TIM_ptr + 7) = 0;\n  }\n  if (((*(uint *)(*TIM_ptr + 0x10) & 0x10) == 0x10) && ((*(uint *)(*TIM_ptr + 0xc) & 0x10) == 0x10))\n  {\n    *(undefined4 *)(*TIM_ptr + 0x10) = 0xffffffef;\n    *(undefined *)(TIM_ptr + 7) = 8;\n    if ((*(uint *)(*TIM_ptr + 0x1c) & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(TIM_ptr);\n      HAL_TIM_PWM_PulseFinishedCallback(TIM_ptr);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(TIM_ptr);\n    }\n    *(undefined *)(TIM_ptr + 7) = 0;\n  }\n  if (((*(uint *)(*TIM_ptr + 0x10) & 1) == 1) && ((*(uint *)(*TIM_ptr + 0xc) & 1) == 1)) {\n    *(undefined4 *)(*TIM_ptr + 0x10) = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(TIM_ptr);\n  }\n  if (((*(uint *)(*TIM_ptr + 0x10) & 0x80) == 0x80) && ((*(uint *)(*TIM_ptr + 0xc) & 0x80) == 0x80))\n  {\n    *(undefined4 *)(*TIM_ptr + 0x10) = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(TIM_ptr);\n  }\n  if (((*(uint *)(*TIM_ptr + 0x10) & 0x40) == 0x40) && ((*(uint *)(*TIM_ptr + 0xc) & 0x40) == 0x40))\n  {\n    *(undefined4 *)(*TIM_ptr + 0x10) = 0xffffffbf;\n    HAL_TIM_TriggerCallback(TIM_ptr);\n  }\n  if (((*(uint *)(*TIM_ptr + 0x10) & 0x20) == 0x20) && ((*(uint *)(*TIM_ptr + 0xc) & 0x20) == 0x20))\n  {\n    *(undefined4 *)(*TIM_ptr + 0x10) = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(TIM_ptr);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036f8": "update_tim_callback_080036f8",
                "param_1": "TIM_ptr"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PWM_PulseFinishedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003908": {
            "entrypoint": "0x08003908",
            "current_name": "set_tim_config_08003908",
            "code": "\nundefined4 setTIMConfig_08003908(int *timerConfig,int configValue,undefined4 ocChannel)\n\n{\n  undefined4 returnValue;\n  \n  if (*(char *)(timerConfig + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(timerConfig + 0xf) = 1;\n    *(undefined *)((int)timerConfig + 0x3d) = 2;\n    switch(ocChannel) {\n    case 0:\n      TIM_OC1_SetConfig(*timerConfig,configValue);\n      *(uint *)(*timerConfig + 0x18) = *(uint *)(*timerConfig + 0x18) | 8;\n      *(uint *)(*timerConfig + 0x18) = *(uint *)(*timerConfig + 0x18) & 0xfffffffb;\n      *(uint *)(*timerConfig + 0x18) = *(uint *)(configValue + 0x10) | *(uint *)(*timerConfig + 0x18);\n      break;\n    case 4:\n      TIM_OC2_SetConfig(*timerConfig,configValue);\n      *(uint *)(*timerConfig + 0x18) = *(uint *)(*timerConfig + 0x18) | 0x800;\n      *(uint *)(*timerConfig + 0x18) = *(uint *)(*timerConfig + 0x18) & 0xfffffbff;\n      *(uint *)(*timerConfig + 0x18) = *(int *)(configValue + 0x10) << 8 | *(uint *)(*timerConfig + 0x18);\n      break;\n    case 8:\n      TIM_OC3_SetConfig(*timerConfig,configValue);\n      *(uint *)(*timerConfig + 0x1c) = *(uint *)(*timerConfig + 0x1c) | 8;\n      *(uint *)(*timerConfig + 0x1c) = *(uint *)(*timerConfig + 0x1c) & 0xfffffffb;\n      *(uint *)(*timerConfig + 0x1c) = *(uint *)(configValue + 0x10) | *(uint *)(*timerConfig + 0x1c);\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(*timerConfig,configValue);\n      *(uint *)(*timerConfig + 0x1c) = *(uint *)(*timerConfig + 0x1c) | 0x800;\n      *(uint *)(*timerConfig + 0x1c) = *(uint *)(*timerConfig + 0x1c) & 0xfffffbff;\n      *(uint *)(*timerConfig + 0x1c) = *(int *)(configValue + 0x10) << 8 | *(uint *)(*timerConfig + 0x1c);\n    }\n    *(undefined *)((int)timerConfig + 0x3d) = 1;\n    *(undefined *)(timerConfig + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08003908": "set_tim_config_08003908",
                "param_1": "timerConfig",
                "param_2": "configValue",
                "param_3": "ocChannel",
                "uVar1": "returnValue"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "TIM_OC2_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC3_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a94": {
            "entrypoint": "0x08003a94",
            "current_name": "configure_timer_08003a94",
            "code": "\nundefined4 configureTimer_08003a94(int *config,uint *settings)\n\n{\n  undefined4 result;\n  uint settingValue;\n  \n  if (*(char *)(config + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(config + 0xf) = 1;\n    *(undefined *)((int)config + 0x3d) = 2;\n    *(uint *)(*config + 8) = *(uint *)(*config + 8) & 0xffff0088;\n    settingValue = *settings;\n    if (settingValue == 0x40) {\n      TIM_TI1_ConfigInputStage(*config,settings[1],settings[3]);\n      TIM_ITRx_SetConfig(*config,0x40);\n    }\n    else if (settingValue < 0x41) {\n      if (settingValue == 0x10) {\n        TIM_ITRx_SetConfig(*config,0x10);\n      }\n      else if (settingValue < 0x11) {\n        if (settingValue == 0) {\n          TIM_ITRx_SetConfig(*config,0);\n        }\n      }\n      else if (settingValue == 0x20) {\n        TIM_ITRx_SetConfig(*config,0x20);\n      }\n      else if (settingValue == 0x30) {\n        TIM_ITRx_SetConfig(*config,0x30);\n      }\n    }\n    else if (settingValue == 0x70) {\n      TIM_ETR_SetConfig(*config,settings[2],settings[1],settings[3]);\n      *(uint *)(*config + 8) = *(uint *)(*config + 8) & 0xffffff88 | 0x77;\n    }\n    else if (settingValue < 0x71) {\n      if (settingValue == 0x50) {\n        TIM_TI1_ConfigInputStage(*config,settings[1],settings[3]);\n        TIM_ITRx_SetConfig(*config,0x50);\n      }\n      else if (settingValue == 0x60) {\n        TIM_TI2_ConfigInputStage(*config,settings[1],settings[3]);\n        TIM_ITRx_SetConfig(*config,0x60);\n      }\n    }\n    else if (settingValue == 0x1000) {\n      *(uint *)(*config + 8) = *(uint *)(*config + 8) & 0xfffffff8;\n    }\n    else if (settingValue == 0x2000) {\n      TIM_ETR_SetConfig(*config,settings[2],settings[1],settings[3]);\n      *(uint *)(*config + 8) = *(uint *)(*config + 8) | 0x4000;\n    }\n    *(undefined *)((int)config + 0x3d) = 1;\n    *(undefined *)(config + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003a94": "configure_timer_08003a94",
                "param_1": "config",
                "param_2": "settings",
                "uVar1": "result",
                "uVar2": "settingValue"
            },
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "called": [
                "TIM_ITRx_SetConfig",
                "TIM_TI1_ConfigInputStage",
                "TIM_TI2_ConfigInputStage",
                "TIM_ETR_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c4a": {
            "entrypoint": "0x08003c4a",
            "current_name": "FUNC_08003c4a",
            "code": "\nvoid FUNC_08003c4a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c4a": "FUNC_08003c4a"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c5c": {
            "entrypoint": "0x08003c5c",
            "current_name": "FUNC_08003c5c",
            "code": "\nvoid FUNC_08003c5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c5c": "FUNC_08003c5c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c6e": {
            "entrypoint": "0x08003c6e",
            "current_name": "FUNC_08003c6e",
            "code": "\nvoid FUNC_08003c6e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c6e": "FUNC_08003c6e"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c80": {
            "entrypoint": "0x08003c80",
            "current_name": "FUNC_08003c80",
            "code": "\nvoid FUNC_08003c80(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c80": "FUNC_08003c80"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c94": {
            "entrypoint": "0x08003c94",
            "current_name": "update_memory_locations_08003c94",
            "code": "\nvoid updateMemoryLocations_08003c94(uint *memoryLocation1,uint *memoryLocation2)\n\n{\n  uint tempValue;\n  \n  tempValue = *memoryLocation1;\n  if ((((memoryLocation1 == (uint *)0x40012c00) || (memoryLocation1 == (uint *)0x40000000)) ||\n      (memoryLocation1 == (uint *)0x40000400)) || (memoryLocation1 == (uint *)0x40000800)) {\n    tempValue = memoryLocation2[1] | tempValue & 0xffffff8f;\n  }\n  if (((memoryLocation1 == (uint *)0x40012c00) || (memoryLocation1 == (uint *)0x40000000)) ||\n     ((memoryLocation1 == (uint *)0x40000400 || (memoryLocation1 == (uint *)0x40000800)))) {\n    tempValue = memoryLocation2[3] | tempValue & 0xfffffcff;\n  }\n  *memoryLocation1 = memoryLocation2[5] | tempValue & 0xffffff7f;\n  memoryLocation1[0xb] = memoryLocation2[2];\n  memoryLocation1[10] = *memoryLocation2;\n  if (memoryLocation1 == (uint *)0x40012c00) {\n    uRam40012c30 = memoryLocation2[4];\n  }\n  memoryLocation1[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c94": "update_memory_locations_08003c94",
                "param_1": "memoryLocation1",
                "param_2": "memoryLocation2",
                "local_c": "tempValue"
            },
            "calling": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d60": {
            "entrypoint": "0x08003d60",
            "current_name": "update_data_08003d60",
            "code": "\nvoid updateData_08003d60(int dataAddress,uint *data)\n\n{\n  uint param1Value;\n  uint param2Value;\n  uint localValue;\n  \n  *(uint *)(dataAddress + 0x20) = *(uint *)(dataAddress + 0x20) & 0xfffffffe;\n  localValue = *(uint *)(dataAddress + 4);\n  param1Value = *data;\n  param2Value = data[2] | *(uint *)(dataAddress + 0x20) & 0xfffffffd;\n  if (dataAddress == 0x40012c00) {\n    param2Value = (data[3] | param2Value & 0xfffffff7) & 0xfffffffb;\n    localValue = data[6] | data[5] | localValue & 0xfffffcff;\n  }\n  *(uint *)(dataAddress + 4) = localValue;\n  *(uint *)(dataAddress + 0x18) = param1Value | *(uint *)(dataAddress + 0x18) & 0xffffff8c;\n  *(uint *)(dataAddress + 0x34) = data[1];\n  *(uint *)(dataAddress + 0x20) = param2Value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003d60": "update_data_08003d60",
                "param_1": "dataAddress",
                "param_2": "data",
                "uVar1": "param1Value",
                "uVar2": "param2Value",
                "local_10": "localValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e38": {
            "entrypoint": "0x08003e38",
            "current_name": "update_data_08003e38",
            "code": "\nvoid updateData_08003e38(int dataAddress,int *inputArray)\n\n{\n  int tempVariable1;\n  uint tempVariable2;\n  uint tempVariable3;\n  \n  *(uint *)(dataAddress + 0x20) = *(uint *)(dataAddress + 0x20) & 0xffffffef;\n  tempVariable3 = *(uint *)(dataAddress + 4);\n  tempVariable1 = *inputArray;\n  tempVariable2 = inputArray[2] << 4 | *(uint *)(dataAddress + 0x20) & 0xffffffdf;\n  if (dataAddress == 0x40012c00) {\n    tempVariable2 = (inputArray[3] << 4 | tempVariable2 & 0xffffff7f) & 0xffffffbf;\n    tempVariable3 = inputArray[6] << 2 | inputArray[5] << 2 | tempVariable3 & 0xfffff3ff;\n  }\n  *(uint *)(dataAddress + 4) = tempVariable3;\n  *(uint *)(dataAddress + 0x18) = tempVariable1 << 8 | *(uint *)(dataAddress + 0x18) & 0xffff8cff;\n  *(int *)(dataAddress + 0x38) = inputArray[1];\n  *(uint *)(dataAddress + 0x20) = tempVariable2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e38": "update_data_08003e38",
                "param_1": "dataAddress",
                "param_2": "inputArray",
                "iVar1": "tempVariable1",
                "uVar2": "tempVariable2",
                "local_10": "tempVariable3"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "update_memory_values_08003f18",
            "code": "\nvoid updateMemoryValues_08003f18(int memoryAddress,uint *paramArray)\n\n{\n  uint value1;\n  uint value2;\n  uint tempValue;\n  \n  *(uint *)(memoryAddress + 0x20) = *(uint *)(memoryAddress + 0x20) & 0xfffffeff;\n  tempValue = *(uint *)(memoryAddress + 4);\n  value1 = *paramArray;\n  value2 = paramArray[2] << 8 | *(uint *)(memoryAddress + 0x20) & 0xfffffdff;\n  if (memoryAddress == 0x40012c00) {\n    value2 = (paramArray[3] << 8 | value2 & 0xfffff7ff) & 0xfffffbff;\n    tempValue = paramArray[6] << 4 | paramArray[5] << 4 | tempValue & 0xffffcfff;\n  }\n  *(uint *)(memoryAddress + 4) = tempValue;\n  *(uint *)(memoryAddress + 0x1c) = value1 | *(uint *)(memoryAddress + 0x1c) & 0xffffff8c;\n  *(uint *)(memoryAddress + 0x3c) = paramArray[1];\n  *(uint *)(memoryAddress + 0x20) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "update_memory_values_08003f18",
                "param_1": "memoryAddress",
                "param_2": "paramArray",
                "uVar1": "value1",
                "uVar2": "value2",
                "local_10": "tempValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff8": {
            "entrypoint": "0x08003ff8",
            "current_name": "update_config_08003ff8",
            "code": "\nvoid updateConfig_08003ff8(int configAddress,int *parameters)\n\n{\n  int value1;\n  int value2;\n  uint configValue;\n  \n  *(uint *)(configAddress + 0x20) = *(uint *)(configAddress + 0x20) & 0xffffefff;\n  configValue = *(uint *)(configAddress + 4);\n  value1 = *parameters;\n  value2 = parameters[2];\n  if (configAddress == 0x40012c00) {\n    configValue = shiftedValue << 6 | configValue & 0xffffbfff;\n  }\n  *(uint *)(configAddress + 4) = configValue;\n  *(uint *)(configAddress + 0x1c) = value1 << 8 | *(uint *)(configAddress + 0x1c) & 0xffff8cff;\n  *(int *)(configAddress + 0x40) = parameters[1];\n  *(uint *)(configAddress + 0x20) = value2 << 0xc | *(uint *)(configAddress + 0x20) & 0xffffdfff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff8": "update_config_08003ff8",
                "param_1": "configAddress",
                "param_2": "parameters",
                "iVar1": "value1",
                "iVar2": "value2",
                "local_c": "configValue",
                "param_2[5]": "shiftedValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040a0": {
            "entrypoint": "0x080040a0",
            "current_name": "update_param_values_080040a0",
            "code": "\nvoid updateParamValues_080040a0(int ptr,uint value,int param)\n\n{\n  uint tempValue;\n  \n  tempValue = *(uint *)(ptr + 0x20);\n  *(uint *)(ptr + 0x20) = *(uint *)(ptr + 0x20) & 0xfffffffe;\n  *(uint *)(ptr + 0x18) = param << 4 | *(uint *)(ptr + 0x18) & 0xffffff0f;\n  *(uint *)(ptr + 0x20) = value | tempValue & 0xfffffff5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040a0": "update_param_values_080040a0",
                "param_1": "ptr",
                "param_2": "value",
                "param_3": "param",
                "uVar1": "tempValue"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004104": {
            "entrypoint": "0x08004104",
            "current_name": "update_flags_and_values_08004104",
            "code": "\nvoid updateFlagsAndValues_08004104(int input,int flag,int value)\n\n{\n  *(uint *)(input + 0x20) = *(uint *)(input + 0x20) & 0xffffffef;\n  *(uint *)(input + 0x18) = value << 0xc | *(uint *)(input + 0x18) & 0xffff0fff;\n  *(uint *)(input + 0x20) = flag << 4 | *(uint *)(input + 0x20) & 0xffffff5f;\n  void;\n}\n\n",
            "renaming": {
                "FUN_08004104": "update_flags_and_values_08004104",
                "param_1": "input",
                "param_2": "flag",
                "param_3": "value",
                "return": "void"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800416a": {
            "entrypoint": "0x0800416a",
            "current_name": "set_param_value_0800416a",
            "code": "\nvoid setParamValue_0800416a(int bufPointer,ushort value)\n\n{\n  *(uint *)(bufPointer + 8) = *(uint *)(bufPointer + 8) & 0xffffff8f | (uint)(value | 7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800416a": "set_param_value_0800416a",
                "param_1": "bufPointer",
                "param_2": "value"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a8": {
            "entrypoint": "0x080041a8",
            "current_name": "set_merged_values_080041a8",
            "code": "\nvoid setMergedValues_080041a8(int ptr,uint value1,uint value2,int value3)\n\n{\n  *(uint *)(ptr + 8) = value1 | value3 << 8 | value2 | *(uint *)(ptr + 8) & 0xffff00ff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a8": "set_merged_values_080041a8",
                "param_1": "ptr",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ea": {
            "entrypoint": "0x080041ea",
            "current_name": "update_bits_080041ea",
            "code": "\nvoid updateBits_080041ea(int baseAddress,uint bitPosition,int newValue)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & ~(1 << (bitPosition & 0xff));\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) | newValue << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041ea": "update_bits_080041ea",
                "param_1": "baseAddress",
                "param_2": "bitPosition",
                "param_3": "newValue"
            },
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800422e": {
            "entrypoint": "0x0800422e",
            "current_name": "set_flag_0800422e",
            "code": "\nundefined4 setFlag_0800422e(int *flag,uint *data)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(flag + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(flag + 0xf) = 1;\n    *(uint *)(*flag + 0x44) =\n         data[6] |\n         (data[6] |\n         (data[5] |\n         (data[4] |\n         (*data | (data[1] | (data[2] | data[3] & 0xfffffcff) & 0xfffffbff) & 0xfffff7ff\n         ) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    *(undefined *)(flag + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800422e": "set_flag_0800422e",
                "param_1": "flag",
                "param_2": "data",
                "uVar1": "result"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042de": {
            "entrypoint": "0x080042de",
            "current_name": "set_flag_if_true_080042de",
            "code": "\nundefined4 setFlagIfTrue_080042de(int *array,uint *flags)\n\n{\n  undefined4 returnValue;\n  \n  if (*(char *)(array + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(array + 0xf) = 1;\n    *(undefined *)((int)array + 0x3d) = 2;\n    *(uint *)(*array + 4) = *(uint *)(*array + 4) & 0xffffff8f;\n    *(uint *)(*array + 4) = *flags | *(uint *)(*array + 4);\n    *(uint *)(*array + 8) = *(uint *)(*array + 8) & 0xffffff7f;\n    *(uint *)(*array + 8) = flags[1] | *(uint *)(*array + 8);\n    *(undefined *)((int)array + 0x3d) = 1;\n    *(undefined *)(array + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080042de": "set_flag_if_true_080042de",
                "param_1": "array",
                "param_2": "flags",
                "uVar1": "returnValue"
            },
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004366": {
            "entrypoint": "0x08004366",
            "current_name": "FUNC_08004366",
            "code": "\nvoid FUNC_08004366(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004366": "FUNC_08004366"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004378": {
            "entrypoint": "0x08004378",
            "current_name": "FUNC_08004378",
            "code": "\nvoid FUNC_08004378(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004378": "FUNC_08004378"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800438a": {
            "entrypoint": "0x0800438a",
            "current_name": "initialize_uart_0800438a",
            "code": "\nundefined4 initializeUART_0800438a(int *uartPort)\n\n{\n  undefined4 result;\n  \n  if (uartPort == (int *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)uartPort + 0x39) == '\\0') {\n      *(undefined *)(uartPort + 0xe) = 0;\n      initializeUART_0800438aPeripheral(uartPort);\n    }\n    *(undefined *)((int)uartPort + 0x39) = 0x24;\n    *(uint *)(*uartPort + 0xc) = *(uint *)(*uartPort + 0xc) & 0xffffdfff;\n    setUARTConfig(uartPort);\n    *(uint *)(*uartPort + 0x10) = *(uint *)(*uartPort + 0x10) & 0xffffb7ff;\n    *(uint *)(*uartPort + 0x14) = *(uint *)(*uartPort + 0x14) & 0xffffffd5;\n    *(uint *)(*uartPort + 0xc) = *(uint *)(*uartPort + 0xc) | 0x2000;\n    counter = 0;\n    *(undefined *)((int)uartPort + 0x39) = 0x20;\n    *(undefined *)((int)uartPort + 0x3a) = 0x20;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800438a": "initialize_uart_0800438a",
                "param_1": "uartPort",
                "uVar1": "result",
                "HAL_UART_MspInit": "initializeUARTPeripheral",
                "UART_SetConfig": "setUARTConfig",
                "param_1[0xf]": "counter"
            },
            "calling": [
                "MX_USART1_UART_Init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004424": {
            "entrypoint": "0x08004424",
            "current_name": "FUNC_08004424",
            "code": "\nvoid FUNC_08004424(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004424": "FUNC_08004424"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004436": {
            "entrypoint": "0x08004436",
            "current_name": "check_input_08004436",
            "code": "\nundefined4 checkInput_08004436(uint **pptr,ushort *inputArray,short inputLength,uint timeout)\n\n{\n  int tempVar1;\n  int tempVar2;\n  undefined4 result;\n  ushort *tempVar3;\n  \n  if (*(char *)((int)pptr + 0x39) == ' ') {\n    if ((inputArray == (ushort *)0x0) || (inputLength == 0)) {\n      result = 1;\n    }\n    else if (*(char *)(pptr + 0xe) == '\\x01') {\n      result = 2;\n    }\n    else {\n      *(undefined *)(pptr + 0xe) = 1;\n      pptr[0xf] = (uint *)0x0;\n      *(undefined *)((int)pptr + 0x39) = 0x21;\n      tempVar1 = HAL_GetTick();\n      *(short *)(pptr + 9) = inputLength;\n      *(short *)((int)pptr + 0x26) = inputLength;\n      tempVar3 = inputArray;\n      while (*(short *)((int)pptr + 0x26) != 0) {\n        *(short *)((int)pptr + 0x26) = *(short *)((int)pptr + 0x26) + -1;\n        if (pptr[2] == (uint *)0x1000) {\n          do {\n            if ((**pptr & 0x80) == 0x80) {\n              tempVar2 = 0;\n              goto LAB_0800454c;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (tempVar2 = HAL_GetTick(), (uint)(tempVar2 - tempVar1) <= timeout))));\n          (*pptr)[3] = (*pptr)[3] & 0xfffffe5f;\n          (*pptr)[5] = (*pptr)[5] & 0xfffffffe;\n          *(undefined *)((int)pptr + 0x39) = 0x20;\n          *(undefined *)((int)pptr + 0x3a) = 0x20;\n          *(undefined *)(pptr + 0xe) = 0;\n          tempVar2 = 3;\nLAB_0800454c:\n          if (tempVar2 != 0) {\n            return 3;\n          }\n          (*pptr)[1] = *tempVar3 & 0x1ff;\n          if (pptr[4] == (uint *)0x0) {\n            tempVar3 = tempVar3 + 1;\n          }\n          else {\n            tempVar3 = (ushort *)((int)tempVar3 + 1);\n          }\n        }\n        else {\n          do {\n            if ((**pptr & 0x80) == 0x80) {\n              tempVar2 = 0;\n              goto LAB_08004614;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (tempVar2 = HAL_GetTick(), (uint)(tempVar2 - tempVar1) <= timeout))));\n          (*pptr)[3] = (*pptr)[3] & 0xfffffe5f;\n          (*pptr)[5] = (*pptr)[5] & 0xfffffffe;\n          *(undefined *)((int)pptr + 0x39) = 0x20;\n          *(undefined *)((int)pptr + 0x3a) = 0x20;\n          *(undefined *)(pptr + 0xe) = 0;\n          tempVar2 = 3;\nLAB_08004614:\n          if (tempVar2 != 0) {\n            return 3;\n          }\n          (*pptr)[1] = (uint)*(byte *)tempVar3;\n          tempVar3 = (ushort *)((int)tempVar3 + 1);\n        }\n      }\n      do {\n        if ((**pptr & 0x40) == 0x40) {\n          tempVar1 = 0;\n          goto LAB_080046c6;\n        }\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (tempVar2 = HAL_GetTick(), (uint)(tempVar2 - tempVar1) <= timeout))));\n      (*pptr)[3] = (*pptr)[3] & 0xfffffe5f;\n      (*pptr)[5] = (*pptr)[5] & 0xfffffffe;\n      *(undefined *)((int)pptr + 0x39) = 0x20;\n      *(undefined *)((int)pptr + 0x3a) = 0x20;\n      *(undefined *)(pptr + 0xe) = 0;\n      tempVar1 = 3;\nLAB_080046c6:\n      if (tempVar1 == 0) {\n        *(undefined *)((int)pptr + 0x39) = 0x20;\n        *(undefined *)(pptr + 0xe) = 0;\n        result = 0;\n      }\n      else {\n        result = 3;\n      }\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004436": "check_input_08004436",
                "param_1": "pptr",
                "param_2": "inputArray",
                "param_3": "inputLength",
                "param_4": "timeout",
                "iVar1": "tempVar1",
                "iVar2": "tempVar2",
                "uVar3": "result",
                "local_58": "tempVar3"
            },
            "calling": [
                "uart_print"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046ec": {
            "entrypoint": "0x080046ec",
            "current_name": "update_clock_frequency_080046ec",
            "code": "\nvoid updateClockFrequency_080046ec(int *inputParams)\n\n{\n  ulonglong calculationResult1;\n  int calculationResult2;\n  int calculationResult3;\n  uint calculationResult4;\n  int calculationResult5;\n  undefined8 fetchedFrequency;\n  \n  *(uint *)(*inputParams + 0x10) = inputParams[3] | *(uint *)(*inputParams + 0x10) & 0xffffcfff;\n  *(uint *)(*inputParams + 0xc) =\n       *(uint *)(*inputParams + 0xc) & 0xffffe9f3 | inputParams[5] | inputParams[2] | inputParams[4];\n  *(uint *)(*inputParams + 0x14) = inputParams[6] | *(uint *)(*inputParams + 0x14) & 0xfffffcff;\n  if (*inputParams == 0x40013800) {\n    fetchedFrequency = HAL_RCC_GetPCLK2Freq();\n    calculationResult1 = (ulonglong)(uint)((int)fetchedFrequency * 0x19) / (ulonglong)(uint)(inputParams[1] << 2);\n    calculationResult2 = HAL_RCC_GetPCLK2Freq\n                      ((int)fetchedFrequency,(int)((ulonglong)fetchedFrequency >> 0x20),(int)(calculationResult1 * 0x51eb851f));\n    calculationResult3 = inputParams[1];\n    fetchedFrequency = HAL_RCC_GetPCLK2Freq();\n    calculationResult4 = ((uint)(calculationResult2 * 0x19) / (uint)(calculationResult3 << 2) +\n            (int)(((ulonglong)(uint)((int)fetchedFrequency * 0x19) / (ulonglong)(uint)(inputParams[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    calculationResult2 = HAL_RCC_GetPCLK2Freq((int)fetchedFrequency,(int)((ulonglong)fetchedFrequency >> 0x20),calculationResult4 * 0x51eb851f);\n    calculationResult5 = inputParams[1];\n    calculationResult3 = HAL_RCC_GetPCLK2Freq();\n    *(uint *)(*inputParams + 8) =\n         ((((uint)(calculationResult2 * 0x19) / (uint)(calculationResult5 << 2) +\n           (int)(((ulonglong)(uint)(calculationResult3 * 0x19) / (ulonglong)(uint)(inputParams[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(calculationResult1 / 100) * 0x10 + (calculationResult4 / 100 & 0xf0);\n  }\n  else {\n    fetchedFrequency = HAL_RCC_GetPCLK1Freq();\n    calculationResult1 = (ulonglong)(uint)((int)fetchedFrequency * 0x19) / (ulonglong)(uint)(inputParams[1] << 2);\n    calculationResult2 = HAL_RCC_GetPCLK1Freq\n                      ((int)fetchedFrequency,(int)((ulonglong)fetchedFrequency >> 0x20),(int)(calculationResult1 * 0x51eb851f));\n    calculationResult3 = inputParams[1];\n    fetchedFrequency = HAL_RCC_GetPCLK1Freq();\n    calculationResult4 = ((uint)(calculationResult2 * 0x19) / (uint)(calculationResult3 << 2) +\n            (int)(((ulonglong)(uint)((int)fetchedFrequency * 0x19) / (ulonglong)(uint)(inputParams[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    calculationResult2 = HAL_RCC_GetPCLK1Freq((int)fetchedFrequency,(int)((ulonglong)fetchedFrequency >> 0x20),calculationResult4 * 0x51eb851f);\n    calculationResult5 = inputParams[1];\n    calculationResult3 = HAL_RCC_GetPCLK1Freq();\n    *(uint *)(*inputParams + 8) =\n         ((((uint)(calculationResult2 * 0x19) / (uint)(calculationResult5 << 2) +\n           (int)(((ulonglong)(uint)(calculationResult3 * 0x19) / (ulonglong)(uint)(inputParams[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(calculationResult1 / 100) * 0x10 + (calculationResult4 / 100 & 0xf0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046ec": "update_clock_frequency_080046ec",
                "param_1": "inputParams",
                "uVar1": "calculationResult1",
                "iVar2": "calculationResult2",
                "iVar3": "calculationResult3",
                "uVar4": "calculationResult4",
                "iVar5": "calculationResult5",
                "uVar6": "fetchedFrequency"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800491c": {
            "entrypoint": "0x0800491c",
            "current_name": "initialize_mpu6050_0800491c",
            "code": "\nvoid initializeMPU6050_0800491c(undefined4 *parameters)\n\n{\n  undefined variable1;\n  undefined variable2;\n  undefined variable3 [5];\n  \n  variable1 = 0;\n  (*DAT_20000a54)(0xd0,0x6b,&variable1,1);\n  variable2 = 0x10;\n  (*DAT_20000a54)(0xd0,0x1c,&variable2,1);\n  variable3[0] = 8;\n  (*DAT_20000a54)(0xd0,0x1b,variable3,1);\n  *parameters = 0;\n  parameters[1] = 0;\n  parameters[2] = 0;\n  parameters[3] = 0;\n  parameters[4] = 0;\n  parameters[5] = 0;\n  parameters[6] = 0;\n  parameters[7] = 0;\n  parameters[8] = 0;\n  parameters[9] = 0;\n  parameters[10] = 0;\n  calibrateMPU(parameters);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800491c": "initialize_mpu6050_0800491c",
                "param_1": "parameters",
                "local_13": "variable1",
                "local_12": "variable2",
                "local_11": "variable3",
                "mpu6050_calibrate": "calibrateMPU"
            },
            "calling": [
                "main"
            ],
            "called": [
                "mpu6050_calibrate"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049cc": {
            "entrypoint": "0x080049cc",
            "current_name": "calculate_average_values_080049cc",
            "code": "\nvoid calculateAverageValues_080049cc(int sensor_data)\n\n{\n  undefined4 uVar1;\n  undefined4 sum_acc_pitch;\n  undefined4 sum_acc_roll;\n  undefined4 current_time;\n  int num_samples;\n  int sample_count;\n  undefined4 avg_acc_roll;\n  undefined4 avg_acc_pitch;\n  undefined4 avg_gyro_y;\n  undefined4 avg_gyro_x;\n  \n  num_samples = 1;\n  avg_gyro_x = 0;\n  avg_gyro_y = 0;\n  avg_acc_pitch = 0;\n  avg_acc_roll = 0;\n  current_time = (*DAT_20000a50)();\n  sample_count = 0;\n  while( true ) {\n    if (num_samples <= sample_count) break;\n    sum_acc_roll = 0;\n    sum_acc_pitch = 0;\n    mpu6050_update(sensor_data);\n    mpu6050_calc_acc_pitch_roll(sensor_data,&sum_acc_roll,&sum_acc_pitch);\n    avg_acc_pitch = __addsf3(avg_acc_pitch,sum_acc_roll);\n    avg_acc_roll = __addsf3(avg_acc_roll,sum_acc_pitch);\n    avg_gyro_x = __addsf3(avg_gyro_x,*(undefined4 *)(sensor_data + 0x10));\n    avg_gyro_y = __addsf3(avg_gyro_y,*(undefined4 *)(sensor_data + 0x14));\n    current_time = (*DAT_20000a50)();\n    sample_count = sample_count + 1;\n  }\n  uVar1 = __floatsisf(num_samples);\n  uVar1 = __aeabi_fdiv(avg_gyro_x,uVar1);\n  *(undefined4 *)(sensor_data + 0x1c) = uVar1;\n  uVar1 = __floatsisf(num_samples);\n  uVar1 = __aeabi_fdiv(avg_gyro_y,uVar1);\n  *(undefined4 *)(sensor_data + 0x20) = uVar1;\n  uVar1 = __floatsisf(num_samples);\n  uVar1 = __aeabi_fdiv(avg_acc_pitch,uVar1);\n  *(undefined4 *)(sensor_data + 0x24) = uVar1;\n  uVar1 = __floatsisf(num_samples);\n  uVar1 = __aeabi_fdiv(avg_acc_roll,uVar1);\n  *(undefined4 *)(sensor_data + 0x28) = uVar1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049cc": "calculate_average_values_080049cc",
                "param_1": "sensor_data",
                "local_2c": "sum_acc_pitch",
                "local_28": "sum_acc_roll",
                "local_24": "current_time",
                "local_20": "num_samples",
                "local_1c": "sample_count",
                "local_18": "avg_acc_roll",
                "local_14": "avg_acc_pitch",
                "local_10": "avg_gyro_y",
                "local_c": "avg_gyro_x"
            },
            "calling": [
                "mpu6050_init"
            ],
            "called": [
                "__aeabi_fdiv",
                "__addsf3",
                "mpu6050_update",
                "mpu6050_calc_acc_pitch_roll",
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ae0": {
            "entrypoint": "0x08004ae0",
            "current_name": "convert_to_floats_08004ae0",
            "code": "\nvoid convertToFloats_08004ae0(undefined4 *outputArray)\n\n{\n  undefined4 uVar1;\n  undefined byte1;\n  undefined byte2;\n  undefined byte3;\n  undefined byte4;\n  undefined byte5;\n  undefined byte6;\n  undefined byte7;\n  undefined byte8;\n  undefined byte9;\n  undefined byte10;\n  undefined byte11;\n  undefined byte12;\n  undefined byte13;\n  undefined byte14;\n  short short1;\n  short short2;\n  short short3;\n  short short4;\n  short short5;\n  short short6;\n  \n  (*DAT_20000a4c)(0xd0,0x3b,&byte1,0xe);\n  short6 = CONCAT11(byte3,byte4);\n  short5 = CONCAT11(byte5,byte6);\n  short4 = CONCAT11(byte7,byte8);\n  short3 = CONCAT11(byte9,byte10);\n  short2 = CONCAT11(byte11,byte12);\n  short1 = CONCAT11(byte13,byte14);\n  uVar1 = __floatsisf((int)CONCAT11(byte1,byte2));\n  *outputArray = uVar1;\n  uVar1 = __floatsisf((int)short6);\n  outputArray[1] = uVar1;\n  uVar1 = __floatsisf((int)short5);\n  outputArray[2] = uVar1;\n  uVar1 = __floatsisf((int)short4);\n  outputArray[3] = uVar1;\n  uVar1 = __floatsisf((int)short3);\n  outputArray[4] = uVar1;\n  uVar1 = __floatsisf((int)short2);\n  outputArray[5] = uVar1;\n  uVar1 = __floatsisf((int)short1);\n  outputArray[6] = uVar1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ae0": "convert_to_floats_08004ae0",
                "param_1": "outputArray",
                "local_2c": "byte1",
                "local_2b": "byte2",
                "local_2a": "byte3",
                "local_29": "byte4",
                "local_28": "byte5",
                "local_27": "byte6",
                "local_26": "byte7",
                "local_25": "byte8",
                "local_24": "byte9",
                "local_23": "byte10",
                "local_22": "byte11",
                "local_21": "byte12",
                "local_20": "byte13",
                "local_1f": "byte14",
                "local_1e": "short1",
                "local_1c": "short2",
                "local_1a": "short3",
                "local_18": "short4",
                "local_16": "short5",
                "local_14": "short6"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calibrate"
            ],
            "called": [
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bd8": {
            "entrypoint": "0x08004bd8",
            "current_name": "calculate_result_08004bd8",
            "code": "\nvoid calculate_result_08004bd8(int input_param,undefined4 *output_param)\n\n{\n  undefined4 difference;\n  undefined8 temp1;\n  undefined8 temp2;\n  \n  difference = __aeabi_fsub(*(undefined4 *)(input_param + 0x10),*(undefined4 *)(input_param + 0x1c));\n  temp1 = __aeabi_f2d(DAT_200009e4);\n  temp2 = __aeabi_f2d(difference);\n  temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x83f5c366,0x3f340215);\n  temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                       (int)((ulonglong)temp2 >> 0x20));\n  DAT_200009e4 = __truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  temp1 = __aeabi_f2d(*(undefined4 *)(input_param + 4));\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40b00000);\n  temp2 = __aeabi_f2d(*(undefined4 *)(input_param + 8));\n  temp2 = __divdf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0,0x40b00000);\n  temp1 = atan2((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40668000);\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x54442d18,0x400921fb);\n  temp2 = __aeabi_f2d(*(undefined4 *)(input_param + 0x24));\n  temp1 = __subdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                   (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40568000);\n  difference = __truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  if (DAT_20000005 == '\\0') {\n    temp1 = __aeabi_f2d(DAT_200009e4);\n    temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x9999999a,0x3fe99999);\n    temp2 = __aeabi_f2d(difference);\n    temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x9999999a,0x3fc99999);\n    temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                         (int)((ulonglong)temp2 >> 0x20));\n    DAT_200009e4 = __truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  }\n  else {\n    DAT_20000005 = '\\0';\n    DAT_200009e4 = difference;\n  }\n  *output_param = DAT_200009e4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bd8": "calculate_result_08004bd8",
                "param_1": "input_param",
                "param_2": "output_param",
                "uVar1": "difference",
                "uVar2": "temp1",
                "uVar3": "temp2"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_fsub",
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "__truncdfsf2",
                "atan2",
                "__subdf3",
                "__aeabi_f2d"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d78": {
            "entrypoint": "0x08004d78",
            "current_name": "calculate_angles_08004d78",
            "code": "\nvoid calculateAngles_08004d78(undefined4 *inputValues,undefined4 *outputAngle1,undefined4 *outputAngle2)\n\n{\n  undefined4 valueDivided1;\n  undefined4 valueDivided2;\n  undefined4 valueDivided3;\n  undefined8 resultAngle1;\n  undefined8 resultAngle2;\n  \n  valueDivided1 = __aeabi_fdiv(*inputValues,0x45800000);\n  valueDivided2 = __aeabi_fdiv(inputValues[1],0x45800000);\n  valueDivided3 = __aeabi_fdiv(inputValues[2],0x45800000);\n  resultAngle1 = __aeabi_f2d(valueDivided2);\n  resultAngle2 = __aeabi_f2d(valueDivided3);\n  resultAngle1 = atan2((int)resultAngle1,(int)((ulonglong)resultAngle1 >> 0x20),(int)resultAngle2,\n                (int)((ulonglong)resultAngle2 >> 0x20));\n  resultAngle1 = __muldf3((int)resultAngle1,(int)((ulonglong)resultAngle1 >> 0x20),0,0x40668000);\n  resultAngle1 = __divdf3((int)resultAngle1,(int)((ulonglong)resultAngle1 >> 0x20),0x54442d18,0x400921fb);\n  valueDivided2 = __truncdfsf2((int)resultAngle1,(int)((ulonglong)resultAngle1 >> 0x20));\n  resultAngle1 = __aeabi_f2d(valueDivided1);\n  resultAngle2 = __aeabi_f2d(valueDivided3);\n  resultAngle1 = atan2((int)resultAngle1,(int)((ulonglong)resultAngle1 >> 0x20),(int)resultAngle2,\n                (int)((ulonglong)resultAngle2 >> 0x20));\n  resultAngle1 = __muldf3((int)resultAngle1,(int)((ulonglong)resultAngle1 >> 0x20),0,0x40668000);\n  resultAngle1 = __divdf3((int)resultAngle1,(int)((ulonglong)resultAngle1 >> 0x20),0x54442d18,0x400921fb);\n  valueDivided1 = __truncdfsf2((int)resultAngle1,(int)((ulonglong)resultAngle1 >> 0x20));\n  *outputAngle1 = valueDivided2;\n  *outputAngle2 = valueDivided1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d78": "calculate_angles_08004d78",
                "param_1": "inputValues",
                "param_2": "outputAngle1",
                "param_3": "outputAngle2",
                "uVar1": "valueDivided1",
                "uVar2": "valueDivided2",
                "uVar3": "valueDivided3",
                "uVar4": "resultAngle1",
                "uVar5": "resultAngle2"
            },
            "calling": [
                "mpu6050_calibrate"
            ],
            "called": [
                "__aeabi_fdiv",
                "__muldf3",
                "__divdf3",
                "__truncdfsf2",
                "atan2",
                "__aeabi_f2d"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e6c": {
            "entrypoint": "0x08004e6c",
            "current_name": "send_system_call_08004e6c",
            "code": "\nvoid send_system_call_08004e6c(void)\n\n{\n  software_interrupt(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e6c": "send_system_call_08004e6c"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "call_function_if_not_zero_08004e74",
            "code": "\nundefined4 callFunctionIfNotZero_08004e74(undefined4 input)\n\n{\n  undefined4 result;\n  \n  if (DAT_200009f0 == 0) {\n    result = aflCall(1,input,0);\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "call_function_if_not_zero_08004e74",
                "param_1": "input",
                "uVar1": "result"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ea4": {
            "entrypoint": "0x08004ea4",
            "current_name": "write_data_to_i2_c_08004ea4",
            "code": "\nvoid writeDataToI2C_08004ea4(undefined deviceAddress,undefined regAddress,undefined4 regAddressSize,undefined2 data)\n\n{\n  HAL_I2C_Mem_Write(&DAT_20000a88,deviceAddress,regAddress,1,regAddressSize,data,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ea4": "write_data_to_i2_c_08004ea4",
                "param_1": "deviceAddress",
                "param_2": "regAddress",
                "param_3": "regAddressSize",
                "param_4": "data"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "read_i2_c_memory_08004ee8",
            "code": "\nvoid readI2CMemory_08004ee8(undefined deviceAddress,undefined memoryAddress,undefined4 dataLength,undefined2 memoryBuffer)\n\n{\n  HAL_I2C_Mem_Read(&DAT_20000a88,deviceAddress,memoryAddress,1,dataLength,memoryBuffer,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "read_i2_c_memory_08004ee8",
                "param_1": "deviceAddress",
                "param_2": "memoryAddress",
                "param_3": "dataLength",
                "param_4": "memoryBuffer"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "get_current_time_08004f2c",
            "code": "\nundefined4 get_current_time_08004f2c(void)\n\n{\n  undefined4 current_time;\n  \n  current_time = HAL_GetTick();\n  return current_time;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "get_current_time_08004f2c",
                "uVar1": "current_time"
            },
            "calling": [],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "transmit_data_08004f3c",
            "code": "\nvoid transmitData_08004f3c(undefined4 dataBuffer,undefined2 length)\n\n{\n  HAL_UART_Transmit(&DAT_20000adc,dataBuffer,length,0x32);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "transmit_data_08004f3c",
                "param_1": "dataBuffer",
                "param_2": "length"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "initialize_memory_08004f60",
            "code": "\nvoid initializeMemory_08004f60(void)\n\n{\n  fillMemory(&DAT_20000ba8,0,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "initialize_memory_08004f60",
                "memset": "fillMemory"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f78": {
            "entrypoint": "0x08004f78",
            "current_name": "update_pitch_and_output_08004f78",
            "code": "\nvoid update_pitch_and_output_08004f78(void)\n\n{\n  undefined4 result;\n  int comparison;\n  undefined4 threshold;\n  uint bitwise_result;\n  undefined8 pitch;\n  byte output;\n  \n  update_mpu6050_data(&DAT_20000a5c);\n  calculate_pitch(&DAT_20000a5c,&DAT_20000ba0);\n  flush_string_buffer();\n  pitch = float_to_double(DAT_20000ba0);\n  format_string(&DAT_20000ba8,\"Pitch: %f\\n\",(int)pitch,(int)((ulonglong)pitch >> 0x20));\n  result = string_length(&DAT_20000ba8);\n  print_uart(&DAT_20000ba8,result);\n  DAT_200009f8 = float_subtraction(DAT_20000014,DAT_20000ba0);\n  DAT_20000be8 = float_multiplication(DAT_20000a00,DAT_200009f8);\n  result = float_multiplication(DAT_20000a04,DAT_200009f8);\n  DAT_20000b5c = float_addition(result,DAT_20000b5c);\n  result = integer_to_float(DAT_20000010);\n  comparison = float_less_than(result,DAT_20000b5c);\n  if (comparison == 0) {\n    result = integer_to_float(DAT_200009f4);\n    comparison = float_greater_than(result,DAT_20000b5c);\n    if (comparison != 0) {\n      DAT_20000b5c = unsigned_integer_to_float(DAT_200009f4);\n    }\n  }\n  else {\n    DAT_20000b5c = unsigned_integer_to_float(DAT_20000010);\n  }\n  bitwise_result = DAT_20000a08 ^ 0x80000000;\n  result = float_subtraction(DAT_200009f8,DAT_200009fc);\n  DAT_20000a58 = float_multiplication(bitwise_result,result);\n  result = float_addition(DAT_20000be8,DAT_20000b5c);\n  result = float_addition(result,DAT_20000a58);\n  threshold = integer_to_float(DAT_20000010);\n  comparison = float_greater_than(result,threshold);\n  if (comparison == 0) {\n    threshold = integer_to_float(DAT_200009f4);\n    comparison = float_less_than(result,threshold);\n    if (comparison == 0) {\n      output = float_to_unsigned_integer(result);\n    }\n    else {\n      output = DAT_200009f4;\n    }\n  }\n  else {\n    output = DAT_20000010;\n  }\n  DAT_200009fc = DAT_200009f8;\n  comparison = float_greater_than(DAT_200009f8,0);\n  write_gpio_pin(0x40010800,2,comparison != 0);\n  comparison = float_greater_than(DAT_200009f8,0);\n  write_gpio_pin(0x40010800,4,comparison == 0);\n  comparison = float_greater_than(DAT_200009f8,0);\n  write_gpio_pin(0x40010800,8,comparison != 0);\n  comparison = float_greater_than(DAT_200009f8,0);\n  write_gpio_pin(0x40010800,0x10,comparison == 0);\n  *(uint *)(DAT_20000b1c + 0x34) = (uint)output;\n  *(uint *)(DAT_20000b1c + 0x40) = (uint)output;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f78": "update_pitch_and_output_08004f78",
                "uVar1": "result",
                "iVar2": "comparison",
                "uVar3": "threshold",
                "uVar4": "bitwise_result",
                "uVar5": "pitch",
                "local_11": "output",
                "mpu6050_update": "update_mpu6050_data",
                "mpu6050_calc_pitch": "calculate_pitch",
                "flush_strbuf": "flush_string_buffer",
                "__aeabi_f2d": "float_to_double",
                "sprintf": "format_string",
                "strlen": "string_length",
                "uart_print": "print_uart",
                "__aeabi_fsub": "float_subtraction",
                "__aeabi_fmul": "float_multiplication",
                "__addsf3": "float_addition",
                "__floatsisf": "integer_to_float",
                "__aeabi_fcmplt": "float_less_than",
                "__floatunsisf": "unsigned_integer_to_float",
                "__aeabi_fcmpgt": "float_greater_than",
                "__fixunssfsi": "float_to_unsigned_integer",
                "HAL_GPIO_WritePin": "write_gpio_pin"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler",
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "__aeabi_fsub",
                "__aeabi_fmul",
                "HAL_GPIO_WritePin",
                "__aeabi_fcmpgt",
                "__floatunsisf",
                "flush_strbuf",
                "mpu6050_calc_pitch",
                "__aeabi_f2d",
                "__fixunssfsi",
                "__aeabi_fcmplt",
                "sprintf",
                "__addsf3",
                "mpu6050_update",
                "strlen",
                "uart_print",
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005224": {
            "entrypoint": "0x08005224",
            "current_name": "initialize_system_08005224",
            "code": "\nvoid initializeSystem_08005224(void)\n\n{\n  initializeHAL();\n  configureSystemClock();\n  initializeGPIO();\n  initializeI2C1();\n  initializeUSART1();\n  initializeTIM2();\n  initializeTIM1();\n  DAT_20000a54 = 0x8004ea5;\n  DAT_20000a4c = 0x8004ee9;\n  DAT_20000a50 = 0x8004f2d;\n  startPWM(&DAT_20000b1c,0);\n  startPWM(&DAT_20000b1c,0xc);\n  initializeMPU6050(&DAT_20000a5c);\n  startTIM_IT(&DAT_20000b60);\n  startForkServer(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005224": "initialize_system_08005224",
                "HAL_Init": "initializeHAL",
                "SystemClock_Config": "configureSystemClock",
                "MX_GPIO_Init": "initializeGPIO",
                "MX_I2C1_Init": "initializeI2C1",
                "MX_USART1_UART_Init": "initializeUSART1",
                "MX_TIM2_Init": "initializeTIM2",
                "MX_TIM1_Init": "initializeTIM1",
                "HAL_TIM_PWM_Start": "startPWM",
                "mpu6050_init": "initializeMPU6050",
                "HAL_TIM_Base_Start_IT": "startTIM_IT",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "startForkserver",
                "MX_USART1_UART_Init",
                "MX_TIM1_Init",
                "MX_GPIO_Init",
                "mpu6050_init",
                "HAL_TIM_Base_Start_IT",
                "MX_I2C1_Init",
                "HAL_Init",
                "HAL_TIM_PWM_Start",
                "MX_TIM2_Init",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052a0": {
            "entrypoint": "0x080052a0",
            "current_name": "configure_rcc_080052a0",
            "code": "\nvoid configureRCC_080052a0(void)\n\n{\n  int result;\n  undefined8 freq;\n  undefined4 sysConfig1;\n  undefined4 sysConfig2;\n  undefined4 sysConfig3;\n  undefined4 sysConfig4;\n  undefined4 sysConfig5;\n  undefined4 oscConfig1;\n  undefined4 oscConfig2;\n  undefined4 oscConfig3;\n  undefined4 oscConfig4;\n  undefined4 oscConfig5;\n  undefined4 oscConfig6;\n  undefined4 oscConfig7;\n  \n  oscConfig1 = 1;\n  oscConfig2 = 0x10000;\n  oscConfig3 = 0;\n  oscConfig4 = 1;\n  oscConfig5 = 2;\n  oscConfig6 = 0x10000;\n  oscConfig7 = 0x1c0000;\n  result = HAL_RCC_OscConfig(&oscConfig1);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",0x151);\n  }\n  sysConfig1 = 0xf;\n  sysConfig2 = 2;\n  sysConfig3 = 0x80;\n  sysConfig4 = 0;\n  sysConfig5 = 0;\n  result = HAL_RCC_ClockConfig(&sysConfig1,2);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",0x15e);\n  }\n  freq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config((uint)freq / 1000,(int)((ulonglong)freq >> 0x20),(uint)freq * 0x10624dd3);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(0xffffffff,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052a0": "configure_rcc_080052a0",
                "local_44": "sysConfig1",
                "local_40": "sysConfig2",
                "local_3c": "sysConfig3",
                "local_38": "sysConfig4",
                "local_34": "sysConfig5",
                "local_30": "oscConfig1",
                "local_2c": "oscConfig2",
                "local_28": "oscConfig3",
                "local_20": "oscConfig4",
                "local_14": "oscConfig5",
                "local_10": "oscConfig6",
                "local_c": "oscConfig7",
                "iVar1": "result",
                "uVar2": "freq"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq",
                "_Error_Handler",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_ClockConfig",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_SYSTICK_Config",
                "HAL_RCC_OscConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005348": {
            "entrypoint": "0x08005348",
            "current_name": "initialize_i2_c_08005348",
            "code": "\nvoid initializeI2C_08005348(void)\n\n{\n  int initResult;\n  \n  DAT_20000a88 = 0x40005400;\n  DAT_20000a8c = 400000;\n  DAT_20000a90 = 0;\n  DAT_20000a94 = 0;\n  DAT_20000a98 = 0x4000;\n  DAT_20000a9c = 0;\n  DAT_20000aa0 = 0;\n  DAT_20000aa4 = 0;\n  DAT_20000aa8 = 0;\n  initResult = HAL_I2C_Init(&DAT_20000a88);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x17a);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005348": "initialize_i2_c_08005348",
                "iVar1": "initResult"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_I2C_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053b0": {
            "entrypoint": "0x080053b0",
            "current_name": "initialize_timer_080053b0",
            "code": "\nvoid initializeTimer_080053b0(void)\n\n{\n  int iVar1;\n  undefined4 prescaler;\n  undefined4 counterMode;\n  undefined4 period;\n  undefined4 clockDivision;\n  undefined4 repetitionCounter;\n  undefined4 deadTime;\n  undefined4 breakState;\n  undefined4 channel;\n  undefined4 polarity;\n  undefined4 signalLevel;\n  undefined4 idleState;\n  undefined4 pulseValue;\n  undefined4 startDelay;\n  undefined4 autoReloadPreload;\n  undefined4 syncOutput;\n  undefined4 syncPolarity;\n  undefined4 config [4];\n  \n  DAT_20000b1c = 0x40012c00;\n  DAT_20000b20 = 0x708;\n  DAT_20000b24 = 0;\n  DAT_20000b28 = 100;\n  DAT_20000b2c = 0;\n  DAT_20000b30 = 0;\n  DAT_20000b34 = 0;\n  iVar1 = HAL_TIM_Base_Init(&DAT_20000b1c);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",399);\n  }\n  config[0] = 0x1000;\n  iVar1 = HAL_TIM_ConfigClockSource(&DAT_20000b1c,config);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x194);\n  }\n  iVar1 = HAL_TIM_PWM_Init(&DAT_20000b1c);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x198);\n  }\n  syncOutput = 0;\n  syncPolarity = 0;\n  iVar1 = HAL_TIMEx_MasterConfigSynchronization(&DAT_20000b1c,&syncOutput);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x19f);\n  }\n  channel = 0x60;\n  polarity = 0;\n  signalLevel = 0;\n  idleState = 0;\n  pulseValue = 0;\n  startDelay = 0;\n  autoReloadPreload = 0;\n  iVar1 = HAL_TIM_PWM_ConfigChannel(&DAT_20000b1c,&channel,0);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x1ab);\n  }\n  iVar1 = HAL_TIM_PWM_ConfigChannel(&DAT_20000b1c,&channel,0xc);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x1b0);\n  }\n  prescaler = 0;\n  counterMode = 0;\n  period = 0;\n  clockDivision = 0;\n  repetitionCounter = 0;\n  deadTime = 0x2000;\n  breakState = 0;\n  iVar1 = HAL_TIMEx_ConfigBreakDeadTime(&DAT_20000b1c,&prescaler);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x1bc);\n  }\n  HAL_TIM_MspPostInit(&DAT_20000b1c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053b0": "initialize_timer_080053b0",
                "local_58": "prescaler",
                "local_54": "counterMode",
                "local_50": "period",
                "local_4c": "clockDivision",
                "local_48": "repetitionCounter",
                "local_44": "deadTime",
                "local_40": "breakState",
                "local_3c": "channel",
                "local_38": "polarity",
                "local_34": "signalLevel",
                "local_30": "idleState",
                "local_2c": "pulseValue",
                "local_28": "startDelay",
                "local_24": "autoReloadPreload",
                "local_20": "syncOutput",
                "local_1c": "syncPolarity",
                "local_18": "config"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_ConfigClockSource",
                "_Error_Handler",
                "HAL_TIM_Base_Init",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_MspPostInit",
                "HAL_TIMEx_MasterConfigSynchronization"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005500": {
            "entrypoint": "0x08005500",
            "current_name": "initialize_timer_08005500",
            "code": "\nvoid initializeTimer_08005500(void)\n\n{\n  int initStatus;\n  undefined4 prescaler;\n  undefined4 counterMode;\n  undefined4 clockSource [4];\n  \n  DAT_20000b60 = 0x40000000;\n  DAT_20000b64 = 36000;\n  DAT_20000b68 = 0;\n  DAT_20000b6c = 0x14;\n  DAT_20000b70 = 0;\n  DAT_20000b78 = 0;\n  initStatus = HAL_TIM_Base_Init(&DAT_20000b60);\n  if (initStatus != 0) {\n    _Error_Handler(\"../src/main.c\",0x1d0);\n  }\n  clockSource[0] = 0x1000;\n  initStatus = HAL_TIM_ConfigClockSource(&DAT_20000b60,clockSource);\n  if (initStatus != 0) {\n    _Error_Handler(\"../src/main.c\",0x1d5);\n  }\n  prescaler = 0x20;\n  counterMode = 0;\n  initStatus = HAL_TIMEx_MasterConfigSynchronization(&DAT_20000b60,&prescaler);\n  if (initStatus != 0) {\n    _Error_Handler(\"../src/main.c\",0x1dc);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005500": "initialize_timer_08005500",
                "local_20": "prescaler",
                "local_1c": "counterMode",
                "local_18": "clockSource",
                "iVar1": "initStatus"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIM_ConfigClockSource",
                "_Error_Handler",
                "HAL_TIM_Base_Init",
                "HAL_TIMEx_MasterConfigSynchronization"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005598": {
            "entrypoint": "0x08005598",
            "current_name": "initialize_uart_08005598",
            "code": "\nvoid initializeUART_08005598(void)\n\n{\n  int initResult;\n  \n  DAT_20000adc = 0x40013800;\n  DAT_20000ae0 = 0x1c200;\n  DAT_20000ae4 = 0;\n  DAT_20000ae8 = 0;\n  DAT_20000aec = 0;\n  DAT_20000af0 = 0xc;\n  DAT_20000af4 = 0;\n  DAT_20000af8 = 0;\n  initResult = HAL_UART_Init(&DAT_20000adc);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x1ed);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005598": "initialize_uart_08005598",
                "iVar1": "initResult"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_UART_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055f4": {
            "entrypoint": "0x080055f4",
            "current_name": "initialize_gpio_080055f4",
            "code": "\n\n\nvoid initializeGPIO_080055f4(void)\n\n{\n  undefined4 pinMode;\n  undefined4 pinState;\n  undefined4 pinNumber;\n  \n  _DAT_40021018 = _DAT_40021018 | 0x2c;\n  HAL_GPIO_WritePin(0x40010800,0x1e,0,_DAT_40021018 & 8);\n  pinMode = 0x1e;\n  pinState = 1;\n  pinNumber = 2;\n  HAL_GPIO_Init(0x40010800,&pinMode);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055f4": "initialize_gpio_080055f4",
                "local_18": "pinMode",
                "local_14": "pinState",
                "local_c": "pinNumber"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_GPIO_Init",
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005674": {
            "entrypoint": "0x08005674",
            "current_name": "infinite_loop_08005674",
            "code": "\nvoid infiniteLoop_08005674(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005674": "infinite_loop_08005674"
            },
            "calling": [
                "MX_USART1_UART_Init",
                "MX_TIM1_Init",
                "MX_I2C1_Init",
                "SystemClock_Config",
                "MX_TIM2_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005680": {
            "entrypoint": "0x08005680",
            "current_name": "initialize_gpio_08005680",
            "code": "\nvoid initializeGPIO_08005680(int *gpioAddress)\n\n{\n  undefined4 gpioConfig;\n  undefined4 mode;\n  undefined4 pull;\n  \n  if (*gpioAddress == 0x40012c00) {\n    gpioConfig = 0x900;\n    mode = 2;\n    pull = 2;\n    configureGPIO(0x40010800,&gpioConfig);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005680": "initialize_gpio_08005680",
                "param_1": "gpioAddress",
                "local_18": "gpioConfig",
                "local_14": "mode",
                "local_c": "pull",
                "HAL_GPIO_Init": "configureGPIO"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005704": {
            "entrypoint": "0x08005704",
            "current_name": "update_system_tick_08005704",
            "code": "\nvoid updateSystemTick_08005704(void)\n\n{\n  incrementTick();\n  handleSysTickInterrupt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005704": "update_system_tick_08005704",
                "HAL_IncTick": "incrementTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "handle_tim_irq_08005714",
            "code": "\nvoid handle_TIM_irq_08005714(void)\n\n{\n  HAL_TIM_IRQHandler(&DAT_20000b60);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005714": "handle_tim_irq_08005714"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "allocate_memory_08005728",
            "code": "\nundefined * allocate_memory_08005728(int size)\n\n{\n  undefined4 *error_code_ptr;\n  undefined *allocated_memory_ptr;\n  undefined error_buffer [4];\n  int remaining_size;\n  undefined *current_memory_ptr;\n  \n  if (DAT_20000a10 == (undefined *)0x0) {\n    DAT_20000a10 = &DAT_20000c18;\n  }\n  current_memory_ptr = DAT_20000a10;\n  if (error_buffer < DAT_20000a10 + size) {\n    remaining_size = size;\n    error_code_ptr = (undefined4 *)__errno();\n    *error_code_ptr = 0xc;\n    allocated_memory_ptr = (undefined *)0xffffffff;\n  }\n  else {\n    allocated_memory_ptr = DAT_20000a10;\n    DAT_20000a10 = DAT_20000a10 + size;\n  }\n  return allocated_memory_ptr;\n}\n\n",
            "renaming": {
                "FUN_08005728": "allocate_memory_08005728",
                "param_1": "size",
                "puVar1": "error_code_ptr",
                "puVar2": "allocated_memory_ptr",
                "auStack_18": "error_buffer",
                "local_14": "remaining_size",
                "local_c": "current_memory_ptr"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [
                "__errno"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005780": {
            "entrypoint": "0x08005780",
            "current_name": "initialize_peripherals_08005780",
            "code": "\n\n\nvoid initializePeripherals_08005780(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005780": "initialize_peripherals_08005780"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057e8": {
            "entrypoint": "0x080057e8",
            "current_name": "initialize_memory_080057e8",
            "code": "\nvoid initializeMemory_080057e8(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  code *functionPointer;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &DAT_200009c8; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(index + 0x800a1a4);\n  }\n  for (pointer = &DAT_200009c8; pointer < &DAT_20000c14; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  functionPointer = (code *)0x800581a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*functionPointer)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057e8": "initialize_memory_080057e8",
                "iVar1": "index",
                "puVar2": "pointer",
                "UNRECOVERED_JUMPTABLE": "functionPointer"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005834": {
            "entrypoint": "0x08005834",
            "current_name": "FUN_08005834",
            "code": "\nuint __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  undefined8 uVar6;\n  \n  uVar4 = param_4 & 0x7fffffff;\n  if ((0x7ff00000 < (uVar4 | (-param_3 | param_3) >> 0x1f)) ||\n     (uVar5 = param_2 & 0x7fffffff, 0x7ff00000 < (uVar5 | (-param_1 | param_1) >> 0x1f))) {\n    uVar4 = __aeabi_dadd(param_3,param_4,param_1,param_2);\n    return uVar4;\n  }\n  if ((param_4 + 0xc0100000 | param_3) == 0) {\n    uVar4 = atan();\n    return uVar4;\n  }\n  uVar3 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n  if ((uVar5 | param_1) == 0) {\n    if (uVar3 == 2) {\n      return 0x54442d18;\n    }\n    if (uVar3 != 3) {\n      return param_1;\n    }\n  }\n  else if ((uVar4 | param_3) != 0) {\n    if (uVar4 == 0x7ff00000) {\n      if (uVar5 == 0x7ff00000) {\n        if (uVar3 == 2) {\n          return 0x7f3321d2;\n        }\n        if (uVar3 == 3) {\n          return 0x7f3321d2;\n        }\n        if (uVar3 == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (uVar3 == 2) {\n        return 0x54442d18;\n      }\n      if (uVar3 != 3) {\n        if (uVar3 != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (uVar5 != 0x7ff00000) {\n      iVar1 = (int)(uVar5 - uVar4) >> 0x14;\n      if (iVar1 < 0x3d) {\n        if (((int)param_4 < 0) && (iVar1 + 0x3c < 0 != SCARRY4(iVar1,0x3c))) {\n          uVar6 = 0;\n        }\n        else {\n          __divdf3(param_1,param_2,param_3,param_4,param_4);\n          fabs();\n          uVar6 = atan();\n        }\n      }\n      else {\n        uVar6 = 0x3ff921fb54442d18;\n      }\n      uVar2 = (undefined4)((ulonglong)uVar6 >> 0x20);\n      uVar4 = (uint)uVar6;\n      if (uVar3 == 1) {\n        return uVar4;\n      }\n      if (uVar3 == 2) {\n        uVar6 = __subdf3(uVar4,uVar2,0x33145c07,0x3ca1a626);\n        uVar4 = __subdf3(0x54442d18,0x400921fb,(int)uVar6,(int)((ulonglong)uVar6 >> 0x20));\n        return uVar4;\n      }\n      if (uVar3 != 0) {\n        uVar6 = __subdf3(uVar4,uVar2,0x33145c07,0x3ca1a626);\n        uVar4 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),0x54442d18,0x400921fb);\n        return uVar4;\n      }\n      return uVar4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {},
            "calling": [
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005838": {
            "entrypoint": "0x08005838",
            "current_name": "calculate_result_08005838",
            "code": "\nuint calculateResult_08005838(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int tempVar1;\n  undefined4 tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  undefined8 tempVar6;\n  \n  tempVar4 = input4 & 0x7fffffff;\n  if ((0x7ff00000 < (tempVar4 | (-input3 | input3) >> 0x1f)) ||\n     (tempVar5 = input2 & 0x7fffffff, 0x7ff00000 < (tempVar5 | (-input1 | input1) >> 0x1f))) {\n    tempVar4 = __aeabi_dadd(input3,input4,input1,input2);\n    return tempVar4;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    tempVar4 = atan();\n    return tempVar4;\n  }\n  tempVar3 = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((tempVar5 | input1) == 0) {\n    if (tempVar3 == 2) {\n      return 0x54442d18;\n    }\n    if (tempVar3 != 3) {\n      return input1;\n    }\n  }\n  else if ((tempVar4 | input3) != 0) {\n    if (tempVar4 == 0x7ff00000) {\n      if (tempVar5 == 0x7ff00000) {\n        if (tempVar3 == 2) {\n          return 0x7f3321d2;\n        }\n        if (tempVar3 == 3) {\n          return 0x7f3321d2;\n        }\n        if (tempVar3 == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (tempVar3 == 2) {\n        return 0x54442d18;\n      }\n      if (tempVar3 != 3) {\n        if (tempVar3 != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (tempVar5 != 0x7ff00000) {\n      tempVar1 = (int)(tempVar5 - tempVar4) >> 0x14;\n      if (tempVar1 < 0x3d) {\n        if (((int)input4 < 0) && (tempVar1 + 0x3c < 0 != SCARRY4(tempVar1,0x3c))) {\n          tempVar6 = 0;\n        }\n        else {\n          __divdf3(input1,input2,input3,input4,input4);\n          fabs();\n          tempVar6 = atan();\n        }\n      }\n      else {\n        tempVar6 = 0x3ff921fb54442d18;\n      }\n      tempVar2 = (undefined4)((ulonglong)tempVar6 >> 0x20);\n      tempVar4 = (uint)tempVar6;\n      if (tempVar3 == 1) {\n        return tempVar4;\n      }\n      if (tempVar3 == 2) {\n        tempVar6 = __subdf3(tempVar4,tempVar2,0x33145c07,0x3ca1a626);\n        tempVar4 = __subdf3(0x54442d18,0x400921fb,(int)tempVar6,(int)((ulonglong)tempVar6 >> 0x20));\n        return tempVar4;\n      }\n      if (tempVar3 != 0) {\n        tempVar6 = __subdf3(tempVar4,tempVar2,0x33145c07,0x3ca1a626);\n        tempVar4 = __subdf3((int)tempVar6,(int)((ulonglong)tempVar6 >> 0x20),0x54442d18,0x400921fb);\n        return tempVar4;\n      }\n      return tempVar4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "FUN_08005838": "calculate_result_08005838",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "uVar6": "tempVar6"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "__aeabi_dadd",
                "atan",
                "__divdf3",
                "fabs",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f0": {
            "entrypoint": "0x080059f0",
            "current_name": "calculate_value_080059f0",
            "code": "\nundefined8 calculateValue_080059f0(int input1,uint input2,undefined4 unused1,undefined4 unused2)\n\n{\n  undefined4 result1;\n  undefined4 result2;\n  undefined4 result3;\n  undefined4 result4;\n  undefined4 result5;\n  undefined4 result6;\n  uint absInput2;\n  int branchVar;\n  undefined8 intermediateResult;\n  undefined8 finalResult;\n  \n  finalResult = CONCAT44(input2,input1);\n  absInput2 = input2 & 0x7fffffff;\n  if (absInput2 < 0x44100000) {\n    if (absInput2 < 0x3fdc0000) {\n      if (absInput2 < 0x3e200000) {\n        intermediateResult = __aeabi_dadd(input1,input2,0x8800759c,0x7e37e43c,unused2);\n        branchVar = __aeabi_dcmpgt((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),0,0x3ff00000);\n        if (branchVar != 0) {\n          return CONCAT44(input2,input1);\n        }\n      }\n      branchVar = -1;\n    }\n    else {\n      finalResult = fabs();\n      result4 = (undefined4)((ulonglong)finalResult >> 0x20);\n      result1 = (undefined4)finalResult;\n      if (absInput2 < 0x3ff30000) {\n        if (absInput2 < 0x3fe60000) {\n          finalResult = __aeabi_dadd(result1,result4,result1,result4);\n          finalResult = __subdf3((int)finalResult,(int)((ulonglong)finalResult >> 0x20),0,0x3ff00000);\n          intermediateResult = __aeabi_dadd(result1,result4,0,0x40000000);\n          finalResult = __divdf3((int)finalResult,(int)((ulonglong)finalResult >> 0x20),(int)intermediateResult,\n                            (int)((ulonglong)intermediateResult >> 0x20));\n          branchVar = 0;\n        }\n        else {\n          finalResult = __subdf3(result1,result4,0,0x3ff00000);\n          intermediateResult = __aeabi_dadd(result1,result4,0,0x3ff00000);\n          finalResult = __divdf3((int)finalResult,(int)((ulonglong)finalResult >> 0x20),(int)intermediateResult,\n                            (int)((ulonglong)intermediateResult >> 0x20));\n          branchVar = 1;\n        }\n      }\n      else if (absInput2 < 0x40038000) {\n        finalResult = __subdf3(result1,result4,0,0x3ff80000);\n        intermediateResult = __muldf3(result1,result4,0,0x3ff80000);\n        intermediateResult = __aeabi_dadd((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),0,0x3ff00000);\n        finalResult = __divdf3((int)finalResult,(int)((ulonglong)finalResult >> 0x20),(int)intermediateResult,\n                          (int)((ulonglong)intermediateResult >> 0x20));\n        branchVar = 2;\n      }\n      else {\n        finalResult = __divdf3(0,0xbff00000,result1,result4);\n        branchVar = 3;\n      }\n    }\n    result6 = (undefined4)((ulonglong)finalResult >> 0x20);\n    result5 = (undefined4)finalResult;\n    finalResult = __muldf3(result5,result6,result5,result6);\n    result2 = (undefined4)((ulonglong)finalResult >> 0x20);\n    result1 = (undefined4)finalResult;\n    finalResult = __muldf3(result1,result2,result1,result2);\n    result3 = (undefined4)((ulonglong)finalResult >> 0x20);\n    result4 = (undefined4)finalResult;\n    finalResult = __muldf3(result4,result3,0xe322da11,0x3f90ad3a);\n    finalResult = __aeabi_dadd((int)finalResult,(int)((ulonglong)finalResult >> 0x20),0x24760deb,0x3fa97b4b);\n    finalResult = __muldf3((int)finalResult,(int)((ulonglong)finalResult >> 0x20),result4,result3);\n    finalResult = __aeabi_dadd((int)finalResult,(int)((ulonglong)finalResult >> 0x20),0xa0d03d51,0x3fb10d66);\n    finalResult = __muldf3((int)finalResult,(int)((ulonglong)finalResult >> 0x20),result4,result3);\n    finalResult = __aeabi_dadd((int)finalResult,(int)((ulonglong)finalResult >> 0x20),0xc54c206e,0x3fb745cd);\n    finalResult = __muldf3((int)finalResult,(int)((ulonglong)finalResult >> 0x20),result4,result3);\n    finalResult = __aeabi_dadd((int)finalResult,(int)((ulonglong)finalResult >> 0x20),0x920083ff,0x3fc24924);\n    finalResult = __muldf3((int)finalResult,(int)((ulonglong)finalResult >> 0x20),result4,result3);\n    finalResult = __aeabi_dadd((int)finalResult,(int)((ulonglong)finalResult >> 0x20),0x5555550d,0x3fd55555);\n    finalResult = __muldf3((int)finalResult,(int)((ulonglong)finalResult >> 0x20),result1,result2);\n    intermediateResult = __muldf3(result4,result3,0x2c6a6c2f,0xbfa2b444);\n    intermediateResult = __subdf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),0x52defd9a,0x3fadde2d);\n    intermediateResult = __muldf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),result4,result3);\n    intermediateResult = __subdf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    intermediateResult = __muldf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),result4,result3);\n    intermediateResult = __subdf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),0xfe231671,0x3fbc71c6);\n    intermediateResult = __muldf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),result4,result3);\n    intermediateResult = __subdf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),0x9998ebc4,0x3fc99999);\n    intermediateResult = __muldf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),result4,result3);\n    finalResult = __aeabi_dadd((int)finalResult,(int)((ulonglong)finalResult >> 0x20),(int)intermediateResult,\n                          (int)((ulonglong)intermediateResult >> 0x20));\n    finalResult = __muldf3((int)finalResult,(int)((ulonglong)finalResult >> 0x20),result5,result6);\n    result1 = (undefined4)((ulonglong)finalResult >> 0x20);\n    if (branchVar == -1) {\n      finalResult = __subdf3(result5,result6,(int)finalResult,result1);\n      return finalResult;\n    }\n    branchVar = branchVar * 8;\n    finalResult = __subdf3((int)finalResult,result1,*(undefined4 *)(&UNK_08009ee8 + branchVar),\n                      *(undefined4 *)(&UNK_08009eec + branchVar));\n    finalResult = __subdf3((int)finalResult,(int)((ulonglong)finalResult >> 0x20),result5,result6);\n    finalResult = __subdf3(*(undefined4 *)(&UNK_08009ec8 + branchVar),*(undefined4 *)(&UNK_08009ecc + branchVar),\n                      (int)finalResult,(int)((ulonglong)finalResult >> 0x20));\n    if ((int)input2 < 0) {\n      return CONCAT44((int)((ulonglong)finalResult >> 0x20) + -0x80000000,(int)finalResult);\n    }\n  }\n  else {\n    if ((absInput2 < 0x7ff00001) && ((absInput2 != 0x7ff00000 || (input1 == 0)))) {\n      result1 = 0xbff921fb;\n      if (0 < (int)input2) {\n        result1 = 0x3ff921fb;\n      }\n      return CONCAT44(result1,0x54442d18);\n    }\n    finalResult = __aeabi_dadd(input1,input2,input1,input2,unused2);\n  }\n  return finalResult;\n}\n\n",
            "renaming": {
                "FUN_080059f0": "calculate_value_080059f0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "unused1",
                "param_4": "unused2",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "result3",
                "uVar4": "result4",
                "uVar5": "result5",
                "uVar6": "result6",
                "uVar7": "absInput2",
                "iVar8": "branchVar",
                "uVar9": "intermediateResult",
                "uVar10": "finalResult"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "fabs",
                "__subdf3",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d0c": {
            "entrypoint": "0x08005d0c",
            "current_name": "FUNC_08005d0c",
            "code": "\nvoid FUNC_08005d0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d0c": "FUNC_08005d0c"
            },
            "calling": [
                "atan",
                "__ieee754_atan2"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005d14": {
            "entrypoint": "0x08005d14",
            "current_name": "get_configuration_value_08005d14",
            "code": "\nundefined4 get_configuration_value_08005d14(void)\n\n{\n  return DAT_2000001c;\n}\n\n",
            "renaming": {
                "FUN_08005d14": "get_configuration_value_08005d14"
            },
            "calling": [
                "_sbrk"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d20": {
            "entrypoint": "0x08005d20",
            "current_name": "execute_initialization_08005d20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005d2c) */\n/* WARNING: Removing unreachable block (ram,0x08005d2e) */\n\nvoid executeInitialization_08005d20(void)\n\n{\n  int iterationCount;\n  code **functionPointer;\n  \n  _init();\n  iterationCount = 0;\n  functionPointer = (code **)&DAT_0800a198;\n  do {\n    iterationCount = iterationCount + 1;\n    (**functionPointer)();\n    functionPointer = functionPointer + 1;\n  } while (iterationCount != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d20": "execute_initialization_08005d20",
                "iVar1": "iterationCount",
                "ppcVar2": "functionPointer"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "register_fini",
                "frame_dummy",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d68": {
            "entrypoint": "0x08005d68",
            "current_name": "memset_08005d68",
            "code": "\nvoid memset_08005d68(undefined4 *dest,undefined value,uint size)\n\n{\n  undefined4 *dest_ptr;\n  undefined4 *next_dest_ptr;\n  uint remaining_size;\n  undefined4 merged_value;\n  bool is_zero;\n  \n  if (((uint)dest & 3) != 0) {\n    remaining_size = size - 1;\n    dest_ptr = dest;\n    if (size == 0) {\n      return;\n    }\n    while( true ) {\n      dest = (undefined4 *)((int)dest_ptr + 1);\n      *(undefined *)dest_ptr = value;\n      size = remaining_size;\n      if (((uint)dest & 3) == 0) break;\n      is_zero = remaining_size == 0;\n      remaining_size = remaining_size - 1;\n      dest_ptr = dest;\n      if (is_zero) {\n        return;\n      }\n    }\n  }\n  if (3 < size) {\n    merged_value = CONCAT22(CONCAT11(value,value),CONCAT11(value,value));\n    remaining_size = size;\n    dest_ptr = dest;\n    if (0xf < size) {\n      remaining_size = size - 0x10;\n      dest_ptr = dest + 4;\n      do {\n        dest_ptr[-4] = merged_value;\n        dest_ptr[-3] = merged_value;\n        dest_ptr[-2] = merged_value;\n        dest_ptr[-1] = merged_value;\n        dest_ptr = dest_ptr + 4;\n      } while (dest_ptr != (undefined4 *)((int)dest + (remaining_size & 0xfffffff0) + 0x20));\n      size = size & 0xf;\n      dest = dest + ((remaining_size >> 4) + 1) * 4;\n      remaining_size = size;\n      dest_ptr = dest;\n      if (size < 4) goto end_of_loop;\n    }\n    do {\n      size = size - 4;\n      *dest = merged_value;\n      dest = dest + 1;\n    } while (3 < size);\n    dest = (undefined4 *)((int)dest_ptr + (remaining_size - 4 & 0xfffffffc) + 4);\n    size = remaining_size & 3;\n  }\nend_of_loop:\n  if (size != 0) {\n    dest_ptr = dest;\n    do {\n      next_dest_ptr = (undefined4 *)((int)dest_ptr + 1);\n      *(undefined *)dest_ptr = value;\n      dest_ptr = next_dest_ptr;\n    } while ((undefined4 *)(size + (int)dest) != next_dest_ptr);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d68": "memset_08005d68",
                "param_1": "dest",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "dest_ptr",
                "puVar2": "next_dest_ptr",
                "uVar3": "remaining_size",
                "uVar4": "merged_value",
                "bVar5": "is_zero",
                "LAB_08005de4": "end_of_loop"
            },
            "calling": [
                "_calloc_r",
                "flush_strbuf"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dfc": {
            "entrypoint": "0x08005dfc",
            "current_name": "print_formatted_output_08005dfc",
            "code": "\nvoid printFormattedOutput_08005dfc(undefined *outputBuffer,undefined4 formatString,undefined4 arg1,undefined4 arg2)\n\n{\n  undefined *formatArgs [2];\n  undefined4 var1;\n  undefined4 var2;\n  undefined *currentOutput;\n  undefined4 maxOutputSize;\n  undefined4 var3;\n  undefined4 var4;\n  \n  maxOutputSize = 0x7fffffff;\n  var1 = 0x7fffffff;\n  var2 = 0xffff0208;\n  formatArgs[0] = outputBuffer;\n  currentOutput = outputBuffer;\n  var3 = arg1;\n  var4 = arg2;\n  _svfprintf_r(DAT_2000001c,formatArgs,formatString,&var3);\n  *formatArgs[0] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005dfc": "print_formatted_output_08005dfc",
                "param_1": "outputBuffer",
                "param_2": "formatString",
                "param_3": "arg1",
                "param_4": "arg2",
                "local_80": "formatArgs",
                "local_78": "var1",
                "uStack_74": "var2",
                "local_70": "currentOutput",
                "local_6c": "maxOutputSize",
                "uStack_8": "var3",
                "uStack_4": "var4"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "_svfprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e40": {
            "entrypoint": "0x08005e40",
            "current_name": "calculate_lz_count_08005e40",
            "code": "\nint calculateLZCount_08005e40(uint input)\n\n{\n  int alignmentOffset;\n  uint *ptr;\n  uint data;\n  \n  ptr = (uint *)(input & 0xfffffffc);\n  alignmentOffset = -(input & 3);\n  data = *ptr;\n  if ((input & 3) != 0) {\n    data = data | 0xffffffffU >> ((alignmentOffset + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    ptr = ptr + 1;\n    data = data + 0xfefefeff & ~data & 0x80808080;\n    if (data != 0) break;\n    data = *ptr;\n    alignmentOffset = alignmentOffset + 4;\n  }\n  return alignmentOffset + (0x1fU - leadingZeroCount(data & -data) >> 3);\n}\n\n",
            "renaming": {
                "FUN_08005e40": "calculate_lz_count_08005e40",
                "param_1": "input",
                "iVar1": "alignmentOffset",
                "puVar2": "ptr",
                "uVar3": "data",
                "LZCOUNT": "leadingZeroCount"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e9c": {
            "entrypoint": "0x08005e9c",
            "current_name": "FUNC_08005e9c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  int iVar8;\n  int *piVar9;\n  undefined4 uVar10;\n  int **ppiVar11;\n  undefined uVar12;\n  ushort uVar13;\n  int **ppiVar14;\n  byte **ppbVar15;\n  int *piVar16;\n  int **ppiVar17;\n  char *pcVar18;\n  uint uVar19;\n  undefined *puVar20;\n  int *piVar21;\n  int *piVar22;\n  int *piVar23;\n  int *piVar24;\n  int *piVar25;\n  byte *pbVar26;\n  int *piVar27;\n  int *piVar28;\n  undefined4 *puVar29;\n  byte *pbVar30;\n  bool bVar31;\n  longlong lVar32;\n  undefined8 uVar33;\n  undefined8 uVar34;\n  undefined4 local_188;\n  int *piStack_184;\n  int **local_180;\n  undefined *puStack_17c;\n  int **local_178;\n  undefined4 *local_16c;\n  int *local_168;\n  byte *local_164;\n  int *local_160;\n  int *local_15c;\n  char *local_158;\n  int **local_154;\n  undefined8 local_150;\n  int *local_148;\n  int *local_144;\n  int *local_140;\n  int **local_13c;\n  int *local_138;\n  int *local_134;\n  int *local_130;\n  uint local_12c;\n  undefined4 local_128;\n  undefined4 local_124;\n  undefined4 local_120;\n  char *local_11c;\n  int *local_118;\n  int *local_114;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  int *local_100;\n  int *local_fc;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0;\n  undefined auStack_ec [4];\n  char local_e8;\n  undefined local_e7;\n  char local_e6 [6];\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int *local_d4;\n  int *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  local_16c = param_1;\n  local_160 = param_2;\n  local_154 = param_4;\n  ppiVar2 = (int **)_localeconv_r();\n  local_114 = *ppiVar2;\n  local_118 = (int *)strlen(local_114);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar3 = _malloc_r(local_16c,0x40);\n    *local_160 = iVar3;\n    local_160[4] = iVar3;\n    if (iVar3 == 0) {\n      *local_16c = 0xc;\n      return (byte *)0xffffffff;\n    }\n    local_160[5] = 0x40;\n  }\n  local_128 = 0;\n  local_138 = (int *)0x0;\n  local_12c = 0;\n  local_d4 = (int *)0x0;\n  local_d0 = (int *)0x0;\n  local_11c = (char *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  local_124 = 0;\n  local_120 = 0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = local_164 + (int)piVar27;\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    piVar25 = (int *)0x0;\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    puVar29 = local_16c;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    switch(piVar24) {\n    case (int *)0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (piVar24 == (int *)0x0) goto LAB_08006216;\n      piVar16 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_158 = (char *)0x1;\n      piVar23 = (int *)&local_8c;\n      piVar22 = piVar16;\n      local_8c = (char)piVar24;\n      goto LAB_08006298;\n    case (int *)0x23:\n      piVar25 = (int *)((uint)piVar25 | 1);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x27:\n      iVar3 = _localeconv_r(local_16c);\n      local_110 = *(int **)(iVar3 + 4);\n      piVar24 = (int *)strlen(local_110);\n      local_104 = piVar24;\n      iVar3 = _localeconv_r(puVar29);\n      local_108 = *(byte **)(iVar3 + 8);\n      if (piVar24 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 0x400);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2a:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2b:\n      local_f5 = 0x2b;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x2d:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\nLAB_08006602:\n      piVar25 = (int *)((uint)piVar25 | 4);\n      goto LAB_08005f4a;\n    case (int *)0x2e:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x2a) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (piVar24 + -0xc < (int *)0xa) {\n        piVar27 = (int *)((int)(piVar24 + -0xc) + (int)piVar27 * 10);\n        piVar24 = (int *)(uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case (int *)0x30:\n      piVar25 = (int *)((uint)piVar25 | 0x80);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x31:\n    case (int *)0x32:\n    case (int *)0x33:\n    case (int *)0x34:\n    case (int *)0x35:\n    case (int *)0x36:\n    case (int *)0x37:\n    case (int *)0x38:\n    case (int *)0x39:\n      goto switchD_08005f58_caseD_31;\n    case (int *)0x41:\n    case (int *)0x45:\n    case (int *)0x46:\n    case (int *)0x47:\n    case (int *)0x61:\n    case (int *)0x65:\n    case (int *)0x66:\n    case (int *)0x67:\n      puVar29 = (undefined4 *)((int)local_154 + 7U & 0xfffffff8);\n      uVar10 = *puVar29;\n      local_12c = puVar29[1];\n      local_168 = (int *)(local_12c & 0x7fffffff);\n      local_154 = (int **)(puVar29 + 2);\n      local_128 = uVar10;\n      iVar3 = __unorddf2(uVar10,local_168,0xffffffff,0x7fefffff);\n      if ((iVar3 == 0) &&\n         (iVar3 = __aeabi_dcmple(uVar10,local_168,0xffffffff,0x7fefffff), iVar3 == 0)) {\n        iVar3 = __aeabi_dcmplt(local_128,local_12c,local_124,local_120);\n        if (iVar3 == 0) {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        piVar23 = (int *)&UNK_08009f10;\n        piVar27 = (int *)&UNK_08009f0c;\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (piVar24 < (int *)0x48) {\n          piVar23 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar25 = (int *)((uint)piVar25 & 0xffffff7f);\n        local_158 = (char *)0x3;\n        local_13c = (int **)0x0;\n        piVar22 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      iVar3 = __unorddf2(local_128,local_12c,local_128,local_12c);\n      if (iVar3 != 0) {\n        if ((int)local_12c < 0) {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        piVar23 = (int *)&UNK_08009f18;\n        piVar27 = (int *)&UNK_08009f14;\n        goto LAB_08006524;\n      }\n      if (piVar24 == (int *)0x61) {\n        uVar12 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar12,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          piVar25 = (int *)((uint)piVar25 | 2);\n        }\n        else {\n          param_3 = (int *)_malloc_r(local_16c,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar13 = *(ushort *)(local_160 + 3) | 0x40;\n            *(ushort *)(local_160 + 3) = uVar13;\n            goto LAB_0800604e;\n          }\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          piVar25 = (int *)((uint)piVar25 | 2);\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = (int *)0x2d;\n          uVar19 = local_12c + 0x80000000;\n        }\n        else {\n          local_144 = (int *)0x0;\n          uVar19 = local_12c;\n        }\n        local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n        piVar22 = piVar27;\n        local_158 = (char *)local_128;\n        if (piVar24 == (int *)0x61) {\n          uVar33 = frexp(local_128,uVar19,&local_f0);\n          local_150 = __muldf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = __aeabi_dcmpeq((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                                 local_120);\n          if (iVar3 != 0) {\n            local_f0 = (int *)0x1;\n          }\n          local_158 = \"0123456789abcdef\";\n          local_13c = ppiVar2;\n          local_138 = piVar28;\n          local_134 = piVar24;\n          local_130 = piVar27;\n          local_100 = piVar25;\n          local_fc = param_3;\n          pcVar18 = local_158;\n          uVar33 = local_150;\n          goto LAB_080072ba;\n        }\n        if (piVar24 == (int *)0x41) {\n          uVar33 = frexp(local_128,uVar19,&local_f0);\n          local_150 = __muldf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = __aeabi_dcmpeq((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                                 local_120);\n          if (iVar3 == 0) {\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          else {\n            local_f0 = (int *)0x1;\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (piVar24 == (int *)0x41) {\n          uVar12 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = (int *)((uint)piVar25 | 0x100);\n        local_148 = (int *)0x0;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar27 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if (((uint)piVar24 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar27 = (int *)0x1;\n            local_148 = (int *)0x0;\n          }\n          goto LAB_0800724a;\n        }\n        if ((int)local_12c < 0) goto LAB_08007414;\n        local_144 = (int *)0x0;\n        uVar19 = local_12c;\n      }\n      local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n      piStack_184 = piVar27;\n      local_158 = (char *)local_128;\n      if (piVar24 == (int *)0x66) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)_dtoa_r(local_16c,local_180,local_128,uVar19);\n        piVar22 = (int *)((int)piVar23 + (int)piVar27);\n        local_150._0_4_ = piVar27;\nLAB_0800764c:\n        if ((*(byte *)piVar23 == 0x30) &&\n           (iVar3 = __aeabi_dcmpeq(local_158,uVar19,local_124,local_120), iVar3 == 0)) {\n          local_f0 = (int *)(1 - (int)(int *)local_150);\n        }\n        piVar22 = (int *)((int)piVar22 + (int)local_f0);\n      }\n      else if (piVar24 == (int *)0x46) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)_dtoa_r(local_16c,local_180,local_128,uVar19);\n        local_150._0_4_ = piVar27;\nLAB_08007760:\n        piVar22 = (int *)((int)piVar23 + (int)(int *)local_150);\n        if (piVar24 == (int *)0x46) goto LAB_0800764c;\n      }\n      else {\n        local_178 = &local_e0;\n        local_150._0_4_ = piVar27;\n        if (local_168 == (int *)0x45) {\n          local_150._0_4_ = (int *)((int)piVar27 + 1);\n        }\n        local_188 = 2;\n        piStack_184 = (int *)local_150;\n        local_180 = &local_f0;\n        puStack_17c = auStack_ec;\n        piVar23 = (int *)_dtoa_r(local_16c,local_180,local_128,uVar19);\n        piVar16 = local_e0;\n        if (piVar24 == (int *)0x67) {\n          if (((uint)piVar25 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (piVar24 == (int *)0x47) {\n          if (((uint)piVar25 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar22 = (int *)((int)(int *)local_150 + (int)piVar23);\n      }\n      iVar3 = __aeabi_dcmpeq(local_158,uVar19,local_124,local_120);\n      piVar16 = piVar22;\n      if (iVar3 == 0) {\n        for (; piVar16 = local_e0, local_e0 < piVar22; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)piVar16 - (int)piVar23);\n      goto LAB_08006cb0;\n    case (int *)0x43:\n    case (int *)0x63:\n      piVar16 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar22 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (char *)0x1;\n      local_8c = SUB41(piVar27,0);\n      piVar23 = (int *)&local_8c;\n      goto LAB_08006298;\n    case (int *)0x44:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_08006102;\n    case (int *)0x4c:\n      piVar25 = (int *)((uint)piVar25 | 8);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x4f:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n    case (int *)0x6f:\n      if (((uint)piVar25 & 0x20) == 0) {\n        ppiVar14 = local_154 + 1;\n        if (((uint)piVar25 & 0x10) == 0) {\n          if (((uint)piVar25 & 0x40) == 0) {\n            if (((uint)piVar25 & 0x200) == 0) goto LAB_08006be2;\n            piVar22 = (int *)(uint)*(byte *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n          else {\n            piVar22 = (int *)(uint)*(ushort *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar22 = *local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\n        ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar22 = *ppiVar14;\n        piVar16 = ppiVar14[1];\n        local_154 = ppiVar14 + 2;\n      }\n      iVar3 = 0;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n      break;\n    case (int *)0x53:\n    case (int *)0x73:\n      local_f5 = 0;\n      piVar23 = *local_154;\n      ppiVar14 = local_154 + 1;\n      if (piVar23 == (int *)0x0) {\n        if ((int *)0x5 < piVar27) {\n          piVar27 = (int *)0x6;\n        }\n        piVar23 = (int *)&UNK_08009f44;\n        piVar16 = (int *)0x0;\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar22 = (int *)0x0;\n        local_168 = piVar27;\n        local_158 = (char *)piVar27;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (piVar27 == (int *)0xffffffff) {\n          local_158 = (char *)strlen(piVar23);\n        }\n        else {\n          iVar3 = memchr(piVar23,0,piVar27);\n          if (iVar3 == 0) {\n            piVar16 = (int *)(uint)local_f5;\n            local_148 = (int *)0x0;\n            local_13c = (int **)0x0;\n            local_134 = (int *)0x0;\n            local_130 = (int *)0x0;\n            piVar22 = (int *)0x0;\n            local_168 = piVar27;\n            local_158 = (char *)piVar27;\n            local_154 = ppiVar14;\n            goto LAB_08006538;\n          }\n          local_158 = (char *)(iVar3 - (int)piVar23);\n        }\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar16 = (int *)(uint)local_f5;\n        piVar22 = (int *)0x0;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        local_154 = ppiVar14;\n      }\n      goto LAB_08006538;\n    case (int *)0x55:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      iVar3 = 1;\n      local_154 = ppiVar14 + 2;\n      break;\n    case (int *)0x58:\n      local_11c = \"0123456789ABCDEF\";\n      if (((uint)piVar25 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_080061be;\n    case (int *)0x64:\n    case (int *)0x69:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bcc:\n        piVar22 = *local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(int)*(short *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bcc;\n        piVar22 = (int *)(int)*(char *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\nLAB_08006102:\n      if ((int)piVar16 < 0) {\n        bVar31 = piVar22 != (int *)0x0;\n        piVar22 = (int *)-(int)piVar22;\n        piVar16 = (int *)(-(int)piVar16 - (uint)bVar31);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar3 = 1;\n        iVar8 = 1;\n        piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n        if (((uint)piVar22 | (uint)piVar16) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      piVar21 = piVar25;\n      if (piVar16 != (int *)0x0 || (int *)0x9 < piVar22) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case (int *)0x68:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x68) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar25 = (int *)((uint)piVar25 | 0x200);\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        piVar25 = (int *)((uint)piVar25 | 0x40);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x6a:\n    case (int *)0x71:\n      piVar25 = (int *)((uint)piVar25 | 0x20);\n    case (int *)0x74:\n    case (int *)0x7a:\nswitchD_08005f58_caseD_74:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case (int *)0x6e:\n      ppiVar14 = local_154 + 1;\n      ppbVar15 = (byte **)*local_154;\n      local_154 = ppiVar14;\n      if (((uint)piVar25 & 0x20) != 0) {\n        *ppbVar15 = local_164;\n        ppbVar15[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) != 0) {\n          *(short *)ppbVar15 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if (((uint)piVar25 & 0x200) != 0) {\n          *(char *)ppbVar15 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar15 = local_164;\n      goto LAB_0800620e;\n    case (int *)0x70:\n      local_f4 = 0x7830;\n      piVar22 = *local_154;\n      local_11c = \"0123456789abcdef\";\n      piVar25 = (int *)((uint)piVar25 | 2);\n      piVar16 = (int *)0x0;\n      iVar3 = 2;\n      piVar24 = (int *)0x78;\n      local_154 = local_154 + 1;\n      break;\n    case (int *)0x75:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bf2:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(uint)*(ushort *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bf2;\n        piVar22 = (int *)(uint)*(byte *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      break;\n    case (int *)0x78:\n      local_11c = \"0123456789abcdef\";\n      if (((uint)piVar25 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar14 = local_154 + 1;\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) == 0) {\n          if (((uint)piVar25 & 0x200) == 0) goto LAB_08006bbc;\n          piVar22 = (int *)(uint)*(byte *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n        else {\n          piVar22 = (int *)(uint)*(ushort *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        local_154 = ppiVar14;\n      }\nLAB_080061be:\n      if ((((uint)piVar25 & 1) != 0) && (((uint)piVar22 | (uint)piVar16) != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 2);\n        local_f4 = CONCAT11((char)piVar24,0x30);\n      }\n      iVar3 = 2;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      if (iVar3 != 1) goto LAB_08006136;\nLAB_08006980:\n      piVar21 = piVar25;\n      if (piVar16 == (int *)0x0 && piVar22 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar32 = CONCAT44(piVar16,piVar22);\n      piVar23 = (int *)(&bStack_2a + 2);\n      piVar22 = (int *)0x0;\n      pbVar26 = local_108;\n      local_168 = piVar23;\n      local_158 = (char *)ppiVar2;\n      local_150._0_4_ = piVar25;\n      local_148 = piVar24;\n      do {\n        iVar3 = (int)((ulonglong)lVar32 >> 0x20);\n        uVar19 = (uint)lVar32;\n        cVar6 = '\\n';\n        __aeabi_uldivmod(uVar19,iVar3,10,0);\n        *(byte *)((int)piVar23 + -1) = cVar6 + 0x30;\n        piVar22 = (int *)((int)piVar22 + 1);\n        piVar23 = (int *)((int)piVar23 + -1);\n        if ((((((uint)piVar25 & 0x400) != 0) && (piVar22 == (int *)(uint)*pbVar26)) &&\n            (piVar22 != (int *)0xff)) && (iVar3 != 0 || 9 < uVar19)) {\n          piVar23 = (int *)((int)piVar23 - (int)local_104);\n          strncpy(piVar23,local_110,local_104);\n          if (pbVar26[1] == 0) {\n            piVar22 = (int *)0x0;\n          }\n          else {\n            pbVar26 = pbVar26 + 1;\n            piVar22 = (int *)0x0;\n          }\n        }\n        lVar32 = __aeabi_uldivmod(uVar19,iVar3,10,0);\n      } while (lVar32 != 0);\n      piVar24 = local_148;\n      piVar25 = (int *)local_150;\n      ppiVar2 = (int **)local_158;\n      local_158 = (char *)((int)local_168 - (int)piVar23);\n      local_138 = piVar22;\n      local_108 = pbVar26;\n    }\n    else {\n      piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n      iVar8 = iVar3;\n      if (((uint)piVar22 | (uint)piVar16) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar3 == 0) {\n            local_158 = (char *)((uint)piVar25 & 1);\n            if ((int *)local_158 == (int *)0x0) {\n              piVar23 = (int *)(&bStack_2a + 2);\n              piVar25 = piVar21;\n            }\n            else {\n              piVar23 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n              piVar25 = piVar21;\n            }\n          }\n          else {\n            piVar23 = (int *)(&bStack_2a + 2);\n            piVar25 = piVar21;\n            local_158 = (char *)piVar27;\n          }\n        }\n        else {\n          piVar25 = piVar21;\n          if (iVar3 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar22 + '0';\n          piVar23 = (int *)(&bStack_2a + 1);\n          local_158 = (char *)0x1;\n          piVar25 = piVar21;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar3 = iVar8;\n        piVar25 = piVar21;\n        if (iVar8 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar3 == 2) {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = (int *)((uint)piVar22 >> 4 | (int)piVar16 << 0x1c);\n            piVar16 = (int *)((uint)piVar16 >> 4);\n            piVar23 = (int *)((int)piVar23 + -1);\n            *(char *)piVar23 = local_11c[(uint)piVar22 & 0xf];\n            piVar22 = piVar21;\n          } while (((uint)piVar21 | (uint)piVar16) != 0);\n        }\n        else {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = piVar23;\n            piVar9 = (int *)((uint)piVar22 >> 3 | (int)piVar16 << 0x1d);\n            piVar16 = (int *)((uint)piVar16 >> 3);\n            iVar3 = ((uint)piVar22 & 7) + 0x30;\n            *(byte *)((int)piVar21 + -1) = (byte)iVar3;\n            piVar23 = (int *)((int)piVar21 + -1);\n            piVar22 = piVar9;\n          } while (((uint)piVar9 | (uint)piVar16) != 0);\n          if ((((uint)piVar25 & 1) != 0) && (iVar3 != 0x30)) {\n            piVar23 = (int *)((int)piVar21 + -2);\n            *(byte *)((int)piVar21 + -2) = 0x30;\n            local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  piVar28 = local_160;\n  if (local_d0 == (int *)0x0) {\nLAB_0800604a:\n    uVar13 = *(ushort *)(local_160 + 3);\n  }\n  else {\n    __ssprint_r(local_16c,local_160,&local_d8);\n    uVar13 = *(ushort *)(piVar28 + 3);\n  }\nLAB_0800604e:\n  if ((uVar13 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (piVar24 == (int *)0x6c) {\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    piVar25 = (int *)((uint)piVar25 | 0x20);\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    piVar25 = (int *)((uint)piVar25 | 0x10);\n  }\n  goto LAB_08005f4a;\n  while( true ) {\n    iVar8 = __aeabi_dcmpeq((int)uVar33,uVar10,local_124,local_120);\n    if (iVar8 != 0) break;\nLAB_080072ba:\n    piVar16 = param_3;\n    piVar22 = (int *)((int)piVar22 + -1);\n    uVar33 = __muldf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x40300000);\n    iVar3 = __aeabi_d2iz();\n    uVar34 = __aeabi_i2d();\n    uVar33 = __subdf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar34,\n                      (int)((ulonglong)uVar34 >> 0x20));\n    uVar10 = (undefined4)((ulonglong)uVar33 >> 0x20);\n    param_3 = (int *)((int)piVar16 + 1);\n    *(char *)piVar16 = pcVar18[iVar3];\n    if (piVar22 == (int *)0xffffffff) break;\n  }\n  piVar23 = local_fc;\n  piVar25 = local_100;\n  piVar27 = local_130;\n  piVar24 = local_134;\n  piVar28 = local_138;\n  ppiVar2 = local_13c;\n  local_13c = (int **)piVar22;\n  local_134 = piVar16;\n  local_150 = uVar33;\n  iVar8 = __aeabi_dcmpgt((int)uVar33,uVar10,0,0x3fe00000);\n  if (iVar8 == 0) {\n    iVar8 = __aeabi_dcmpeq((int *)local_150,local_150._4_4_,0,0x3fe00000);\n    if ((iVar8 != 0) && (iVar3 << 0x1f < 0)) goto LAB_0800748a;\n    if (-1 < (int)local_13c) {\n      piVar16 = (int *)((byte *)((int)local_13c + 1) + (int)param_3);\n      piVar22 = param_3;\n      do {\n        param_3 = (int *)((int)piVar22 + 1);\n        *(byte *)piVar22 = 0x30;\n        piVar22 = param_3;\n      } while (piVar16 != param_3);\n    }\n  }\n  else {\nLAB_0800748a:\n    bVar1 = local_158[0xf];\n    bVar7 = *(byte *)piVar16;\n    piVar22 = param_3;\n    local_e0 = local_134;\n    while (bVar1 == bVar7) {\n      *(byte *)((int)piVar22 + -1) = 0x30;\n      bVar7 = *(byte *)((int)local_e0 + -1);\n      piVar22 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar7 == 0x39) {\n      bVar7 = local_158[10];\n    }\n    else {\n      bVar7 = bVar7 + 1;\n    }\n    *(byte *)((int)piVar22 + -1) = bVar7;\n  }\n  local_138 = (int *)((int)param_3 - (int)piVar23);\nLAB_08006cb0:\n  local_134 = local_f0;\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0 + 3) < 0 == SCARRY4((int)local_f0,3)) &&\n       ((int)local_f0 <= (int)piVar27)) {\n      if ((int)local_f0 < (int)local_138) {\n        local_158 = (char *)((int)local_138 + (int)local_118);\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (char *)((int)local_158 + (1 - (int)local_f0));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        piVar24 = (int *)0x67;\n      }\n      else {\n        if ((int)piVar25 << 0x1f < 0) {\n          local_158 = (char *)((int)local_f0 + (int)local_118);\n        }\n        else {\n          local_158 = (char *)local_f0;\n        }\n        if (-1 < (int)piVar25 << 0x15) {\n          piVar24 = (int *)0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074fc;\n        }\n        piVar24 = (int *)0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    piVar24 = (int *)((int)piVar24 + -2);\n    local_168 = (int *)((uint)piVar24 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8 = (char)piVar24;\n    if (local_168 == (int *)0x41) {\n      local_e8 = local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0 + -1);\n    if ((int)piVar27 < 0) {\n      local_e7 = 0x2d;\n      local_f0 = (int *)(1 - (int)local_f0);\n    }\n    else {\n      local_e7 = 0x2b;\n      local_f0 = piVar27;\n    }\n    if ((int)local_f0 < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e6[0] = 0x30;\n        pcVar18 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar18 = (char)local_f0 + '0';\n      pcVar18 = pcVar18 + 1;\n    }\n    else {\n      pbVar30 = abStack_dc + 3;\n      pbVar26 = pbVar30;\n      do {\n        pbVar5 = pbVar26;\n        piVar22 = (int *)((uint)local_f0 / 10);\n        pbVar5[-1] = (char)local_f0 + (char)piVar22 * -10 + 0x30;\n        pbVar26 = pbVar5 + -1;\n        local_f0 = piVar22;\n      } while ((int *)0x9 < piVar22);\n      uVar19 = (uint)(piVar22 + 0xc) & 0xff;\n      pbVar5[-2] = (byte)uVar19;\n      if (pbVar5 + -2 < pbVar30) {\n        pbVar5 = pbVar26;\n        puVar20 = (undefined *)((int)&local_e8 + 2);\n        while( true ) {\n          *puVar20 = (char)uVar19;\n          if (pbVar30 == pbVar5) break;\n          uVar19 = (uint)*pbVar5;\n          pbVar5 = pbVar5 + 1;\n          puVar20 = puVar20 + 1;\n        }\n        pcVar18 = (char *)(((int)&local_188 * 2 - (int)pbVar26) + 0x152);\n      }\n      else {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar18 + -(int)&local_e8);\n    local_158 = (char *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)piVar25 << 0x1f < 0)) {\n      local_158 = (char *)((int)local_158 + (int)local_118);\n    }\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    piVar25 = (int *)((uint)piVar25 & 0xfffffbff | 0x100);\n    local_f0 = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0 < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_168 = (int *)0x1;\n        local_158 = (char *)0x1;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_118 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      piVar25 = local_140;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)local_f0;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_f0 + (int)local_118) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)piVar25 << 0x15) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      uVar19 = (uint)*local_108;\n      while (uVar19 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar19) goto LAB_08007524;\n          uVar4 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar19);\n          if (uVar4 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = (int *)((int)local_130 + 1);\n          uVar19 = uVar4;\n          if (uVar4 == 0xff) goto LAB_08007524;\n        }\n        local_13c = (int **)((int)local_13c + 1);\n      }\nLAB_08007524:\n      local_158 = (char *)((int)local_158 + (int)local_104 * ((int)local_130 + (int)local_13c));\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      piVar25 = local_140;\n    }\n  }\n  if (local_144 == (int *)0x0) {\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = (int *)0x0;\nLAB_08006538:\n    if (piVar16 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar16 = (int *)0x2d;\n    piVar22 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n  }\nLAB_08006298:\n  piVar27 = local_160;\n  puVar29 = local_16c;\n  local_150._0_4_ = (int *)((uint)piVar25 & 2);\n  if ((int *)local_150 != (int *)0x0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  local_144 = (int *)((uint)piVar25 & 0x84);\n  if ((local_144 == (int *)0x0) &&\n     (piVar21 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar21)) {\n    if (0x10 < (int)piVar21) {\n      piVar16 = (int *)0x10;\n      local_100 = piVar24;\n      do {\n        piVar9 = piVar21;\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = piVar16;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n          piVar24 = local_100;\n        }\n        else {\n          local_140 = piVar16;\n          iVar3 = __ssprint_r(puVar29,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = local_140;\n          piVar24 = local_100;\n        }\n        piVar21 = piVar9 + -4;\n        local_100 = piVar24;\n      } while (0x10 < (int)piVar21);\n      piVar21 = piVar9 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar21);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar21;\n    if ((int)local_d4 < 8) {\n      piVar16 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar16 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar16 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 1);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((int *)local_150 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 2);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  if ((local_144 == (int *)0x80) &&\n     (piVar16 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar16)) {\n    if (0x10 < (int)piVar16) {\n      do {\n        while( true ) {\n          piVar21 = piVar16;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = __ssprint_r(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = piVar21 + -4;\n          if ((int)(piVar21 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar16 = piVar21 + -4;\n      } while (0x10 < (int)(piVar21 + -4));\nLAB_08006882:\n      piVar16 = piVar21 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar16);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar16;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  piVar22 = (int *)((int)piVar22 - (int)local_158);\n  if (0 < (int)piVar22) {\n    if (0x10 < (int)piVar22) {\n      do {\n        while( true ) {\n          piVar16 = piVar22;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = __ssprint_r(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar22 = piVar16 + -4;\n          if ((int)(piVar16 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar22 = piVar16 + -4;\n      } while (0x10 < (int)(piVar16 + -4));\nLAB_080063d2:\n      piVar22 = piVar16 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar22);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar22;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_d0;\n  if (((uint)piVar25 & 0x100) == 0) {\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)local_158);\n    *ppiVar2 = piVar23;\n    ppiVar2[1] = (int *)local_158;\n    if ((int)local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else if ((int)piVar24 < 0x66) {\n    local_158 = (char *)((int)local_d0 + 1);\n    piVar27 = (int *)((int)local_d4 + 1);\n    ppiVar14 = ppiVar2 + 2;\n    local_d0 = (int *)local_158;\n    if (((int)local_138 < 2) && (((uint)piVar25 & 1) == 0)) {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)piVar27 < 8) {\n        local_150._0_4_ = (int *)((int)local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = piVar27;\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        local_150._0_4_ = (int *)((int)local_d4 + 1);\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = piVar27;\n      if (7 < (int)piVar27) {\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n      }\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_158 = (char *)((int)local_158 + (int)local_118);\n      *ppiVar14 = local_114;\n      ppiVar14[1] = local_118;\n      local_d0 = (int *)local_158;\n      if ((int)local_d4 < 8) {\n        ppiVar17 = ppiVar14 + 2;\n      }\n      else {\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar17 = local_cc;\n      }\n      piVar24 = local_d4;\n      local_150._0_4_ = (int *)((int)local_d4 + 1);\n      piVar22 = (int *)((int)local_138 + -1);\n      ppiVar11 = ppiVar17 + 2;\n      local_158 = (char *)local_d0;\n      local_144 = (int *)local_150;\n      iVar3 = __aeabi_dcmpeq(local_128,local_12c,local_124,local_120);\n      piVar27 = local_160;\n      puVar29 = local_16c;\n      if (iVar3 == 0) {\n        local_158 = (char *)((int)local_158 + (int)piVar22);\n        *ppiVar17 = (int *)((int)piVar23 + 1);\n        ppiVar17[1] = piVar22;\n        local_d0 = (int *)local_158;\n        if ((int)(int *)local_150 < 8) {\n          local_150._0_4_ = (int *)((int)piVar24 + 2);\n          ppiVar14 = ppiVar11;\n          ppiVar2 = ppiVar17 + 4;\n        }\n        else {\nLAB_08006d9c:\n          local_158 = (char *)local_d0;\n          local_d4 = (int *)local_150;\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          local_150._0_4_ = (int *)((int)local_d4 + 1);\n          local_158 = (char *)local_d0;\n          ppiVar14 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar14 = ppiVar17;\n        ppiVar2 = ppiVar11;\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)local_158;\n          local_d4 = local_144;\n          if (0x10 < (int)piVar22) {\n            while( true ) {\n              local_d0 = local_d0 + 4;\n              *ppiVar17 = (int *)0x8009f60;\n              ppiVar17[1] = (int *)0x10;\n              if ((int)local_d4 < 8) {\n                ppiVar17 = ppiVar17 + 2;\n              }\n              else {\n                iVar3 = __ssprint_r(puVar29,piVar27,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar17 = local_cc;\n              }\n              piVar22 = piVar22 + -4;\n              if ((int)piVar22 < 0x11) break;\n              local_d4 = (int *)((int)local_d4 + 1);\n            }\n            local_150._0_4_ = (int *)((int)local_d4 + 1);\n            ppiVar11 = ppiVar17 + 2;\n            local_158 = (char *)local_d0;\n          }\n          *ppiVar17 = (int *)0x8009f60;\n          ppiVar17[1] = piVar22;\n          local_158 = (char *)((int)local_158 + (int)piVar22);\n          local_d0 = (int *)local_158;\n          if (7 < (int)(int *)local_150) goto LAB_08006d9c;\n          local_150._0_4_ = (int *)((int)(int *)local_150 + 1);\n          ppiVar2 = ppiVar11 + 2;\n          ppiVar14 = ppiVar11;\n        }\n      }\n    }\n    ppiVar14[1] = local_10c;\n    local_d0 = (int *)((int)local_158 + (int)local_10c);\n    local_d4 = (int *)local_150;\n    *ppiVar14 = (int *)&local_e8;\n    piVar27 = local_d0;\n    if (7 < (int)(int *)local_150) {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else {\n    iVar3 = __aeabi_dcmpeq(local_128,local_12c,local_124,local_120);\n    if (iVar3 == 0) {\n      if ((int)local_f0 < 1) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)piVar27 + 1);\n        *ppiVar2 = (int *)&DAT_08009f4c;\n        ppiVar2[1] = (int *)0x1;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0 != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)local_d0 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          puVar29 = local_16c;\n          if ((int)local_f0 < 0) {\n            piVar27 = (int *)-(int)local_f0;\n            if ((int)(local_f0 + 4) < 0 != SCARRY4((int)local_f0,0x10)) {\n              do {\n                local_d4 = (int *)((int)local_d4 + 1);\n                local_d0 = local_d0 + 4;\n                *ppiVar2 = (int *)0x8009f60;\n                ppiVar2[1] = (int *)0x10;\n                if ((int)local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar3 = __ssprint_r(puVar29,local_160,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)local_d0 + (int)piVar27);\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = piVar27;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = (int *)((int)local_d0 + (int)local_138);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar24 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar24 = local_138;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar24);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = piVar24;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        piVar22 = local_134;\n        if (-1 < (int)piVar24) {\n          piVar22 = (int *)((int)local_134 - (int)piVar24);\n        }\n        if (0 < (int)piVar22) {\n          for (; 0x10 < (int)piVar22; piVar22 = piVar22 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = piVar27 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          local_d4 = (int *)((int)local_d4 + 1);\n          piVar27 = (int *)((int)piVar27 + (int)piVar22);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar22;\n          local_d0 = piVar27;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar22 = local_104;\n        piVar24 = local_160;\n        puVar29 = local_16c;\n        piVar16 = (int *)((int)local_134 + (int)piVar23);\n        if (((uint)piVar25 & 0x400) != 0) {\n          local_158 = (char *)((int)piVar23 + (int)local_138);\n          pbVar26 = local_108;\n          local_150._0_4_ = piVar28;\n          local_144 = piVar25;\n          local_140 = piVar23;\n          if (local_130 == (int *)0x0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != (int **)0x0) goto LAB_0800717e;\n          pbVar26 = pbVar26 + -1;\n          local_130 = (int *)((int)local_130 + -1);\n          do {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)piVar27 + (int)piVar22);\n            *ppiVar2 = local_110;\n            ppiVar2[1] = piVar22;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = (int *)(uint)*pbVar26;\n            piVar28 = (int *)((int)local_158 - (int)piVar16);\n            if ((int)piVar27 <= (int)(int *)((int)local_158 - (int)piVar16)) {\n              piVar28 = piVar27;\n            }\n            if (0 < (int)piVar28) {\n              local_d0 = (int *)((int)local_d0 + (int)piVar28);\n              local_d4 = (int *)((int)local_d4 + 1);\n              *ppiVar2 = piVar16;\n              ppiVar2[1] = piVar28;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar27 = (int *)(uint)*pbVar26;\n              }\n            }\n            piVar25 = piVar27;\n            if (-1 < (int)piVar28) {\n              piVar25 = (int *)((int)piVar27 - (int)piVar28);\n            }\n            if (0 < (int)piVar25) {\n              for (; 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n                while( true ) {\n                  local_d4 = (int *)((int)local_d4 + 1);\n                  local_d0 = local_d0 + 4;\n                  *ppiVar2 = (int *)0x8009f60;\n                  ppiVar2[1] = (int *)0x10;\n                  if ((int)local_d4 < 8) break;\n                  iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  piVar25 = piVar25 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar25 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = (int *)((int)local_d4 + 1);\n              local_d0 = (int *)((int)local_d0 + (int)piVar25);\n              *ppiVar2 = (int *)0x8009f60;\n              ppiVar2[1] = piVar25;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = local_cc;\n              }\n            }\n            piVar16 = (int *)((int)piVar16 + (int)piVar27);\n            piVar27 = local_d0;\n            if (local_130 != (int *)0x0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == (int **)0x0) {\n              piVar23 = local_140;\n              piVar25 = local_144;\n              piVar28 = (int *)local_150;\n              local_108 = pbVar26;\n              if ((int *)((int)local_140 + (int)local_138) <= piVar16) {\n                piVar16 = (int *)((int)local_140 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = (int **)((int)local_13c + -1);\n          } while( true );\n        }\n        if (((int)local_f0 < (int)local_138) || (((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)piVar27 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar24 = (int *)((int)local_138 - (int)local_f0);\n        piVar22 = (int *)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16);\n        if ((int)piVar24 <= (int)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16)) {\n          piVar22 = piVar24;\n        }\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar22);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar16;\n          ppiVar2[1] = piVar22;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar24 = (int *)((int)local_138 - (int)local_f0);\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        if (-1 < (int)piVar22) {\n          piVar24 = (int *)((int)piVar24 - (int)piVar22);\n        }\n        if (0 < (int)piVar24) {\n          for (; local_d0 = piVar27, 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_d0 = (int *)((int)piVar27 + 1);\n      *ppiVar2 = (int *)&DAT_08009f4c;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0 < (int)local_138) || (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)local_118);\n        *ppiVar2 = local_114;\n        ppiVar2[1] = local_118;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar22 = local_160;\n        puVar29 = local_16c;\n        piVar24 = (int *)((int)local_138 + -1);\n        piVar27 = local_d0;\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar22,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\nLAB_08007014:\n          local_d0 = (int *)((int)local_d0 + (int)piVar24);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar24;\njoined_r0x08006a1c:\n          local_d4 = (int *)((int)local_d4 + 1);\n          if (7 < (int)local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  piVar24 = local_160;\n  puVar29 = local_16c;\n  if ((((uint)piVar25 & 4) != 0) &&\n     (piVar25 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar25)) {\n    for (; local_d0 = piVar27, 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n      while( true ) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if ((int)local_d4 < 8) break;\n        iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        piVar25 = piVar25 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar25 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar25);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar25;\n    piVar27 = local_d0;\n    if ((7 < (int)local_d4) &&\n       (iVar3 = __ssprint_r(local_16c,local_160,&local_d8), piVar27 = local_d0, iVar3 != 0))\n    goto LAB_0800603e;\n  }\n  piVar24 = local_15c;\n  if ((int)local_15c < (int)local_168) {\n    piVar24 = local_168;\n  }\n  local_164 = local_164 + (int)piVar24;\n  if ((piVar27 == (int *)0x0) || (iVar3 = __ssprint_r(local_16c,local_160,&local_d8), iVar3 == 0)) {\n    local_d4 = (int *)0x0;\n    if (local_148 != (int *)0x0) {\n      _free_r(local_16c,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    _free_r(local_16c,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  piVar16 = piVar24 + -0xc;\n  piVar22 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar22 + 1);\n    piVar24 = (int *)(uint)*(byte *)piVar22;\n    local_15c = (int *)((int)piVar16 + (int)local_15c * 10);\n    piVar16 = piVar24 + -0xc;\n    piVar22 = piVar28;\n  } while (piVar16 < (int *)0xa);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "calling": [
                "sprintf"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__ssprint_r",
                "__aeabi_dcmpgt",
                "__unorddf2",
                "__aeabi_dcmple",
                "__aeabi_dcmpeq",
                "memchr",
                "__muldf3",
                "frexp",
                "_dtoa_r",
                "__aeabi_i2d",
                "_malloc_r",
                "__aeabi_uldivmod",
                "__aeabi_d2iz",
                "__subdf3",
                "strncpy",
                "strlen",
                "_free_r",
                "_localeconv_r"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078a0": {
            "entrypoint": "0x080078a0",
            "current_name": "FUNC_080078a0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080078a4) */\n\nvoid FUNC_080078a0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078a0": "FUNC_080078a0"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078c0": {
            "entrypoint": "0x080078c0",
            "current_name": "calculate_quotient_080078c0",
            "code": "\nuint calculateQuotient_080078c0(int dividend,int divisor)\n\n{\n  uint tempVar1;\n  uint *dividendPtr;\n  int carry;\n  int divisorValue;\n  int divisorIndex;\n  uint quotient;\n  uint *divisorArrayPtr;\n  uint *dividendArrayPtr;\n  uint *lastElementOfDivisorArray;\n  uint tempVar2;\n  uint *divisorPtr;\n  uint *nextDivisorPtr;\n  \n  divisorValue = *(int *)(divisor + 0x10);\n  if (*(int *)(dividend + 0x10) < divisorValue) {\n    return 0;\n  }\n  divisorIndex = divisorValue + -1;\n  divisorArrayPtr = (uint *)(divisor + 0x14);\n  dividendArrayPtr = (uint *)(dividend + 0x14);\n  quotient = dividendArrayPtr[divisorIndex] / (divisorArrayPtr[divisorIndex] + 1);\n  lastElementOfDivisorArray = divisorArrayPtr + divisorIndex;\n  if (quotient != 0) {\n    tempVar1 = 0;\n    carry = 0;\n    dividendPtr = dividendArrayPtr;\n    divisorPtr = divisorArrayPtr;\n    do {\n      nextDivisorPtr = divisorPtr + 1;\n      tempVar1 = quotient * (*divisorPtr & 0xffff) + tempVar1;\n      tempVar2 = quotient * (*divisorPtr >> 0x10) + (tempVar1 >> 0x10);\n      tempVar1 = (carry - (tempVar1 & 0xffff)) + (*dividendPtr & 0xffff);\n      carry = ((*dividendPtr >> 0x10) - (tempVar2 & 0xffff)) + ((int)tempVar1 >> 0x10);\n      *dividendPtr = tempVar1 & 0xffff | carry * 0x10000;\n      carry = carry >> 0x10;\n      tempVar1 = tempVar2 >> 0x10;\n      dividendPtr = dividendPtr + 1;\n      divisorPtr = nextDivisorPtr;\n    } while (nextDivisorPtr <= lastElementOfDivisorArray);\n    if (dividendArrayPtr[divisorIndex] == 0) {\n      if ((dividendArrayPtr < dividendArrayPtr + divisorValue + -2) && (dividendArrayPtr[divisorValue + -2] == 0)) {\n        dividendPtr = dividendArrayPtr + divisorValue + -3;\n        do {\n          divisorIndex = divisorIndex + -1;\n          if (dividendPtr <= dividendArrayPtr) break;\n          tempVar1 = *dividendPtr;\n          dividendPtr = dividendPtr + -1;\n        } while (tempVar1 == 0);\n      }\n      *(int *)(dividend + 0x10) = divisorIndex;\n    }\n  }\n  divisorValue = __mcmp();\n  if (-1 < divisorValue) {\n    divisorValue = 0;\n    quotient = quotient + 1;\n    dividendPtr = dividendArrayPtr;\n    do {\n      divisorPtr = divisorArrayPtr + 1;\n      tempVar1 = (divisorValue - (*divisorArrayPtr & 0xffff)) + (*dividendPtr & 0xffff);\n      divisorValue = ((*dividendPtr >> 0x10) - (*divisorArrayPtr >> 0x10)) + ((int)tempVar1 >> 0x10);\n      *dividendPtr = tempVar1 & 0xffff | divisorValue * 0x10000;\n      divisorValue = divisorValue >> 0x10;\n      dividendPtr = dividendPtr + 1;\n      divisorArrayPtr = divisorPtr;\n    } while (divisorPtr <= lastElementOfDivisorArray);\n    if (dividendArrayPtr[divisorIndex] == 0) {\n      if ((dividendArrayPtr < dividendArrayPtr + divisorIndex + -1) && (dividendArrayPtr[divisorIndex + -1] == 0)) {\n        divisorArrayPtr = dividendArrayPtr + divisorIndex + -2;\n        do {\n          divisorIndex = divisorIndex + -1;\n          if (divisorArrayPtr <= dividendArrayPtr) break;\n          tempVar1 = *divisorArrayPtr;\n          divisorArrayPtr = divisorArrayPtr + -1;\n        } while (tempVar1 == 0);\n      }\n      *(int *)(dividend + 0x10) = divisorIndex;\n    }\n  }\n  return quotient;\n}\n\n",
            "renaming": {
                "FUN_080078c0": "calculate_quotient_080078c0",
                "param_1": "dividend",
                "param_2": "divisor",
                "iVar4": "divisorValue",
                "iVar5": "divisorIndex",
                "puVar7": "divisorArrayPtr",
                "puVar8": "dividendArrayPtr",
                "uVar6": "quotient",
                "puVar9": "lastElementOfDivisorArray",
                "uVar1": "tempVar1",
                "iVar3": "carry",
                "puVar2": "dividendPtr",
                "puVar11": "divisorPtr",
                "puVar12": "nextDivisorPtr",
                "uVar10": "tempVar2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__mcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e8": {
            "entrypoint": "0x080079e8",
            "current_name": "convert_double_to_string_080079e8",
            "code": "\nchar * convertDoubleToString_080079e8(int doubleValue,undefined4 param2,uint signBit,uint exponent,uint digits,\n                   uint precision,int *outputLength,uint *returnSign,char **outputString)\n\n{\n  bool useInfinity;\n  bool roundUp;\n  bool useNaN;\n  char digit;\n  byte comparisonResult;\n  undefined4 normalizedDouble;\n  int exponentBits;\n  int tmpExponent;\n  int exponentDiff;\n  char *resultString;\n  uint normalizedExponent;\n  undefined4 tmp1;\n  undefined4 tmp2;\n  int normalizedExponentOffset;\n  int normalizedLength;\n  undefined4 tmp3;\n  uint normalizedValue;\n  uint absoluteExponent;\n  int tempVariable1;\n  char *pcVar20;\n  char *pcVar21;\n  undefined4 *puVar22;\n  undefined4 globalVar3;\n  int tempVariable2;\n  bool roundUp5;\n  undefined8 tempVariable3;\n  undefined8 tempVariable4;\n  undefined8 tempVariable5;\n  uint globalVar7;\n  uint globalVar8;\n  uint globalVar9;\n  int globalVar10;\n  uint globalVar11;\n  int globalVar12;\n  int globalVar13;\n  uint globalVar14;\n  uint globalVar15;\n  uint globalVar16;\n  uint globalVar17;\n  uint globalVar18;\n  int globalVar19;\n  int local_2c [2];\n  \n  normalizedExponentOffset = *(int *)(doubleValue + 0x40);\n  if (normalizedExponentOffset != 0) {\n    absoluteExponent = *(uint *)(doubleValue + 0x44);\n    *(uint *)(normalizedExponentOffset + 4) = absoluteExponent;\n    *(int *)(normalizedExponentOffset + 8) = 1 << (absoluteExponent & 0xff);\n    _Bfree(doubleValue,normalizedExponentOffset);\n    *(undefined4 *)(doubleValue + 0x40) = 0;\n  }\n  roundUp5 = (int)exponent < 0;\n  absoluteExponent = exponent;\n  if (roundUp5) {\n    absoluteExponent = exponent & 0x7fffffff;\n  }\n  *returnSign = (uint)roundUp5;\n  globalVar8 = exponent;\n  if (roundUp5) {\n    globalVar8 = absoluteExponent;\n  }\n  normalizedValue = globalVar8;\n  if ((~absoluteExponent & 0x7ff00000) == 0) {\n    *outputLength = 9999;\n    if ((signBit == 0) && ((absoluteExponent & 0xfffff) == 0)) {\n      resultString = \"Infinity\";\n      if (outputString == (char **)0x0) {\n        return resultString;\n      }\n      pcVar21 = \"\";\n    }\n    else {\n      resultString = \"NaN\";\n      if (outputString == (char **)0x0) {\n        return resultString;\n      }\n      pcVar21 = \"\";\n    }\n    *outputString = pcVar21;\n    return resultString;\n  }\n  tempVariable3 = __aeabi_dcmpeq(signBit,globalVar8,0,0);\n  if ((int)tempVariable3 != 0) {\n    *outputLength = 1;\n    if (outputString != (char **)0x0) {\n      *outputString = \"\";\n      return \"0\";\n    }\n    return \"0\";\n  }\n  normalizedDouble = __d2b(doubleValue,(int)((ulonglong)tempVariable3 >> 0x20),signBit,globalVar8,local_2c,&globalVar19);\n  normalizedExponentOffset = globalVar19;\n  if (absoluteExponent >> 0x14 == 0) {\n    tempVariable1 = local_2c[0] + globalVar19;\n    normalizedLength = tempVariable1 + 0x432;\n    if (normalizedLength < 0x21) {\n      absoluteExponent = signBit << (0x20U - normalizedLength & 0xff);\n    }\n    else {\n      absoluteExponent = signBit >> (tempVariable1 + 0x412U & 0xff) | absoluteExponent << (0x40U - normalizedLength & 0xff);\n    }\n    tempVariable3 = __floatunsidf(absoluteExponent);\n    tempVariable1 = tempVariable1 + -1;\n    roundUp5 = true;\n    normalizedExponent = (int)((ulonglong)tempVariable3 >> 0x20) + 0xfe100000;\n    absoluteExponent = (uint)tempVariable3;\n  }\n  else {\n    tempVariable1 = (absoluteExponent >> 0x14) - 0x3ff;\n    normalizedExponent = globalVar8 & 0xfffff | 0x3ff00000;\n    roundUp5 = false;\n    absoluteExponent = signBit;\n  }\n  tempVariable3 = __subdf3(absoluteExponent,normalizedExponent,0,0x3ff80000);\n  tempVariable3 = __muldf3((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),0x636f4361,0x3fd287a7);\n  tempVariable3 = __aeabi_dadd((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),0x8b60c8b3,0x3fc68a28);\n  tempVariable4 = __aeabi_i2d(tempVariable1);\n  tempVariable4 = __muldf3((int)tempVariable4,(int)((ulonglong)tempVariable4 >> 0x20),0x509f79fb,0x3fd34413);\n  tempVariable3 = __aeabi_dadd((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),(int)tempVariable4,\n                        (int)((ulonglong)tempVariable4 >> 0x20));\n  tmp2 = (undefined4)((ulonglong)tempVariable3 >> 0x20);\n  globalVar9 = __aeabi_d2iz();\n  normalizedLength = __aeabi_dcmplt((int)tempVariable3,tmp2,0,0);\n  if (normalizedLength != 0) {\n    tempVariable4 = __aeabi_i2d(globalVar9);\n    normalizedLength = __aeabi_dcmpeq((int)tempVariable4,(int)((ulonglong)tempVariable4 >> 0x20),(int)tempVariable3,tmp2);\n    if (normalizedLength == 0) {\n      globalVar9 = globalVar9 - 1;\n    }\n  }\n  if (globalVar9 < 0x17) {\n    normalizedLength = __aeabi_dcmpgt(*(undefined4 *)(&DAT_08009fa8 + globalVar9 * 8),\n                            *(undefined4 *)(&DAT_08009fac + globalVar9 * 8),signBit,globalVar8);\n    if (normalizedLength == 0) {\n      roundUp = false;\n    }\n    else {\n      globalVar9 = globalVar9 - 1;\n      roundUp = false;\n    }\n  }\n  else {\n    roundUp = true;\n  }\n  normalizedLength = (normalizedExponentOffset - tempVariable1) + -1;\n  if (normalizedLength < 0) {\n    globalVar10 = 1 - (normalizedExponentOffset - tempVariable1);\n    normalizedLength = 0;\n  }\n  else {\n    globalVar10 = 0;\n  }\n  if ((int)globalVar9 < 0) {\n    globalVar14 = 0;\n    globalVar10 = globalVar10 - globalVar9;\n    globalVar13 = -globalVar9;\n  }\n  else {\n    normalizedLength = normalizedLength + globalVar9;\n    globalVar14 = globalVar9;\n    globalVar13 = 0;\n  }\n  if (9 < digits) {\n    globalVar17 = 0xffffffff;\n    useInfinity = true;\n    globalVar11 = 0xffffffff;\n    useNaN = true;\n    digits = 0;\n    precision = 0;\n    goto LAB_08007c24;\n  }\n  useInfinity = (int)digits < 6;\n  if (!useInfinity) {\n    digits = digits - 4;\n  }\n  switch(digits) {\n  case 2:\n    useNaN = false;\n    break;\n  case 3:\n    useNaN = false;\n    goto LAB_08008300;\n  case 4:\n    useNaN = true;\n    break;\n  case 5:\n    useNaN = true;\nLAB_08008300:\n    globalVar17 = globalVar9 + precision;\n    globalVar11 = globalVar17 + 1;\n    absoluteExponent = globalVar11;\n    if ((int)globalVar11 < 1) {\n      absoluteExponent = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(doubleValue + 0x44) = 0;\n    resultString = (char *)_Balloc(doubleValue,0);\n    globalVar17 = 0xffffffff;\n    globalVar11 = 0xffffffff;\n    precision = 0;\n    *(char **)(doubleValue + 0x40) = resultString;\n    useNaN = true;\n    goto LAB_08007e36;\n  }\n  if ((int)precision < 1) {\n    globalVar17 = 1;\n    precision = 1;\n    globalVar11 = 1;\nLAB_08007c24:\n    *(undefined4 *)(doubleValue + 0x44) = 0;\n    normalizedExponent = globalVar17;\n  }\n  else {\n    globalVar17 = precision;\n    globalVar11 = precision;\n    absoluteExponent = precision;\nLAB_08008314:\n    *(undefined4 *)(doubleValue + 0x44) = 0;\n    normalizedExponent = globalVar11;\n    if (0x17 < (int)absoluteExponent) {\n      tempVariable1 = 4;\n      normalizedExponentOffset = 1;\n      do {\n        exponentBits = normalizedExponentOffset;\n        tempVariable1 = tempVariable1 * 2;\n        normalizedExponentOffset = exponentBits + 1;\n      } while (tempVariable1 + 0x14U <= absoluteExponent);\n      *(int *)(doubleValue + 0x44) = exponentBits;\n    }\n  }\n  resultString = (char *)_Balloc(doubleValue);\n  *(char **)(doubleValue + 0x40) = resultString;\n  if ((normalizedExponent < 0xf) && (useInfinity)) {\n    if ((int)globalVar9 < 1) {\n      if (globalVar9 == 0) {\n        normalizedExponentOffset = 2;\n        globalVar7 = signBit;\n      }\n      else {\n        normalizedExponentOffset = (-globalVar9 & 0xf) * 8;\n        tempVariable3 = __muldf3(signBit,globalVar8,*(undefined4 *)(&DAT_08009fa8 + normalizedExponentOffset),\n                          *(undefined4 *)(&DAT_08009fac + normalizedExponentOffset));\n        globalVar8 = (uint)((ulonglong)tempVariable3 >> 0x20);\n        globalVar7 = (uint)tempVariable3;\n        tempVariable1 = (int)-globalVar9 >> 4;\n        if (tempVariable1 == 0) {\n          normalizedExponentOffset = 2;\n        }\n        else {\n          useInfinity = false;\n          normalizedExponentOffset = 2;\n          puVar22 = &DAT_08009f80;\n          do {\n            if (tempVariable1 << 0x1f < 0) {\n              tempVariable3 = __muldf3((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),*puVar22,puVar22[1]);\n              useInfinity = true;\n              normalizedExponentOffset = normalizedExponentOffset + 1;\n            }\n            tempVariable1 = tempVariable1 >> 1;\n            puVar22 = puVar22 + 2;\n          } while (tempVariable1 != 0);\n          if (useInfinity) {\n            globalVar7 = (uint)tempVariable3;\n            globalVar8 = (uint)((ulonglong)tempVariable3 >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      absoluteExponent = (int)globalVar9 >> 4;\n      tempVariable4 = *(undefined8 *)(&DAT_08009fa8 + (globalVar9 & 0xf) * 8);\n      tempVariable3 = *(undefined8 *)(&DAT_08009fa8 + (globalVar9 & 0xf) * 8);\n      if ((int)(absoluteExponent << 0x1b) < 0) {\n        tempVariable5 = __divdf3(signBit,globalVar8,0x7f73bf3c,0x75154fdd);\n        globalVar16 = (uint)((ulonglong)tempVariable5 >> 0x20);\n        globalVar15 = (uint)tempVariable5;\n        normalizedExponentOffset = 3;\n        absoluteExponent = absoluteExponent & 0xf;\n      }\n      else {\n        normalizedExponentOffset = 2;\n        globalVar16 = globalVar8;\n        globalVar15 = signBit;\n      }\n      if (absoluteExponent != 0) {\n        puVar22 = &DAT_08009f80;\n        do {\n          if ((int)(absoluteExponent << 0x1f) < 0) {\n            tempVariable3 = __muldf3((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),*puVar22,puVar22[1]);\n            normalizedExponentOffset = normalizedExponentOffset + 1;\n          }\n          absoluteExponent = (int)absoluteExponent >> 1;\n          puVar22 = puVar22 + 2;\n          tempVariable4 = tempVariable3;\n        } while (absoluteExponent != 0);\n      }\n      globalVar8 = (uint)((ulonglong)tempVariable4 >> 0x20);\n      globalVar7 = (uint)tempVariable4;\n      tempVariable3 = __divdf3(globalVar15,globalVar16,globalVar7,globalVar8);\n      globalVar7 = (uint)tempVariable3;\n      globalVar8 = (uint)((ulonglong)tempVariable3 >> 0x20);\n    }\n    tempVariable3 = CONCAT44(globalVar8,globalVar7);\n    if ((roundUp) && (tempVariable1 = __aeabi_dcmplt(globalVar7,globalVar8,0,0x3ff00000), tempVariable1 != 0)) {\n      if (globalVar11 == 0) {\n        tempVariable3 = __aeabi_i2d(normalizedExponentOffset);\n        tempVariable3 = __muldf3((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),globalVar7,globalVar8);\n        tempVariable3 = __aeabi_dadd((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),0,0x401c0000);\n        tmp2 = (undefined4)tempVariable3;\n        normalizedExponentOffset = (int)((ulonglong)tempVariable3 >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)globalVar17) {\n        tempVariable3 = __muldf3(globalVar7,globalVar8,0,0x40240000);\n        tempVariable4 = __aeabi_i2d(normalizedExponentOffset + 1);\n        tempVariable4 = __muldf3((int)tempVariable4,(int)((ulonglong)tempVariable4 >> 0x20),(int)tempVariable3,\n                          (int)((ulonglong)tempVariable3 >> 0x20));\n        tempVariable4 = __aeabi_dadd((int)tempVariable4,(int)((ulonglong)tempVariable4 >> 0x20),0,0x401c0000);\n        tmp2 = (undefined4)tempVariable4;\n        globalVar15 = globalVar17;\n        globalVar18 = globalVar9 - 1;\n        normalizedExponentOffset = (int)((ulonglong)tempVariable4 >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    tempVariable4 = __aeabi_i2d(normalizedExponentOffset);\n    tempVariable4 = __muldf3((int)tempVariable4,(int)((ulonglong)tempVariable4 >> 0x20),globalVar7,globalVar8);\n    tempVariable4 = __aeabi_dadd((int)tempVariable4,(int)((ulonglong)tempVariable4 >> 0x20),0,0x401c0000);\n    tmp2 = (undefined4)tempVariable4;\n    normalizedExponentOffset = (int)((ulonglong)tempVariable4 >> 0x20) + -0x3400000;\n    if (globalVar11 != 0) {\n      globalVar18 = globalVar9;\n      globalVar15 = globalVar11;\nLAB_08007cfa:\n      globalVar8 = (uint)((ulonglong)tempVariable3 >> 0x20);\n      globalVar7 = (uint)tempVariable3;\n      digit = __aeabi_d2iz(globalVar7,globalVar8);\n      digit = digit + '0';\n      tmp3 = (&DAT_08009fa0)[globalVar15 * 2];\n      tmp1 = (&DAT_08009fa4)[globalVar15 * 2];\n      tempVariable3 = __aeabi_i2d();\n      tempVariable3 = __subdf3(globalVar7,globalVar8,(int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20));\n      globalVar3 = (undefined4)((ulonglong)tempVariable3 >> 0x20);\n      pcVar21 = resultString + 1;\n      if (useNaN) {\n        tempVariable4 = __divdf3(0,0x3fe00000,tmp3,tmp1);\n        tempVariable4 = __subdf3((int)tempVariable4,(int)((ulonglong)tempVariable4 >> 0x20),tmp2,normalizedExponentOffset);\n        tmp2 = (undefined4)((ulonglong)tempVariable4 >> 0x20);\n        *resultString = digit;\n        normalizedExponentOffset = __aeabi_dcmpgt((int)tempVariable4,tmp2,(int)tempVariable3,globalVar3);\n        if (normalizedExponentOffset != 0) {\nLAB_08008784:\n          globalVar9 = globalVar18;\n          goto LAB_08008294;\n        }\n        tempVariable5 = __subdf3(0,0x3ff00000,(int)tempVariable3,globalVar3);\n        normalizedExponentOffset = __aeabi_dcmpgt((int)tempVariable4,tmp2,(int)tempVariable5,(int)((ulonglong)tempVariable5 >> 0x20));\n        if (normalizedExponentOffset == 0) {\n          if (globalVar15 != 1) {\n            pcVar20 = pcVar21;\n            do {\n              tempVariable4 = __muldf3((int)tempVariable4,(int)((ulonglong)tempVariable4 >> 0x20),0,0x40240000);\n              tmp2 = (undefined4)((ulonglong)tempVariable4 >> 0x20);\n              tempVariable3 = __muldf3((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),0,0x40240000);\n              digit = __aeabi_d2iz();\n              tempVariable5 = __aeabi_i2d();\n              tempVariable3 = __subdf3((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),(int)tempVariable5,\n                                (int)((ulonglong)tempVariable5 >> 0x20));\n              tmp3 = (undefined4)((ulonglong)tempVariable3 >> 0x20);\n              digit = digit + '0';\n              pcVar21 = pcVar20 + 1;\n              *pcVar20 = digit;\n              normalizedExponentOffset = __aeabi_dcmplt((int)tempVariable3,tmp3,(int)tempVariable4,tmp2);\n              if (normalizedExponentOffset != 0) {\n                globalVar9 = globalVar18;\n                goto LAB_08008294;\n              }\n              tempVariable5 = __subdf3(0,0x3ff00000,(int)tempVariable3,tmp3);\n              normalizedExponentOffset = __aeabi_dcmplt((int)tempVariable5,(int)((ulonglong)tempVariable5 >> 0x20),(int)tempVariable4,\n                                      tmp2);\n              if (normalizedExponentOffset != 0) goto LAB_08008798;\n              pcVar20 = pcVar21;\n            } while (pcVar21 != resultString + globalVar15);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        globalVar9 = globalVar18;\n      }\n      else {\n        tempVariable4 = __muldf3(tmp2,normalizedExponentOffset,tmp3,tmp1);\n        tmp2 = (undefined4)((ulonglong)tempVariable4 >> 0x20);\n        *resultString = digit;\n        if (globalVar15 != 1) {\n          pcVar20 = pcVar21;\n          do {\n            tempVariable3 = __muldf3((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),0,0x40240000);\n            digit = __aeabi_d2iz();\n            tempVariable5 = __aeabi_i2d();\n            tempVariable3 = __subdf3((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),(int)tempVariable5,\n                              (int)((ulonglong)tempVariable5 >> 0x20));\n            pcVar21 = pcVar20 + 1;\n            *pcVar20 = digit + '0';\n            pcVar20 = pcVar21;\n          } while (pcVar21 != resultString + globalVar15);\n        }\n        tmp3 = (undefined4)((ulonglong)tempVariable3 >> 0x20);\n        tempVariable5 = __aeabi_dadd((int)tempVariable4,tmp2,0,0x3fe00000);\n        normalizedExponentOffset = __aeabi_dcmplt((int)tempVariable5,(int)((ulonglong)tempVariable5 >> 0x20),(int)tempVariable3,tmp3);\n        if (normalizedExponentOffset == 0) {\n          tempVariable4 = __subdf3(0,0x3fe00000,(int)tempVariable4,tmp2);\n          normalizedExponentOffset = __aeabi_dcmpgt((int)tempVariable4,(int)((ulonglong)tempVariable4 >> 0x20),(int)tempVariable3,tmp3);\n          pcVar20 = pcVar21;\n          if (normalizedExponentOffset == 0) goto LAB_08007e36;\n          do {\n            pcVar21 = pcVar20;\n            pcVar20 = pcVar21 + -1;\n          } while (pcVar21[-1] == '0');\n          goto LAB_08008784;\n        }\n        globalVar9 = globalVar18;\n        digit = pcVar21[-1];\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    tempVariable3 = __subdf3(globalVar7,globalVar8,0,0x40140000);\n    tmp3 = (undefined4)((ulonglong)tempVariable3 >> 0x20);\n    tempVariable1 = __aeabi_dcmpgt((int)tempVariable3,tmp3,tmp2,normalizedExponentOffset);\n    if (tempVariable1 == 0) {\n      normalizedExponentOffset = __aeabi_dcmplt((int)tempVariable3,tmp3,tmp2,normalizedExponentOffset + -0x80000000);\n      if (normalizedExponentOffset == 0) goto LAB_08007e36;\n      tempVariable1 = 0;\n      normalizedExponentOffset = 0;\n      pcVar21 = resultString;\n      goto LAB_080084f0;\n    }\n    normalizedLength = 0;\n    exponentBits = 0;\nLAB_08008406:\n    *resultString = '1';\n    globalVar9 = globalVar9 + 1;\n    pcVar21 = resultString + 1;\n    tempVariable1 = exponentBits;\n    normalizedExponentOffset = normalizedLength;\nLAB_08008416:\n    _Bfree(doubleValue,normalizedExponentOffset);\n    if (tempVariable1 == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pcVar21 = resultString;\n    if ((-1 < local_2c[0]) && ((int)globalVar9 < 0xf)) {\n      tmp2 = *(undefined4 *)(&DAT_08009fa8 + globalVar9 * 8);\n      tmp3 = *(undefined4 *)(&DAT_08009fac + globalVar9 * 8);\n      if ((-1 < (int)precision) || (0 < (int)globalVar11)) {\n        __divdf3(signBit,normalizedValue,tmp2,tmp3);\n        comparisonResult = __aeabi_d2iz();\n        tempVariable3 = __aeabi_i2d();\n        tempVariable3 = __muldf3((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),tmp2,tmp3);\n        tempVariable3 = __subdf3(signBit,normalizedValue,(int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20));\n        *resultString = comparisonResult + 0x30;\n        pcVar21 = resultString + 1;\n        if (globalVar11 != 1) {\n          tempVariable3 = __muldf3((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),0,0x40240000);\n          normalizedExponentOffset = __aeabi_dcmpeq((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),0,0);\n          while (normalizedExponentOffset == 0) {\n            globalVar3 = (undefined4)((ulonglong)tempVariable3 >> 0x20);\n            __divdf3((int)tempVariable3,globalVar3,tmp2,tmp3);\n            comparisonResult = __aeabi_d2iz();\n            tempVariable4 = __aeabi_i2d();\n            tempVariable4 = __muldf3((int)tempVariable4,(int)((ulonglong)tempVariable4 >> 0x20),tmp2,tmp3);\n            tempVariable3 = __subdf3((int)tempVariable3,globalVar3,(int)tempVariable4,(int)((ulonglong)tempVariable4 >> 0x20));\n            pcVar20 = pcVar21 + 1;\n            *pcVar21 = comparisonResult + 0x30;\n            pcVar21 = pcVar20;\n            if (globalVar11 == (int)pcVar20 - (int)resultString) goto LAB_08007f3a;\n            tempVariable3 = __muldf3((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),0,0x40240000);\n            normalizedExponentOffset = __aeabi_dcmpeq((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        tempVariable3 = __aeabi_dadd((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20));\n        globalVar3 = (undefined4)((ulonglong)tempVariable3 >> 0x20);\n        normalizedExponentOffset = __aeabi_dcmpgt((int)tempVariable3,globalVar3,tmp2,tmp3);\n        if ((normalizedExponentOffset == 0) &&\n           ((normalizedExponentOffset = __aeabi_dcmpeq((int)tempVariable3,globalVar3,tmp2,tmp3), normalizedExponentOffset == 0 ||\n            ((comparisonResult & 1) == 0)))) goto LAB_08008294;\n        digit = pcVar21[-1];\nLAB_08007f7c:\n        while (pcVar20 = pcVar21 + -1, digit == '9') {\n          if (resultString == pcVar20) {\n            *resultString = '0';\n            digit = pcVar21[-1];\n            globalVar9 = globalVar9 + 1;\n            pcVar20 = resultString;\n            break;\n          }\n          digit = pcVar21[-2];\n          pcVar21 = pcVar20;\n        }\n        *pcVar20 = digit + '\\x01';\n        goto LAB_08008294;\n      }\n      if (globalVar11 == 0) {\n        tempVariable3 = __muldf3(tmp2,tmp3,0,0x40140000);\n        exponentDiff = __aeabi_dcmpge((int)tempVariable3,(int)((ulonglong)tempVariable3 >> 0x20),signBit,normalizedValue);\n        tempVariable1 = 0;\n        normalizedLength = 0;\n        exponentBits = 0;\n        normalizedExponentOffset = 0;\n        if (exponentDiff == 0) goto LAB_08008406;\n      }\n      else {\n        tempVariable1 = 0;\n        normalizedExponentOffset = 0;\n      }\nLAB_080084f0:\n      globalVar9 = ~precision;\n      resultString = pcVar21;\n      goto LAB_08008416;\n    }\n    normalizedExponentOffset = globalVar13;\n    if (useNaN) {\n      if ((int)digits < 2) {\n        if (roundUp5) {\n          globalVar12 = globalVar10;\n          globalVar10 = globalVar10 + local_2c[0] + 0x433;\n          normalizedLength = normalizedLength + local_2c[0] + 0x433;\n        }\n        else {\n          globalVar12 = globalVar10;\n          globalVar10 = globalVar10 + (0x36 - globalVar19);\n          normalizedLength = normalizedLength + (0x36 - globalVar19);\n        }\n      }\n      else {\n        tempVariable1 = globalVar11 - 1;\n        if (globalVar13 < tempVariable1) {\n          globalVar14 = globalVar14 + (tempVariable1 - globalVar13);\n          normalizedExponentOffset = 0;\n          globalVar13 = tempVariable1;\n        }\n        else {\n          normalizedExponentOffset = globalVar13 - tempVariable1;\n        }\n        if ((int)globalVar11 < 0) {\n          globalVar12 = globalVar10 - globalVar11;\n        }\n        else {\n          normalizedLength = normalizedLength + globalVar11;\n          globalVar12 = globalVar10;\n          globalVar10 = globalVar10 + globalVar11;\n        }\n      }\n      tempVariable1 = __i2b(doubleValue,1);\n    }\n    else {\n      globalVar12 = globalVar10;\n      tempVariable1 = 0;\n    }\n    if ((0 < globalVar12) && (0 < normalizedLength)) {\n      exponentBits = globalVar12;\n      if (normalizedLength <= globalVar12) {\n        exponentBits = normalizedLength;\n      }\n      normalizedLength = normalizedLength - exponentBits;\n      globalVar10 = globalVar10 - exponentBits;\n      globalVar12 = globalVar12 - exponentBits;\n    }\n    if (globalVar13 != 0) {\n      if (useNaN) {\n        tmp2 = normalizedDouble;\n        if (normalizedExponentOffset != 0) {\n          tempVariable1 = __pow5mult(doubleValue,tempVariable1,normalizedExponentOffset);\n          tmp2 = __multiply(doubleValue,tempVariable1,normalizedDouble);\n          _Bfree(doubleValue,normalizedDouble);\n          normalizedDouble = tmp2;\n          if (globalVar13 - normalizedExponentOffset == 0) goto LAB_08008062;\n        }\n        normalizedDouble = __pow5mult(doubleValue,tmp2,globalVar13 - normalizedExponentOffset);\n      }\n      else {\n        normalizedDouble = __pow5mult(doubleValue,normalizedDouble,globalVar13);\n      }\n    }\nLAB_08008062:\n    normalizedExponentOffset = __i2b(doubleValue,1);\n    if (globalVar14 == 0) {\n      if (((int)digits < 2) && (signBit == 0)) {\nLAB_0800835a:\n        if ((normalizedValue & 0xfffff) == 0) {\n          normalizedValue = normalizedValue & 0x7ff00000;\n          if (normalizedValue != 0) {\n            normalizedLength = normalizedLength + 1;\n            globalVar10 = globalVar10 + 1;\n            normalizedValue = 1;\n          }\n        }\n        else {\n          normalizedValue = 0;\n        }\n        roundUp5 = globalVar14 != 0;\n        absoluteExponent = signBit;\n        globalVar14 = normalizedValue;\n        if (roundUp5) goto LAB_080082d4;\n      }\n      exponentBits = 1;\n    }\n    else {\n      tempVariable3 = __pow5mult(doubleValue,normalizedExponentOffset);\n      normalizedExponentOffset = (int)tempVariable3;\n      if (((int)digits < 2) && (signBit == 0)) goto LAB_0800835a;\n      globalVar14 = 0;\n      absoluteExponent = (uint)((ulonglong)tempVariable3 >> 0x20);\nLAB_080082d4:\n      exponentBits = __hi0bits(*(undefined4 *)(normalizedExponentOffset + *(int *)(normalizedExponentOffset + 0x10) * 4 + 0x10),absoluteExponent);\n      exponentBits = 0x20 - exponentBits;\n    }\n    absoluteExponent = exponentBits + normalizedLength & 0x1f;\n    if (absoluteExponent == 0) {\n      exponentBits = 0x1c;\nLAB_08008096:\n      normalizedLength = normalizedLength + exponentBits;\n      globalVar10 = globalVar10 + exponentBits;\n      globalVar12 = globalVar12 + exponentBits;\n    }\n    else {\n      if (4 < (int)(0x20 - absoluteExponent)) {\n        exponentBits = 0x1c - absoluteExponent;\n        goto LAB_08008096;\n      }\n      if (0x20 - absoluteExponent != 4) {\n        exponentBits = 0x3c - absoluteExponent;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < globalVar10) {\n      normalizedDouble = __lshift(doubleValue,normalizedDouble,globalVar10);\n    }\n    if (0 < normalizedLength) {\n      normalizedExponentOffset = __lshift(doubleValue,normalizedExponentOffset,normalizedLength);\n    }\n    pcVar20 = resultString;\n    if ((roundUp) && (normalizedLength = __mcmp(normalizedDouble,normalizedExponentOffset), normalizedLength < 0)) {\n      globalVar9 = globalVar9 - 1;\n      normalizedDouble = __multadd(doubleValue,normalizedDouble,10,0);\n      if (useNaN) {\n        tempVariable1 = __multadd(doubleValue,tempVariable1,10,0);\n        if ((0 < (int)globalVar17) || ((int)digits < 3)) {\n          globalVar11 = globalVar17;\n          goto LAB_080080de;\n        }\n      }\n      else if ((0 < (int)globalVar17) || ((int)digits < 3)) {\n        globalVar11 = globalVar17;\n        goto LAB_0800820a;\n      }\n      globalVar11 = globalVar17;\nLAB_080084e8:\n      if (globalVar11 == 0) {\n        normalizedLength = __multadd(doubleValue,normalizedExponentOffset,5);\n        exponentDiff = __mcmp(normalizedDouble,normalizedLength);\n        exponentBits = tempVariable1;\n        normalizedExponentOffset = normalizedLength;\n        if (0 < exponentDiff) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)globalVar11 < 1) && (2 < (int)digits)) goto LAB_080084e8;\n    if (useNaN) {\nLAB_080080de:\n      globalVar7 = tempVariable1;\n      if (0 < globalVar12) {\n        globalVar7 = __lshift(doubleValue,tempVariable1,globalVar12);\n      }\n      tempVariable1 = globalVar7;\n      if (globalVar14 != 0) {\n        tempVariable1 = _Balloc(doubleValue,*(undefined4 *)(globalVar7 + 4));\n        memcpy(tempVariable1 + 0xc,globalVar7 + 0xc,(*(int *)(globalVar7 + 0x10) + 2) * 4);\n        tempVariable1 = __lshift(doubleValue,tempVariable1,1);\n      }\nLAB_08008108:\n      normalizedLength = quorem(normalizedDouble,normalizedExponentOffset);\n      exponentBits = __mcmp(normalizedDouble,globalVar7);\n      exponentDiff = __mdiff(doubleValue,normalizedExponentOffset,tempVariable1);\n      tempVariable2 = normalizedLength + 0x30;\n      if (*(int *)(exponentDiff + 0xc) == 0) {\n        tmpExponent = __mcmp(normalizedDouble);\n        _Bfree(doubleValue,exponentDiff);\n        if ((tmpExponent != 0) || (digits != 0)) goto LAB_0800815a;\n        if ((signBit & 1) != 0) {\n          tmpExponent = 0;\n          goto LAB_0800815a;\n        }\n        if (tempVariable2 != 0x39) {\n          if (0 < exponentBits) goto LAB_0800874c;\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pcVar21 = pcVar20 + 1;\n        digit = '9';\n        *pcVar20 = '9';\n        goto LAB_08008268;\n      }\n      _Bfree(doubleValue,exponentDiff);\n      tmpExponent = 1;\nLAB_0800815a:\n      if ((exponentBits < 0) || (((exponentBits == 0 && (digits == 0)) && ((signBit & 1) == 0)))) {\n        if (0 < tmpExponent) {\n          normalizedDouble = __lshift(doubleValue,normalizedDouble,1);\n          exponentBits = __mcmp(normalizedDouble,normalizedExponentOffset);\n          if ((0 < exponentBits) || ((exponentBits == 0 && (normalizedLength << 0x1f < 0)))) {\n            if (tempVariable2 == 0x39) goto LAB_08008752;\nLAB_0800874c:\n            tempVariable2 = normalizedLength + 0x31;\n          }\n        }\nLAB_080085a4:\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)tempVariable2;\n        goto LAB_08008274;\n      }\n      pcVar21 = pcVar20 + 1;\n      if (0 < tmpExponent) {\n        if (tempVariable2 == 0x39) goto LAB_08008752;\n        *pcVar20 = (char)normalizedLength + '1';\n        goto LAB_08008274;\n      }\n      *pcVar20 = (char)tempVariable2;\n      if (resultString + (globalVar11 - 1) != pcVar20) {\n        normalizedDouble = __multadd(doubleValue,normalizedDouble,10,0);\n        pcVar20 = pcVar21;\n        if (globalVar7 == tempVariable1) {\n          globalVar7 = __multadd(doubleValue,globalVar7,10,0);\n          tempVariable1 = globalVar7;\n        }\n        else {\n          globalVar7 = __multadd(doubleValue,globalVar7,10,0);\n          tempVariable1 = __multadd(doubleValue,tempVariable1,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    else {\nLAB_0800820a:\n      while( true ) {\n        tempVariable2 = quorem(normalizedDouble,normalizedExponentOffset);\n        tempVariable2 = tempVariable2 + 0x30;\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)tempVariable2;\n        if ((int)globalVar11 <= (int)pcVar21 - (int)resultString) break;\n        normalizedDouble = __multadd(doubleValue,normalizedDouble,10,0);\n        pcVar20 = pcVar21;\n      }\n      globalVar7 = 0;\n    }\n    normalizedDouble = __lshift(doubleValue,normalizedDouble,1);\n    normalizedLength = __mcmp(normalizedDouble,normalizedExponentOffset);\n    digit = pcVar21[-1];\n    if ((0 < normalizedLength) || ((normalizedLength == 0 && (tempVariable2 << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pcVar20 = pcVar21 + -1;\n        if (digit != '9') goto code_r0x08008270;\n        if (resultString == pcVar20) {\n          *resultString = '1';\n          globalVar9 = globalVar9 + 1;\n          goto LAB_08008274;\n        }\n        digit = pcVar21[-2];\n        pcVar21 = pcVar20;\n      } while( true );\n    }\n    while (digit == '0') {\n      digit = pcVar21[-2];\n      pcVar21 = pcVar21 + -1;\n    }\nLAB_08008274:\n    _Bfree(doubleValue,normalizedExponentOffset);\n    if (tempVariable1 == 0) goto LAB_08008294;\n    if ((globalVar7 != 0) && (globalVar7 != tempVariable1)) {\n      _Bfree(doubleValue);\n    }\n  }\n  _Bfree(doubleValue,tempVariable1);\nLAB_08008294:\n  _Bfree(doubleValue,normalizedDouble);\n  *pcVar21 = '\\0';\n  *outputLength = globalVar9 + 1;\n  if (outputString == (char **)0x0) {\n    return resultString;\n  }\n  *outputString = pcVar21;\n  return resultString;\ncode_r0x08008270:\n  *pcVar20 = digit + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "renaming": {
                "FUN_080079e8": "convert_double_to_string_080079e8",
                "param_1": "doubleValue",
                "param_2": "param2",
                "param_3": "signBit",
                "param_4": "exponent",
                "param_5": "digits",
                "param_6": "precision",
                "param_7": "outputLength",
                "param_8": "returnSign",
                "param_9": "outputString",
                "bVar1": "useInfinity",
                "bVar2": "roundUp",
                "bVar3": "useNaN",
                "cVar4": "digit",
                "bVar5": "comparisonResult",
                "uVar6": "normalizedDouble",
                "iVar7": "exponentBits",
                "iVar8": "tmpExponent",
                "iVar9": "exponentDiff",
                "pcVar10": "resultString",
                "uVar11": "normalizedExponent",
                "uVar12": "tmp1",
                "uVar13": "tmp2",
                "uVar16": "tmp3",
                "uVar17": "normalizedValue",
                "uVar18": "absoluteExponent",
                "iVar15": "normalizedLength",
                "iVar14": "normalizedExponentOffset",
                "iVar19": "tempVariable1",
                "iVar24": "tempVariable2",
                "uVar26": "tempVariable3",
                "uVar27": "tempVariable4",
                "uVar28": "tempVariable5",
                "local_80": "globalVar7",
                "local_7c": "globalVar8",
                "local_74": "globalVar9",
                "local_70": "globalVar10",
                "local_68": "globalVar11",
                "local_60": "globalVar12",
                "local_5c": "globalVar13",
                "local_58": "globalVar14",
                "local_48": "globalVar15",
                "uStack_44": "globalVar16",
                "local_38": "globalVar17",
                "local_34": "globalVar18",
                "local_30": "globalVar19",
                "uVar23": "globalVar3"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "_Bfree",
                "__floatunsidf",
                "memcpy",
                "quorem",
                "__aeabi_dcmplt",
                "__multiply",
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt",
                "_Balloc",
                "__pow5mult",
                "__i2b",
                "__mcmp",
                "__hi0bits",
                "__aeabi_dcmpeq",
                "__d2b",
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "__aeabi_i2d",
                "__aeabi_d2iz",
                "__subdf3",
                "__mdiff",
                "__multadd",
                "__lshift"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800884c": {
            "entrypoint": "0x0800884c",
            "current_name": "allocate_memory_block_0800884c",
            "code": "\nundefined4 allocate_memory_block_0800884c(undefined4 lock,int size)\n\n{\n  int result;\n  int aligned_address;\n  uint old_size;\n  \n  __malloc_lock();\n  old_size = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  aligned_address = ((0xfef - size) + old_size & 0xfffff000) - 0x1000;\n  if (0xfff < aligned_address) {\n    result = increase_heap(lock,0);\n    if (result == DAT_20000454 + old_size) {\n      result = increase_heap(lock,-aligned_address);\n      if (result != -1) {\n        DAT_20000a14 = DAT_20000a14 - aligned_address;\n        *(uint *)(DAT_20000454 + 4) = old_size - aligned_address | 1;\n        __malloc_unlock(lock);\n        return 1;\n      }\n      aligned_address = increase_heap(lock,0);\n      if (0xf < aligned_address - DAT_20000454) {\n        DAT_20000a14 = aligned_address - DAT_20000854;\n        *(uint *)(DAT_20000454 + 4) = aligned_address - DAT_20000454 | 1;\n      }\n    }\n  }\n  __malloc_unlock(lock);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800884c": "allocate_memory_block_0800884c",
                "param_1": "lock",
                "param_2": "size",
                "iVar1": "result",
                "iVar2": "aligned_address",
                "uVar3": "old_size",
                "_sbrk_r": "increase_heap"
            },
            "calling": [
                "_free_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088ec": {
            "entrypoint": "0x080088ec",
            "current_name": "reallocate_memory_080088ec",
            "code": "\nvoid reallocateMemory_080088ec(undefined4 lock,int ptr,undefined4 param_3,undefined4 param_4)\n\n{\n  int index;\n  uint *prevBlock;\n  uint *currBlock;\n  undefined *prevPtr;\n  uint totalSize;\n  uint chunkSize;\n  undefined *prevChunk;\n  undefined *nextChunk;\n  undefined4 *prevMetadata;\n  int metadataIndex;\n  uint metadata;\n  uint nextMetadata;\n  \n  if (ptr == 0) {\n    return;\n  }\n  __malloc_lock();\n  metadata = *(uint *)(ptr + -4);\n  prevBlock = (uint *)(ptr + -8);\n  totalSize = metadata & 0xfffffffe;\n  currBlock = (uint *)((int)prevBlock + totalSize);\n  chunkSize = currBlock[1] & 0xfffffffc;\n  if (DAT_20000454 == currBlock) {\n    totalSize = totalSize + chunkSize;\n    if ((metadata & 1) == 0) {\n      prevBlock = (uint *)((int)prevBlock - *(int *)(ptr + -8));\n      chunkSize = prevBlock[2];\n      metadata = prevBlock[3];\n      totalSize = totalSize + *(int *)(ptr + -8);\n      *(uint *)(chunkSize + 0xc) = metadata;\n      *(uint *)(metadata + 8) = chunkSize;\n    }\n    chunkSize = DAT_20000858;\n    prevBlock[1] = totalSize | 1;\n    DAT_20000454 = prevBlock;\n    if (chunkSize <= totalSize) {\n      _malloc_trim_r(lock,DAT_20000a44);\n    }\nLAB_080089f0:\n    __malloc_unlock(lock);\n    return;\n  }\n  currBlock[1] = chunkSize;\n  if ((metadata & 1) == 0) {\n    prevBlock = (uint *)((int)prevBlock - *(int *)(ptr + -8));\n    prevMetadata = (undefined4 *)prevBlock[2];\n    totalSize = totalSize + *(int *)(ptr + -8);\n    metadata = *(uint *)((int)currBlock + chunkSize + 4) & 1;\n    if ((uint **)prevMetadata == &DAT_20000454) {\n      if (metadata == 0) {\n        metadata = currBlock[2];\n        nextMetadata = currBlock[3];\n        totalSize = totalSize + chunkSize;\n        *(uint *)(metadata + 0xc) = nextMetadata;\n        *(uint *)(nextMetadata + 8) = metadata;\n        prevBlock[1] = totalSize | 1;\n        *(uint *)((int)prevBlock + totalSize) = totalSize;\n      }\n      else {\n        prevBlock[1] = totalSize | 1;\n        *currBlock = totalSize;\n      }\n      goto LAB_080089f0;\n    }\n    nextMetadata = prevBlock[3];\n    prevMetadata[3] = nextMetadata;\n    *(undefined4 **)(nextMetadata + 8) = prevMetadata;\n  }\n  else {\n    metadata = *(uint *)((int)currBlock + chunkSize + 4) & 1;\n  }\n  if (metadata == 0) {\n    prevMetadata = (undefined4 *)currBlock[2];\n    totalSize = totalSize + chunkSize;\n    if ((uint **)prevMetadata == &DAT_20000454) {\n      DAT_2000045c = prevBlock;\n      DAT_20000460 = prevBlock;\n      prevBlock[2] = (uint)&DAT_20000454;\n      prevBlock[3] = (uint)&DAT_20000454;\n      prevBlock[1] = totalSize | 1;\n      *(uint *)((int)prevBlock + totalSize) = totalSize;\n      goto LAB_080089f0;\n    }\n    chunkSize = currBlock[3];\n    prevMetadata[3] = chunkSize;\n    *(undefined4 **)(chunkSize + 8) = prevMetadata;\n    prevBlock[1] = totalSize | 1;\n    *(uint *)((int)prevBlock + totalSize) = totalSize;\n  }\n  else {\n    prevBlock[1] = totalSize | 1;\n    *(uint *)((int)prevBlock + totalSize) = totalSize;\n  }\n  if (totalSize < 0x200) {\n    metadataIndex = (totalSize >> 3) + 1;\n    totalSize = 1 << ((int)(totalSize >> 3) >> 2 & 0xffU) | (uint)DAT_20000450;\n    chunkSize = *(uint *)(&DAT_2000044c + metadataIndex * 8);\n    prevBlock[2] = chunkSize;\n    prevBlock[3] = (uint)(&DAT_20000444 + metadataIndex * 8);\n    DAT_20000450 = (undefined *)totalSize;\n    *(uint **)(&DAT_2000044c + metadataIndex * 8) = prevBlock;\n    *(uint **)(chunkSize + 0xc) = prevBlock;\n    __malloc_unlock(lock,prevBlock,totalSize,param_4);\n    return;\n  }\n  chunkSize = totalSize >> 9;\n  if (chunkSize < 5) {\n    metadataIndex = ((totalSize >> 6) + 0x39) * 8;\n    index = (totalSize >> 6) + 0x38;\n  }\n  else if (chunkSize < 0x15) {\n    metadataIndex = (chunkSize + 0x5c) * 8;\n    index = chunkSize + 0x5b;\n  }\n  else if (chunkSize < 0x55) {\n    metadataIndex = ((totalSize >> 0xc) + 0x6f) * 8;\n    index = (totalSize >> 0xc) + 0x6e;\n  }\n  else if (chunkSize < 0x155) {\n    metadataIndex = ((totalSize >> 0xf) + 0x78) * 8;\n    index = (totalSize >> 0xf) + 0x77;\n  }\n  else if (chunkSize < 0x555) {\n    metadataIndex = ((totalSize >> 0x12) + 0x7d) * 8;\n    index = (totalSize >> 0x12) + 0x7c;\n  }\n  else {\n    metadataIndex = 0x3f8;\n    index = 0x7e;\n  }\n  prevPtr = *(undefined **)(&DAT_2000044c + metadataIndex);\n  prevChunk = &DAT_20000444 + metadataIndex;\n  if (prevChunk == prevPtr) {\n    prevPtr = (undefined *)(1 << (index >> 2 & 0xffU) | (uint)DAT_20000450);\n    nextChunk = prevChunk;\n    DAT_20000450 = prevPtr;\n  }\n  else {\n    do {\n      nextChunk = prevPtr;\n      if ((*(uint *)(prevPtr + 4) & 0xfffffffc) <= totalSize) break;\n      prevPtr = *(undefined **)(prevPtr + 8);\n      nextChunk = prevChunk;\n    } while (prevChunk != prevPtr);\n    prevChunk = *(undefined **)(nextChunk + 0xc);\n  }\n  prevBlock[2] = (uint)nextChunk;\n  prevBlock[3] = (uint)prevChunk;\n  *(uint **)(prevChunk + 8) = prevBlock;\n  *(uint **)(nextChunk + 0xc) = prevBlock;\n  __malloc_unlock(lock,prevBlock,prevPtr,param_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088ec": "reallocate_memory_080088ec",
                "param_1": "lock",
                "param_2": "ptr",
                "iVar1": "index",
                "puVar2": "prevBlock",
                "puVar3": "currBlock",
                "puVar4": "prevPtr",
                "puVar7": "prevChunk",
                "puVar8": "nextChunk",
                "puVar9": "prevMetadata",
                "iVar10": "metadataIndex",
                "uVar5": "totalSize",
                "uVar6": "chunkSize",
                "uVar11": "metadata",
                "uVar12": "nextMetadata"
            },
            "calling": [
                "_malloc_r",
                "__ssprint_r",
                "_svfprintf_r",
                "_realloc_r"
            ],
            "called": [
                "_malloc_trim_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ad4": {
            "entrypoint": "0x08008ad4",
            "current_name": "get_updated_value_08008ad4",
            "code": "\nint getUpdatedValue_08008ad4(void)\n\n{\n  int currentValue;\n  \n  currentValue = *(int *)(DAT_2000001c + 0x34);\n  if (currentValue == 0) {\n    currentValue = 0x2000085c;\n  }\n  return currentValue + 0xf0;\n}\n\n",
            "renaming": {
                "FUN_08008ad4": "get_updated_value_08008ad4",
                "iVar1": "currentValue"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "FUNC_08008af0",
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_lock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af4": {
            "entrypoint": "0x08008af4",
            "current_name": "FUNC_08008af4",
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af8": {
            "entrypoint": "0x08008af8",
            "current_name": "allocate_memory_08008af8",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_memory_08008af8(undefined4 *param_1,uint size)\n\n{\n  undefined *ptr;\n  uint rounded_size;\n  uint difference;\n  int index;\n  undefined *current_block;\n  uint block_size;\n  uint mask;\n  undefined4 *temp_block;\n  undefined *alloc_block;\n  undefined *block_header;\n  int *allocated_memory;\n  uint block_size;\n  uint rounded_size;\n  int prev_index;\n  undefined4 *new_block;\n  undefined4 *temp_block;\n  \n  block_size = size + 0xb;\n  if (block_size < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    __malloc_lock();\n    rounded_size = 0x10;\n    index = 0x18;\n    block_size = 2;\nLAB_08008b18:\n    block_header = *(undefined **)((int)&DAT_20000450 + index);\n    if ((block_header != &DAT_20000444 + index) ||\n       (block_header = *(undefined **)((int)&DAT_20000458 + index), &DAT_2000044c + index != block_header)) {\n      index = *(int *)(block_header + 0xc);\n      current_block = block_header + (*(uint *)(block_header + 4) & 0xfffffffc);\n      block_size = *(uint *)(current_block + 4);\nLAB_08008b34:\n      prev_index = *(int *)(block_header + 8);\n      *(int *)(prev_index + 0xc) = index;\n      *(int *)(index + 8) = prev_index;\n      *(uint *)(current_block + 4) = block_size | 1;\n      __malloc_unlock(param_1);\n      return (int *)(block_header + 8);\n    }\n    block_size = block_size + 2;\n  }\n  else {\n    rounded_size = block_size & 0xfffffff8;\n    if (((int)rounded_size < 0) || (rounded_size < size)) {\nLAB_08008c7a:\n      *param_1 = 0xc;\n      return (int *)0x0;\n    }\n    __malloc_lock();\n    if (rounded_size < 0x1f8) {\n      block_size = block_size >> 3;\n      index = rounded_size + 8;\n      goto LAB_08008b18;\n    }\n    rounded_size = block_size >> 9;\n    if (rounded_size == 0) {\n      index = 0x200;\n      block_size = 0x40;\n      rounded_size = 0x3f;\n    }\n    else if (rounded_size < 5) {\n      block_size = (block_size >> 6) + 0x39;\n      rounded_size = (block_size >> 6) + 0x38;\n      index = block_size * 8;\n    }\n    else if (rounded_size < 0x15) {\n      block_size = rounded_size + 0x5c;\n      rounded_size = rounded_size + 0x5b;\n      index = block_size * 8;\n    }\n    else if (rounded_size < 0x55) {\n      block_size = (block_size >> 0xc) + 0x6f;\n      rounded_size = (block_size >> 0xc) + 0x6e;\n      index = block_size * 8;\n    }\n    else if (rounded_size < 0x155) {\n      block_size = (block_size >> 0xf) + 0x78;\n      rounded_size = (block_size >> 0xf) + 0x77;\n      index = block_size * 8;\n    }\n    else if (rounded_size < 0x555) {\n      block_size = (block_size >> 0x12) + 0x7d;\n      rounded_size = (block_size >> 0x12) + 0x7c;\n      index = block_size * 8;\n    }\n    else {\n      index = 0x3f8;\n      block_size = 0x7f;\n      rounded_size = 0x7e;\n    }\n    for (block_header = *(undefined **)((int)&DAT_20000450 + index); block_size = block_size,\n        &DAT_20000444 + index != block_header; block_header = *(undefined **)(block_header + 0xc)) {\n      prev_index = (*(uint *)(block_header + 4) & 0xfffffffc) - rounded_size;\n      block_size = rounded_size;\n      if (0xf < prev_index) break;\n      if (-1 < prev_index) {\n        current_block = block_header + (*(uint *)(block_header + 4) & 0xfffffffc);\n        block_size = *(uint *)(current_block + 4);\n        index = *(int *)(block_header + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  new_block = DAT_2000045c;\n  if ((undefined **)DAT_2000045c == &DAT_20000454) {\n    block_size = 1 << ((int)block_size >> 2 & 0xffU);\n    rounded_size = DAT_20000450;\n    if (block_size <= DAT_20000450) goto LAB_08008c06;\n  }\n  else {\n    block_size = DAT_2000045c[1];\n    mask = block_size & 0xfffffffc;\n    rounded_size = mask - rounded_size;\n    if (0xf < (int)rounded_size) {\n      temp_block = (undefined4 *)(rounded_size + (int)DAT_2000045c);\n      DAT_2000045c[1] = rounded_size | 1;\n      DAT_2000045c = temp_block;\n      DAT_20000460 = temp_block;\n      temp_block[2] = &DAT_20000454;\n      temp_block[3] = &DAT_20000454;\n      temp_block[1] = rounded_size | 1;\n      *(uint *)((int)new_block + mask) = rounded_size;\n      __malloc_unlock(param_1);\n      return new_block + 2;\n    }\n    DAT_2000045c = &DAT_20000454;\n    DAT_20000460 = &DAT_20000454;\n    if (-1 < (int)rounded_size) {\n      *(uint *)((int)new_block + mask + 4) = *(uint *)((int)new_block + mask + 4) | 1;\n      __malloc_unlock(param_1);\n      return new_block + 2;\n    }\n    if (mask < 0x200) {\n      index = (block_size >> 3) + 1;\n      prev_index = *(int *)(&DAT_2000044c + index * 8);\n      rounded_size = 1 << ((int)(block_size >> 3) >> 2 & 0xffU) | DAT_20000450;\n      new_block[2] = prev_index;\n      new_block[3] = &DAT_20000444 + index * 8;\n      DAT_20000450 = rounded_size;\n      *(undefined4 **)(&DAT_2000044c + index * 8) = new_block;\n      *(undefined4 **)(prev_index + 0xc) = new_block;\n    }\n    else {\n      rounded_size = block_size >> 9;\n      if (rounded_size < 5) {\n        index = ((block_size >> 6) + 0x39) * 8;\n        prev_index = (block_size >> 6) + 0x38;\n      }\n      else if (rounded_size < 0x15) {\n        index = (rounded_size + 0x5c) * 8;\n        prev_index = rounded_size + 0x5b;\n      }\n      else if (rounded_size < 0x55) {\n        index = ((block_size >> 0xc) + 0x6f) * 8;\n        prev_index = (block_size >> 0xc) + 0x6e;\n      }\n      else if (rounded_size < 0x155) {\n        index = ((block_size >> 0xf) + 0x78) * 8;\n        prev_index = (block_size >> 0xf) + 0x77;\n      }\n      else if (rounded_size < 0x555) {\n        index = ((block_size >> 0x12) + 0x7d) * 8;\n        prev_index = (block_size >> 0x12) + 0x7c;\n      }\n      else {\n        index = 0x3f8;\n        prev_index = 0x7e;\n      }\n      block_header = *(undefined **)(&DAT_2000044c + index);\n      current_block = &DAT_20000444 + index;\n      if (current_block == block_header) {\n        DAT_20000450 = 1 << (prev_index >> 2 & 0xffU) | DAT_20000450;\n      }\n      else {\n        do {\n          if ((*(uint *)(block_header + 4) & 0xfffffffc) <= mask) break;\n          block_header = *(undefined **)(block_header + 8);\n        } while (current_block != block_header);\n        current_block = *(undefined **)(block_header + 0xc);\n      }\n      rounded_size = DAT_20000450;\n      new_block[2] = block_header;\n      new_block[3] = current_block;\n      *(undefined4 **)(current_block + 8) = new_block;\n      *(undefined4 **)(block_header + 0xc) = new_block;\n    }\n    block_size = 1 << ((int)block_size >> 2 & 0xffU);\n    if (block_size <= rounded_size) {\nLAB_08008c06:\n      if ((block_size & rounded_size) == 0) {\n        block_size = block_size & 0xfffffffc;\n        do {\n          block_size = block_size << 1;\n          block_size = block_size + 4;\n        } while ((block_size & rounded_size) == 0);\n      }\n      do {\n        temp_block = (undefined4 *)(&DAT_2000044c + block_size * 8);\n        rounded_size = block_size;\n        new_block = temp_block;\n        do {\n          for (temp_block = (undefined4 *)new_block[3]; new_block != temp_block;\n              temp_block = (undefined4 *)temp_block[3]) {\n            mask = temp_block[1] & 0xfffffffc;\n            difference = mask - rounded_size;\n            if (0xf < (int)difference) {\n              prev_index = temp_block[2];\n              index = temp_block[3];\n              new_block = (undefined4 *)(rounded_size + (int)temp_block);\n              temp_block[1] = rounded_size | 1;\n              *(int *)(prev_index + 0xc) = index;\n              *(int *)(index + 8) = prev_index;\n              DAT_2000045c = new_block;\n              DAT_20000460 = new_block;\n              new_block[2] = &DAT_20000454;\n              new_block[3] = &DAT_20000454;\n              new_block[1] = difference | 1;\n              *(uint *)((int)temp_block + mask) = difference;\n              __malloc_unlock(param_1);\n              return temp_block + 2;\n            }\n            if (-1 < (int)difference) {\n              index = temp_block[3];\n              prev_index = temp_block[2];\n              *(uint *)((int)temp_block + mask + 4) = *(uint *)((int)temp_block + mask + 4) | 1;\n              *(int *)(prev_index + 0xc) = index;\n              *(int *)(index + 8) = prev_index;\n              __malloc_unlock(param_1);\n              return temp_block + 2;\n            }\n          }\n          rounded_size = rounded_size + 1;\n          new_block = new_block + 2;\n        } while ((rounded_size & 3) != 0);\n        do {\n          mask = block_size & 3;\n          new_block = temp_block + -2;\n          block_size = block_size - 1;\n          if (mask == 0) {\n            DAT_20000450 = DAT_20000450 & ~block_size;\n            break;\n          }\n          temp_block = (undefined4 *)*temp_block;\n        } while (temp_block == new_block);\n        block_size = block_size * 2;\n        if ((DAT_20000450 <= block_size && block_size - DAT_20000450 != 0) || (block_size = rounded_size, block_size == 0))\n        break;\n        for (; (block_size & DAT_20000450) == 0; block_size = block_size << 1) {\n          block_size = block_size + 4;\n        }\n      } while( true );\n    }\n  }\n  block_header = DAT_20000454;\n  block_size = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  if ((rounded_size <= block_size) && (rounded_size = block_size - rounded_size, 0xf < (int)rounded_size)) goto LAB_08008dac;\n  if (DAT_20000854 == (undefined *)0xffffffff) {\n    rounded_size = rounded_size + DAT_20000a44 + 0x10;\n  }\n  else {\n    rounded_size = rounded_size + DAT_20000a44 + 0x100f & 0xfffff000;\n  }\n  current_block = (undefined *)_sbrk_r(param_1,rounded_size);\n  if (current_block == (undefined *)0xffffffff) {\nLAB_08008ed8:\n    block_size = *(uint *)(DAT_20000454 + 4);\n  }\n  else {\n    ptr = block_header + block_size;\n    if (ptr < current_block || ptr == current_block) {\n      alloc_block = DAT_20000a14 + rounded_size;\n      if ((ptr != current_block) || (((uint)ptr & 0xfff) != 0)) goto LAB_08008d02;\n      DAT_20000a14 = alloc_block;\n      *(uint *)(DAT_20000454 + 4) = block_size + rounded_size | 1;\n    }\n    else {\n      if (block_header != &DAT_2000044c) goto LAB_08008ed8;\nLAB_08008d02:\n      DAT_20000a14 = DAT_20000a14 + rounded_size;\n      alloc_block = current_block;\n      if (DAT_20000854 != (undefined *)0xffffffff) {\n        DAT_20000a14 = DAT_20000a14 + ((int)current_block - (int)ptr);\n        alloc_block = DAT_20000854;\n      }\n      DAT_20000854 = alloc_block;\n      block_size = (uint)current_block & 7;\n      if (block_size == 0) {\n        index = 0x1000;\n      }\n      else {\n        current_block = current_block + (8 - block_size);\n        index = 0x1008 - block_size;\n      }\n      index = index - ((uint)(current_block + rounded_size) & 0xfff);\n      prev_index = _sbrk_r(param_1,index);\n      if (prev_index == -1) {\n        rounded_size = 1;\n        index = 0;\n      }\n      else {\n        rounded_size = (prev_index - (int)current_block) + index | 1;\n      }\n      alloc_block = DAT_20000a14 + index;\n      DAT_20000454 = current_block;\n      DAT_20000a14 = alloc_block;\n      *(uint *)(current_block + 4) = rounded_size;\n      if (block_header != &DAT_2000044c) {\n        if (block_size < 0x10) {\n          *(undefined4 *)(current_block + 4) = 1;\n          goto LAB_08008eee;\n        }\n        block_size = block_size - 0xc & 0xfffffff8;\n        *(uint *)(block_header + 4) = *(uint *)(block_header + 4) & 1 | block_size;\n        *(undefined4 *)(block_header + block_size + 4) = 5;\n        *(undefined4 *)(block_header + block_size + 8) = 5;\n        if (0xf < block_size) {\n          _free_r(param_1,block_header + 8);\n          alloc_block = DAT_20000a14;\n        }\n      }\n    }\n    if (DAT_20000a3c < alloc_block) {\n      DAT_20000a3c = alloc_block;\n    }\n    block_size = *(uint *)(DAT_20000454 + 4);\n    if (DAT_20000a40 < alloc_block) {\n      DAT_20000a40 = alloc_block;\n    }\n  }\n  rounded_size = (block_size & 0xfffffffc) - rounded_size;\n  if ((rounded_size <= (block_size & 0xfffffffc)) && (0xf < (int)rounded_size)) {\nLAB_08008dac:\n    block_header = DAT_20000454 + rounded_size;\n    *(uint *)(DAT_20000454 + 4) = rounded_size | 1;\n    allocated_memory = (int *)(DAT_20000454 + 8);\n    DAT_20000454 = block_header;\n    *(uint *)(block_header + 4) = rounded_size | 1;\n    __malloc_unlock(param_1);\n    return allocated_memory;\n  }\nLAB_08008eee:\n  __malloc_unlock(param_1);\n  return (int *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08008af8": "allocate_memory_08008af8",
                "param_2": "size",
                "puVar1": "ptr",
                "uVar2": "rounded_size",
                "uVar3": "difference",
                "iVar4": "index",
                "puVar5": "current_block",
                "uVar6": "block_size",
                "uVar7": "mask",
                "puVar8": "temp_block",
                "puVar9": "alloc_block",
                "puVar10": "block_header",
                "piVar11": "allocated_memory",
                "uVar12": "block_size",
                "uVar13": "rounded_size",
                "iVar14": "prev_index",
                "puVar15": "new_block",
                "puVar16": "temp_block"
            },
            "calling": [
                "_calloc_r",
                "__ssprint_r",
                "_svfprintf_r",
                "_realloc_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "_free_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800901c": {
            "entrypoint": "0x0800901c",
            "current_name": "find_first_match_0800901c",
            "code": "\nuint * find_first_match_0800901c(uint *array,uint search_value,uint array_length)\n\n{\n  uint result;\n  uint combined_value;\n  uint *current_ptr;\n  uint search_byte;\n  bool finished_search;\n  \n  search_byte = search_value & 0xff;\n  if (((uint)array & 3) == 0) {\nLAB_0800904a:\n    if (3 < array_length) {\n      combined_value = (search_value & 0xff) << 8 | search_byte;\n      current_ptr = array;\n      do {\n        result = *current_ptr ^ (combined_value | combined_value << 0x10);\n        array = current_ptr + 1;\n        if ((result + 0xfefefeff & ~result & 0x80808080) != 0) goto LAB_08009050;\n        array_length = array_length - 4;\n        current_ptr = array;\n      } while (3 < array_length);\n    }\n    current_ptr = array;\n    if (array_length == 0) {\n      array = (uint *)0x0;\n    }\n    else {\nLAB_08009050:\n      array = current_ptr;\n      if (*(byte *)array != search_byte) {\n        current_ptr = (uint *)(array_length + (int)array);\n        do {\n          array = (uint *)((int)array + 1);\n          if (current_ptr == array) goto LAB_0800906c;\n        } while (*(byte *)array != search_byte);\n      }\n    }\n  }\n  else {\n    combined_value = array_length - 1;\n    if (array_length == 0) {\nLAB_0800906c:\n      array = (uint *)0x0;\n    }\n    else if (*(byte *)array != search_byte) {\n      current_ptr = (uint *)((int)array + 1);\n      do {\n        array = current_ptr;\n        array_length = combined_value;\n        if (((uint)array & 3) == 0) goto LAB_0800904a;\n        finished_search = combined_value == 0;\n        combined_value = combined_value - 1;\n        if (finished_search) goto LAB_0800906c;\n        current_ptr = (uint *)((int)array + 1);\n      } while (*(byte *)array != search_byte);\n    }\n  }\n  return array;\n}\n\n",
            "renaming": {
                "FUN_0800901c": "find_first_match_0800901c",
                "param_1": "array",
                "param_2": "search_value",
                "param_3": "array_length",
                "uVar1": "result",
                "uVar2": "combined_value",
                "puVar3": "current_ptr",
                "uVar4": "search_byte",
                "bVar5": "finished_search"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090a8": {
            "entrypoint": "0x080090a8",
            "current_name": "acquire_recursive_lock_080090a8",
            "code": "\nvoid acquire_recursive_lock_080090a8(void)\n\n{\n  __retarget_lock_acquire_recursive(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090a8": "acquire_recursive_lock_080090a8"
            },
            "calling": [
                "_malloc_trim_r",
                "_malloc_r",
                "_free_r",
                "_realloc_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "release_recursive_lock_080090b4",
            "code": "\nvoid releaseRecursiveLock_080090b4(void)\n\n{\n  __retarget_lock_release_recursive(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "release_recursive_lock_080090b4"
            },
            "calling": [
                "_malloc_trim_r",
                "_malloc_r",
                "_realloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c0": {
            "entrypoint": "0x080090c0",
            "current_name": "allocate_or_retrieve_item_080090c0",
            "code": "\nundefined4 * allocateOrRetrieveItem_080090c0(int itemArray,uint index)\n\n{\n  undefined4 *item;\n  int arrayPointer;\n  \n  arrayPointer = *(int *)(itemArray + 0x4c);\n  if (arrayPointer == 0) {\n    arrayPointer = _calloc_r(itemArray,4,0x21);\n    *(int *)(itemArray + 0x4c) = arrayPointer;\n    if (arrayPointer == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  item = *(undefined4 **)(arrayPointer + index * 4);\n  if (item == (undefined4 *)0x0) {\n    arrayPointer = 1 << (index & 0xff);\n    item = (undefined4 *)_calloc_r(itemArray,1,(arrayPointer + 5) * 4);\n    if (item == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    item[1] = index;\n    item[2] = arrayPointer;\n  }\n  else {\n    *(undefined4 *)(arrayPointer + index * 4) = *item;\n  }\n  item[3] = 0;\n  item[4] = 0;\n  return item;\n}\n\n",
            "renaming": {
                "FUN_080090c0": "allocate_or_retrieve_item_080090c0",
                "param_1": "itemArray",
                "param_2": "index",
                "puVar1": "item",
                "iVar2": "arrayPointer"
            },
            "calling": [
                "__d2b",
                "_dtoa_r",
                "__multiply",
                "__i2b",
                "__mdiff",
                "__pow5mult",
                "__multadd",
                "__lshift"
            ],
            "called": [
                "_calloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800910c": {
            "entrypoint": "0x0800910c",
            "current_name": "update_pointer_value_0800910c",
            "code": "\nvoid updatePointerValue_0800910c(int pointerListAddress,undefined4 *selectedPointer)\n\n{\n  int pointerList;\n  \n  if (selectedPointer != (undefined4 *)0x0) {\n    pointerList = *(int *)(pointerListAddress + 0x4c);\n    *selectedPointer = *(undefined4 *)(pointerList + selectedPointer[1] * 4);\n    *(undefined4 **)(pointerList + selectedPointer[1] * 4) = selectedPointer;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800910c": "update_pointer_value_0800910c",
                "param_1": "pointerListAddress",
                "param_2": "selectedPointer",
                "iVar1": "pointerList"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009120": {
            "entrypoint": "0x08009120",
            "current_name": "calculate_new_values_08009120",
            "code": "\nundefined4 * calculateNewValues_08009120(int param1,undefined4 *inputArray,int multiplier,uint accumulator)\n\n{\n  undefined4 *outputArray;\n  uint tempValue;\n  int arrayLength;\n  uint *arrayPointer;\n  int iterationCount;\n  \n  iterationCount = 0;\n  arrayLength = inputArray[4];\n  arrayPointer = inputArray + 5;\n  do {\n    iterationCount = iterationCount + 1;\n    accumulator = multiplier * (*arrayPointer & 0xffff) + accumulator;\n    tempValue = multiplier * (*arrayPointer >> 0x10) + (accumulator >> 0x10);\n    *arrayPointer = (accumulator & 0xffff) + tempValue * 0x10000;\n    accumulator = tempValue >> 0x10;\n    arrayPointer = arrayPointer + 1;\n  } while (iterationCount < arrayLength);\n  outputArray = inputArray;\n  if (accumulator != 0) {\n    if ((int)inputArray[2] <= arrayLength) {\n      outputArray = (undefined4 *)_Balloc(param1,inputArray[1] + 1);\n      memcpy(outputArray + 3,inputArray + 3,(inputArray[4] + 2) * 4);\n      iterationCount = *(int *)(param1 + 0x4c);\n      *inputArray = *(undefined4 *)(iterationCount + inputArray[1] * 4);\n      *(undefined4 **)(iterationCount + inputArray[1] * 4) = inputArray;\n    }\n    outputArray[arrayLength + 5] = accumulator;\n    outputArray[4] = arrayLength + 1;\n  }\n  return outputArray;\n}\n\n",
            "renaming": {
                "FUN_08009120": "calculate_new_values_08009120",
                "param_1": "param1",
                "param_2": "inputArray",
                "param_3": "multiplier",
                "param_4": "accumulator",
                "puVar1": "outputArray",
                "uVar2": "tempValue",
                "iVar3": "arrayLength",
                "puVar4": "arrayPointer",
                "iVar5": "iterationCount"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "memcpy",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a4": {
            "entrypoint": "0x080091a4",
            "current_name": "count_leading_zeros_080091a4",
            "code": "\nint countLeadingZeros_080091a4(uint input)\n\n{\n  int leadingZeros;\n  \n  if ((input & 0xffff0000) == 0) {\n    input = input << 0x10;\n    leadingZeros = 0x10;\n  }\n  else {\n    leadingZeros = 0;\n  }\n  if ((input & 0xff000000) == 0) {\n    input = input << 8;\n    leadingZeros = leadingZeros + 8;\n  }\n  if ((input & 0xf0000000) == 0) {\n    input = input << 4;\n    leadingZeros = leadingZeros + 4;\n  }\n  if ((input & 0xc0000000) == 0) {\n    input = input << 2;\n    leadingZeros = leadingZeros + 2;\n  }\n  if (-1 < (int)input) {\n    if ((int)(input << 1) < 0) {\n      return leadingZeros + 1;\n    }\n    leadingZeros = 0x20;\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_080091a4": "count_leading_zeros_080091a4",
                "param_1": "input",
                "iVar1": "leadingZeros"
            },
            "calling": [
                "__d2b",
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091e4": {
            "entrypoint": "0x080091e4",
            "current_name": "bit_count_080091e4",
            "code": "\nint bitCount_080091e4(uint *value)\n\n{\n  int count;\n  uint temp;\n  \n  temp = *value;\n  if ((temp & 7) == 0) {\n    if ((temp & 0xffff) == 0) {\n      temp = temp >> 0x10;\n      count = 0x10;\n    }\n    else {\n      count = 0;\n    }\n    if ((temp & 0xff) == 0) {\n      temp = temp >> 8;\n      count = count + 8;\n    }\n    if ((temp & 0xf) == 0) {\n      temp = temp >> 4;\n      count = count + 4;\n    }\n    if ((temp & 3) == 0) {\n      temp = temp >> 2;\n      count = count + 2;\n    }\n    if (-1 < (int)(temp << 0x1f)) {\n      temp = temp >> 1;\n      if (temp == 0) {\n        return 0x20;\n      }\n      count = count + 1;\n    }\n    *value = temp;\n    return count;\n  }\n  if ((int)(temp << 0x1f) < 0) {\n    return 0;\n  }\n  if (-1 < (int)(temp << 0x1e)) {\n    *value = temp >> 2;\n    return 2;\n  }\n  *value = temp >> 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080091e4": "bit_count_080091e4",
                "param_1": "value",
                "iVar1": "count",
                "uVar2": "temp"
            },
            "calling": [
                "__d2b"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009244": {
            "entrypoint": "0x08009244",
            "current_name": "initialize_memory_block_08009244",
            "code": "\nvoid initializeMemoryBlock_08009244(undefined4 blockSize,undefined4 data)\n\n{\n  int memoryBlock;\n  \n  memoryBlock = _Balloc(blockSize,1);\n  *(undefined4 *)(memoryBlock + 0x10) = 1;\n  *(undefined4 *)(memoryBlock + 0x14) = data;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009244": "initialize_memory_block_08009244",
                "param_1": "blockSize",
                "param_2": "data",
                "iVar1": "memoryBlock"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009258": {
            "entrypoint": "0x08009258",
            "current_name": "calculate_polynomial_product_08009258",
            "code": "\nvoid calculatePolynomialProduct_08009258(undefined4 outputBuffer,int polynomial1,int polynomial2)\n\n{\n  uint *tempVar1;\n  uint *tempVar2;\n  int allocatedSize;\n  uint partialProduct;\n  uint *bufferPtr;\n  uint bufferEndPtr;\n  uint *tempPtr1;\n  uint partialSum;\n  int polynomial1Size;\n  int polynomial2Size;\n  uint currentValue;\n  int polynomialSize1;\n  int polynomialSize2;\n  uint *currentPtr1;\n  uint *currentPtr2;\n  uint *tempPtr2;\n  uint *bufferEndPtr;\n  uint *bufferPtr;\n  \n  polynomialSize1 = *(int *)(polynomial1 + 0x10);\n  polynomial1Size = *(int *)(polynomial2 + 0x10);\n  polynomial2Size = polynomial1Size;\n  polynomialSize2 = polynomial1;\n  if (polynomialSize1 < polynomial1Size) {\n    polynomial2Size = polynomialSize1;\n    polynomialSize1 = polynomial1Size;\n    polynomialSize2 = polynomial2;\n    polynomial2 = polynomial1;\n  }\n  polynomial1Size = polynomialSize1 + polynomial2Size;\n  allocatedSize = *(int *)(polynomialSize2 + 4);\n  if (*(int *)(polynomialSize2 + 8) < polynomial1Size) {\n    allocatedSize = allocatedSize + 1;\n  }\n  allocatedSize = _Balloc(outputBuffer,allocatedSize);\n  bufferPtr = (uint *)(allocatedSize + 0x14);\n  bufferEndPtr = bufferPtr + polynomial1Size;\n  for (bufferPtr = bufferPtr; bufferPtr < bufferEndPtr; bufferPtr = bufferPtr + 1) {\n    *bufferPtr = 0;\n  }\n  bufferEndPtr = polynomial2 + 0x14;\n  currentValue = bufferEndPtr + polynomial2Size * 4;\n  bufferPtr = (uint *)(polynomialSize2 + 0x14);\n  if (bufferEndPtr < currentValue) {\n    tempPtr1 = (uint *)(bufferEndPtr + ((currentValue - polynomial2) - 0x15 & 0xfffffffc));\n    tempPtr2 = (uint *)(polynomial2 + 0x10);\n    do {\n      while( true ) {\n        tempPtr2 = tempPtr2 + 1;\n        bufferEndPtr = *tempPtr2 & 0xffff;\n        if (bufferEndPtr != 0) break;\n        bufferEndPtr = *tempPtr2 >> 0x10;\n        if (bufferEndPtr == 0) goto LAB_080092d2;\nLAB_0800932c:\n        partialSum = *bufferPtr;\n        partialProduct = 0;\n        tempVar1 = bufferPtr;\n        currentPtr1 = bufferPtr;\n        currentValue = partialSum;\n        do {\n          currentPtr2 = currentPtr1;\n          partialProduct = partialProduct + bufferEndPtr * *(ushort *)tempVar1 + (currentValue >> 0x10);\n          *currentPtr2 = partialSum & 0xffff | partialProduct * 0x10000;\n          tempVar2 = tempVar1 + 1;\n          currentValue = currentPtr2[1];\n          partialSum = bufferEndPtr * (*tempVar1 >> 0x10) + (currentValue & 0xffff) + (partialProduct >> 0x10);\n          partialProduct = partialSum >> 0x10;\n          tempVar1 = tempVar2;\n          currentPtr1 = currentPtr2 + 1;\n        } while (tempVar2 < bufferPtr + polynomialSize1);\n        currentPtr2[1] = partialSum;\n        bufferPtr = bufferPtr + 1;\n        if (tempPtr1 == tempPtr2) goto LAB_0800937a;\n      }\n      currentValue = 0;\n      tempVar1 = bufferPtr;\n      currentPtr1 = bufferPtr;\n      do {\n        tempVar2 = tempVar1;\n        currentPtr2 = currentPtr1 + 1;\n        partialSum = bufferEndPtr * (*currentPtr1 & 0xffff) + (*tempVar2 & 0xffff) + currentValue;\n        partialProduct = bufferEndPtr * (*currentPtr1 >> 0x10) + (*tempVar2 >> 0x10) + (partialSum >> 0x10);\n        currentValue = partialProduct >> 0x10;\n        *tempVar2 = partialSum & 0xffff | partialProduct * 0x10000;\n        tempVar1 = tempVar2 + 1;\n        currentPtr1 = currentPtr2;\n      } while (currentPtr2 < bufferPtr + polynomialSize1);\n      tempVar2[1] = currentValue;\n      bufferEndPtr = *tempPtr2 >> 0x10;\n      if (bufferEndPtr != 0) goto LAB_0800932c;\nLAB_080092d2:\n      bufferPtr = bufferPtr + 1;\n    } while (tempPtr1 != tempPtr2);\n  }\nLAB_0800937a:\n  if (0 < polynomial1Size) {\n    bufferEndPtr = bufferEndPtr[-1];\n    bufferEndPtr = bufferEndPtr + -1;\n    while ((bufferEndPtr == 0 && (polynomial1Size = polynomial1Size + -1, polynomial1Size != 0))) {\n      bufferEndPtr = bufferEndPtr + -1;\n      bufferEndPtr = *bufferEndPtr;\n    }\n  }\n  *(int *)(allocatedSize + 0x10) = polynomial1Size;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009258": "calculate_polynomial_product_08009258",
                "param_1": "outputBuffer",
                "param_2": "polynomial1",
                "param_3": "polynomial2",
                "puVar1": "tempVar1",
                "puVar2": "tempVar2",
                "iVar3": "allocatedSize",
                "uVar4": "partialProduct",
                "puVar5": "bufferPtr",
                "uVar6": "bufferEndPtr",
                "puVar7": "tempPtr1",
                "puVar16": "tempPtr2",
                "uVar8": "partialSum",
                "iVar9": "polynomial1Size",
                "iVar10": "polynomial2Size",
                "uVar11": "currentValue",
                "iVar12": "polynomialSize1",
                "iVar13": "polynomialSize2",
                "puVar14": "currentPtr1",
                "puVar15": "currentPtr2",
                "puVar17": "bufferEndPtr",
                "puVar18": "bufferPtr"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080093a4": {
            "entrypoint": "0x080093a4",
            "current_name": "calculate_result_080093a4",
            "code": "\nundefined4 * calculateResult_080093a4(int input_1,undefined4 *resultArray,uint size)\n\n{\n  int index;\n  int dividend;\n  undefined4 *tempArray;\n  undefined4 *tempArray2;\n  \n  if ((size & 3) != 0) {\n    resultArray = (undefined4 *)\n              __multadd(input_1,resultArray,*(undefined4 *)(&DAT_0800a070 + ((size & 3) - 1) * 4),0);\n  }\n  dividend = (int)size >> 2;\n  if (dividend != 0) {\n    tempArray2 = *(undefined4 **)(input_1 + 0x48);\n    if (tempArray2 == (undefined4 *)0x0) {\n      tempArray2 = (undefined4 *)_Balloc(input_1,1);\n      tempArray2[4] = 1;\n      tempArray2[5] = 0x271;\n      *(undefined4 **)(input_1 + 0x48) = tempArray2;\n      *tempArray2 = 0;\n    }\n    tempArray = resultArray;\n    if (dividend << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    dividend = dividend >> 1;\n    tempArray = tempArray2;\n    if (dividend != 0) {\n      while( true ) {\n        tempArray2 = (undefined4 *)*tempArray;\n        if (tempArray2 == (undefined4 *)0x0) {\n          tempArray2 = (undefined4 *)__multiply(input_1,tempArray,tempArray);\n          *tempArray = tempArray2;\n          *tempArray2 = 0;\n        }\n        tempArray = resultArray;\n        if (-1 < dividend << 0x1f) break;\nLAB_080093d2:\n        resultArray = (undefined4 *)__multiply(input_1,tempArray,tempArray2);\n        if (tempArray == (undefined4 *)0x0) break;\n        index = *(int *)(input_1 + 0x4c);\n        dividend = dividend >> 1;\n        *tempArray = *(undefined4 *)(index + tempArray[1] * 4);\n        *(undefined4 **)(index + tempArray[1] * 4) = tempArray;\n        tempArray = tempArray2;\n        if (dividend == 0) {\n          return resultArray;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return resultArray;\n}\n\n",
            "renaming": {
                "FUN_080093a4": "calculate_result_080093a4",
                "param_1": "input_1",
                "param_2": "resultArray",
                "param_3": "size",
                "iVar1": "index",
                "iVar2": "dividend",
                "puVar3": "tempArray",
                "puVar4": "tempArray2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__multiply",
                "_Balloc",
                "__multadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009444": {
            "entrypoint": "0x08009444",
            "current_name": "convert_and_store_bits_08009444",
            "code": "\nvoid convertAndStoreBits_08009444(int destination,undefined4 *input,uint bitCount)\n\n{\n  int increment;\n  int doubledValue;\n  int length;\n  undefined4 defaultValue;\n  int offset;\n  int negativeIncrement;\n  uint *output;\n  uint *inputPtr;\n  uint *inputPtr2;\n  uint *inputPtr3;\n  int shiftedCount;\n  int adjustedCount;\n  uint carryOver;\n  uint *outputPtr;\n  \n  offset = input[4];\n  shiftedCount = (int)bitCount >> 5;\n  adjustedCount = shiftedCount + offset + 1;\n  length = input[1];\n  doubledValue = input[2];\n  if ((int)input[2] < adjustedCount) {\n    do {\n      negativeIncrement = doubledValue * 2;\n      increment = doubledValue * -2;\n      length = length + 1;\n      doubledValue = negativeIncrement;\n    } while (adjustedCount != negativeIncrement && adjustedCount + increment < 0 == checkSubtractionBorrow(adjustedCount,negativeIncrement));\n  }\n  doubledValue = allocateBuffer(destination,length);\n  output = (uint *)(doubledValue + 0x14);\n  if (0 < shiftedCount) {\n    inputPtr3 = output + shiftedCount;\n    inputPtr = output;\n    do {\n      outputPtr = inputPtr + 1;\n      *inputPtr = 0;\n      output = inputPtr3;\n      inputPtr = outputPtr;\n    } while (outputPtr != inputPtr3);\n  }\n  length = input[4];\n  inputPtr = input + 5;\n  bitCount = bitCount & 0x1f;\n  if (bitCount == 0) {\n    output = output + -1;\n    inputPtr3 = inputPtr;\n    do {\n      outputPtr = inputPtr3 + 1;\n      output = output + 1;\n      *output = *inputPtr3;\n      inputPtr3 = outputPtr;\n    } while (outputPtr < inputPtr + length);\n  }\n  else {\n    carryOver = 0;\n    inputPtr3 = inputPtr;\n    do {\n      outputPtr = output;\n      *outputPtr = *inputPtr3 << bitCount | carryOver;\n      inputPtr2 = inputPtr3 + 1;\n      carryOver = *inputPtr3 >> (0x20 - bitCount & 0xff);\n      output = outputPtr + 1;\n      inputPtr3 = inputPtr2;\n    } while (inputPtr2 < inputPtr + length);\n    outputPtr[1] = carryOver;\n    if (carryOver != 0) {\n      adjustedCount = shiftedCount + offset + 2;\n    }\n  }\n  offset = *(int *)(destination + 0x4c);\n  length = input[1];\n  defaultValue = *(undefined4 *)(offset + length * 4);\n  *(int *)(doubledValue + 0x10) = adjustedCount + -1;\n  *input = defaultValue;\n  *(undefined4 **)(offset + length * 4) = input;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009444": "convert_and_store_bits_08009444",
                "param_1": "destination",
                "param_2": "input",
                "param_3": "bitCount",
                "iVar1": "increment",
                "iVar2": "doubledValue",
                "iVar3": "length",
                "uVar4": "defaultValue",
                "iVar5": "offset",
                "iVar6": "negativeIncrement",
                "puVar7": "output",
                "puVar8": "inputPtr",
                "puVar9": "outputPtr",
                "puVar10": "inputPtr2",
                "puVar11": "inputPtr3",
                "iVar12": "shiftedCount",
                "iVar13": "adjustedCount",
                "uVar14": "carryOver",
                "_Balloc": "allocateBuffer",
                "SBORROW4": "checkSubtractionBorrow"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094f8": {
            "entrypoint": "0x080094f8",
            "current_name": "compare_arrays_080094f8",
            "code": "\nint compare_arrays_080094f8(int array1,int array2)\n\n{\n  int length_difference;\n  uint *array2_ptr;\n  int array2_length;\n  uint *array1_ptr;\n  \n  array2_length = *(int *)(array2 + 0x10);\n  length_difference = *(int *)(array1 + 0x10) - array2_length;\n  if (length_difference == 0) {\n    array2_ptr = (uint *)(array2 + 0x14 + array2_length * 4);\n    array1_ptr = (uint *)(array1 + 0x14) + array2_length;\n    do {\n      array1_ptr = array1_ptr + -1;\n      array2_ptr = array2_ptr + -1;\n      if (*array1_ptr != *array2_ptr) {\n        if (*array2_ptr <= *array1_ptr) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1 + 0x14) < array1_ptr);\n  }\n  return length_difference;\n}\n\n",
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1",
                "param_2": "array2",
                "iVar1": "length_difference",
                "iVar3": "array2_length",
                "puVar2": "array2_ptr",
                "puVar4": "array1_ptr"
            },
            "calling": [
                "_dtoa_r",
                "quorem"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009530": {
            "entrypoint": "0x08009530",
            "current_name": "decompile_and_compare_08009530",
            "code": "\nvoid decompile_and_compare_08009530(undefined4 param1,uint *source_array,uint *target_array,undefined4 param4)\n\n{\n  int result;\n  uint *source_length;\n  uint source_checksum;\n  uint carry;\n  undefined4 is_negative;\n  uint *result_length;\n  uint *source_ptr;\n  uint *source_end;\n  uint *target_ptr;\n  uint *target_end;\n  int overflow;\n  uint *source_start;\n  uint target_checksum;\n  uint *temp_ptr;\n  \n  source_length = (uint *)target_array[4];\n  target_end = source_array + 5;\n  source_start = target_array + 5;\n  source_ptr = target_end;\n  source_end = source_array;\n  if ((uint *)source_array[4] == source_length) {\n    result_length = target_end + (int)source_length;\n    source_length = source_start + (int)source_length;\n    while( true ) {\n      result_length = result_length + -1;\n      source_length = source_length + -1;\n      if (*result_length != *source_length) break;\n      if (result_length <= target_end) {\n        overflow = _Balloc(param1,0,result_length,source_length,param4);\n        *(undefined4 *)(overflow + 0x10) = 1;\n        *(undefined4 *)(overflow + 0x14) = 0;\n        return;\n      }\n    }\n    is_negative = 0;\n    if (*source_length <= *result_length) goto LAB_08009578;\n  }\n  else if (-1 < (int)(uint *)source_array[4] - (int)source_length) {\n    is_negative = 0;\n    result_length = target_array;\n    goto LAB_08009578;\n  }\n  is_negative = 1;\n  result_length = target_end;\n  source_length = source_array;\n  source_ptr = source_start;\n  source_end = target_array;\n  target_array = source_array;\n  source_start = target_end;\nLAB_08009578:\n  result = _Balloc(param1,source_end[1],result_length,source_length,param4);\n  overflow = 0;\n  target_checksum = source_end[4];\n  source_checksum = target_array[4];\n  *(undefined4 *)(result + 0xc) = is_negative;\n  target_end = source_ptr + target_checksum;\n  source_length = (uint *)(result + 0x14);\n  source_end = source_start;\n  do {\n    temp_ptr = source_ptr + 1;\n    target_ptr = source_end + 1;\n    carry = ((*source_ptr & 0xffff) + overflow) - (*source_end & 0xffff);\n    overflow = ((*source_ptr >> 0x10) - (*source_end >> 0x10)) + ((int)carry >> 0x10);\n    carry = carry & 0xffff | overflow * 0x10000;\n    result_length = source_length + 1;\n    *source_length = carry;\n    overflow = overflow >> 0x10;\n    source_length = result_length;\n    source_ptr = temp_ptr;\n    source_end = target_ptr;\n  } while (target_ptr < source_start + source_checksum);\n  source_length = temp_ptr;\n  source_ptr = result_length;\n  if (temp_ptr < target_end) {\n    do {\n      source_end = source_length + 1;\n      source_checksum = (*source_length & 0xffff) + overflow;\n      overflow = ((int)source_checksum >> 0x10) + (*source_length >> 0x10);\n      carry = source_checksum & 0xffff | overflow * 0x10000;\n      *source_ptr = carry;\n      overflow = overflow >> 0x10;\n      source_length = source_end;\n      source_ptr = source_ptr + 1;\n    } while (source_end < target_end);\n    result_length = (uint *)((int)result_length + ((int)target_end + ~(uint)temp_ptr & 0xfffffffc) + 4);\n  }\n  result_length = result_length + -1;\n  while (carry == 0) {\n    result_length = result_length + -1;\n    target_checksum = target_checksum - 1;\n    carry = *result_length;\n  }\n  *(uint *)(result + 0x10) = target_checksum;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009530": "decompile_and_compare_08009530",
                "param_1": "param1",
                "param_2": "source_array",
                "param_3": "target_array",
                "param_4": "param4",
                "iVar1": "result",
                "puVar2": "source_length",
                "uVar3": "source_checksum",
                "uVar4": "carry",
                "uVar5": "is_negative",
                "puVar6": "result_length",
                "puVar7": "source_ptr",
                "puVar8": "temp_ptr",
                "puVar9": "source_end",
                "puVar10": "target_ptr",
                "puVar11": "target_end",
                "iVar12": "overflow",
                "puVar13": "source_start",
                "uVar14": "target_checksum"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009630": {
            "entrypoint": "0x08009630",
            "current_name": "extract_bits_from_binary_08009630",
            "code": "\nint extract_bits_from_binary_08009630(undefined4 binary_length,undefined4 buffer_size,uint start_index,uint end_index,int *bits_extracted,\n                int *remaining_bits)\n\n{\n  int buffer_address;\n  uint bits_shifted;\n  int leading_zeros;\n  int bits_extracted_indicator;\n  uint shifted_bits;\n  uint non_zero_shifted_bits;\n  undefined8 leading_zeros_high_bits;\n  uint start_index_temp;\n  uint end_index_temp;\n  \n  buffer_address = _Balloc(binary_length,1);\n  non_zero_shifted_bits = (end_index << 1) >> 0x15;\n  end_index_temp = end_index & 0xfffff;\n  if (non_zero_shifted_bits != 0) {\n    end_index_temp = end_index_temp | 0x100000;\n  }\n  if (start_index == 0) {\n    leading_zeros = __lo0bits(&end_index_temp);\n    bits_extracted_indicator = 1;\n    bits_shifted = leading_zeros + 0x20;\n    *(undefined4 *)(buffer_address + 0x10) = 1;\n    *(uint *)(buffer_address + 0x14) = end_index_temp;\n  }\n  else {\n    start_index_temp = start_index;\n    bits_shifted = __lo0bits(&start_index_temp);\n    if (bits_shifted == 0) {\n      *(uint *)(buffer_address + 0x14) = start_index_temp;\n    }\n    else {\n      shifted_bits = end_index_temp << (0x20 - bits_shifted & 0xff);\n      end_index_temp = end_index_temp >> (bits_shifted & 0xff);\n      *(uint *)(buffer_address + 0x14) = shifted_bits | start_index_temp;\n    }\n    if (end_index_temp == 0) {\n      bits_extracted_indicator = 1;\n    }\n    else {\n      bits_extracted_indicator = 2;\n    }\n    *(uint *)(buffer_address + 0x18) = end_index_temp;\n    *(int *)(buffer_address + 0x10) = bits_extracted_indicator;\n  }\n  if (non_zero_shifted_bits == 0) {\n    *bits_extracted = bits_shifted - 0x432;\n    leading_zeros_high_bits = __hi0bits(*(undefined4 *)(buffer_address + bits_extracted_indicator * 4 + 0x10));\n    *remaining_bits = (int)((ulonglong)leading_zeros_high_bits >> 0x20) * 0x20 - (int)leading_zeros_high_bits;\n    return buffer_address;\n  }\n  *bits_extracted = (non_zero_shifted_bits - 0x433) + bits_shifted;\n  *remaining_bits = 0x35 - bits_shifted;\n  return buffer_address;\n}\n\n",
            "renaming": {
                "FUN_08009630": "extract_bits_from_binary_08009630",
                "param_1": "binary_length",
                "param_2": "buffer_size",
                "param_3": "start_index",
                "param_4": "end_index",
                "param_5": "bits_extracted",
                "param_6": "remaining_bits",
                "iVar1": "buffer_address",
                "uVar2": "bits_shifted",
                "iVar3": "leading_zeros",
                "iVar4": "bits_extracted_indicator",
                "uVar5": "shifted_bits",
                "uVar6": "non_zero_shifted_bits",
                "uVar7": "leading_zeros_high_bits",
                "local_20": "start_index_temp",
                "local_1c": "end_index_temp"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__lo0bits",
                "_Balloc",
                "__hi0bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e0": {
            "entrypoint": "0x080096e0",
            "current_name": "float_to_integer_080096e0",
            "code": "\nundefined8 floatToInteger_080096e0(uint floatValue,uint floatBits,int *pIntegerValue,undefined4 floatMask)\n\n{\n  int shiftAmount;\n  uint maskedFloatBits;\n  undefined8 combinedValue;\n  \n  combinedValue = CONCAT44(floatBits,floatValue);\n  shiftAmount = 0;\n  maskedFloatBits = floatBits & 0x7fffffff;\n  *pIntegerValue = 0;\n  if ((maskedFloatBits < 0x7ff00000) && ((maskedFloatBits | floatValue) != 0)) {\n    if (maskedFloatBits < 0x100000) {\n      combinedValue = __muldf3(floatValue,floatBits,0,0x43500000,floatMask);\n      shiftAmount = -0x36;\n      maskedFloatBits = (uint)((ulonglong)combinedValue >> 0x20) & 0x7fffffff;\n    }\n    floatValue = (uint)combinedValue;\n    floatBits = (uint)((ulonglong)combinedValue >> 0x20) & 0x800fffff | 0x3fe00000;\n    *pIntegerValue = ((int)maskedFloatBits >> 0x14) + -0x3fe + shiftAmount;\n  }\n  return CONCAT44(floatBits,floatValue);\n}\n\n",
            "renaming": {
                "FUN_080096e0": "float_to_integer_080096e0",
                "param_1": "floatValue",
                "param_2": "floatBits",
                "param_3": "pIntegerValue",
                "param_4": "floatMask",
                "iVar1": "shiftAmount",
                "uVar2": "maskedFloatBits",
                "uVar3": "combinedValue"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__muldf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009744": {
            "entrypoint": "0x08009744",
            "current_name": "allocate_memory_08009744",
            "code": "\nvoid allocateMemory_08009744(int *outputPointer,undefined4 size)\n\n{\n  int allocationResult;\n  \n  DAT_20000c10 = 0;\n  allocationResult = _sbrk(size);\n  if ((allocationResult == -1) && (DAT_20000c10 != 0)) {\n    *outputPointer = DAT_20000c10;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009744": "allocate_memory_08009744",
                "param_1": "outputPointer",
                "param_2": "size",
                "iVar1": "allocationResult"
            },
            "calling": [
                "_malloc_trim_r",
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009768": {
            "entrypoint": "0x08009768",
            "current_name": "copy_string_08009768",
            "code": "\nvoid copyString_08009768(uint *dest,uint *src,uint size)\n\n{\n  char currentChar;\n  uint *srcPointer;\n  uint *destPointer;\n  uint currentWord;\n  \n  if (((((uint)dest | (uint)src) & 3) == 0) &&\n     (destPointer = dest, srcPointer = src, 3 < size)) {\n    do {\n      src = srcPointer + 1;\n      currentWord = *srcPointer;\n      dest = destPointer;\n      if ((currentWord + 0xfefefeff & ~currentWord & 0x80808080) != 0) goto LAB_0800979c;\n      size = size - 4;\n      dest = destPointer + 1;\n      *destPointer = currentWord;\n      destPointer = dest;\n      srcPointer = src;\n    } while (3 < size);\n  }\n  srcPointer = src;\n  if (size != 0) {\nLAB_0800979c:\n    currentChar = *(char *)srcPointer;\n    *(char *)dest = currentChar;\n    while( true ) {\n      dest = (uint *)((int)dest + 1);\n      size = size - 1;\n      if (currentChar == '\\0') break;\n      if (size == 0) {\n        return;\n      }\n      srcPointer = (uint *)((int)srcPointer + 1);\n      currentChar = *(char *)srcPointer;\n      *(char *)dest = currentChar;\n    }\n    if (size != 0) {\n      srcPointer = dest;\n      do {\n        destPointer = (uint *)((int)srcPointer + 1);\n        *(char *)srcPointer = '\\0';\n        srcPointer = destPointer;\n      } while (destPointer != (uint *)(size + (int)dest));\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009768": "copy_string_08009768",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "cVar1": "currentChar",
                "puVar2": "srcPointer",
                "puVar3": "destPointer",
                "uVar4": "currentWord"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080097cc": {
            "entrypoint": "0x080097cc",
            "current_name": "copy_and_resize_buffer_080097cc",
            "code": "\nundefined4 copy_and_resize_buffer_080097cc(undefined4 *output_buffer,int *input_buffer,int *auxiliary_buffer)\n\n{\n  int copy_start;\n  uint copy_length;\n  int new_buffer;\n  int copy_offset;\n  uint new_buffer_size;\n  uint copy_remaining;\n  undefined4 *input_copied;\n  undefined4 *input_remaining;\n  undefined4 copy_source;\n  \n  if (auxiliary_buffer[2] != 0) {\n    copy_start = *input_buffer;\n    new_buffer_size = input_buffer[2];\n    input_remaining = (undefined4 *)*auxiliary_buffer;\n    do {\n      do {\n        input_copied = input_remaining + 2;\n        copy_source = *input_remaining;\n        copy_remaining = input_remaining[1];\n        input_remaining = input_copied;\n      } while (copy_remaining == 0);\n      copy_length = copy_remaining;\n      if ((new_buffer_size <= copy_remaining) && (copy_length = new_buffer_size, (*(ushort *)(input_buffer + 3) & 0x480) != 0)) {\n        copy_offset = copy_start - input_buffer[4];\n        new_buffer_size = (input_buffer[5] * 3) / 2;\n        copy_length = copy_remaining + 1 + copy_offset;\n        if (new_buffer_size < copy_length) {\n          new_buffer_size = copy_length;\n        }\n        if ((int)((uint)*(ushort *)(input_buffer + 3) << 0x15) < 0) {\n          new_buffer = _malloc_r(output_buffer,new_buffer_size);\n          if (new_buffer == 0) {\nLAB_08009896:\n            *output_buffer = 0xc;\n            *(ushort *)(input_buffer + 3) = *(ushort *)(input_buffer + 3) | 0x40;\n            auxiliary_buffer[1] = 0;\n            auxiliary_buffer[2] = 0;\n            return 0xffffffff;\n          }\n          memcpy(new_buffer,input_buffer[4],copy_offset);\n          *(ushort *)(input_buffer + 3) = *(ushort *)(input_buffer + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          new_buffer = _realloc_r(output_buffer);\n          if (new_buffer == 0) {\n            _free_r(output_buffer,input_buffer[4]);\n            goto LAB_08009896;\n          }\n        }\n        copy_start = new_buffer + copy_offset;\n        input_buffer[5] = new_buffer_size;\n        input_buffer[4] = new_buffer;\n        *input_buffer = copy_start;\n        input_buffer[2] = new_buffer_size - copy_offset;\n        copy_length = copy_remaining;\n      }\n      memmove(copy_start,copy_source,copy_length);\n      copy_offset = auxiliary_buffer[2];\n      new_buffer_size = input_buffer[2] - copy_length;\n      copy_start = *input_buffer + copy_length;\n      input_buffer[2] = new_buffer_size;\n      *input_buffer = copy_start;\n      auxiliary_buffer[2] = copy_offset - copy_remaining;\n    } while (copy_offset - copy_remaining != 0);\n  }\n  auxiliary_buffer[1] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080097cc": "copy_and_resize_buffer_080097cc",
                "param_1": "output_buffer",
                "param_2": "input_buffer",
                "param_3": "auxiliary_buffer",
                "iVar1": "copy_start",
                "uVar2": "copy_length",
                "iVar3": "new_buffer",
                "iVar4": "copy_offset",
                "uVar5": "new_buffer_size",
                "uVar6": "copy_remaining",
                "puVar7": "input_copied",
                "puVar8": "input_remaining",
                "uVar9": "copy_source"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "memcpy",
                "_malloc_r",
                "memmove",
                "_free_r",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098c0": {
            "entrypoint": "0x080098c0",
            "current_name": "update_data_080098c0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009906) */\n/* WARNING: Removing unreachable block (ram,0x08009912) */\n\nundefined4 updateData_080098c0(int type,undefined4 data,undefined4 value,undefined4 extraValue)\n\n{\n  undefined *dataPtr;\n  undefined4 result;\n  uint bitMask;\n  uint count;\n  \n  __retarget_lock_acquire_recursive(DAT_20000448);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  dataPtr = DAT_20000168;\n  count = *(uint *)(DAT_20000168 + 4);\n  if ((int)count < 0x20) {\n    if (type != 0) {\n      *(undefined4 *)(DAT_20000168 + count * 4 + 0x88) = value;\n      bitMask = 1 << (count & 0xff);\n      *(uint *)(dataPtr + 0x188) = *(uint *)(dataPtr + 0x188) | bitMask;\n      *(undefined4 *)(dataPtr + count * 4 + 0x108) = extraValue;\n      if (type == 2) {\n        *(uint *)(dataPtr + 0x18c) = bitMask | *(uint *)(dataPtr + 0x18c);\n      }\n    }\n    *(uint *)(dataPtr + 4) = count + 1;\n    result = DAT_20000448;\n    *(undefined4 *)(dataPtr + (count + 2) * 4) = data;\n    __retarget_lock_release_recursive(result);\n    result = 0;\n  }\n  else {\n    __retarget_lock_release_recursive(DAT_20000448);\n    result = 0xffffffff;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080098c0": "update_data_080098c0",
                "param_1": "type",
                "param_2": "data",
                "param_3": "value",
                "param_4": "extraValue",
                "puVar1": "dataPtr",
                "uVar2": "result",
                "uVar3": "bitMask",
                "uVar4": "count"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009980": {
            "entrypoint": "0x08009980",
            "current_name": "allocate_and_initialize_array_08009980",
            "code": "\nundefined4 * allocate_and_initialize_array_08009980(undefined4 array_size,int element_size,int element_count)\n\n{\n  undefined4 *array_ptr;\n  uint adjusted_size;\n  undefined4 *offset_ptr;\n  \n  array_ptr = (undefined4 *)_malloc_r(array_size,element_count * element_size);\n  if (array_ptr == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  adjusted_size = (array_ptr[-1] & 0xfffffffc) - 4;\n  if (adjusted_size < 0x25) {\n    offset_ptr = array_ptr;\n    if (0x13 < adjusted_size) {\n      *array_ptr = 0;\n      array_ptr[1] = 0;\n      if (0x1b < adjusted_size) {\n        array_ptr[2] = 0;\n        array_ptr[3] = 0;\n        if (adjusted_size == 0x24) {\n          array_ptr[4] = 0;\n          array_ptr[5] = 0;\n          offset_ptr = array_ptr + 6;\n        }\n        else {\n          offset_ptr = array_ptr + 4;\n        }\n        *offset_ptr = 0;\n        offset_ptr[1] = 0;\n        offset_ptr[2] = 0;\n        return array_ptr;\n      }\n      offset_ptr = array_ptr + 2;\n    }\n    *offset_ptr = 0;\n    offset_ptr[1] = 0;\n    offset_ptr[2] = 0;\n    return array_ptr;\n  }\n  memset(array_ptr,0);\n  return array_ptr;\n}\n\n",
            "renaming": {
                "FUN_08009980": "allocate_and_initialize_array_08009980",
                "param_1": "array_size",
                "param_2": "element_size",
                "param_3": "element_count",
                "puVar1": "array_ptr",
                "uVar2": "adjusted_size",
                "puVar3": "offset_ptr"
            },
            "calling": [
                "_Balloc"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a18": {
            "entrypoint": "0x08009a18",
            "current_name": "copy_memory_08009a18",
            "code": "\nvoid copyMemory_08009a18(undefined4 *destination,undefined4 *source,uint size)\n\n{\n  undefined4 *destPtr;\n  undefined4 *srcPtr;\n  int i;\n  undefined *destBytePtr;\n  undefined4 *srcBytePtr;\n  uint remainingSize;\n  uint remainingSizeAligned;\n  \n  if ((source < destination) && (srcPtr = (undefined4 *)((int)source + size), destination < srcPtr)) {\n    destBytePtr = (undefined *)((int)destination + size);\n    if (size != 0) {\n      do {\n        srcPtr = (undefined4 *)((int)srcPtr + -1);\n        destBytePtr = destBytePtr + -1;\n        *destBytePtr = *(undefined *)srcPtr;\n      } while (source != srcPtr);\n    }\n  }\n  else {\n    remainingSizeAligned = size;\n    if (0xf < size) {\n      if ((((uint)destination | (uint)source) & 3) != 0) goto LAB_08009abc;\n      srcPtr = source + 4;\n      destPtr = destination + 4;\n      do {\n        srcBytePtr = srcPtr + 4;\n        destPtr[-4] = srcPtr[-4];\n        destPtr[-3] = srcPtr[-3];\n        destPtr[-2] = srcPtr[-2];\n        destPtr[-1] = srcPtr[-1];\n        srcPtr = srcBytePtr;\n        destPtr = destPtr + 4;\n      } while (srcBytePtr != (undefined4 *)((int)source + (size - 0x10 & 0xfffffff0) + 0x20));\n      i = (size - 0x10 >> 4) + 1;\n      remainingSizeAligned = size & 0xf;\n      source = source + i * 4;\n      destination = destination + i * 4;\n      if (3 < remainingSizeAligned) {\n        srcPtr = destination + -1;\n        remainingSize = remainingSizeAligned;\n        destPtr = source;\n        do {\n          remainingSize = remainingSize - 4;\n          srcPtr = srcPtr + 1;\n          *srcPtr = *destPtr;\n          destPtr = destPtr + 1;\n        } while (3 < remainingSize);\n        i = (remainingSizeAligned - 4 & 0xfffffffc) + 4;\n        destination = (undefined4 *)((int)destination + i);\n        source = (undefined4 *)((int)source + i);\n        remainingSizeAligned = size & 3;\n      }\n    }\n    size = remainingSizeAligned;\n    if (remainingSizeAligned != 0) {\nLAB_08009abc:\n      destBytePtr = (undefined *)((int)destination + -1);\n      srcPtr = source;\n      do {\n        destPtr = (undefined4 *)((int)srcPtr + 1);\n        destBytePtr = destBytePtr + 1;\n        *destBytePtr = *(undefined *)srcPtr;\n        srcPtr = destPtr;\n      } while (destPtr != (undefined4 *)(size + (int)source));\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009a18": "copy_memory_08009a18",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "puVar1": "destPtr",
                "puVar2": "srcPtr",
                "iVar3": "i",
                "puVar4": "destBytePtr",
                "puVar5": "srcBytePtr",
                "uVar6": "remainingSize",
                "uVar7": "remainingSizeAligned"
            },
            "calling": [
                "__ssprint_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009adc": {
            "entrypoint": "0x08009adc",
            "current_name": "allocate_memory_08009adc",
            "code": "\nint * allocateMemory_08009adc(undefined4 *lock,int *ptr,uint size)\n\n{\n  int *prevBlock;\n  int currentBlock;\n  int *newBlock;\n  uint blockSize;\n  int temp1;\n  uint prevSize;\n  int *tempBlock;\n  uint alignedSize;\n  uint requestedSize;\n  uint blockTotalSize;\n  int blockEnd;\n  \n  if (ptr == (int *)0x0) {\n    newBlock = (int *)_malloc_r(lock,size);\n    return newBlock;\n  }\n  __malloc_lock();\n  prevSize = ptr[-1];\n  requestedSize = prevSize & 0xfffffffc;\n  newBlock = ptr + -2;\n  if (size + 0xb < 0x17) {\n    alignedSize = 0x10;\n  }\n  else {\n    alignedSize = size + 0xb & 0xfffffff8;\n    if ((int)alignedSize < 0) goto LAB_08009b8e;\n  }\n  if (alignedSize < size) {\nLAB_08009b8e:\n    *lock = 0xc;\n    return (int *)0x0;\n  }\n  blockEnd = (int)newBlock + requestedSize;\n  blockTotalSize = requestedSize;\n  if ((int)requestedSize < (int)alignedSize) {\n    if (DAT_20000454 == blockEnd) {\n      blockEnd = (*(uint *)(DAT_20000454 + 4) & 0xfffffffc) + requestedSize;\n      if ((int)(alignedSize + 0x10) <= blockEnd) {\n        DAT_20000454 = (int)newBlock + alignedSize;\n        *(uint *)(DAT_20000454 + 4) = blockEnd - alignedSize | 1;\n        ptr[-1] = alignedSize | ptr[-1] & 1U;\n        __malloc_unlock(lock);\n        return ptr;\n      }\n      if (-1 < (int)(prevSize << 0x1f)) {\n        prevBlock = (int *)((int)newBlock - ptr[-2]);\n        prevSize = prevBlock[1] & 0xfffffffc;\n        if ((int)(alignedSize + 0x10) <= (int)(blockEnd + prevSize)) {\n          temp1 = prevBlock[3];\n          newBlock = prevBlock + 2;\n          currentBlock = *newBlock;\n          requestedSize = requestedSize - 4;\n          *(int *)(currentBlock + 0xc) = temp1;\n          *(int *)(temp1 + 8) = currentBlock;\n          if (requestedSize < 0x25) {\n            currentBlock = *ptr;\n            tempBlock = newBlock;\n            if (0x13 < requestedSize) {\n              prevBlock[2] = currentBlock;\n              prevBlock[3] = ptr[1];\n              currentBlock = ptr[2];\n              if (requestedSize < 0x1c) {\n                ptr = ptr + 2;\n                tempBlock = prevBlock + 4;\n              }\n              else {\n                prevBlock[4] = currentBlock;\n                prevBlock[5] = ptr[3];\n                currentBlock = ptr[4];\n                if (requestedSize == 0x24) {\n                  prevBlock[6] = currentBlock;\n                  prevBlock[7] = ptr[5];\n                  currentBlock = ptr[6];\n                  ptr = ptr + 6;\n                  tempBlock = prevBlock + 8;\n                }\n                else {\n                  ptr = ptr + 4;\n                  tempBlock = prevBlock + 6;\n                }\n              }\n            }\n            *tempBlock = currentBlock;\n            tempBlock[1] = ptr[1];\n            tempBlock[2] = ptr[2];\n          }\n          else {\n            memmove(newBlock,ptr);\n          }\n          DAT_20000454 = (int)prevBlock + alignedSize;\n          *(uint *)(DAT_20000454 + 4) = (blockEnd + prevSize) - alignedSize | 1;\n          prevBlock[1] = alignedSize | prevBlock[1] & 1U;\n          __malloc_unlock(lock);\n          return newBlock;\n        }\nLAB_08009bb0:\n        blockTotalSize = requestedSize + prevSize;\n        if ((int)alignedSize <= (int)blockTotalSize) {\n          temp1 = prevBlock[3];\n          tempBlock = prevBlock + 2;\n          currentBlock = *tempBlock;\n          *(int *)(currentBlock + 0xc) = temp1;\n          blockEnd = (int)prevBlock + blockTotalSize;\n          *(int *)(temp1 + 8) = currentBlock;\n          newBlock = prevBlock;\n          if (requestedSize - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          memmove(tempBlock,ptr);\n          ptr = tempBlock;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(blockEnd + 4) & 0xfffffffe) + blockEnd + 4) << 0x1f) {\n        blockSize = *(uint *)(blockEnd + 4) & 0xfffffffc;\n        blockTotalSize = requestedSize + blockSize;\n        if ((int)blockTotalSize < (int)alignedSize) {\n          if ((int)(prevSize << 0x1f) < 0) goto LAB_08009b36;\n          prevBlock = (int *)((int)newBlock - ptr[-2]);\n          prevSize = prevBlock[1] & 0xfffffffc;\n          blockTotalSize = blockSize + prevSize + requestedSize;\n          if ((int)blockTotalSize < (int)alignedSize) goto LAB_08009bb0;\n          currentBlock = *(int *)(blockEnd + 8);\n          blockEnd = *(int *)(blockEnd + 0xc);\n          *(int *)(currentBlock + 0xc) = blockEnd;\n          *(int *)(blockEnd + 8) = currentBlock;\n          tempBlock = prevBlock + 2;\n          currentBlock = *tempBlock;\n          temp1 = prevBlock[3];\n          *(int *)(currentBlock + 0xc) = temp1;\n          blockEnd = (int)prevBlock + blockTotalSize;\n          *(int *)(temp1 + 8) = currentBlock;\n          newBlock = prevBlock;\n          if (0x24 < requestedSize - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          requestedSize = requestedSize - 4;\n          currentBlock = *ptr;\n          prevBlock = tempBlock;\n          if (0x13 < requestedSize) {\n            newBlock[2] = currentBlock;\n            newBlock[3] = ptr[1];\n            currentBlock = ptr[2];\n            if (requestedSize < 0x1c) {\n              ptr = ptr + 2;\n              prevBlock = newBlock + 4;\n            }\n            else {\n              newBlock[4] = currentBlock;\n              newBlock[5] = ptr[3];\n              currentBlock = ptr[4];\n              if (requestedSize == 0x24) {\n                newBlock[6] = currentBlock;\n                newBlock[7] = ptr[5];\n                currentBlock = ptr[6];\n                ptr = ptr + 6;\n                prevBlock = newBlock + 8;\n              }\n              else {\n                ptr = ptr + 4;\n                prevBlock = newBlock + 6;\n              }\n            }\n          }\n          *prevBlock = currentBlock;\n          prevBlock[1] = ptr[1];\n          prevBlock[2] = ptr[2];\n          ptr = tempBlock;\n        }\n        else {\n          currentBlock = *(int *)(blockEnd + 8);\n          temp1 = *(int *)(blockEnd + 0xc);\n          *(int *)(currentBlock + 0xc) = temp1;\n          blockEnd = (int)newBlock + blockTotalSize;\n          *(int *)(temp1 + 8) = currentBlock;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(prevSize << 0x1f)) {\n        prevBlock = (int *)((int)newBlock - ptr[-2]);\n        prevSize = prevBlock[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    prevBlock = (int *)_malloc_r(lock,size);\n    if (prevBlock != (int *)0x0) {\n      if ((int *)((ptr[-1] & 0xfffffffeU) + (int)newBlock) == prevBlock + -2) {\n        blockTotalSize = requestedSize + (prevBlock[-1] & 0xfffffffcU);\n        blockEnd = (int)newBlock + blockTotalSize;\n        goto LAB_08009c00;\n      }\n      requestedSize = requestedSize - 4;\n      if (requestedSize < 0x25) {\n        blockEnd = *ptr;\n        newBlock = ptr;\n        tempBlock = prevBlock;\n        if (0x13 < requestedSize) {\n          *prevBlock = blockEnd;\n          prevBlock[1] = ptr[1];\n          if (requestedSize < 0x1c) {\n            blockEnd = ptr[2];\n            newBlock = ptr + 2;\n            tempBlock = prevBlock + 2;\n          }\n          else {\n            prevBlock[2] = ptr[2];\n            prevBlock[3] = ptr[3];\n            if (requestedSize == 0x24) {\n              prevBlock[4] = ptr[4];\n              prevBlock[5] = ptr[5];\n              blockEnd = ptr[6];\n              newBlock = ptr + 6;\n              tempBlock = prevBlock + 6;\n            }\n            else {\n              blockEnd = ptr[4];\n              newBlock = ptr + 4;\n              tempBlock = prevBlock + 4;\n            }\n          }\n        }\n        *tempBlock = blockEnd;\n        tempBlock[1] = newBlock[1];\n        tempBlock[2] = newBlock[2];\n      }\n      else {\n        memmove(prevBlock,ptr);\n      }\n      _free_r(lock,ptr);\n    }\n    __malloc_unlock(lock);\n    ptr = prevBlock;\n  }\n  else {\nLAB_08009c00:\n    if (blockTotalSize - alignedSize < 0x10) {\n      newBlock[1] = newBlock[1] & 1U | blockTotalSize;\n      *(uint *)(blockEnd + 4) = *(uint *)(blockEnd + 4) | 1;\n    }\n    else {\n      newBlock[1] = newBlock[1] & 1U | alignedSize;\n      *(uint *)((int)newBlock + alignedSize + 4) = blockTotalSize - alignedSize | 1;\n      *(uint *)(blockEnd + 4) = *(uint *)(blockEnd + 4) | 1;\n      _free_r(lock,(int)newBlock + alignedSize + 8);\n    }\n    __malloc_unlock(lock);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08009adc": "allocate_memory_08009adc",
                "param_1": "lock",
                "param_2": "ptr",
                "param_3": "size",
                "piVar1": "prevBlock",
                "iVar2": "currentBlock",
                "piVar3": "newBlock",
                "uVar4": "blockSize",
                "iVar5": "temp1",
                "uVar6": "prevSize",
                "piVar7": "tempBlock",
                "uVar8": "alignedSize",
                "uVar9": "requestedSize",
                "uVar10": "blockTotalSize",
                "iVar11": "blockEnd"
            },
            "calling": [
                "__ssprint_r"
            ],
            "called": [
                "_malloc_r",
                "memmove",
                "__malloc_unlock",
                "_free_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e68": {
            "entrypoint": "0x08009e68",
            "current_name": "FUNC_08009e68",
            "code": "\nvoid FUNC_08009e68(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e68": "FUNC_08009e68"
            },
            "calling": [
                "__libc_init_array",
                "frame_dummy",
                "__do_global_dtors_aux"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009e74": {
            "entrypoint": "0x08009e74",
            "current_name": "FUNC_08009e74",
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 148284,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000158",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_080003f4",
            "FUN_08000418",
            "FUN_080006a4",
            "FUN_0800088a",
            "FUN_080008fc",
            "FUN_08000978",
            "FUN_08000988",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_080009c0",
            "FUN_080009d4",
            "FUN_080009e8",
            "FUN_080009fc",
            "FUN_08000aa4",
            "FUN_08000aa8",
            "FUN_08000c08",
            "FUN_08000c10",
            "FUN_08000cb8",
            "FUN_08000e20",
            "FUN_08000f68",
            "FUN_08000fc8",
            "FUN_08000fd0",
            "FUN_08000ff4",
            "FUN_08001030",
            "FUN_08001044",
            "FUN_08001084",
            "FUN_08001170",
            "FUN_0800119c",
            "FUN_080011ec",
            "FUN_0800121c",
            "FUN_080014f0",
            "FUN_0800151c",
            "FUN_0800157c",
            "FUN_080015a0",
            "FUN_080015b4",
            "FUN_080015fc",
            "FUN_08001618",
            "FUN_0800166c",
            "FUN_080016d0",
            "FUN_08001714",
            "FUN_0800172a",
            "FUN_08001762",
            "FUN_0800177c",
            "FUN_080017b4",
            "FUN_080017c4",
            "FUN_08001a80",
            "FUN_08001ab0",
            "FUN_08001ccc",
            "FUN_08001f6c",
            "FUN_08002640",
            "FUN_080027f4",
            "FUN_08002ad8",
            "FUN_08002bb4",
            "FUN_08002c2e",
            "FUN_08002ca8",
            "FUN_08002d3c",
            "FUN_08002d98",
            "FUN_08003260",
            "FUN_08003440",
            "FUN_08003504",
            "FUN_08003518",
            "FUN_08003540",
            "FUN_08003568",
            "FUN_080035a4",
            "FUN_0800360c",
            "FUN_08003640",
            "FUN_080036a8",
            "FUN_080036f8",
            "FUN_08003908",
            "FUN_08003a94",
            "FUN_08003c94",
            "FUN_08003d60",
            "FUN_08003e38",
            "FUN_08003f18",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08004104",
            "FUN_0800416a",
            "FUN_080041a8",
            "FUN_080041ea",
            "FUN_0800422e",
            "FUN_080042de",
            "FUN_0800438a",
            "FUN_08004436",
            "FUN_080046ec",
            "FUN_0800491c",
            "FUN_080049cc",
            "FUN_08004ae0",
            "FUN_08004bd8",
            "FUN_08004d78",
            "FUN_08004e6c",
            "FUN_08004e74",
            "FUN_08004ea4",
            "FUN_08004ee8",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f60",
            "FUN_08004f78",
            "FUN_08005224",
            "FUN_080052a0",
            "FUN_08005348",
            "FUN_080053b0",
            "FUN_08005500",
            "FUN_08005598",
            "FUN_080055f4",
            "FUN_08005674",
            "FUN_08005680",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_08005728",
            "FUN_08005780",
            "FUN_080057e8",
            "FUN_08005838",
            "FUN_080059f0",
            "FUN_08005d14",
            "FUN_08005d20",
            "FUN_08005d68",
            "FUN_08005dfc",
            "FUN_08005e40",
            "FUN_080078c0",
            "FUN_080079e8",
            "FUN_0800884c",
            "FUN_080088ec",
            "FUN_08008ad4",
            "FUN_08008af8",
            "FUN_0800901c",
            "FUN_080090a8",
            "FUN_080090b4",
            "FUN_080090c0",
            "FUN_0800910c",
            "FUN_08009120",
            "FUN_080091a4",
            "FUN_080091e4",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_080093a4",
            "FUN_08009444",
            "FUN_080094f8",
            "FUN_08009530",
            "FUN_08009630",
            "FUN_080096e0",
            "FUN_08009744",
            "FUN_08009768",
            "FUN_080097cc",
            "FUN_080098c0",
            "FUN_08009980",
            "FUN_08009a18",
            "FUN_08009adc"
        ],
        [
            "FUN_080004c8",
            "FUN_0800071c"
        ]
    ],
    "locked_functions": []
}