{
    "functions": {
        "FUN_080001ac": {
            "entrypoint": "0x080001ac",
            "current_name": "initialize_flag_080001ac",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001b8) */\n\nundefined4 initializeFlag_080001ac(undefined4 inputParam)\n\n{\n  if ((char)DAT_20000104 == '\\0') {\n    DAT_20000104._0_1_ = '\\x01';\n  }\n  return inputParam;\n}\n\n",
            "renaming": {
                "FUN_080001ac": "initialize_flag_080001ac",
                "param_1": "inputParam"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000230": {
            "entrypoint": "0x08000230",
            "current_name": "find_pattern_position_08000230",
            "code": "\nbyte * find_pattern_position_08000230(uint *data,uint pattern_byte,uint data_size)\n\n{\n  byte current_byte;\n  char is_byte_zero;\n  char is_high_byte_zero;\n  char is_higher_byte_zero;\n  char is_highest_byte_zero;\n  byte *found_pattern;\n  uint *current_data;\n  byte *next_byte;\n  uint data_alignment;\n  uint aligned_data_size;\n  uint toggled_data;\n  uint toggled_data_next;\n  bool is_high_byte_set;\n  bool is_higher_byte_set;\n  bool is_highest_byte_set;\n  bool is_highest_byte_set_prev;\n  \n  pattern_byte = pattern_byte & 0xff;\n  if ((int)data_size < 0x10) {\njoined_r0x08000290:\n    do {\n      if (data_size == 0) {\n        return (byte *)0x0;\n      }\n      current_data = (uint *)((int)data + 1);\n      current_byte = *(byte *)data;\n      data_size = data_size - 1;\n      data = current_data;\n    } while (current_byte != pattern_byte);\n  }\n  else {\n    data_alignment = (uint)data & 7;\n    while( true ) {\n      if (data_alignment == 0) {\n        data_alignment = pattern_byte | pattern_byte << 8;\n        data_alignment = data_alignment | data_alignment << 0x10;\n        aligned_data_size = data_size & 0xfffffff8;\n        do {\n          current_data = data + 2;\n          aligned_data_size = aligned_data_size - 8;\n          toggled_data = *data ^ data_alignment;\n          toggled_data_next = data[1] ^ data_alignment;\n          is_byte_zero = -((char)toggled_data == '\\0');\n          is_high_byte_zero = -((char)(toggled_data >> 8) == '\\0');\n          is_higher_byte_zero = -((char)(toggled_data >> 0x10) == '\\0');\n          is_highest_byte_zero = -((char)(toggled_data >> 0x18) == '\\0');\n          toggled_data = CONCAT13(is_highest_byte_zero,CONCAT12(is_higher_byte_zero,CONCAT11(is_high_byte_zero,is_byte_zero)));\n          is_high_byte_set = (char)toggled_data_next != '\\0';\n          is_higher_byte_set = (char)(toggled_data_next >> 8) != '\\0';\n          is_highest_byte_set = (char)(toggled_data_next >> 0x10) != '\\0';\n          is_highest_byte_set_prev = (char)(toggled_data_next >> 0x18) != '\\0';\n          toggled_data_next = CONCAT13(is_highest_byte_set_prev * is_highest_byte_zero - !is_highest_byte_set_prev,\n                            CONCAT12(is_highest_byte_set * is_higher_byte_zero - !is_highest_byte_set,\n                                     CONCAT11(is_higher_byte_set * is_high_byte_zero - !is_higher_byte_set,is_high_byte_set * is_byte_zero - !is_high_byte_set)));\n          if (toggled_data_next != 0) {\n            if (toggled_data == 0) {\n              next_byte = (byte *)((int)data + 5);\n              toggled_data = toggled_data_next;\n            }\n            else {\n              next_byte = (byte *)((int)data + 1);\n            }\n            if ((toggled_data & 1) == 0) {\n              is_high_byte_set = (toggled_data & 0x100) == 0;\n              found_pattern = next_byte + 1;\n              if (is_high_byte_set) {\n                is_high_byte_set = (toggled_data & 0x18000) == 0;\n                found_pattern = next_byte + 2;\n              }\n              next_byte = found_pattern;\n              if (is_high_byte_set) {\n                next_byte = next_byte + 1;\n              }\n            }\n            return next_byte + -1;\n          }\n          data = current_data;\n        } while (aligned_data_size != 0);\n        data_size = data_size & 7;\n        goto joined_r0x08000290;\n      }\n      current_data = (uint *)((int)data + 1);\n      data_size = data_size - 1;\n      if (*(byte *)data == pattern_byte) break;\n      data_alignment = (uint)current_data & 7;\n      data = current_data;\n      if (data_size == 0) {\n        return (byte *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)current_data + -1);\n}\n\n",
            "renaming": {
                "FUN_08000230": "find_pattern_position_08000230",
                "param_1": "data",
                "param_2": "pattern_byte",
                "param_3": "data_size",
                "bVar1": "current_byte",
                "cVar2": "is_byte_zero",
                "cVar3": "is_high_byte_zero",
                "cVar4": "is_higher_byte_zero",
                "cVar5": "is_highest_byte_zero",
                "pbVar6": "found_pattern",
                "puVar7": "current_data",
                "pbVar8": "next_byte",
                "uVar9": "data_alignment",
                "uVar10": "aligned_data_size",
                "uVar11": "toggled_data",
                "uVar12": "toggled_data_next",
                "bVar13": "is_high_byte_set",
                "bVar14": "is_higher_byte_set",
                "bVar15": "is_highest_byte_set",
                "bVar16": "is_highest_byte_set_prev"
            },
            "calling": [
                "_printf_i",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002d0": {
            "entrypoint": "0x080002d0",
            "current_name": "calculate_result_080002d0",
            "code": "\nundefined8 calculate_result_080002d0(int input_1,int input_2,int input_3,int input_4)\n\n{\n  undefined8 result;\n  \n  if ((input_4 == 0) && (input_3 == 0)) {\n    if (input_2 != 0 || input_1 != 0) {\n      input_2 = -1;\n      input_1 = -1;\n    }\n    return CONCAT44(input_2,input_1);\n  }\n  result = __udivmoddi4();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080002d0": "calculate_result_080002d0",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result"
            },
            "calling": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "called": [
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000300": {
            "entrypoint": "0x08000300",
            "current_name": "division_with_remainder_08000300",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080005aa) */\n\nulonglong division_with_remainder_08000300(uint dividend,uint dividend_upper,uint divisor,uint divisor_upper,uint *quotient)\n\n{\n  ulonglong combined_quotient;\n  uint temp;\n  uint quotient_lower;\n  uint quotient_upper;\n  uint remainder;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  int shift_amount;\n  bool carry_flag;\n  \n  if (divisor_upper == 0) {\n    if (dividend_upper < divisor) {\n      shift_amount = LZCOUNT(divisor);\n      if (shift_amount != 0) {\n        divisor = divisor << shift_amount;\n        dividend_upper = dividend >> (0x20U - shift_amount & 0xff) | dividend_upper << shift_amount;\n        dividend = dividend << shift_amount;\n      }\n      temp3 = divisor >> 0x10;\n      temp1 = dividend_upper / temp3;\n      remainder = dividend >> 0x10 | (dividend_upper - temp3 * temp1) * 0x10000;\n      quotient_upper = temp1 * (divisor & 0xffff);\n      quotient_lower = temp1;\n      if (remainder <= quotient_upper && quotient_upper - remainder != 0) {\n        carry_flag = CARRY4(remainder,divisor);\n        remainder = remainder + divisor;\n        quotient_lower = temp1 - 1;\n        if ((carry_flag == false) && (remainder <= quotient_upper && quotient_upper - remainder != 0)) {\n          quotient_lower = temp1 - 2;\n          remainder = remainder + divisor;\n        }\n      }\n      temp1 = (remainder - quotient_upper) / temp3;\n      remainder = dividend & 0xffff | ((remainder - quotient_upper) - temp3 * temp1) * 0x10000;\n      temp3 = temp1 * (divisor & 0xffff);\n      quotient_upper = temp1;\n      if (remainder <= temp3 && temp3 - remainder != 0) {\n        carry_flag = CARRY4(remainder,divisor);\n        remainder = remainder + divisor;\n        quotient_upper = temp1 - 1;\n        if ((carry_flag == false) && (remainder <= temp3 && temp3 - remainder != 0)) {\n          quotient_upper = temp1 - 2;\n          remainder = remainder + divisor;\n        }\n      }\n      remainder = remainder - temp3;\n      quotient_upper = quotient_upper | quotient_lower << 0x10;\n      quotient_lower = 0;\n    }\n    else {\n      if (divisor == 0) {\n        divisor = 1 / 0;\n      }\n      shift_amount = LZCOUNT(divisor);\n      if (shift_amount == 0) {\n        dividend_upper = dividend_upper - divisor;\n        remainder = divisor >> 0x10;\n        temp4 = divisor & 0xffff;\n        quotient_lower = 1;\n      }\n      else {\n        divisor = divisor << shift_amount;\n        remainder = divisor >> 0x10;\n        quotient_upper = dividend_upper >> (0x20U - shift_amount & 0xff);\n        temp2 = dividend >> (0x20U - shift_amount & 0xff) | dividend_upper << shift_amount;\n        quotient_lower = quotient_upper / remainder;\n        temp4 = divisor & 0xffff;\n        temp3 = temp2 >> 0x10 | (quotient_upper - remainder * quotient_lower) * 0x10000;\n        temp1 = quotient_lower * temp4;\n        dividend = dividend << shift_amount;\n        quotient_upper = quotient_lower;\n        if (temp3 <= temp1 && temp1 - temp3 != 0) {\n          carry_flag = CARRY4(temp3,divisor);\n          temp3 = temp3 + divisor;\n          quotient_upper = quotient_lower - 1;\n          if ((carry_flag == false) && (temp3 <= temp1 && temp1 - temp3 != 0)) {\n            quotient_upper = quotient_lower - 2;\n            temp3 = temp3 + divisor;\n          }\n        }\n        temp = (temp3 - temp1) / remainder;\n        dividend_upper = temp2 & 0xffff | ((temp3 - temp1) - remainder * temp) * 0x10000;\n        temp1 = temp * temp4;\n        quotient_lower = temp;\n        if (dividend_upper <= temp1 && temp1 - dividend_upper != 0) {\n          carry_flag = CARRY4(dividend_upper,divisor);\n          dividend_upper = dividend_upper + divisor;\n          quotient_lower = temp - 1;\n          if ((carry_flag == false) && (dividend_upper <= temp1 && temp1 - dividend_upper != 0)) {\n            quotient_lower = temp - 2;\n            dividend_upper = dividend_upper + divisor;\n          }\n        }\n        dividend_upper = dividend_upper - temp1;\n        quotient_lower = quotient_lower | quotient_upper << 0x10;\n      }\n      temp2 = dividend_upper / remainder;\n      temp3 = dividend >> 0x10 | (dividend_upper - remainder * temp2) * 0x10000;\n      quotient_upper = temp4 * temp2;\n      temp1 = temp2;\n      if (temp3 <= quotient_upper && quotient_upper - temp3 != 0) {\n        carry_flag = CARRY4(temp3,divisor);\n        temp3 = temp3 + divisor;\n        temp1 = temp2 - 1;\n        if ((carry_flag == false) && (temp3 <= quotient_upper && quotient_upper - temp3 != 0)) {\n          temp1 = temp2 - 2;\n          temp3 = temp3 + divisor;\n        }\n      }\n      temp2 = (temp3 - quotient_upper) / remainder;\n      remainder = dividend & 0xffff | ((temp3 - quotient_upper) - remainder * temp2) * 0x10000;\n      temp4 = temp4 * temp2;\n      quotient_upper = temp2;\n      if (remainder <= temp4 && temp4 - remainder != 0) {\n        carry_flag = CARRY4(remainder,divisor);\n        remainder = remainder + divisor;\n        quotient_upper = temp2 - 1;\n        if ((carry_flag == false) && (remainder <= temp4 && temp4 - remainder != 0)) {\n          quotient_upper = temp2 - 2;\n          remainder = remainder + divisor;\n        }\n      }\n      remainder = remainder - temp4;\n      quotient_upper = quotient_upper | temp1 << 0x10;\n    }\n    if (quotient != (uint *)0x0) {\n      *quotient = remainder >> shift_amount;\n      quotient[1] = 0;\n      return CONCAT44(quotient_lower,quotient_upper);\n    }\n  }\n  else if (dividend_upper < divisor_upper) {\n    if (quotient != (uint *)0x0) {\n      *quotient = dividend;\n      quotient[1] = dividend_upper;\n      return 0;\n    }\n    quotient_upper = 0;\n    quotient_lower = 0;\n  }\n  else {\n    shift_amount = LZCOUNT(divisor_upper);\n    if (shift_amount != 0) {\n      temp3 = 0x20 - shift_amount;\n      quotient_lower = divisor >> (temp3 & 0xff) | divisor_upper << shift_amount;\n      temp4 = quotient_lower >> 0x10;\n      quotient_upper = dividend_upper >> (temp3 & 0xff);\n      temp = dividend >> (temp3 & 0xff) | dividend_upper << shift_amount;\n      temp2 = quotient_upper / temp4;\n      temp1 = temp >> 0x10 | (quotient_upper - temp4 * temp2) * 0x10000;\n      remainder = temp2 * (quotient_lower & 0xffff);\n      dividend = dividend << shift_amount;\n      quotient_upper = temp2;\n      if (temp1 <= remainder && remainder - temp1 != 0) {\n        carry_flag = CARRY4(temp1,quotient_lower);\n        temp1 = temp1 + quotient_lower;\n        quotient_upper = temp2 - 1;\n        if ((carry_flag == false) && (temp1 <= remainder && remainder - temp1 != 0)) {\n          quotient_upper = temp2 - 2;\n          temp1 = temp1 + quotient_lower;\n        }\n      }\n      temp2 = (temp1 - remainder) / temp4;\n      temp1 = temp & 0xffff | ((temp1 - remainder) - temp4 * temp2) * 0x10000;\n      temp4 = temp2 * (quotient_lower & 0xffff);\n      remainder = temp2;\n      if (temp1 <= temp4 && temp4 - temp1 != 0) {\n        carry_flag = CARRY4(temp1,quotient_lower);\n        temp1 = temp1 + quotient_lower;\n        remainder = temp2 - 1;\n        if ((carry_flag == false) && (temp1 <= temp4 && temp4 - temp1 != 0)) {\n          remainder = temp2 - 2;\n          temp1 = temp1 + quotient_lower;\n        }\n      }\n      remainder = remainder | quotient_upper << 0x10;\n      combined_quotient = (ulonglong)remainder * (ulonglong)(divisor << shift_amount);\n      if (CONCAT44(temp1 - temp4,dividend) < combined_quotient) {\n        combined_quotient = combined_quotient - CONCAT44(quotient_lower,divisor << shift_amount);\n        remainder = remainder - 1;\n      }\n      if (quotient != (uint *)0x0) {\n        quotient_upper = ((temp1 - temp4) - (int)(combined_quotient >> 0x20)) - (uint)(dividend < (uint)combined_quotient);\n        *quotient = quotient_upper << (temp3 & 0xff) | dividend - (uint)combined_quotient >> shift_amount;\n        quotient[1] = quotient_upper >> shift_amount;\n      }\n      return (ulonglong)remainder;\n    }\n    if ((divisor_upper < dividend_upper) || (divisor <= dividend)) {\n      carry_flag = dividend < divisor;\n      dividend = dividend - divisor;\n      dividend_upper = (dividend_upper - divisor_upper) - (uint)carry_flag;\n      quotient_upper = 1;\n    }\n    else {\n      quotient_upper = 0;\n    }\n    quotient_lower = 0;\n    if (quotient != (uint *)0x0) {\n      *quotient = dividend;\n      quotient[1] = dividend_upper;\n      return (ulonglong)quotient_upper;\n    }\n  }\n  return CONCAT44(quotient_lower,quotient_upper);\n}\n\n",
            "renaming": {
                "FUN_08000300": "division_with_remainder_08000300",
                "param_1": "dividend",
                "param_2": "dividend_upper",
                "param_3": "divisor",
                "param_4": "divisor_upper",
                "param_5": "quotient",
                "uVar1": "combined_quotient",
                "uVar2": "temp",
                "uVar3": "quotient_lower",
                "uVar4": "quotient_upper",
                "uVar5": "remainder",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "uVar8": "temp3",
                "uVar9": "temp4",
                "iVar10": "shift_amount",
                "bVar11": "carry_flag"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005e0": {
            "entrypoint": "0x080005e0",
            "current_name": "perform_system_call_080005e0",
            "code": "\nvoid performSystemCall_080005e0(void)\n\n{\n  software_interrupt(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080005e0": "perform_system_call_080005e0"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005e4": {
            "entrypoint": "0x080005e4",
            "current_name": "process_afl_080005e4",
            "code": "\nundefined4 processAFL_080005e4(undefined4 inputParam,undefined4 unusedParam,undefined4 unusedParam2,undefined4 aflParam)\n\n{\n  undefined4 result;\n  \n  if (DAT_20000120 != 0) {\n    return 0;\n  }\n  result = aflCall(1,inputParam,0,0,aflParam);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080005e4": "process_afl_080005e4",
                "param_1": "inputParam",
                "param_2": "unusedParam",
                "param_3": "unusedParam2",
                "param_4": "aflParam",
                "uVar1": "result"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000600": {
            "entrypoint": "0x08000600",
            "current_name": "initialize_gpio_08000600",
            "code": "\nvoid initializeGPIO_08000600(int **gpioPtr,undefined4 param2)\n\n{\n  char gpioValue;\n  int returnValue;\n  \n  gpioValue = *(char *)((int)gpioPtr + 5);\n  if (gpioValue == '\\x02') {\n    *gpioPtr = &DAT_20000338;\n  }\n  else if (gpioValue == '\\x03') {\n    *gpioPtr = &DAT_20000338;\n  }\n  else if (gpioValue == '\\x01') {\n    *gpioPtr = &DAT_20000338;\n  }\n  else {\n    *gpioPtr = &DAT_20000338;\n  }\n  begin(*gpioPtr,param2,6);\n  if (1 < *(byte *)((int)gpioPtr + 6)) {\n    pinMode(*(byte *)((int)gpioPtr + 6),1);\n    digitalWrite(*(undefined *)((int)gpioPtr + 6),0);\n  }\n  do {\n    returnValue = (**(code **)(**gpioPtr + 0xc))();\n  } while (-1 < returnValue);\n  *(undefined *)((int)gpioPtr + 0x49) = 0;\n  *(undefined *)((int)gpioPtr + 0x4a) = 0;\n  *(undefined2 *)(gpioPtr + 0x15) = 0;\n  *(undefined2 *)((int)gpioPtr + 0x52) = 0;\n  *(undefined2 *)(gpioPtr + 0x14) = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000600": "initialize_gpio_08000600",
                "param_1": "gpioPtr",
                "param_2": "param2",
                "cVar1": "gpioValue",
                "iVar2": "returnValue"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "digitalWrite",
                "pinMode",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800066c": {
            "entrypoint": "0x0800066c",
            "current_name": "initialize_data_0800066c",
            "code": "\nvoid initializeData_0800066c(int dataPtr,undefined value,int limit,undefined otherValue)\n\n{\n  *(undefined *)(dataPtr + 4) = value;\n  if (3 < limit) {\n    limit = 0;\n  }\n  *(char *)(dataPtr + 5) = (char)limit;\n  *(undefined *)(dataPtr + 6) = otherValue;\n  *(undefined2 *)(dataPtr + 0x56) = 1000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800066c": "initialize_data_0800066c",
                "param_1": "dataPtr",
                "param_2": "value",
                "param_3": "limit",
                "param_4": "otherValue"
            },
            "calling": [
                "Modbus"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000682": {
            "entrypoint": "0x08000682",
            "current_name": "initialize_and_return_param_08000682",
            "code": "\nundefined4 initialize_and_return_param_08000682(undefined4 input_param)\n\n{\n  initialize_data();\n  return input_param;\n}\n\n",
            "renaming": {
                "FUN_08000682": "initialize_and_return_param_08000682",
                "param_1": "input_param",
                "initialize_data_0800066c": "initialize_data"
            },
            "calling": [
                "FUN_08000690"
            ],
            "called": [
                "FUN_0800066c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000690": {
            "entrypoint": "0x08000690",
            "current_name": "process_modbus_message_08000690",
            "code": "\nvoid process_modbus_message_08000690(int is_valid_message,int message_code,undefined4 unused_param,undefined4 modbus_data)\n\n{\n  if (is_valid_message != 1) {\n    return;\n  }\n  if (message_code == 0xffff) {\n    Modbus(&DAT_20000124,1,0,0,modbus_data);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000690": "process_modbus_message_08000690",
                "param_1": "is_valid_message",
                "param_2": "message_code",
                "param_3": "unused_param",
                "param_4": "modbus_data"
            },
            "calling": [],
            "called": [
                "Modbus"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006b4": {
            "entrypoint": "0x080006b4",
            "current_name": "analyze_data_080006b4",
            "code": "\nint analyze_data_080006b4(int **data)\n\n{\n  bool hasOverflow;\n  undefined result;\n  int returnValue;\n  byte index;\n  \n  if (1 < *(byte *)((int)data plus 6)) {\n    turnOffDigitalPin(*(byte *)((int)data plus 6),0);\n  }\n  *(undefined *)((int)data plus 0x49) = 0;\n  if (*(byte *)((int)data plus 5) < 4) {\n    hasOverflow = false;\n    while (returnValue = (**(functionPointer **)(**data plus 8))(), returnValue isNotEqualTo 0) {\n      index = *(byte *)((int)data plus 0x49);\n      result = (**(functionPointer **)(**data plus 0xc))();\n      *(undefined *)((int)data plus index plus 9) = result;\n      index = *(char *)((int)data plus 0x49) plus 1;\n      *(byte *)((int)data plus 0x49) = index;\n      if (0x3f < index) {\n        hasOverflow = true;\n      }\n    }\n  }\n  else {\n    hasOverflow = false;\n  }\n  *(short *)(data plus 0x14) = *(short *)(data plus 0x14) plus 1;\n  if (hasOverflow) {\n    *(short *)(data plus 0x15) = *(short *)(data plus 0x15) plus 1;\n    return -3;\n  }\n  return (int)*(char *)((int)data plus 0x49);\n}\n\n",
            "renaming": {
                "FUN_080006b4": "analyze_data_080006b4",
                "param_1": "data",
                "bVar1": "hasOverflow",
                "uVar2": "result",
                "iVar3": "returnValue",
                "bVar4": "index",
                "digitalWrite": "turnOffDigitalPin",
                "code": "functionPointer",
                "+": "plus",
                "!=": "isNotEqualTo"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000728": {
            "entrypoint": "0x08000728",
            "current_name": "calculate_crc16_08000728",
            "code": "\nuint calculate_crc16_08000728(int data_ptr,int data_length)\n\n{\n  byte bit_count;\n  uint crc;\n  uint lsb;\n  uint i;\n  \n  crc = 0xffff;\n  for (i = 0; (int)i < data_length; i = i + 1 & 0xff) {\n    crc = crc ^ *(byte *)(data_ptr + i + 9);\n    for (bit_count = 1; bit_count < 9; bit_count = bit_count + 1) {\n      lsb = crc & 1;\n      crc = crc >> 1;\n      if (lsb != 0) {\n        crc = crc ^ 0xa001;\n      }\n    }\n  }\n  return (crc & 0xff) << 8 | crc >> 8;\n}\n\n",
            "renaming": {
                "FUN_08000728": "calculate_crc16_08000728",
                "param_1": "data_ptr",
                "param_2": "data_length",
                "bVar1": "bit_count",
                "uVar2": "crc",
                "uVar3": "lsb",
                "uVar4": "i"
            },
            "calling": [
                "sendTxBuffer"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800076c": {
            "entrypoint": "0x0800076c",
            "current_name": "update_crc_and_set_timer_0800076c",
            "code": "\nvoid updateCRCAndSetTimer_0800076c(int **inputParams,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  undefined2 calculatedCRC;\n  int iterationCount;\n  uint currentValue;\n  \n  currentValue = (uint)*(byte *)((int)inputParams + 0x49);\n  calculatedCRC = calculateCRC(inputParams,currentValue,param3,param4,param4);\n  *(char *)((int)inputParams + currentValue + 9) = (char)((ushort)calculatedCRC >> 8);\n  currentValue = currentValue + 1 & 0xff;\n  *(char *)((int)inputParams + currentValue + 9) = (char)calculatedCRC;\n  *(char *)((int)inputParams + 0x49) = (char)currentValue + '\\x01';\n  if (1 < *(byte *)((int)inputParams + 6)) {\n    setDigitalState(*(byte *)((int)inputParams + 6),1);\n  }\n  if (*(byte *)((int)inputParams + 5) < 4) {\n    (**(code **)(**inputParams + 4))(*inputParams,(int)inputParams + 9,*(undefined *)((int)inputParams + 0x49));\n  }\n  if (1 < *(byte *)((int)inputParams + 6)) {\n    setDigitalState(*(byte *)((int)inputParams + 6),0);\n  }\n  if (*(byte *)((int)inputParams + 5) < 4) {\n    do {\n      iterationCount = (**(code **)(**inputParams + 0xc))();\n    } while (-1 < iterationCount);\n  }\n  *(undefined *)((int)inputParams + 0x49) = 0;\n  iterationCount = getCurrentTime();\n  inputParams[0x17] = (int *)(iterationCount + (uint)*(ushort *)((int)inputParams + 0x56));\n  *(short *)((int)inputParams + 0x52) = *(short *)((int)inputParams + 0x52) + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800076c": "update_crc_and_set_timer_0800076c",
                "param_1": "inputParams",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "calculatedCRC",
                "iVar2": "iterationCount",
                "uVar3": "currentValue",
                "calcCRC": "calculateCRC",
                "digitalWrite": "setDigitalState",
                "millis": "getCurrentTime"
            },
            "calling": [
                "process_FC3",
                "poll",
                "process_FC15",
                "process_FC6",
                "process_FC5",
                "process_FC16",
                "process_FC1"
            ],
            "called": [
                "digitalWrite",
                "calcCRC",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080007f0": {
            "entrypoint": "0x080007f0",
            "current_name": "check_conditions_080007f0",
            "code": "\nundefined4 checkConditions_080007f0(int arg1,undefined4 arg2,uint arg3,undefined4 arg4)\n\n{\n  bool isMatch;\n  byte result;\n  char word1;\n  char word2;\n  int num1;\n  uint index;\n  int num2;\n  \n  index = 0;\n  do {\n    if (7 < index) {\n      isMatch = false;\nLAB_0800080a:\n      if (!isMatch) {\n        *(short *)(arg1 + 0x54) = *(short *)(arg1 + 0x54) + 1;\n        return 1;\n      }\n      num2 = *(byte *)(arg1 + 10) - 1;\n      switch(*(byte *)(arg1 + 10)) {\n      case 1:\n      case 2:\n      case 0xf:\n        goto switchD_08000816_caseD_1;\n      case 3:\n      case 4:\n      case 0x10:\n        word1 = makeWord(*(undefined *)(arg1 + 0xb),*(undefined *)(arg1 + 0xc),arg3,num2,\n                         arg4);\n        word2 = makeWord(*(undefined *)(arg1 + 0xd),*(undefined *)(arg1 + 0xe));\n        if (*(byte *)(arg1 + 0x60) < (byte)(word2 + word1)) {\n          return 2;\n        }\n        return 0;\n      case 5:\n        num2 = makeWord(*(undefined *)(arg1 + 0xb),*(undefined *)(arg1 + 0xc),arg3,num2,\n                         arg4);\n        if ((uint)*(byte *)(arg1 + 0x60) < (uint)(num2 << 0x14) >> 0x18) {\n          return 2;\n        }\n        return 0;\n      case 6:\n        result = makeWord(*(undefined *)(arg1 + 0xb),*(undefined *)(arg1 + 0xc),arg3,num2,\n                         arg4);\n        if (*(byte *)(arg1 + 0x60) < result) {\n          return 2;\n        }\n        return 0;\n      default:\n        return 0;\n      }\n    }\n    arg3 = (uint)*(byte *)(arg1 + 10);\n    if ((byte)(&DAT_08005a10)[index] == arg3) {\n      isMatch = true;\n      goto LAB_0800080a;\n    }\n    index = index + 1 & 0xff;\n  } while( true );\nswitchD_08000816_caseD_1:\n  num2 = makeWord(*(undefined *)(arg1 + 0xb),*(undefined *)(arg1 + 0xc),arg3,num2,arg4\n                  );\n  num1 = makeWord(*(undefined *)(arg1 + 0xd),*(undefined *)(arg1 + 0xe));\n  if ((uint)*(byte *)(arg1 + 0x60) <\n      (((uint)(num2 << 0xc) >> 0x10) + ((uint)(num1 << 0xc) >> 0x10) & 0xff)) {\n    return 2;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080007f0": "check_conditions_080007f0",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "bVar1": "isMatch",
                "bVar2": "result",
                "cVar3": "word1",
                "cVar4": "word2",
                "iVar5": "num1",
                "uVar6": "index",
                "iVar7": "num2"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008cc": {
            "entrypoint": "0x080008cc",
            "current_name": "copy_data_080008cc",
            "code": "\nvoid copyData_080008cc(int destination,undefined value)\n\n{\n  *(undefined *)(destination + 9) = *(undefined *)(destination + 4);\n  *(byte *)(destination + 10) = *(byte *)(destination + 10) ^ 0x80;\n  *(undefined *)(destination + 0xb) = value;\n  *(undefined *)(destination + 0x49) = 3;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080008cc": "copy_data_080008cc",
                "param_1": "destination",
                "param_2": "value"
            },
            "calling": [
                "poll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008e2": {
            "entrypoint": "0x080008e2",
            "current_name": "update_flags_and_send_080008e2",
            "code": "\nint updateFlagsAndSend_080008e2(int buffer,int data,undefined4 param3,undefined4 param4)\n\n{\n  int word;\n  uint wordData;\n  uint index;\n  uint bitIndex;\n  char shiftedBits;\n  int offset;\n  \n  word = makeWord(*(undefined *)(buffer + 0xb),*(undefined *)(buffer + 0xc),param3,param4,\n                   param4);\n  wordData = makeWord(*(undefined *)(buffer + 0xd),*(undefined *)(buffer + 0xe));\n  shiftedBits = (char)((wordData << 0x15) >> 0x18);\n  if ((wordData & 7) != 0) {\n    shiftedBits = shiftedBits + '\\x01';\n  }\n  *(char *)(buffer + 0xb) = shiftedBits;\n  *(undefined *)(buffer + 0x49) = 3;\n  bitIndex = 0;\n  for (index = 0; (int)index < (int)wordData; index = index + 1 & 0xffff) {\n    if (((int)(uint)*(ushort *)(data + ((index + word) * 0x100000 >> 0x18) * 2) >>\n         (index + word & 0xf) & 1U) == 0) {\n      offset = (uint)*(byte *)(buffer + 0x49) + buffer;\n      *(byte *)(offset + 9) = *(byte *)(offset + 9) & ~(byte)(1 << bitIndex);\n    }\n    else {\n      offset = (uint)*(byte *)(buffer + 0x49) + buffer;\n      *(byte *)(offset + 9) = *(byte *)(offset + 9) | (byte)(1 << bitIndex);\n    }\n    bitIndex = bitIndex + 1 & 0xff;\n    if (7 < bitIndex) {\n      *(char *)(buffer + 0x49) = *(char *)(buffer + 0x49) + '\\x01';\n      bitIndex = 0;\n    }\n  }\n  if ((wordData & 7) != 0) {\n    *(char *)(buffer + 0x49) = *(char *)(buffer + 0x49) + '\\x01';\n  }\n  shiftedBits = *(char *)(buffer + 0x49);\n  sendTxBuffer(buffer);\n  return (int)(char)(shiftedBits + '\\x02');\n}\n\n",
            "renaming": {
                "FUN_080008e2": "update_flags_and_send_080008e2",
                "param_1": "buffer",
                "param_2": "data",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "word",
                "uVar2": "wordData",
                "uVar3": "index",
                "uVar4": "bitIndex",
                "cVar5": "shiftedBits",
                "iVar6": "offset"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "parse_and_send_data_08000998",
            "code": "\nint parseAndSendData_08000998(int buffer,int data,undefined4 input1,undefined4 input2)\n\n{\n  byte count;\n  char index;\n  byte word1;\n  byte word2;\n  uint start;\n  uint next;\n  \n  word1 = combineBytes(*(undefined *)(buffer + 0xb),*(undefined *)(buffer + 0xc),input1,input2,\n                   input2);\n  word2 = combineBytes(*(undefined *)(buffer + 0xd),*(undefined *)(buffer + 0xe));\n  *(byte *)(buffer + 0xb) = word2 << 1;\n  *(undefined *)(buffer + 0x49) = 3;\n  for (start = (uint)word1; start < (uint)word1 + (uint)word2; start = start + 1 & 0xff) {\n    count = *(byte *)(buffer + 0x49);\n    *(char *)(buffer + (uint)count + 9) = (char)((ushort)*(undefined2 *)(data + start * 2) >> 8)\n    ;\n    next = count + 1 & 0xff;\n    index = (char)next;\n    *(char *)(buffer + 0x49) = index;\n    *(undefined *)(buffer + next + 9) = *(undefined *)(data + start * 2);\n    *(char *)(buffer + 0x49) = index + '\\x01';\n  }\n  index = *(char *)(buffer + 0x49);\n  transmitBuffer(buffer);\n  return (int)(char)(index + '\\x02');\n}\n\n",
            "renaming": {
                "FUN_08000998": "parse_and_send_data_08000998",
                "param_1": "buffer",
                "param_2": "data",
                "param_3": "input1",
                "param_4": "input2",
                "bVar1": "count",
                "cVar2": "index",
                "bVar3": "word1",
                "bVar4": "word2",
                "uVar5": "start",
                "uVar6": "next",
                "makeWord": "combineBytes",
                "sendTxBuffer": "transmitBuffer"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a00": {
            "entrypoint": "0x08000a00",
            "current_name": "update_value_in_buffer_08000a00",
            "code": "\nundefined4 updateValueInBuffer_08000a00(int bufferOffset,int dataBuffer,undefined4 value1,undefined4 value2)\n\n{\n  uint combinedValue;\n  uint bufferIndex;\n  \n  combinedValue = makeWord(*(undefined *)(bufferOffset + 0xb),*(undefined *)(bufferOffset + 0xc),value1,value2,\n                   value2);\n  bufferIndex = (combinedValue << 0x14) >> 0x18;\n  if (*(char *)(bufferOffset + 0xd) == -1) {\n    *(ushort *)(dataBuffer + bufferIndex * 2) =\n         (ushort)(1 << (combinedValue & 0xf)) | *(ushort *)(dataBuffer + bufferIndex * 2);\n  }\n  else {\n    *(ushort *)(dataBuffer + bufferIndex * 2) =\n         *(ushort *)(dataBuffer + bufferIndex * 2) & ~(ushort)(1 << (combinedValue & 0xf));\n  }\n  *(undefined *)(bufferOffset + 0x49) = 6;\n  sendTxBuffer(bufferOffset);\n  return 8;\n}\n\n",
            "renaming": {
                "FUN_08000a00": "update_value_in_buffer_08000a00",
                "param_1": "bufferOffset",
                "param_2": "dataBuffer",
                "param_3": "value1",
                "param_4": "value2",
                "uVar1": "combinedValue",
                "uVar2": "bufferIndex"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a4e": {
            "entrypoint": "0x08000a4e",
            "current_name": "update_tx_buffer_08000a4e",
            "code": "\nundefined4 updateTxBuffer_08000a4e(int bufferAddress,int txBufferAddress)\n\n{\n  byte word1;\n  undefined2 word2;\n  \n  word1 = makeWord(*(undefined *)(bufferAddress + 0xb),*(undefined *)(bufferAddress + 0xc));\n  word2 = makeWord(*(undefined *)(bufferAddress + 0xd),*(undefined *)(bufferAddress + 0xe));\n  *(undefined2 *)(txBufferAddress + (uint)word1 * 2) = word2;\n  *(undefined *)(bufferAddress + 0x49) = 6;\n  sendTxBuffer(bufferAddress);\n  return 8;\n}\n\n",
            "renaming": {
                "FUN_08000a4e": "update_tx_buffer_08000a4e",
                "param_1": "bufferAddress",
                "param_2": "txBufferAddress",
                "bVar1": "word1",
                "uVar2": "word2"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a7a": {
            "entrypoint": "0x08000a7a",
            "current_name": "decode_and_write_bits_08000a7a",
            "code": "\nundefined4 decodeAndWriteBits_08000a7a(int dataBuffer,int outputBuffer,undefined4 param3,undefined4 param4)\n\n{\n  int word1;\n  int word2;\n  uint bitIndex;\n  uint byteIndex;\n  uint bitMask;\n  uint byteOffset;\n  uint paramIndex;\n  \n  word1 = makeWord(*(undefined *)(dataBuffer + 0xb),*(undefined *)(dataBuffer + 0xc),param3,param4,\n                   param4);\n  word2 = makeWord(*(undefined *)(dataBuffer + 0xd),*(undefined *)(dataBuffer + 0xe));\n  byteIndex = 0;\n  paramIndex = 7;\n  for (bitIndex = 0; (int)bitIndex < word2; bitIndex = bitIndex + 1 & 0xffff) {\n    byteOffset = (bitIndex + word1) * 0x100000 >> 0x18;\n    bitMask = bitIndex + word1 & 0xf;\n    if (((int)(uint)*(byte *)(dataBuffer + paramIndex + 9) >> byteIndex & 1U) == 0) {\n      *(ushort *)(outputBuffer + byteOffset * 2) = *(ushort *)(outputBuffer + byteOffset * 2) & ~(ushort)(1 << bitMask);\n    }\n    else {\n      *(ushort *)(outputBuffer + byteOffset * 2) = (ushort)(1 << bitMask) | *(ushort *)(outputBuffer + byteOffset * 2);\n    }\n    byteIndex = byteIndex + 1 & 0xff;\n    if (7 < byteIndex) {\n      paramIndex = paramIndex + 1 & 0xff;\n      byteIndex = 0;\n    }\n  }\n  *(undefined *)(dataBuffer + 0x49) = 6;\n  sendTxBuffer(dataBuffer);\n  return 8;\n}\n\n",
            "renaming": {
                "FUN_08000a7a": "decode_and_write_bits_08000a7a",
                "param_1": "dataBuffer",
                "param_2": "outputBuffer",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "word1",
                "iVar2": "word2",
                "uVar3": "bitIndex",
                "uVar4": "byteIndex",
                "uVar5": "bitMask",
                "uVar6": "byteOffset",
                "uVar7": "paramIndex"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b04": {
            "entrypoint": "0x08000b04",
            "current_name": "process_data_08000b04",
            "code": "\nint processData_08000b04(int data1,int data2)\n\n{\n  byte byte1;\n  byte byte2;\n  char char1;\n  undefined2 word1;\n  uint index;\n  \n  byte1 = *(byte *)(data1 + 0xc);\n  byte2 = *(byte *)(data1 + 0xe);\n  *(undefined *)(data1 + 0xd) = 0;\n  *(byte *)(data1 + 0xe) = byte2;\n  *(undefined *)(data1 + 0x49) = 6;\n  for (index = 0; index < byte2; index = index + 1 & 0xff) {\n    word1 = makeWord(*(undefined *)(index * 2 + data1 + 0x10),\n                     *(undefined *)(data1 + (index + 4) * 2 + 9));\n    *(undefined2 *)(data2 + (byte1 + index) * 2) = word1;\n  }\n  char1 = *(char *)(data1 + 0x49);\n  sendTxBuffer(data1);\n  return (int)(char)(char1 + '\\x02');\n}\n\n",
            "renaming": {
                "FUN_08000b04": "process_data_08000b04",
                "param_1": "data1",
                "param_2": "data2",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "cVar3": "char1",
                "uVar4": "word1",
                "uVar5": "index"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b54": {
            "entrypoint": "0x08000b54",
            "current_name": "process_request_08000b54",
            "code": "\nint processRequest_08000b54(int **request,int *buffer,undefined4 size)\n\n{\n  byte result;\n  int validationResult;\n  uint errorCode;\n  int returnValue;\n  \n  request[0x13] = buffer;\n  *(char *)(request + 0x18) = (char)size;\n  if (*(byte *)((int)request + 5) < 4) {\n    result = (**(code **)(**request + 8))();\n    errorCode = (uint)result;\n  }\n  if (errorCode == 0) {\n    returnValue = 0;\n  }\n  else if ((int)errorCode < 8) {\n    returnValue = 0;\n  }\n  else {\n    returnValue = getRxBuffer(request);\n    *(char *)(request + 2) = (char)returnValue;\n    if (*(char *)((int)request + 9) == *(char *)(request + 1)) {\n      validationResult = validateRequest(request);\n      if (validationResult < 1) {\n        validationResult = millis();\n        request[0x17] = (int *)((uint)*(ushort *)((int)request + 0x56) + validationResult);\n        *(undefined *)(request + 2) = 0;\n        switch(*(undefined *)((int)request + 10)) {\n        case 1:\n        case 2:\n          returnValue = process_FC1(request,buffer,size);\n          break;\n        case 3:\n        case 4:\n          returnValue = process_FC3(request,buffer,size);\n          break;\n        case 5:\n          returnValue = process_FC5(request,buffer,size);\n          break;\n        case 6:\n          returnValue = process_FC6(request,buffer,size);\n          break;\n        case 0xf:\n          returnValue = process_FC15(request,buffer,size);\n          break;\n        case 0x10:\n          returnValue = process_FC16(request,buffer,size);\n        }\n      }\n      else {\n        if (validationResult != 0xff) {\n          buildException(request,validationResult);\n          sendTxBuffer(request);\n        }\n        *(char *)(request + 2) = (char)validationResult;\n        returnValue = (int)(char)validationResult;\n      }\n    }\n    else {\n      returnValue = 0;\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08000b54": "process_request_08000b54",
                "param_1": "request",
                "param_2": "buffer",
                "param_3": "size",
                "bVar1": "result",
                "iVar2": "validationResult",
                "unaff_r5": "errorCode",
                "iVar3": "returnValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "buildException",
                "process_FC3",
                "process_FC15",
                "getRxBuffer",
                "process_FC6",
                "validateRequest",
                "process_FC5",
                "process_FC16",
                "millis",
                "process_FC1",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c4c": {
            "entrypoint": "0x08000c4c",
            "current_name": "initialize_forkserver_08000c4c",
            "code": "\nvoid initialize_forkserver_08000c4c(void)\n\n{\n  startForkserver(0);\n  initialize_gpio(&DAT_20000124,0x4b00);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c4c": "initialize_forkserver_08000c4c",
                "initialize_gpio_08000600": "initialize_gpio"
            },
            "calling": [
                "main"
            ],
            "called": [
                "startForkserver",
                "FUN_08000600"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c64": {
            "entrypoint": "0x08000c64",
            "current_name": "poll_data_08000c64",
            "code": "\nvoid pollData_08000c64(void)\n\n{\n  undefined4 input;\n  \n  poll(&DAT_20000124,&DAT_20000004,0x10,input,input);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c64": "poll_data_08000c64",
                "in_r3": "input"
            },
            "calling": [
                "main"
            ],
            "called": [
                "poll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c8c": {
            "entrypoint": "0x08000c8c",
            "current_name": "initialize_system_08000c8c",
            "code": "\n\n\nvoid initializeSystem_08000c8c(void)\n\n{\n  uint systemFrequency;\n  undefined4 oscillatorConfig;\n  undefined4 systemConfig_1;\n  undefined4 oscillatorConfig_1;\n  undefined4 systemConfig_2;\n  undefined4 systemConfig_3;\n  undefined4 systemConfig_4;\n  undefined4 oscillatorConfig_2;\n  undefined4 priorityConfig_1;\n  undefined4 clockConfig_1;\n  undefined4 clockConfig_2;\n  undefined4 clockConfig_3;\n  undefined4 clockConfig_4;\n  undefined4 clockConfig_5;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0xc000;\n  oscillatorConfig = 1;\n  systemConfig_1 = 0x50000;\n  oscillatorConfig_1 = 2;\n  systemConfig_2 = 0x400000;\n  systemConfig_3 = 8;\n  systemConfig_4 = 0x150;\n  oscillatorConfig_2 = 2;\n  priorityConfig_1 = 7;\n  HAL_RCC_OscConfig(&oscillatorConfig);\n  HAL_PWREx_EnableOverDrive();\n  clockConfig_1 = 0xf;\n  clockConfig_2 = 2;\n  clockConfig_3 = 0;\n  clockConfig_4 = 0x1400;\n  clockConfig_5 = 0x1000;\n  HAL_RCC_ClockConfig(&clockConfig_1,5);\n  systemFrequency = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(systemFrequency / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(0xffffffff,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c8c": "initialize_system_08000c8c",
                "local_54": "oscillatorConfig",
                "local_50": "systemConfig_1",
                "local_3c": "oscillatorConfig_1",
                "local_38": "systemConfig_2",
                "local_34": "systemConfig_3",
                "local_30": "systemConfig_4",
                "local_2c": "oscillatorConfig_2",
                "local_28": "priorityConfig_1",
                "local_24": "clockConfig_1",
                "local_20": "clockConfig_2",
                "local_1c": "clockConfig_3",
                "local_18": "clockConfig_4",
                "local_14": "clockConfig_5",
                "uVar1": "systemFrequency"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig",
                "HAL_PWREx_EnableOverDrive",
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d3c": {
            "entrypoint": "0x08000d3c",
            "current_name": "initialize_system_08000d3c",
            "code": "\n/* WARNING: This function may have set the stack pointer */\n\nvoid initializeSystem_08000d3c(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &DAT_20000104; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(index + 0x8006034);\n  }\n  for (ptr = &DAT_20000104; ptr < &DAT_20000678; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x8000d72;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08000d72. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d3c": "initialize_system_08000d3c",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "main",
                "__libc_init_array",
                "SystemInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d8e": {
            "entrypoint": "0x08000d8e",
            "current_name": "initialize_hardware_08000d8e",
            "code": "\nvoid initialize_hardware_08000d8e(void)\n\n{\n  initialize_hardware_08000d8e_configuration();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d8e": "initialize_hardware_08000d8e",
                "hw_config_init": "initialize_hardware_configuration"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d96": {
            "entrypoint": "0x08000d96",
            "current_name": "FUNC_08000d96",
            "code": "\nvoid FUNC_08000d96(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d96": "FUNC_08000d96"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000d98": {
            "entrypoint": "0x08000d98",
            "current_name": "configure_sys_tick_08000d98",
            "code": "\nundefined4 configureSysTick_08000d98(uint priority)\n\n{\n  int result;\n  \n  result = HAL_SYSTICK_Config(DAT_2000002c / (1000 / DAT_20000024));\n  if (result != 0) {\n    return 1;\n  }\n  if (0xf < priority) {\n    return 1;\n  }\n  HAL_NVIC_SetPriority(0xffffffff,priority,0);\n  DAT_20000028 = priority;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000d98": "configure_sys_tick_08000d98",
                "param_1": "priority",
                "iVar1": "result"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000de4": {
            "entrypoint": "0x08000de4",
            "current_name": "initialize_system_08000de4",
            "code": "\n\n\nundefined4 initializeSystem_08000de4(void)\n\n{\n  _DAT_40023c00 = _DAT_40023c00 | 0x700;\n  setPriorityGrouping(3);\n  initializeTick(0xf);\n  initializeMsp();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000de4": "initialize_system_08000de4",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializeMsp"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_InitTick",
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e18": {
            "entrypoint": "0x08000e18",
            "current_name": "add_data_to_global_variable_08000e18",
            "code": "\nvoid addDataToGlobalVariable_08000e18(void)\n\n{\n  DAT_20000670 = (uint)DAT_20000024 + DAT_20000670;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e18": "add_data_to_global_variable_08000e18"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e30": {
            "entrypoint": "0x08000e30",
            "current_name": "get_global_variable_08000e30",
            "code": "\nundefined4 get_global_variable_08000e30(void)\n\n{\n  return DAT_20000670;\n}\n\n",
            "renaming": {
                "FUN_08000e30": "get_global_variable_08000e30"
            },
            "calling": [
                "UART_WaitOnFlagUntilTimeout",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig",
                "uart_debug_write",
                "HAL_UART_Transmit",
                "HAL_PWREx_EnableOverDrive",
                "GetCurrentMilli"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e3c": {
            "entrypoint": "0x08000e3c",
            "current_name": "update_data_08000e3c",
            "code": "\n\n\nvoid updateData_08000e3c(uint inputValue)\n\n{\n  _DAT_e000ed0c = (inputValue & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e3c": "update_data_08000e3c",
                "param_1": "inputValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e60": {
            "entrypoint": "0x08000e60",
            "current_name": "apply_mask_and_shift_08000e60",
            "code": "\n\n\nvoid applyMaskAndShift_08000e60(uint inputValue,uint mask,uint value)\n\n{\n  uint shiftAmount;\n  uint effectiveShiftAmount;\n  \n  shiftAmount = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  effectiveShiftAmount = 7 - shiftAmount;\n  if (3 < effectiveShiftAmount) {\n    effectiveShiftAmount = 4;\n  }\n  if (shiftAmount + 4 < 7) {\n    shiftAmount = 0;\n  }\n  else {\n    shiftAmount = shiftAmount - 3;\n  }\n  shiftAmount = (mask & (1 << (effectiveShiftAmount & 0xff)) - 1U) << (shiftAmount & 0xff) |\n          (1 << (shiftAmount & 0xff)) - 1U & value;\n  if ((int)inputValue < 0) {\n    *(char *)((inputValue & 0xf) + 0xe000ed14) = (char)(shiftAmount << 4);\n  }\n  else {\n    *(char *)(inputValue + 0xe000e400) = (char)(shiftAmount << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e60": "apply_mask_and_shift_08000e60",
                "param_1": "inputValue",
                "param_2": "mask",
                "param_3": "value",
                "uVar1": "shiftAmount",
                "uVar2": "effectiveShiftAmount"
            },
            "calling": [
                "uart_attach_rx_callback",
                "HAL_InitTick",
                "uart_attach_tx_callback",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ec4": {
            "entrypoint": "0x08000ec4",
            "current_name": "set_bit_in_array_08000ec4",
            "code": "\nvoid setBitInArray_08000ec4(uint index)\n\n{\n  if (-1 < (int)index) {\n    *(int *)((index >> 5) * 4 + -0x1fff1f00) = 1 << (index & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ec4": "set_bit_in_array_08000ec4",
                "param_1": "index"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ee0": {
            "entrypoint": "0x08000ee0",
            "current_name": "initialize_data_08000ee0",
            "code": "\n\n\nundefined4 initializeData_08000ee0(int inputData)\n\n{\n  if (inputData - 1U < 0x1000000) {\n    _DAT_e000e014 = inputData - 1U;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000ee0": "initialize_data_08000ee0",
                "param_1": "inputData"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f0c": {
            "entrypoint": "0x08000f0c",
            "current_name": "set_bit_08000f0c",
            "code": "\nvoid setBit_08000f0c(uint input)\n\n{\n  if (-1 < (int)input) {\n    *(int *)(((input >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (input & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f0c": "set_bit_08000f0c",
                "param_1": "input"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f2c": {
            "entrypoint": "0x08000f2c",
            "current_name": "update_status_08000f2c",
            "code": "\n\n\nvoid updateStatus_08000f2c(int status)\n\n{\n  if (status != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f2c": "update_status_08000f2c",
                "param_1": "status"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4c": {
            "entrypoint": "0x08000f4c",
            "current_name": "FUNC_08000f4c",
            "code": "\nvoid FUNC_08000f4c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4c": "FUNC_08000f4c"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4e": {
            "entrypoint": "0x08000f4e",
            "current_name": "handle_sys_tick_callback_08000f4e",
            "code": "\nvoid handleSysTickCallback_08000f4e(void)\n\n{\n  invokeSysTickCallback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4e": "handle_sys_tick_callback_08000f4e",
                "HAL_SYSTICK_Callback": "invokeSysTickCallback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f56": {
            "entrypoint": "0x08000f56",
            "current_name": "reset_dac_08000f56",
            "code": "\nundefined4 resetDac_08000f56(int dacPtr)\n\n{\n  if (dacPtr != 0) {\n    *(undefined *)(dacPtr + 4) = 2;\n    deinitializeDac();\n    *(undefined4 *)(dacPtr + 0x10) = 0;\n    *(undefined *)(dacPtr + 4) = 0;\n    *(undefined *)(dacPtr + 5) = 0;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000f56": "reset_dac_08000f56",
                "param_1": "dacPtr",
                "HAL_DAC_MspDeInit": "deinitializeDac"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "HAL_DAC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f72": {
            "entrypoint": "0x08000f72",
            "current_name": "clear_bit_and_set_flag_08000f72",
            "code": "\nundefined4 clearBitAndSetFlag_08000f72(uint **ptrToValue,uint bitPosition)\n\n{\n  **ptrToValue = **ptrToValue & ~(1 << (bitPosition & 0xff));\n  *(undefined *)(ptrToValue + 1) = 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000f72": "clear_bit_and_set_flag_08000f72",
                "param_1": "ptrToValue",
                "param_2": "bitPosition"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f8c": {
            "entrypoint": "0x08000f8c",
            "current_name": "update_param_value_08000f8c",
            "code": "\nundefined4 updateParamValue_08000f8c(uint **paramArray)\n\n{\n  if (*(char *)((int)paramArray + 0x35) != '\\x02') {\n    paramArray[21] = (uint *)0x80;\n    return 1;\n  }\n  *(undefined *)((int)paramArray + 0x35) = 5;\n  **paramArray = **paramArray & 0xfffffffe;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000f8c": "update_param_value_08000f8c",
                "param_1": "paramArray",
                "param_1[0x15]": "paramArray[21]"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fb4": {
            "entrypoint": "0x08000fb4",
            "current_name": "update_registers_08000fb4",
            "code": "\n\n\nvoid updateRegisters_08000fb4(uint *configuration,uint *input)\n\n{\n  uint temp1;\n  uint temp2;\n  uint index;\n  uint flag;\n  uint temp3;\n  int group;\n  uint shift;\n  int offset;\n  \n  for (index = 0; index < 0x10; index = index + 1) {\n    temp2 = 1 << (index & 0xff);\n    flag = temp2 & *input;\n    temp1 = _DAT_40013c0c;\n    if (temp2 == flag) {\n      if ((input[1] == 2) || (input[1] == 0x12)) {\n        group = (index >> 3) + 8;\n        offset = (index & 7) << 2;\n        configuration[group] = configuration[group] & ~(0xf << offset) | input[4] << offset;\n      }\n      shift = index << 1;\n      temp1 = ~(3 << (shift & 0xff));\n      *configuration = *configuration & temp1 | (input[1] & 3) << (shift & 0xff);\n      temp3 = input[1];\n      if (((temp3 - 1 < 2) || (temp3 == 0x11)) || (temp3 == 0x12)) {\n        configuration[2] = configuration[2] & temp1 | input[3] << (shift & 0xff);\n        configuration[1] = configuration[1] & ~temp2 | ((input[1] << 0x1b) >> 0x1f) << (index & 0xff);\n      }\n      configuration[3] = temp1 & configuration[3] | input[2] << (shift & 0xff);\n      temp1 = _DAT_40013c0c;\n      if ((input[1] & 0x10000000) != 0) {\n        _DAT_40023844 = _DAT_40023844 | 0x4000;\n        offset = (index & 3) << 2;\n        if (configuration == (uint *)0x40020000) {\n          group = 0;\n        }\n        else if (configuration == (uint *)0x40020400) {\n          group = 1;\n        }\n        else if (configuration == (uint *)0x40020800) {\n          group = 2;\n        }\n        else if (configuration == (uint *)0x40020c00) {\n          group = 3;\n        }\n        else if (configuration == (uint *)0x40021000) {\n          group = 4;\n        }\n        else if (configuration == (uint *)0x40021400) {\n          group = 5;\n        }\n        else if (configuration == (uint *)0x40021800) {\n          group = 6;\n        }\n        else if (configuration == (uint *)0x40021c00) {\n          group = 7;\n        }\n        else if (configuration == (uint *)0x40022000) {\n          group = 8;\n        }\n        else if (configuration == (uint *)0x40022400) {\n          group = 9;\n        }\n        else {\n          group = 10;\n        }\n        *(uint *)(((index >> 2) + 2) * 4 + 0x40013800) =\n             *(uint *)(((index >> 2) + 2) * 4 + 0x40013800) & ~(0xf << offset) | group << offset;\n        temp1 = ~flag;\n        temp2 = _DAT_40013c00 & temp1;\n        if ((input[1] & 0x10000) != 0) {\n          temp2 = flag | _DAT_40013c00;\n        }\n        temp3 = temp1 & _DAT_40013c04;\n        if ((input[1] & 0x20000) != 0) {\n          temp3 = flag | _DAT_40013c04;\n        }\n        shift = temp1 & _DAT_40013c08;\n        if ((input[1] & 0x100000) != 0) {\n          shift = flag | _DAT_40013c08;\n        }\n        _DAT_40013c00 = temp2;\n        _DAT_40013c04 = temp3;\n        _DAT_40013c08 = shift;\n        temp1 = temp1 & _DAT_40013c0c;\n        if ((input[1] & 0x200000) != 0) {\n          temp1 = flag | _DAT_40013c0c;\n        }\n      }\n    }\n    _DAT_40013c0c = temp1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fb4": "update_registers_08000fb4",
                "param_1": "configuration",
                "param_2": "input",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "index",
                "uVar4": "flag",
                "uVar5": "temp3",
                "iVar6": "group",
                "uVar7": "shift",
                "iVar8": "offset"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001198": {
            "entrypoint": "0x08001198",
            "current_name": "set_param_value_08001198",
            "code": "\nvoid setParamValue_08001198(int objPtr,int value,int shiftValue)\n\n{\n  if (shiftValue == 0) {\n    *(int *)(objPtr + 0x18) = value << 0x10;\n    return;\n  }\n  *(int *)(objPtr + 0x18) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001198": "set_param_value_08001198",
                "param_1": "objPtr",
                "param_2": "value",
                "param_3": "shiftValue"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011a4": {
            "entrypoint": "0x080011a4",
            "current_name": "update_gpio_on_interrupt_080011a4",
            "code": "\n\n\nvoid update_GPIO_on_Interrupt_080011a4(uint interrupt_flags)\n\n{\n  if ((_DAT_40013c14 & interrupt_flags) != 0) {\n    _DAT_40013c14 = interrupt_flags;\n    HAL_GPIO_EXTI_Callback();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011a4": "update_gpio_on_interrupt_080011a4",
                "param_1": "interrupt_flags"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011c0": {
            "entrypoint": "0x080011c0",
            "current_name": "update_param_values_080011c0",
            "code": "\nundefined4 updateParamValues_080011c0(int *params)\n\n{\n  if (*(char *)((int)params + 0x3e) == '@') {\n    if (paramData[20] == 0) {\n      *(uint *)(*params + 0x10) = params[0x11] & 0xfe;\n    }\n    else {\n      *(uint *)(*params + 0x10) = params[0x11] & 0xffU | 1;\n    }\n  }\n  else if (paramData[4] == 0x4000) {\n    if (*(char *)((int)params + 0x3d) == '!') {\n      *(uint *)(*params + 0x10) = params[0x11] & 0xfe;\n    }\n    else {\n      *(uint *)(*params + 0x10) = params[0x11] & 0xffU | 1;\n    }\n  }\n  else if (paramData[20] == 0) {\n    *(uint *)(*params + 0x10) = (uint)(params[0x11] << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (paramData[20] == 1) {\n    *(uint *)(*params + 0x10) = (uint)(params[0x11] << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080011c0": "update_param_values_080011c0",
                "param_1": "params",
                "param_1[0x14]": "paramData[20]",
                "param_1[4]": "paramData[4]"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800124a": {
            "entrypoint": "0x0800124a",
            "current_name": "copy_byte_to_pointer_0800124a",
            "code": "\nundefined4 copyByteToPointer_0800124a(int *arrayPointer)\n\n{\n  *(uint *)(*arrayPointer + 0x10) = arrayPointer[0x11] & 0xff;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800124a": "copy_byte_to_pointer_0800124a",
                "param_1": "arrayPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001256": {
            "entrypoint": "0x08001256",
            "current_name": "update_flags_08001256",
            "code": "\nundefined4 updateFlags_08001256(uint **parameter)\n\n{\n  uint *pointer;\n  \n  pointer = parameter[0xb];\n  if ((*(char *)((int)parameter + 0x3d) == '\\\"') &&\n     ((variable2 != (uint *)0x0 || (*(char *)((int)parameter + 0x3e) != '@')))) {\n    if ((variable2 == (uint *)0x0) && (parameter[4] == (uint *)0xc000)) {\n      **parameter = **parameter | 0x100;\n      variable2 = (uint *)((int)variable2 + 1);\n    }\n    else {\n      if (*(short *)((int)parameter + 0x2a) == 0) {\n        **parameter = **parameter | 0x200;\n      }\n      else if (*(short *)((int)parameter + 0x2a) == 1) {\n        if (pointer == (uint *)0xffff0000) {\n          **parameter = **parameter & 0xfffffbff;\n          pointer = *parameter;\n          if ((pointer[1] & 0x800) == 0) {\n            *pointer = *pointer | 0x200;\n          }\n          else {\n            *pointer = *pointer & 0xfffffbff;\n          }\n        }\n        else if (((pointer == (uint *)0x4) || (pointer == (uint *)0x8)) ||\n                (parameter[0xc] == (uint *)0x12)) {\n          **parameter = **parameter & 0xfffffbff;\n          **parameter = **parameter | 0x200;\n        }\n        else if (parameter[0xb] == (uint *)0x2) {\n          **parameter = **parameter | 0x400;\n        }\n        else {\n          **parameter = **parameter & 0xfffffbff;\n        }\n      }\n      else if (*(short *)((int)parameter + 0x2a) == 2) {\n        if (parameter[0xb] == (uint *)0x2) {\n          **parameter = **parameter | 0x400;\n        }\n        else {\n          **parameter = **parameter & 0xfffffbff;\n          **parameter = **parameter | 0x800;\n        }\n        pointer = *parameter;\n        if ((pointer[1] & 0x800) != 0) {\n          pointer[1] = pointer[1] | 0x1000;\n        }\n      }\n      else {\n        **parameter = **parameter | 0x400;\n        pointer = *parameter;\n        if ((pointer[1] & 0x800) != 0) {\n          pointer[1] = pointer[1] | 0x1000;\n        }\n      }\n      variable2 = (uint *)0x0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001256": "update_flags_08001256",
                "param_1": "parameter",
                "puVar1": "pointer",
                "param_1[0x14]": "variable2"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001420": {
            "entrypoint": "0x08001420",
            "current_name": "update_byte_array_08001420",
            "code": "\nundefined4 updateByteArray_08001420(int *arrayPointer)\n\n{\n  byte *byteArrayPointer;\n  \n  if (*(short *)((int)arrayPointer + 0x2a) != 0) {\n    byteArrayPointer = (byte *)arrayPointer[9];\n    arrayPointer[9] = (int)(byteArrayPointer + 1);\n    *(uint *)(*arrayPointer + 0x10) = (uint)*byteArrayPointer;\n    *(short *)((int)arrayPointer + 0x2a) = *(short *)((int)arrayPointer + 0x2a) + -1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001420": "update_byte_array_08001420",
                "param_1": "arrayPointer",
                "pbVar1": "byteArrayPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001440": {
            "entrypoint": "0x08001440",
            "current_name": "update_value_and_decrement_08001440",
            "code": "\nundefined4 updateValueAndDecrement_08001440(int *data)\n\n{\n  undefined *ptrToValue;\n  \n  if (*(short *)((int)data + 0x2a) != 0) {\n    ptrToValue = (undefined *)array;\n    array = (int)(ptrToValue + 1);\n    *ptrToValue = (char)*(undefined4 *)(*data + 0x10);\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001440": "update_value_and_decrement_08001440",
                "param_1": "data",
                "puVar1": "ptrToValue",
                "param_1[9]": "array"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001460": {
            "entrypoint": "0x08001460",
            "current_name": "validate_input_08001460",
            "code": "\nundefined4 validate_input_08001460(uint **param_list,uint *input_array,int array_length,uint *output_array)\n\n{\n  undefined4 result;\n  uint *pointer_var;\n  \n  if (*(char *)((int)param_list + 0x3d) == '(') {\n    if (input_array == (uint *)0x0) {\n      result = 1;\n    }\n    else if (array_length == 0) {\n      result = 1;\n    }\n    else if (*(char *)(param_list + 0xf) == '\\x01') {\n      result = 2;\n    }\n    else {\n      *(undefined *)(param_list + 0xf) = 1;\n      pointer_var = *param_list;\n      if ((*pointer_var & 1) == 0) {\n        *pointer_var = *pointer_var | 1;\n      }\n      **param_list = **param_list & 0xfffff7ff;\n      *(undefined *)((int)param_list + 0x3d) = 0x29;\n      *(undefined *)((int)param_list + 0x3e) = 0x20;\n      result = 0;\n      param_list[0x10] = (uint *)0x0;\n      param_list[9] = input_array;\n      *(short *)((int)param_list + 0x2a) = (short)array_length;\n      param_list[0xb] = output_array;\n      *(undefined2 *)(param_list + 10) = *(undefined2 *)((int)param_list + 0x2a);\n      *(undefined *)(param_list + 0xf) = 0;\n      (*param_list)[1] = (*param_list)[1] | 0x700;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001460": "validate_input_08001460",
                "param_1": "param_list",
                "param_2": "input_array",
                "param_3": "array_length",
                "param_4": "output_array",
                "uVar1": "result",
                "puVar2": "pointer_var"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ec": {
            "entrypoint": "0x080014ec",
            "current_name": "process_function_080014ec",
            "code": "\nundefined4 processFunction_080014ec(uint **functionParams1,uint *functionParams2,int functionParams3,uint *functionParams4)\n\n{\n  undefined4 returnValue;\n  uint *pointerVar;\n  \n  if (*(char *)((int)functionParams1 + 0x3d) == '(') {\n    if (functionParams2 == (uint *)0x0) {\n      returnValue = 1;\n    }\n    else if (functionParams3 == 0) {\n      returnValue = 1;\n    }\n    else if (*(char *)(functionParams1 + 0xf) == '\\x01') {\n      returnValue = 2;\n    }\n    else {\n      *(undefined *)(functionParams1 + 0xf) = 1;\n      pointerVar = *functionParams1;\n      if ((*pointerVar & 1) == 0) {\n        *pointerVar = *pointerVar | 1;\n      }\n      **functionParams1 = **functionParams1 & 0xfffff7ff;\n      *(undefined *)((int)functionParams1 + 0x3d) = 0x2a;\n      *(undefined *)((int)functionParams1 + 0x3e) = 0x20;\n      returnValue = 0;\n      functionParams1[0x10] = (uint *)0x0;\n      functionParams1[9] = functionParams2;\n      *(short *)((int)functionParams1 + 0x2a) = (short)functionParams3;\n      functionParams1[0xb] = functionParams4;\n      *(undefined2 *)(functionParams1 + 10) = *(undefined2 *)((int)functionParams1 + 0x2a);\n      *(undefined *)(functionParams1 + 0xf) = 0;\n      (*functionParams1)[1] = (*functionParams1)[1] | 0x700;\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080014ec": "process_function_080014ec",
                "param_1": "functionParams1",
                "param_2": "functionParams2",
                "param_3": "functionParams3",
                "param_4": "functionParams4",
                "uVar1": "returnValue",
                "puVar2": "pointerVar"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001578": {
            "entrypoint": "0x08001578",
            "current_name": "initialize_data_08001578",
            "code": "\nundefined4 initializeData_08001578(uint **data)\n\n{\n  uint *ptr;\n  \n  if (*(char *)((int)data + 0x3d) != ' ') {\n    return 2;\n  }\n  *(undefined *)((int)data + 0x3d) = 0x28;\n  ptr = *data;\n  if ((*ptr & 1) == 0) {\n    *ptr = *ptr | 1;\n  }\n  **data = **data | 0x400;\n  (*data)[1] = (*data)[1] | 0x300;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001578": "initialize_data_08001578",
                "param_1": "data",
                "puVar1": "ptr"
            },
            "calling": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b6": {
            "entrypoint": "0x080015b6",
            "current_name": "FUNC_080015b6",
            "code": "\nvoid FUNC_080015b6(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b6": "FUNC_080015b6"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015b8": {
            "entrypoint": "0x080015b8",
            "current_name": "FUNC_080015b8",
            "code": "\nvoid FUNC_080015b8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b8": "FUNC_080015b8"
            },
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015ba": {
            "entrypoint": "0x080015ba",
            "current_name": "FUNC_080015ba",
            "code": "\nvoid FUNC_080015ba(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015ba": "FUNC_080015ba"
            },
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015bc": {
            "entrypoint": "0x080015bc",
            "current_name": "process_input_data_080015bc",
            "code": "\nundefined4 processInputData_080015bc(int *data)\n\n{\n  char character;\n  byte *pointer;\n  \n  character = *(char *)((int)data + 0x3d);\n  if (*(short *)((int)data + 0x2a) != 0) {\n    pointer = (byte *)data[9];\n    data[9] = (int)(pointer + 1);\n    *(uint *)(*data + 0x10) = (uint)*pointer;\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    if ((*(short *)((int)data + 0x2a) == 0) && (character == ')')) {\n      *(uint *)(*data + 4) = *(uint *)(*data + 4) & 0xfffffbff;\n      data[0xc] = 0x21;\n      *(undefined *)((int)data + 0x3d) = 0x28;\n      HAL_I2C_SlaveTxCpltCallback();\n    }\n    return 0;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080015bc": "process_input_data_080015bc",
                "param_1": "data",
                "cVar1": "character",
                "pbVar2": "pointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800160c": {
            "entrypoint": "0x0800160c",
            "current_name": "FUNC_0800160c",
            "code": "\nvoid FUNC_0800160c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800160c": "FUNC_0800160c"
            },
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800160e": {
            "entrypoint": "0x0800160e",
            "current_name": "process_data_0800160e",
            "code": "\nundefined4 processData_0800160e(int *inputArray)\n\n{\n  char character;\n  undefined *pointer;\n  \n  character = *(char *)((int)inputArray + 0x3d);\n  if (*(short *)((int)inputArray + 0x2a) != 0) {\n    pointer = (undefined *)inputArray[9];\n    inputArray[9] = (int)(pointer + 1);\n    *pointer = (char)*(undefined4 *)(*inputArray + 0x10);\n    *(short *)((int)inputArray + 0x2a) = *(short *)((int)inputArray + 0x2a) + -1;\n    if ((*(short *)((int)inputArray + 0x2a) == 0) && (character == '*')) {\n      *(uint *)(*inputArray + 4) = *(uint *)(*inputArray + 4) & 0xfffffbff;\n      value = 0x22;\n      *(undefined *)((int)inputArray + 0x3d) = 0x28;\n      callback;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800160e": "process_data_0800160e",
                "param_1": "inputArray",
                "cVar1": "character",
                "puVar2": "pointer",
                "param_1[0xc]": "value",
                "HAL_I2C_SlaveRxCpltCallback()": "callback"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800165a": {
            "entrypoint": "0x0800165a",
            "current_name": "update_i2_c_address_0800165a",
            "code": "\nundefined4 updateI2CAddress_0800165a(int *i2cData,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  undefined2 address;\n  uint flags;\n  \n  flags = *(uint *)(*i2cData + 0x18);\n  if ((flags & 0x80) == 0) {\n    address = *(undefined2 *)(i2cData + 3);\n  }\n  else {\n    address = *(undefined2 *)(i2cData + 6);\n  }\n  HAL_I2C_AddrCallback(i2cData,(*(uint *)(*i2cData + 0x18) & 4) == 0,address,flags,param4);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800165a": "update_i2_c_address_0800165a",
                "param_1": "i2cData",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "address",
                "uVar2": "flags"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001684": {
            "entrypoint": "0x08001684",
            "current_name": "process_i2_c_data_08001684",
            "code": "\nundefined4 processI2CData_08001684(uint **i2cData)\n\n{\n  if (((i2cData[11] == (uint *)0x4) || (i2cData[11] == (uint *)0x8)) &&\n     (*(char *)((int)i2cData + 0x3d) == '(')) {\n    i2cData[11] = (uint *)0xffff0000;\n    (*i2cData)[1] = (*i2cData)[1] & 0xfffff8ff;\n    (*i2cData)[5] = 0xfffffbff;\n    **i2cData = **i2cData & 0xfffffbff;\n    i2cData[12] = (uint *)0x0;\n    *(undefined *)((int)i2cData + 0x3d) = 0x20;\n    *(undefined *)((int)i2cData + 0x3e) = 0;\n    HAL_I2C_ListenCpltCallback();\n  }\n  else if (*(char *)((int)i2cData + 0x3d) == '!') {\n    i2cData[11] = (uint *)0xffff0000;\n    i2cData[12] = (uint *)0x21;\n    *(undefined *)((int)i2cData + 0x3d) = 0x20;\n    *(undefined *)((int)i2cData + 0x3e) = 0;\n    (*i2cData)[1] = (*i2cData)[1] & 0xfffff8ff;\n    (*i2cData)[5] = 0xfffffbff;\n    **i2cData = **i2cData & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback();\n  }\n  else {\n    (*i2cData)[5] = 0xfffffbff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001684": "process_i2_c_data_08001684",
                "param_1": "i2cData",
                "param_1[0xb]": "i2cData[11]",
                "param_1[0xc]": "i2cData[12]"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001718": {
            "entrypoint": "0x08001718",
            "current_name": "FUNC_08001718",
            "code": "\nvoid FUNC_08001718(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001718": "FUNC_08001718"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800171a": {
            "entrypoint": "0x0800171a",
            "current_name": "process_data_0800171a",
            "code": "\nundefined4 processData_0800171a(uint **data)\n\n{\n  char character;\n  uint *pointerVar;\n  \n  character = *(char *)((int)data + 0x3d);\n  pointerVar = pointerArray1;\n  if ((*(short *)(data + 10) == 0) && (character == '!')) {\n    if ((pointerVar == (uint *)0x4) || ((pointerVar == (uint *)0x8 || (pointerVar == (uint *)0xffff0000)))) {\n      (*data)[1] = (*data)[1] & 0xfffff8ff;\n      **data = **data | 0x200;\n      pointerArray2 = (uint *)0x0;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      if (*(char *)((int)data + 0x3e) == '@') {\n        *(undefined *)((int)data + 0x3e) = 0;\n        HAL_I2C_MemTxCpltCallback();\n      }\n      else {\n        *(undefined *)((int)data + 0x3e) = 0;\n        HAL_I2C_MasterTxCpltCallback();\n      }\n    }\n    else {\n      (*data)[1] = (*data)[1] & 0xfffff8ff;\n      pointerArray2 = (uint *)0x11;\n      *(undefined *)((int)data + 0x3e) = 0;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      HAL_I2C_MasterTxCpltCallback();\n    }\n  }\n  else if ((character == '!') || ((*(char *)((int)data + 0x3e) == '@' && (character == '\\\"')))) {\n    if (*(short *)((int)data + 0x2a) == 0) {\n      (*data)[1] = (*data)[1] & 0xfffffbff;\n    }\n    else if (*(char *)((int)data + 0x3e) == '@') {\n      if (pointerArray3 == (uint *)0x0) {\n        if (pointerArray4 == (uint *)0x1) {\n          (*data)[4] = (uint)pointerArray5 & 0xff;\n          pointerArray3 = (uint *)((int)pointerArray3 + 2);\n        }\n        else {\n          (*data)[4] = (uint)((int)pointerArray5 << 0x10) >> 0x18;\n          pointerArray3 = (uint *)((int)pointerArray3 + 1);\n        }\n      }\n      else if (pointerArray3 == (uint *)0x1) {\n        (*data)[4] = (uint)pointerArray5 & 0xff;\n        pointerArray3 = (uint *)((int)pointerArray3 + 1);\n      }\n      else if (pointerArray3 == (uint *)0x2) {\n        if (*(char *)((int)data + 0x3d) == '\\\"') {\n          **data = **data | 0x100;\n        }\n        else if (*(char *)((int)data + 0x3d) == '!') {\n          pointerVar = pointerArray6;\n          pointerArray6 = (uint *)((int)pointerVar + 1);\n          (*data)[4] = (uint)*(byte *)pointerVar;\n          *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n        }\n      }\n    }\n    else {\n      pointerVar = pointerArray6;\n      pointerArray6 = (uint *)((int)pointerVar + 1);\n      (*data)[4] = (uint)*(byte *)pointerVar;\n      *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800171a": "process_data_0800171a",
                "param_1": "data",
                "cVar1": "character",
                "puVar2": "pointerVar",
                "param_1[0xb]": "pointerArray1",
                "param_1[0xc]": "pointerArray2",
                "param_1[0x14]": "pointerArray3",
                "param_1[0x13]": "pointerArray4",
                "param_1[0x12]": "pointerArray5",
                "param_1[9]": "pointerArray6"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001864": {
            "entrypoint": "0x08001864",
            "current_name": "process_data_08001864",
            "code": "\nundefined4 processData_08001864(uint **data)\n\n{\n  uint *ptr;\n  \n  ptr = data[0xb];\n  if (*(char *)((int)data + 0x3d) == '!') {\n    if (*(short *)((int)data + 0x2a) == 0) {\n      if (((ptr == (uint *)0x4) || (ptr == (uint *)0x8)) || (ptr == (uint *)0xffff0000)) {\n        (*data)[1] = (*data)[1] & 0xfffff8ff;\n        **data = **data | 0x200;\n        ptr2 = (uint *)0x0;\n        *(undefined *)((int)data + 0x3d) = 0x20;\n        if (*(char *)((int)data + 0x3e) == '@') {\n          *(undefined *)((int)data + 0x3e) = 0;\n          memTxCpltCallback();\n        }\n        else {\n          *(undefined *)((int)data + 0x3e) = 0;\n          masterTxCpltCallback();\n        }\n      }\n      else {\n        (*data)[1] = (*data)[1] & 0xfffff8ff;\n        ptr2 = (uint *)0x11;\n        *(undefined *)((int)data + 0x3e) = 0;\n        *(undefined *)((int)data + 0x3d) = 0x20;\n        masterTxCpltCallback();\n      }\n    }\n    else {\n      ptr = data[9];\n      data[9] = (uint *)((int)ptr + 1);\n      (*data)[4] = (uint)*(byte *)ptr;\n      *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001864": "process_data_08001864",
                "param_1": "data",
                "puVar1": "ptr",
                "param_1[0xc]": "ptr2",
                "HAL_I2C_MemTxCpltCallback()": "memTxCpltCallback()",
                "HAL_I2C_MasterTxCpltCallback()": "masterTxCpltCallback()"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001902": {
            "entrypoint": "0x08001902",
            "current_name": "FUNC_08001902",
            "code": "\nvoid FUNC_08001902(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001902": "FUNC_08001902"
            },
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001904": {
            "entrypoint": "0x08001904",
            "current_name": "process_data_08001904",
            "code": "\nundefined4 processData_08001904(uint **data)\n\n{\n  uint *tempPtr;\n  \n  if (*(char *)((int)data + 0x3d) == '\\\"') {\n    if (*(ushort *)((int)data + 0x2a) < 4) {\n      if (*(ushort *)((int)data + 0x2a) < 2) {\n        **data = **data & 0xfffffbff;\n        (*data)[1] = (*data)[1] & 0xfffff8ff;\n        tempPtr = data[9];\n        data[9] = (uint *)((int)tempPtr + 1);\n        *(char *)tempPtr = (char)(*data)[4];\n        *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n        *(undefined *)((int)data + 0x3d) = 0x20;\n        data[0xc] = (uint *)0x0;\n        if (*(char *)((int)data + 0x3e) == '@') {\n          *(undefined *)((int)data + 0x3e) = 0;\n          HAL_I2C_MemRxCpltCallback();\n        }\n        else {\n          *(undefined *)((int)data + 0x3e) = 0;\n          HAL_I2C_MasterRxCpltCallback();\n        }\n      }\n    }\n    else {\n      tempPtr = data[9];\n      data[9] = (uint *)((int)tempPtr + 1);\n      *(char *)tempPtr = (char)(*data)[4];\n      *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n      if (*(short *)((int)data + 0x2a) == 3) {\n        (*data)[1] = (*data)[1] & 0xfffffbff;\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001904": "process_data_08001904",
                "param_1": "data",
                "puVar1": "tempPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080019a0": {
            "entrypoint": "0x080019a0",
            "current_name": "process_binary_data_080019a0",
            "code": "\nundefined4 processBinaryData_080019a0(uint **binaryData)\n\n{\n  uint *tempPtr;\n  \n  if (*(short *)((int)binaryData + 0x2a) == 4) {\n    (*binaryData)[1] = (*binaryData)[1] & 0xfffffbff;\n    tempPtr = binaryData[9];\n    binaryData[9] = (uint *)((int)tempPtr + 1);\n    *(char *)tempPtr = (char)(*binaryData)[4];\n    *(short *)((int)binaryData + 0x2a) = *(short *)((int)binaryData + 0x2a) + -1;\n  }\n  else if (*(short *)((int)binaryData + 0x2a) == 3) {\n    (*binaryData)[1] = (*binaryData)[1] & 0xfffffbff;\n    **binaryData = **binaryData & 0xfffffbff;\n    tempPtr = binaryData[9];\n    binaryData[9] = (uint *)((int)tempPtr + 1);\n    *(char *)tempPtr = (char)(*binaryData)[4];\n    *(short *)((int)binaryData + 0x2a) = *(short *)((int)binaryData + 0x2a) + -1;\n  }\n  else if (*(short *)((int)binaryData + 0x2a) == 2) {\n    if ((int)binaryData[0xb] - 1U < 2) {\n      **binaryData = **binaryData & 0xfffffbff;\n      **binaryData = **binaryData | 0x100;\n    }\n    else {\n      **binaryData = **binaryData | 0x200;\n    }\n    tempPtr = binaryData[9];\n    binaryData[9] = (uint *)((int)tempPtr + 1);\n    *(char *)tempPtr = (char)(*binaryData)[4];\n    *(short *)((int)binaryData + 0x2a) = *(short *)((int)binaryData + 0x2a) + -1;\n    tempPtr = binaryData[9];\n    binaryData[9] = (uint *)((int)tempPtr + 1);\n    *(char *)tempPtr = (char)(*binaryData)[4];\n    *(short *)((int)binaryData + 0x2a) = *(short *)((int)binaryData + 0x2a) + -1;\n    (*binaryData)[1] = (*binaryData)[1] & 0xfffffcff;\n    *(undefined *)((int)binaryData + 0x3d) = 0x20;\n    binaryData[0xc] = (uint *)0x0;\n    if (*(char *)((int)binaryData + 0x3e) == '@') {\n      *(undefined *)((int)binaryData + 0x3e) = 0;\n      HAL_I2C_MemRxCpltCallback();\n    }\n    else {\n      *(undefined *)((int)binaryData + 0x3e) = 0;\n      HAL_I2C_MasterRxCpltCallback();\n    }\n  }\n  else {\n    tempPtr = binaryData[9];\n    binaryData[9] = (uint *)((int)tempPtr + 1);\n    *(char *)tempPtr = (char)(*binaryData)[4];\n    *(short *)((int)binaryData + 0x2a) = *(short *)((int)binaryData + 0x2a) + -1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080019a0": "process_binary_data_080019a0",
                "param_1": "binaryData",
                "puVar1": "tempPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001aac": {
            "entrypoint": "0x08001aac",
            "current_name": "FUNC_08001aac",
            "code": "\nvoid FUNC_08001aac(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001aac": "FUNC_08001aac"
            },
            "calling": [
                "I2C_ITError"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "handle_i2_c_event_08001ab0",
            "code": "\nvoid handleI2CEvent_08001ab0(uint **eventData)\n\n{\n  int result;\n  uint *charPtr;\n  uint *uintPtr;\n  \n  if (*(byte *)((int)eventData + 0x3d) - 0x29 < 2) {\n    eventData[0xc] = (uint *)0x0;\n    *(undefined *)((int)eventData + 0x3d) = 0x28;\n  }\n  else {\n    if ((*(char *)((int)eventData + 0x3d) != '`') && (((*eventData)[1] & 0x800) == 0)) {\n      *(undefined *)((int)eventData + 0x3d) = 0x20;\n    }\n    eventData[0xc] = (uint *)0x0;\n    *(undefined *)((int)eventData + 0x3e) = 0;\n  }\n  **eventData = **eventData & 0xfffff7ff;\n  uintPtr = *eventData;\n  if ((uintPtr[1] & 0x800) == 0) {\n    if (*(char *)((int)eventData + 0x3d) == '`') {\n      *(undefined *)((int)eventData + 0x3d) = 0x20;\n      eventData[0x10] = (uint *)0x0;\n      if ((uintPtr[5] & 0x40) != 0) {\n        charPtr = eventData[9];\n        eventData[9] = (uint *)((int)charPtr + 1);\n        *(char *)charPtr = (char)uintPtr[4];\n      }\n      **eventData = **eventData & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(eventData);\n    }\n    else {\n      if ((uintPtr[5] & 0x40) != 0) {\n        charPtr = eventData[9];\n        eventData[9] = (uint *)((int)charPtr + 1);\n        *(char *)charPtr = (char)uintPtr[4];\n      }\n      HAL_I2C_ErrorCallback(eventData);\n    }\n  }\n  else {\n    uintPtr[1] = uintPtr[1] & 0xfffff7ff;\n    if (*(char *)((int)eventData[0xd] + 0x35) == '\\x01') {\n      eventData[0xe][0x14] = (uint)&LAB_08001f3c_1;\n      result = HAL_DMA_Abort_IT(eventData[0xe]);\n      if (result != 0) {\n        if (((*eventData)[5] & 0x40) != 0) {\n          uintPtr = eventData[9];\n          eventData[9] = (uint *)((int)uintPtr + 1);\n          *(char *)uintPtr = (char)(*eventData)[4];\n        }\n        **eventData = **eventData & 0xfffffffe;\n        *(undefined *)((int)eventData + 0x3d) = 0x20;\n        (*(code *)eventData[0xe][0x14])();\n      }\n    }\n    else {\n      eventData[0xd][0x14] = (uint)&LAB_08001f3c_1;\n      result = HAL_DMA_Abort_IT(eventData[0xd]);\n      if (result != 0) {\n        **eventData = **eventData & 0xfffffffe;\n        *(undefined *)((int)eventData + 0x3d) = 0x20;\n        (*(code *)eventData[0xd][0x14])();\n      }\n    }\n  }\n  if ((*(char *)((int)eventData + 0x3d) == '(') && (((uint)eventData[0x10] & 4) != 0)) {\n    eventData[0xb] = (uint *)0xffff0000;\n    eventData[0xc] = (uint *)0x0;\n    *(undefined *)((int)eventData + 0x3d) = 0x20;\n    *(undefined *)((int)eventData + 0x3e) = 0;\n    HAL_I2C_ListenCpltCallback(eventData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "handle_i2_c_event_08001ab0",
                "param_1": "eventData",
                "iVar1": "result",
                "puVar2": "charPtr",
                "puVar3": "uintPtr"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_I2C_ErrorCallback",
                "HAL_DMA_Abort_IT",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001bfc": {
            "entrypoint": "0x08001bfc",
            "current_name": "process_i2_c_packet_08001bfc",
            "code": "\nundefined4 processI2CPacket_08001bfc(uint **packet)\n\n{\n  char packetType;\n  uint *ptrPacket;\n  uint *ptrNextByte;\n  \n  packetType = *(char *)((int)packet + 0x3d);\n  (*packet)[1] = (*packet)[1] & 0xfffff8ff;\n  **packet = **packet | 1;\n  **packet = **packet & 0xfffffbff;\n  ptrPacket = *packet;\n  if ((ptrPacket[1] & 0x800) != 0) {\n    if ((*(char *)((int)packet + 0x3d) == '\\\"') || (*(char *)((int)packet + 0x3d) == '*')) {\n      *(short *)((int)packet + 0x2a) = (short)*(undefined4 *)(*packet[0xe] + 4);\n    }\n    else {\n      *(short *)((int)packet + 0x2a) = (short)*(undefined4 *)(*packet[0xd] + 4);\n    }\n  }\n  if (*(short *)((int)packet + 0x2a) != 0) {\n    if ((ptrPacket[5] & 4) != 0) {\n      ptrNextByte = packet[9];\n      packet[9] = (uint *)((int)ptrNextByte + 1);\n      *(char *)ptrNextByte = (char)ptrPacket[4];\n      *(short *)((int)packet + 0x2a) = *(short *)((int)packet + 0x2a) + -1;\n    }\n    if (((*packet)[5] & 0x40) != 0) {\n      ptrPacket = packet[9];\n      packet[9] = (uint *)((int)ptrPacket + 1);\n      *(char *)ptrPacket = (char)(*packet)[4];\n      *(short *)((int)packet + 0x2a) = *(short *)((int)packet + 0x2a) + -1;\n    }\n    packet[0x10] = (uint *)((uint)packet[0x10] | 4);\n  }\n  if (packet[0x10] == (uint *)0x0) {\n    if (((packetType == '(') || (packetType == '*')) || (packetType == ')')) {\n      packet[0xb] = (uint *)0xffff0000;\n      packet[0xc] = (uint *)0x0;\n      *(undefined *)((int)packet + 0x3d) = 0x20;\n      *(undefined *)((int)packet + 0x3e) = 0;\n      HAL_I2C_ListenCpltCallback();\n    }\n    else if ((packet[0xc] == (uint *)0x22) || (packetType == '\\\"')) {\n      packet[0xc] = (uint *)0x0;\n      *(undefined *)((int)packet + 0x3d) = 0x20;\n      *(undefined *)((int)packet + 0x3e) = 0;\n      HAL_I2C_SlaveRxCpltCallback();\n    }\n  }\n  else {\n    I2C_ITError();\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001bfc": "process_i2_c_packet_08001bfc",
                "param_1": "packet",
                "cVar1": "packetType",
                "puVar2": "ptrPacket",
                "puVar3": "ptrNextByte"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "HAL_I2C_SlaveRxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001d00": {
            "entrypoint": "0x08001d00",
            "current_name": "handle_i2_c_event_08001d00",
            "code": "\nvoid handleI2CEvent_08001d00(int *i2cData)\n\n{\n  int i2cPtr;\n  uint statusReg1;\n  uint statusReg2;\n  uint controlReg;\n  \n  i2cPtr = *i2cData;\n  controlReg = *(uint *)(i2cPtr + 0x18);\n  statusReg1 = *(uint *)(i2cPtr + 0x14);\n  statusReg2 = *(uint *)(i2cPtr + 4);\n  if ((*(char *)((int)i2cData + 0x3e) == '\\x10') || (*(char *)((int)i2cData + 0x3e) == '@')) {\n    if (((statusReg1 & 0x10001) == 0) || ((statusReg2 & 0x200) == 0)) {\n      if (((statusReg1 & 0x10008) == 0) || ((statusReg2 & 0x200) == 0)) {\n        if (((statusReg1 & 0x10002) != 0) && ((statusReg2 & 0x200) != 0)) {\n          handleMasterAddress(i2cData);\n        }\n      }\n      else {\n        handleMasterADD10(i2cData);\n      }\n    }\n    else {\n      handleMasterStartBit(i2cData);\n    }\n    if ((controlReg & 0x100004) == 0) {\n      if ((((statusReg1 & 0x10040) != 0) && ((statusReg2 & 0x400) != 0)) && ((statusReg1 & 0x10004) == 0)) {\n        handleMasterReceiveRXNE(i2cData);\n        return;\n      }\n      if (((statusReg1 & 0x10004) != 0) && ((statusReg2 & 0x200) != 0)) {\n        handleMasterReceiveBTF(i2cData);\n        return;\n      }\n    }\n    else {\n      if ((((statusReg1 & 0x10080) != 0) && ((statusReg2 & 0x400) != 0)) && ((statusReg1 & 0x10004) == 0)) {\n        handleMasterTransmitTXE(i2cData);\n        return;\n      }\n      if (((statusReg1 & 0x10004) != 0) && ((statusReg2 & 0x200) != 0)) {\n        handleMasterTransmitBTF(i2cData);\n        return;\n      }\n    }\n  }\n  else {\n    if (((statusReg1 & 0x10002) != 0) && ((statusReg2 & 0x200) != 0)) {\n      handleSlaveAddress();\n      return;\n    }\n    if (((statusReg1 & 0x10010) != 0) && ((statusReg2 & 0x200) != 0)) {\n      handleSlaveSTOPF(i2cData);\n      return;\n    }\n    if ((controlReg & 0x100004) == 0) {\n      if ((((statusReg1 & 0x10040) != 0) && ((statusReg2 & 0x400) != 0)) && ((statusReg1 & 0x10004) == 0)) {\n        handleSlaveReceiveRXNE(i2cData);\n        return;\n      }\n      if (((statusReg1 & 0x10004) != 0) && ((statusReg2 & 0x200) != 0)) {\n        handleSlaveReceiveBTF(i2cData);\n      }\n    }\n    else {\n      if ((((statusReg1 & 0x10080) != 0) && ((statusReg2 & 0x400) != 0)) && ((statusReg1 & 0x10004) == 0)) {\n        handleSlaveTransmitTXE(i2cData);\n        return;\n      }\n      if (((statusReg1 & 0x10004) != 0) && ((statusReg2 & 0x200) != 0)) {\n        handleSlaveTransmitBTF(i2cData);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001d00": "handle_i2_c_event_08001d00",
                "param_1": "i2cData",
                "iVar1": "i2cPtr",
                "uVar2": "statusReg1",
                "uVar3": "statusReg2",
                "uVar4": "controlReg",
                "I2C_Master_ADDR": "handleMasterAddress",
                "I2C_Master_ADD10": "handleMasterADD10",
                "I2C_Master_SB": "handleMasterStartBit",
                "I2C_MasterReceive_RXNE": "handleMasterReceiveRXNE",
                "I2C_MasterReceive_BTF": "handleMasterReceiveBTF",
                "I2C_MasterTransmit_TXE": "handleMasterTransmitTXE",
                "I2C_MasterTransmit_BTF": "handleMasterTransmitBTF",
                "I2C_Slave_ADDR": "handleSlaveAddress",
                "I2C_Slave_STOPF": "handleSlaveSTOPF",
                "I2C_SlaveReceive_RXNE": "handleSlaveReceiveRXNE",
                "I2C_SlaveReceive_BTF": "handleSlaveReceiveBTF",
                "I2C_SlaveTransmit_TXE": "handleSlaveTransmitTXE",
                "I2C_SlaveTransmit_BTF": "handleSlaveTransmitBTF"
            },
            "calling": [],
            "called": [
                "I2C_MasterReceive_RXNE",
                "I2C_SlaveReceive_BTF",
                "I2C_Master_SB",
                "I2C_SlaveReceive_RXNE",
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_ADDR",
                "I2C_MasterTransmit_TXE",
                "I2C_MasterTransmit_BTF",
                "I2C_Master_ADD10",
                "I2C_Slave_STOPF",
                "I2C_Master_ADDR",
                "I2C_SlaveTransmit_BTF",
                "I2C_MasterReceive_BTF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e68": {
            "entrypoint": "0x08001e68",
            "current_name": "identify_faulty_i2_c_08001e68",
            "code": "\nvoid identifyFaultyI2C_08001e68(uint **parameterList)\n\n{\n  char characterVar;\n  uint *pointerVar;\n  uint variable1;\n  uint variable2;\n  \n  pointerVar = *parameterList;\n  variable1 = pointerVar[5];\n  variable2 = pointerVar[1];\n  if (((variable1 & 0x10100) != 0) && ((variable2 & 0x100) != 0)) {\n    parameterList[0x10] = (uint *)((uint)parameterList[0x10] | 1);\n    pointerVar[5] = 0xfffffeff;\n  }\n  if (((variable1 & 0x10200) != 0) && ((variable2 & 0x100) != 0)) {\n    parameterList[0x10] = (uint *)((uint)parameterList[0x10] | 2);\n    (*parameterList)[5] = 0xfffffdff;\n  }\n  if (((variable1 & 0x10400) != 0) && ((variable2 & 0x100) != 0)) {\n    characterVar = *(char *)((int)parameterList + 0x3d);\n    if (((*(char *)((int)parameterList + 0x3e) == ' ') && (*(short *)((int)parameterList + 0x2a) == 0)) &&\n       (((characterVar == '!' || (characterVar == ')')) || ((characterVar == '(' && (parameterList[0xc] == (uint *)0x21)))))) {\n      I2C_Slave_AF(parameterList);\n    }\n    else {\n      parameterList[0x10] = (uint *)((uint)parameterList[0x10] | 4);\n      if (*(char *)((int)parameterList + 0x3e) == '\\x10') {\n        **parameterList = **parameterList | 0x200;\n      }\n      (*parameterList)[5] = 0xfffffbff;\n    }\n  }\n  if (((variable1 & 0x10800) != 0) && ((variable2 & 0x100) != 0)) {\n    parameterList[0x10] = (uint *)((uint)parameterList[0x10] | 8);\n    (*parameterList)[5] = 0xfffff7ff;\n  }\n  if (parameterList[0x10] != (uint *)0x0) {\n    I2C_ITError(parameterList);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001e68": "identify_faulty_i2_c_08001e68",
                "param_1": "parameterList",
                "cVar1": "characterVar",
                "puVar2": "pointerVar",
                "uVar3": "variable1",
                "uVar4": "variable2"
            },
            "calling": [],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f9c": {
            "entrypoint": "0x08001f9c",
            "current_name": "wait_for_flag_clear_08001f9c",
            "code": "\n\n\nundefined4 waitForFlagClear_08001f9c(void)\n\n{\n  int startTime;\n  int currentTime;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_420e0040 = 1;\n  startTime = HAL_GetTick();\n  do {\n    if ((_DAT_40007004 & 0x10000) != 0) {\n      _DAT_420e0044 = 1;\n      startTime = HAL_GetTick();\n      do {\n        if ((_DAT_40007004 & 0x20000) != 0) {\n          return 0;\n        }\n        currentTime = HAL_GetTick();\n      } while ((uint)(currentTime - startTime) < 0x3e9);\n      return 3;\n    }\n    currentTime = HAL_GetTick();\n  } while ((uint)(currentTime - startTime) < 0x3e9);\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_08001f9c": "wait_for_flag_clear_08001f9c",
                "iVar1": "startTime",
                "iVar2": "currentTime"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800201c": {
            "entrypoint": "0x0800201c",
            "current_name": "execute_operation_0800201c",
            "code": "\n\n\nundefined4 executeOperation_0800201c(uint *operationParams)\n\n{\n  int startTime;\n  int currentTime;\n  undefined4 result;\n  bool isFlagSet;\n  \n  if (operationParams == (uint *)0x0) {\n    return 1;\n  }\n  if ((*operationParams & 1) != 0) {\n    if (((_DAT_40023808 & 0xc) == 4) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) != 0)))) {\n      if (((_DAT_40023800 & 0x20000) != 0) && (operationParams[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      if (operationParams[1] == 0x10000) {\n        _DAT_40023800 = _DAT_40023800 | 0x10000;\n      }\n      else if (operationParams[1] == 0x50000) {\n        _DAT_40023800 = _DAT_40023800 | 0x50000;\n      }\n      else {\n        _DAT_40023800 = _DAT_40023800 & 0xfffaffff;\n      }\n      if (operationParams[1] == 0) {\n        startTime = getCurrentTime();\n        while ((_DAT_40023800 & 0x20000) != 0) {\n          currentTime = getCurrentTime();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        startTime = getCurrentTime();\n        while ((_DAT_40023800 & 0x20000) == 0) {\n          currentTime = getCurrentTime();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*operationParams & 2) != 0) {\n    if (((_DAT_40023808 & 0xc) == 0) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) == 0)))) {\n      if (((_DAT_40023800 & 2) != 0) && (operationParams[3] != 1)) {\n        return 1;\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | operationParams[4] << 3;\n    }\n    else if (operationParams[3] == 0) {\n      _DAT_42470000 = 0;\n      startTime = getCurrentTime();\n      while ((_DAT_40023800 & 2) != 0) {\n        currentTime = getCurrentTime();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42470000 = 1;\n      startTime = getCurrentTime();\n      while ((_DAT_40023800 & 2) == 0) {\n        currentTime = getCurrentTime();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | operationParams[4] << 3;\n    }\n  }\n  if ((*operationParams & 8) != 0) {\n    if (operationParams[5] == 0) {\n      _DAT_42470e80 = 0;\n      startTime = getCurrentTime();\n      while ((_DAT_40023874 & 2) != 0) {\n        currentTime = getCurrentTime();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42470e80 = 1;\n      startTime = getCurrentTime();\n      while ((_DAT_40023874 & 2) == 0) {\n        currentTime = getCurrentTime();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n  }\n  if ((*operationParams & 4) != 0) {\n    isFlagSet = (_DAT_40023840 & 0x10000000) == 0;\n    if (isFlagSet) {\n      _DAT_40023840 = _DAT_40023840 | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = getCurrentTime();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = getCurrentTime();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (operationParams[2] == 1) {\n      _DAT_40023870 = _DAT_40023870 | 1;\n    }\n    else if (operationParams[2] == 5) {\n      _DAT_40023870 = _DAT_40023870 | 5;\n    }\n    else {\n      _DAT_40023870 = _DAT_40023870 & 0xfffffffa;\n    }\n    if (operationParams[2] == 0) {\n      startTime = getCurrentTime();\n      while ((_DAT_40023870 & 2) != 0) {\n        currentTime = getCurrentTime();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      startTime = getCurrentTime();\n      while ((_DAT_40023870 & 2) == 0) {\n        currentTime = getCurrentTime();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (isFlagSet) {\n      _DAT_40023840 = _DAT_40023840 & 0xefffffff;\n    }\n  }\n  if (operationParams[6] == 0) {\n    result = 0;\n  }\n  else if ((_DAT_40023808 & 0xc) == 8) {\n    result = 1;\n  }\n  else if (operationParams[6] == 2) {\n    _DAT_42470060 = 0;\n    startTime = getCurrentTime();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        _DAT_40023804 =\n             operation1 | operation2 | operation3 << 6 | ((operation4 >> 1) - 1) * 0x10000 |\n             operationParams[0xb] << 0x18;\n        _DAT_42470060 = 1;\n        startTime = getCurrentTime();\n        do {\n          if ((_DAT_40023800 & 0x2000000) != 0) {\n            return 0;\n          }\n          currentTime = getCurrentTime();\n        } while ((uint)(currentTime - startTime) < 3);\n        return 3;\n      }\n      currentTime = getCurrentTime();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  else {\n    _DAT_42470060 = 0;\n    startTime = getCurrentTime();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return 0;\n      }\n      currentTime = getCurrentTime();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800201c": "execute_operation_0800201c",
                "param_1": "operationParams",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "result",
                "bVar4": "isFlagSet",
                "HAL_GetTick": "getCurrentTime",
                "param_1[7]": "operation1",
                "param_1[8]": "operation2",
                "param_1[9]": "operation3",
                "param_1[10]": "operation4"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080023b4": {
            "entrypoint": "0x080023b4",
            "current_name": "calculate_divisor_080023b4",
            "code": "\n\n\nuint calculate_divisor_080023b4(void)\n\n{\n  undefined4 additional_input;\n  uint result;\n  \n  if ((_DAT_40023808 & 0xc) == 4) {\n    return 8000000;\n  }\n  if ((_DAT_40023808 & 0xc) != 8) {\n    return 16000000;\n  }\n  if ((_DAT_40023804 & 0x400000) == 0) {\n    result = (_DAT_40023804 << 0x11) >> 0x17;\n    result = __aeabi_uldivmod(result * 16000000,\n                             (((uint)(result * 0x20 < result) * -0x3f -\n                              (uint)(result * 0x7c0 < result * 0x1f)) * 8 +\n                             (uint)CARRY4(result * 0x3d08,result)) * 0x400 | result * 0x3d09 >> 0x16,\n                             _DAT_40023804 & 0x3f,0,additional_input);\n  }\n  else {\n    result = (_DAT_40023804 << 0x11) >> 0x17;\n    result = __aeabi_uldivmod(result * 8000000,\n                             (((uint)(result * 0x20 < result) * -0x3f -\n                              (uint)(result * 0x7c0 < result * 0x1f)) * 8 +\n                             (uint)CARRY4(result * 0x3d08,result)) * 0x200,_DAT_40023804 & 0x3f,0,\n                             additional_input);\n  }\n  return result / ((((_DAT_40023804 << 0xe) >> 0x1e) + 1) * 2);\n}\n\n",
            "renaming": {
                "FUN_080023b4": "calculate_divisor_080023b4",
                "in_r3": "additional_input",
                "uVar1": "result"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "__aeabi_uldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002488": {
            "entrypoint": "0x08002488",
            "current_name": "initialize_system_08002488",
            "code": "\n\n\nundefined4 initializeSystem_08002488(uint *configParams,uint numParams)\n\n{\n  int startTime;\n  int currentTime;\n  uint systemFreq;\n  \n  if (configParams == (uint *)0x0) {\n    return 1;\n  }\n  if ((_DAT_40023c00 & 0xf) < numParams) {\n    _DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)numParams);\n    if (numParams != (numParams & 0xf)) {\n      return 1;\n    }\n  }\n  if ((*configParams & 2) != 0) {\n    if ((*configParams & 4) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0x1c00;\n    }\n    if ((*configParams & 8) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0xe000;\n    }\n    _DAT_40023808 = _DAT_40023808 & 0xffffff0f | configParams[2];\n  }\n  if ((*configParams & 1) != 0) {\n    systemFreq = configParams[1];\n    if (systemFreq == 1) {\n      if ((_DAT_40023800 & 0x20000) == 0) {\n        return 1;\n      }\n    }\n    else if (systemFreq - 2 < 2) {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return 1;\n      }\n    }\n    else if ((_DAT_40023800 & 2) == 0) {\n      return 1;\n    }\n    _DAT_40023808 = systemFreq | _DAT_40023808 & 0xfffffffc;\n    startTime = HAL_GetTick();\n    while( true ) {\n      if ((_DAT_40023808 & 0xc) == configParams[1] * 4) break;\n      currentTime = HAL_GetTick();\n      if (5000 < (uint)(currentTime - startTime)) {\n        return 3;\n      }\n    }\n  }\n  if (numParams < (_DAT_40023c00 & 0xf)) {\n    _DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)numParams);\n    if (numParams != (numParams & 0xf)) {\n      return 1;\n    }\n  }\n  if ((*configParams & 4) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffffe3ff | configParams[3];\n  }\n  if ((*configParams & 8) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffff1fff | configParams[4] << 3;\n  }\n  systemFreq = HAL_RCC_GetSysClockFreq();\n  DAT_2000002c = systemFreq >> (&DAT_08005dfc)[(_DAT_40023808 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002488": "initialize_system_08002488",
                "param_1": "configParams",
                "param_2": "numParams",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "systemFreq"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_InitTick",
                "HAL_RCC_GetSysClockFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e0": {
            "entrypoint": "0x080025e0",
            "current_name": "get_return_value_080025e0",
            "code": "\nundefined4 getReturnValue_080025e0(void)\n\n{\n  return DAT_2000002c;\n}\n\n",
            "renaming": {
                "FUN_080025e0": "get_return_value_080025e0"
            },
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "SystemClock_Config",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025ec": {
            "entrypoint": "0x080025ec",
            "current_name": "get_adjusted_hclk_freq_080025ec",
            "code": "\n\n\nuint getAdjustedHCLKFreq_080025ec(void)\n\n{\n  uint hclkFreq;\n  \n  hclkFreq = getHCLKFreq();\n  return hclkFreq >> (&DAT_08005e0c)[(uint)(_DAT_40023808 << 0x13) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_080025ec": "get_adjusted_hclk_freq_080025ec",
                "uVar1": "hclkFreq",
                "HAL_RCC_GetHCLKFreq": "getHCLKFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800260c": {
            "entrypoint": "0x0800260c",
            "current_name": "get_adjusted_hclk_freq_0800260c",
            "code": "\n\n\nuint getAdjustedHCLKFreq_0800260c(void)\n\n{\n  uint hclkFreq;\n  \n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  return hclkFreq >> (&DAT_08005e0c)[(uint)(_DAT_40023808 << 0x10) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_0800260c": "get_adjusted_hclk_freq_0800260c",
                "uVar1": "hclkFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800262c": {
            "entrypoint": "0x0800262c",
            "current_name": "handle_alarm_events_0800262c",
            "code": "\n\n\nvoid handleAlarmEvents_0800262c(int *alarmEventList)\n\n{\n  if (((*(uint *)(*alarmEventList + 0xc) & 0x100) != 0) && ((*(uint *)(*alarmEventList + 8) & 0x1000) != 0)) {\n    handleAlarmACallback();\n    *(uint *)(*alarmEventList + 0xc) = *(uint *)(*alarmEventList + 0xc) & 0xff | 0xfffffe7f;\n  }\n  if (((*(uint *)(*alarmEventList + 0xc) & 0x200) != 0) && ((*(uint *)(*alarmEventList + 8) & 0x2000) != 0)) {\n    handleAlarmBCallback(alarmEventList);\n    *(uint *)(*alarmEventList + 0xc) = *(uint *)(*alarmEventList + 0xc) & 0xff | 0xfffffd7f;\n  }\n  _DAT_40013c14 = 0x20000;\n  *(undefined *)((int)alarmEventList + 0x1d) = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800262c": "handle_alarm_events_0800262c",
                "param_1": "alarmEventList",
                "HAL_RTC_AlarmAEventCallback()": "handleAlarmACallback()",
                "HAL_RTCEx_AlarmBEventCallback(param_1)": "handleAlarmBCallback(alarmEventList)"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmAEventCallback",
                "HAL_RTCEx_AlarmBEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800268c": {
            "entrypoint": "0x0800268c",
            "current_name": "FUNC_0800268c",
            "code": "\nvoid FUNC_0800268c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800268c": "FUNC_0800268c"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800268e": {
            "entrypoint": "0x0800268e",
            "current_name": "disable_pwm_0800268e",
            "code": "\nvoid disablePWM_0800268e(uint **pParam)\n\n{\n  uint *pVar1;\n  \n  *(undefined *)((int)pParam + 0x39) = 2;\n  pVar1 = *pParam;\n  if ((pVar1[8] & 0x1111) == 0) {\n    if ((pVar1[8] & 0x444) == 0) {\n      *pVar1 = *pVar1 & 0xfffffffe;\n    }\n  }\n  HAL_TIM_PWM_MspDeInit(pParam);\n  *(undefined *)((int)pParam + 0x39) = 0;\n  *(undefined *)(pParam + 0xe) = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800268e": "disable_pwm_0800268e",
                "param_1": "pParam",
                "puVar1": "pVar1"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080026c8": {
            "entrypoint": "0x080026c8",
            "current_name": "FUNC_080026c8",
            "code": "\nvoid FUNC_080026c8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026c8": "FUNC_080026c8"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ca": {
            "entrypoint": "0x080026ca",
            "current_name": "FUNC_080026ca",
            "code": "\nvoid FUNC_080026ca(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ca": "FUNC_080026ca"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026cc": {
            "entrypoint": "0x080026cc",
            "current_name": "FUNC_080026cc",
            "code": "\nvoid FUNC_080026cc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026cc": "FUNC_080026cc"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ce": {
            "entrypoint": "0x080026ce",
            "current_name": "process_timers_080026ce",
            "code": "\nvoid processTimers_080026ce(int *timerArray)\n\n{\n  int currentTimer;\n  \n  currentTimer = *timerArray;\n  if (((*(uint *)(currentTimer + 0x10) & 2) != 0) && ((*(uint *)(currentTimer + 0xc) & 2) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xfffffffd;\n    *(undefined *)(timerArray + 6) = 1;\n    if ((*(uint *)(*timerArray + 0x18) & 3) == 0) {\n      handleOC_DelayElapsedCallback();\n      handlePWM_PulseFinishedCallback(param_1);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback();\n    }\n    *(undefined *)(timerArray + 6) = 0;\n  }\n  currentTimer = *timerArray;\n  if (((*(uint *)(currentTimer + 0x10) & 4) != 0) && ((*(uint *)(currentTimer + 0xc) & 4) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xfffffffb;\n    *(undefined *)(timerArray + 6) = 2;\n    if ((*(uint *)(*timerArray + 0x18) & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerArray);\n      handlePWM_PulseFinishedCallback(param_1);\n    }\n    else {\n      handleIC_CaptureCallback(param_1);\n    }\n    *(undefined *)(timerArray + 6) = 0;\n  }\n  currentTimer = *timerArray;\n  if (((*(uint *)(currentTimer + 0x10) & 8) != 0) && ((*(uint *)(currentTimer + 0xc) & 8) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xfffffff7;\n    *(undefined *)(timerArray + 6) = 4;\n    if ((*(uint *)(*timerArray + 0x1c) & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerArray);\n      handlePWM_PulseFinishedCallback(param_1);\n    }\n    else {\n      handleIC_CaptureCallback(param_1);\n    }\n    *(undefined *)(timerArray + 6) = 0;\n  }\n  currentTimer = *timerArray;\n  if (((*(uint *)(currentTimer + 0x10) & 0x10) != 0) && ((*(uint *)(currentTimer + 0xc) & 0x10) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xffffffef;\n    *(undefined *)(timerArray + 6) = 8;\n    if ((*(uint *)(*timerArray + 0x1c) & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerArray);\n      handlePWM_PulseFinishedCallback(param_1);\n    }\n    else {\n      handleIC_CaptureCallback(param_1);\n    }\n    *(undefined *)(timerArray + 6) = 0;\n  }\n  currentTimer = *timerArray;\n  if (((*(uint *)(currentTimer + 0x10) & 1) != 0) && ((*(uint *)(currentTimer + 0xc) & 1) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xfffffffe;\n    handlePeriodElapsedCallback(param_1);\n  }\n  currentTimer = *timerArray;\n  if (((*(uint *)(currentTimer + 0x10) & 0x80) != 0) && ((*(uint *)(currentTimer + 0xc) & 0x80) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xffffff7f;\n    handleBreakCallback(param_1);\n  }\n  currentTimer = *timerArray;\n  if (((*(uint *)(currentTimer + 0x10) & 0x40) != 0) && ((*(uint *)(currentTimer + 0xc) & 0x40) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xffffffbf;\n    handleTriggerCallback(param_1);\n  }\n  currentTimer = *timerArray;\n  if (((*(uint *)(currentTimer + 0x10) & 0x20) != 0) && ((*(uint *)(currentTimer + 0xc) & 0x20) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xffffffdf;\n    handleCommutationCallback(param_1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ce": "process_timers_080026ce",
                "param_1": "timerArray",
                "iVar1": "currentTimer",
                "HAL_TIM_OC_DelayElapsedCallback()": "handleOC_DelayElapsedCallback()",
                "HAL_TIM_PWM_PulseFinishedCallback(param_1)": "handlePWM_PulseFinishedCallback(param_1)",
                "HAL_TIM_IC_CaptureCallback(param_1)": "handleIC_CaptureCallback(param_1)",
                "HAL_TIM_PeriodElapsedCallback(param_1)": "handlePeriodElapsedCallback(param_1)",
                "HAL_TIMEx_BreakCallback(param_1)": "handleBreakCallback(param_1)",
                "HAL_TIM_TriggerCallback(param_1)": "handleTriggerCallback(param_1)",
                "HAL_TIMEx_CommutationCallback(param_1)": "handleCommutationCallback(param_1)"
            },
            "calling": [
                "TIM1_UP_TIM10_IRQHandler"
            ],
            "called": [
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIMEx_BreakCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002848": {
            "entrypoint": "0x08002848",
            "current_name": "update_bit_value_08002848",
            "code": "\nvoid updateBitValue_08002848(int baseAddress,uint bitPosition,int newValue)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & ~(1 << (bitPosition & 0xff));\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) | newValue << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002848": "update_bit_value_08002848",
                "param_1": "baseAddress",
                "param_2": "bitPosition",
                "param_3": "newValue"
            },
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002864": {
            "entrypoint": "0x08002864",
            "current_name": "initialize_tim_channel_08002864",
            "code": "\nundefined4 initializeTimChannel_08002864(uint **timChannel,undefined4 command)\n\n{\n  bool isRegisterValid;\n  uint *registerPointer;\n  \n  TIM_CCxChannelCmd(*timChannel,command,0);\n  registerPointer = *timChannel;\n  if (registerPointer == (uint *)0x40010000) {\n    isRegisterValid = true;\n  }\n  else if (registerPointer == (uint *)0x40010400) {\n    isRegisterValid = true;\n  }\n  else {\n    isRegisterValid = false;\n  }\n  if (((isRegisterValid) && ((registerPointer[8] & 0x1111) == 0)) && ((registerPointer[8] & 0x444) == 0)) {\n    registerPointer[0x11] = registerPointer[0x11] & 0xffff7fff;\n  }\n  registerPointer = *timChannel;\n  if (((registerPointer[8] & 0x1111) == 0) && ((registerPointer[8] & 0x444) == 0)) {\n    *registerPointer = *registerPointer & 0xfffffffe;\n  }\n  *(undefined *)((int)timChannel + 0x39) = 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002864": "initialize_tim_channel_08002864",
                "param_1": "timChannel",
                "param_2": "command",
                "bVar1": "isRegisterValid",
                "puVar2": "registerPointer"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028d4": {
            "entrypoint": "0x080028d4",
            "current_name": "update_flag_080028d4",
            "code": "\nvoid updateFlag_080028d4(int baseAddress,uint bitIndex,int newFlagValue)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & ~(4 << (bitIndex & 0xff));\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) | newFlagValue << (bitIndex & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080028d4": "update_flag_080028d4",
                "param_1": "baseAddress",
                "param_2": "bitIndex",
                "param_3": "newFlagValue"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028f0": {
            "entrypoint": "0x080028f0",
            "current_name": "configure_tim_c_cx_n_channel_080028f0",
            "code": "\nundefined4 configure_TIM_CCxNChannel_080028f0(uint **TIM_registers,undefined4 channel_number)\n\n{\n  uint *current_TIM_registers;\n  \n  TIM_CCxNChannelCmd(*TIM_registers,channel_number,0);\n  current_TIM_registers = *TIM_registers;\n  if (((current_TIM_registers[8] & 0x1111) == 0) && ((current_TIM_registers[8] & 0x444) == 0)) {\n    current_TIM_registers[0x11] = current_TIM_registers[0x11] & 0xffff7fff;\n  }\n  current_TIM_registers = *TIM_registers;\n  if (((current_TIM_registers[8] & 0x1111) == 0) && ((current_TIM_registers[8] & 0x444) == 0)) {\n    *current_TIM_registers = *current_TIM_registers & 0xfffffffe;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080028f0": "configure_tim_c_cx_n_channel_080028f0",
                "param_1": "TIM_registers",
                "param_2": "channel_number",
                "puVar1": "current_TIM_registers"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800293c": {
            "entrypoint": "0x0800293c",
            "current_name": "FUNC_0800293c",
            "code": "\nvoid FUNC_0800293c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293c": "FUNC_0800293c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800293e": {
            "entrypoint": "0x0800293e",
            "current_name": "FUNC_0800293e",
            "code": "\nvoid FUNC_0800293e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293e": "FUNC_0800293e"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002940": {
            "entrypoint": "0x08002940",
            "current_name": "clear_flags_and_set_space_08002940",
            "code": "\nvoid clearFlagsAndSetSpace_08002940(int *flagsPointer)\n\n{\n  *(uint *)(*flagsPointer + 0xc) = *(uint *)(*flagsPointer + 0xc) & 0xfffffedf;\n  *(uint *)(*flagsPointer + 0x14) = *(uint *)(*flagsPointer + 0x14) & 0xfffffffe;\n  *(undefined *)((int)flagsPointer + 0x3a) = 0x20;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002940": "clear_flags_and_set_space_08002940",
                "param_1": "flagsPointer"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800295c": {
            "entrypoint": "0x0800295c",
            "current_name": "process_data_0800295c",
            "code": "\nundefined4 processData_0800295c(int *data)\n\n{\n  short counter;\n  byte *bytePtr;\n  \n  if (*(char *)((int)data + 0x39) != '!') {\n    return 2;\n  }\n  if (data[2] == 0x1000) {\n    *(uint *)(*data + 4) = *(ushort *)data[8] & 0x1ff;\n    if (data[4] == 0) {\n      data[8] = data[8] + 2;\n    }\n    else {\n      data[8] = data[8] + 1;\n    }\n  }\n  else {\n    bytePtr = (byte *)data[8];\n    data[8] = (int)(bytePtr + 1);\n    *(uint *)(*data + 4) = (uint)*bytePtr;\n  }\n  counter = *(short *)((int)data + 0x26) + -1;\n  *(short *)((int)data + 0x26) = counter;\n  if (counter == 0) {\n    *(uint *)(*data + 0xc) = *(uint *)(*data + 0xc) & 0xffffff7f;\n    *(uint *)(*data + 0xc) = *(uint *)(*data + 0xc) | 0x40;\n    return 0;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800295c": "process_data_0800295c",
                "param_1": "data",
                "sVar1": "counter",
                "pbVar2": "bytePtr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080029c8": {
            "entrypoint": "0x080029c8",
            "current_name": "calculate_clock_frequency_080029c8",
            "code": "\nvoid calculateClockFrequency_080029c8(int *clockParams)\n\n{\n  int pclkFreq1;\n  int pclkFreq1;\n  int pclkFreq1;\n  int pclkFreq1;\n  int pclkFreq1;\n  int param1Var;\n  int param1Var;\n  int param1Var;\n  int param1Var;\n  int iVar;\n  \n  *(uint *)(*clockParams + 0x10) = *(uint *)(*clockParams + 0x10) & 0xffffcfff | clockParams[3];\n  *(uint *)(*clockParams + 0xc) =\n       *(uint *)(*clockParams + 0xc) & 0xffff69f3 | clockParams[2] | clockParams[4] | clockParams[5] | clockParams[7];\n  *(uint *)(*clockParams + 0x14) = *(uint *)(*clockParams + 0x14) & 0xfffffcff | clockParams[6];\n  if (clockParams[7] == 0x8000) {\n    iVar = *clockParams;\n    if ((iVar != 0x40011000) && (iVar != 0x40011400)) {\n      pclkFreq1 = getPCLK1Freq();\n      param1Var = clockParams[1];\n      pclkFreq1 = getPCLK1Freq();\n      param1Var = clockParams[1];\n      pclkFreq1 = getPCLK1Freq();\n      param1Var = clockParams[1];\n      pclkFreq1 = getPCLK1Freq();\n      param1Var = clockParams[1];\n      pclkFreq1 = getPCLK1Freq();\n      *(uint *)(iVar + 8) =\n           ((uint)((int)((ulonglong)\n                         (((uint)(pclkFreq1 * 0x19) / (uint)(param1Var << 1) +\n                          (int)(((ulonglong)(uint)(pclkFreq1 * 0x19) /\n                                (ulonglong)(uint)(clockParams[1] << 1)) / 100) * -100) * 8 + 0x32) *\n                         0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n           ((((uint)(pclkFreq1 * 0x19) / (uint)(param1Var << 1) +\n             (int)(((ulonglong)(uint)(pclkFreq1 * 0x19) / (ulonglong)(uint)(param1Var << 1)) / 100) * -100)\n             * 8 + 0x32) / 100 & 0xf8) * 2 +\n           (int)(((ulonglong)(uint)(pclkFreq1 * 0x19) / (ulonglong)(uint)(param1Var << 1)) / 100) * 0x10;\n      return;\n    }\n    pclkFreq1 = getPCLK2Freq();\n    param1Var = clockParams[1];\n    pclkFreq1 = getPCLK2Freq();\n    param1Var = clockParams[1];\n    pclkFreq1 = getPCLK2Freq();\n    param1Var = clockParams[1];\n    pclkFreq1 = getPCLK2Freq();\n    param1Var = clockParams[1];\n    pclkFreq1 = getPCLK2Freq();\n    *(uint *)(iVar + 8) =\n         ((uint)((int)((ulonglong)\n                       (((uint)(pclkFreq1 * 0x19) / (uint)(param1Var << 1) +\n                        (int)(((ulonglong)(uint)(pclkFreq1 * 0x19) / (ulonglong)(uint)(clockParams[1] << 1))\n                             / 100) * -100) * 8 + 0x32) * 0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n         ((((uint)(pclkFreq1 * 0x19) / (uint)(param1Var << 1) +\n           (int)(((ulonglong)(uint)(pclkFreq1 * 0x19) / (ulonglong)(uint)(param1Var << 1)) / 100) * -100) *\n           8 + 0x32) / 100 & 0xf8) * 2 +\n         (int)(((ulonglong)(uint)(pclkFreq1 * 0x19) / (ulonglong)(uint)(param1Var << 1)) / 100) * 0x10;\n    return;\n  }\n  iVar = *clockParams;\n  if ((iVar != 0x40011000) && (iVar != 0x40011400)) {\n    pclkFreq1 = getPCLK1Freq();\n    param1Var = clockParams[1];\n    pclkFreq1 = getPCLK1Freq();\n    param1Var = clockParams[1];\n    pclkFreq1 = getPCLK1Freq();\n    param1Var = clockParams[1];\n    pclkFreq1 = getPCLK1Freq();\n    param1Var = clockParams[1];\n    pclkFreq1 = getPCLK1Freq();\n    *(uint *)(iVar + 8) =\n         ((uint)((int)((ulonglong)\n                       (((uint)(pclkFreq1 * 0x19) / (uint)(param1Var << 2) +\n                        (int)(((ulonglong)(uint)(pclkFreq1 * 0x19) / (ulonglong)(uint)(clockParams[1] << 2))\n                             / 100) * -100) * 0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n         ((((uint)(pclkFreq1 * 0x19) / (uint)(param1Var << 2) +\n           (int)(((ulonglong)(uint)(pclkFreq1 * 0x19) / (ulonglong)(uint)(param1Var << 2)) / 100) * -100) *\n           0x10 + 0x32) / 100 & 0xf0) +\n         (int)(((ulonglong)(uint)(pclkFreq1 * 0x19) / (ulonglong)(uint)(param1Var << 2)) / 100) * 0x10;\n    return;\n  }\n  pclkFreq1 = getPCLK2Freq();\n  param1Var = clockParams[1];\n  pclkFreq1 = getPCLK2Freq();\n  param1Var = clockParams[1];\n  pclkFreq1 = getPCLK2Freq();\n  param1Var = clockParams[1];\n  pclkFreq1 = getPCLK2Freq();\n  param1Var = clockParams[1];\n  pclkFreq1 = getPCLK2Freq();\n  *(uint *)(iVar + 8) =\n       ((uint)((int)((ulonglong)\n                     (((uint)(pclkFreq1 * 0x19) / (uint)(param1Var << 2) +\n                      (int)(((ulonglong)(uint)(pclkFreq1 * 0x19) / (ulonglong)(uint)(clockParams[1] << 2)) /\n                           100) * -100) * 0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n       ((((uint)(pclkFreq1 * 0x19) / (uint)(param1Var << 2) +\n         (int)(((ulonglong)(uint)(pclkFreq1 * 0x19) / (ulonglong)(uint)(param1Var << 2)) / 100) * -100) *\n         0x10 + 0x32) / 100 & 0xf0) +\n       (int)(((ulonglong)(uint)(pclkFreq1 * 0x19) / (ulonglong)(uint)(param1Var << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080029c8": "calculate_clock_frequency_080029c8",
                "param_1": "clockParams",
                "iVar1": "pclkFreq1",
                "iVar2": "pclkFreq1",
                "iVar3": "pclkFreq1",
                "iVar4": "pclkFreq1",
                "iVar5": "pclkFreq1",
                "iVar6": "param1Var",
                "iVar7": "param1Var",
                "iVar8": "param1Var",
                "iVar9": "param1Var",
                "iVar10": "iVar",
                "HAL_RCC_GetPCLK1Freq": "getPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq": "getPCLK2Freq"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d0c": {
            "entrypoint": "0x08002d0c",
            "current_name": "check_condition_and_set_values_08002d0c",
            "code": "\nundefined4 checkConditionAndSetValues_08002d0c(uint **parameter1,uint condition1,uint expectedResult,int referenceTime,uint timeLimit)\n\n{\n  int currentTime;\n  \n  do {\n    if (((condition1 & ~**parameter1) == 0) != expectedResult) {\n      return 0;\n    }\n  } while ((timeLimit == 0xffffffff) ||\n          ((timeLimit != 0 && (currentTime = HAL_GetTick(), (uint)(currentTime - referenceTime) <= timeLimit))));\n  (*parameter1)[3] = (*parameter1)[3] & 0xfffffe5f;\n  (*parameter1)[5] = (*parameter1)[5] & 0xfffffffe;\n  *(undefined *)((int)parameter1 + 0x39) = 0x20;\n  *(undefined *)((int)parameter1 + 0x3a) = 0x20;\n  *(undefined *)(parameter1 + 0xe) = 0;\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_08002d0c": "check_condition_and_set_values_08002d0c",
                "param_1": "parameter1",
                "param_2": "condition1",
                "param_3": "expectedResult",
                "param_4": "referenceTime",
                "param_5": "timeLimit",
                "iVar1": "currentTime"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d70": {
            "entrypoint": "0x08002d70",
            "current_name": "FUNC_08002d70",
            "code": "\nvoid FUNC_08002d70(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d70": "FUNC_08002d70"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d72": {
            "entrypoint": "0x08002d72",
            "current_name": "initialize_uart_08002d72",
            "code": "\nundefined4 initializeUart_08002d72(int *uartParams)\n\n{\n  if (uartParams != (int *)0x0) {\n    if (*(char *)((int)uartParams + 0x39) == '\\0') {\n      *(undefined *)(uartParams + 0xe) = 0;\n      initializeUart_08002d72Msp();\n    }\n    *(undefined *)((int)uartParams + 0x39) = 0x24;\n    *(uint *)(*uartParams + 0xc) = *(uint *)(*uartParams + 0xc) & 0xffffdfff;\n    setUartConfig(uartParams);\n    *(uint *)(*uartParams + 0x10) = *(uint *)(*uartParams + 0x10) & 0xffffb7ff;\n    *(uint *)(*uartParams + 0x14) = *(uint *)(*uartParams + 0x14) & 0xffffffd5;\n    *(uint *)(*uartParams + 0xc) = *(uint *)(*uartParams + 0xc) | 0x2000;\n    uartFlag = 0;\n    *(undefined *)((int)uartParams + 0x39) = 0x20;\n    *(undefined *)((int)uartParams + 0x3a) = 0x20;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002d72": "initialize_uart_08002d72",
                "param_1": "uartParams",
                "HAL_UART_MspInit": "initializeUartMsp",
                "UART_SetConfig": "setUartConfig",
                "param_1[0xf]": "uartFlag"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002dd0": {
            "entrypoint": "0x08002dd0",
            "current_name": "process_data_08002dd0",
            "code": "\nundefined4 processData_08002dd0(int *dataBuffer,ushort *dataStream,int dataLength,undefined4 timeout)\n\n{\n  int result;\n  undefined4 returnValue;\n  \n  if (*(char *)((int)dataBuffer + 0x39) == ' ') {\n    if (dataStream == (ushort *)0x0) {\n      returnValue = 1;\n    }\n    else if (dataLength == 0) {\n      returnValue = 1;\n    }\n    else if (*(char *)(dataBuffer + 0xe) == '\\x01') {\n      returnValue = 2;\n    }\n    else {\n      *(undefined *)(dataBuffer + 0xe) = 1;\n      dataBuffer[0xf] = 0;\n      *(undefined *)((int)dataBuffer + 0x39) = 0x21;\n      returnValue = HAL_GetTick();\n      *(short *)(dataBuffer + 9) = (short)dataLength;\n      *(short *)((int)dataBuffer + 0x26) = (short)dataLength;\n      while (*(short *)((int)dataBuffer + 0x26) != 0) {\n        *(short *)((int)dataBuffer + 0x26) = *(short *)((int)dataBuffer + 0x26) + -1;\n        if (dataBuffer[2] == 0x1000) {\n          result = UART_WaitOnFlagUntilTimeout(dataBuffer,0x80,0,returnValue,timeout);\n          if (result != 0) {\n            return 3;\n          }\n          *(uint *)(*dataBuffer + 4) = *dataStream & 0x1ff;\n          if (dataBuffer[4] == 0) {\n            dataStream = dataStream + 1;\n          }\n          else {\n            dataStream = (ushort *)((int)dataStream + 1);\n          }\n        }\n        else {\n          result = UART_WaitOnFlagUntilTimeout(dataBuffer,0x80,0,returnValue,timeout);\n          if (result != 0) {\n            return 3;\n          }\n          *(uint *)(*dataBuffer + 4) = (uint)*(byte *)dataStream;\n          dataStream = (ushort *)((int)dataStream + 1);\n        }\n      }\n      result = UART_WaitOnFlagUntilTimeout(dataBuffer,0x40,0,returnValue,timeout);\n      if (result == 0) {\n        *(undefined *)((int)dataBuffer + 0x39) = 0x20;\n        *(undefined *)(dataBuffer + 0xe) = 0;\n        returnValue = 0;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08002dd0": "process_data_08002dd0",
                "param_1": "dataBuffer",
                "param_2": "dataStream",
                "param_3": "dataLength",
                "param_4": "timeout",
                "iVar1": "result",
                "uVar2": "returnValue"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002eb2": {
            "entrypoint": "0x08002eb2",
            "current_name": "check_and_modify_data_08002eb2",
            "code": "\nundefined4 checkAndModifyData_08002eb2(int *dataPointer,int value1,int value2)\n\n{\n  if (*(char *)((int)dataPointer + 0x39) != ' ') {\n    return 2;\n  }\n  if (value1 == 0) {\n    return 1;\n  }\n  if (value2 == 0) {\n    return 1;\n  }\n  if (*(char *)(dataPointer + 0xe) != '\\x01') {\n    dataPointer[8] = value1;\n    *(short *)(dataPointer + 9) = (short)value2;\n    *(short *)((int)dataPointer + 0x26) = (short)value2;\n    dataPointer[0xf] = 0;\n    *(undefined *)((int)dataPointer + 0x39) = 0x21;\n    *(undefined *)(dataPointer + 0xe) = 0;\n    *(uint *)(*dataPointer + 0xc) = *(uint *)(*dataPointer + 0xc) | 0x80;\n    return 0;\n  }\n  return 2;\n}\n\n",
            "renaming": {
                "FUN_08002eb2": "check_and_modify_data_08002eb2",
                "param_1": "dataPointer",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efa": {
            "entrypoint": "0x08002efa",
            "current_name": "check_and_modify_values_08002efa",
            "code": "\nundefined4 check_and_modify_values_08002efa(int *array,int value1,int value2)\n\n{\n  if (*(char *)((int)array + 0x3a) != ' ') {\n    return 2;\n  }\n  if (value1 == 0) {\n    return 1;\n  }\n  if (value2 == 0) {\n    return 1;\n  }\n  if (*(char *)(array + 0xe) != '\\x01') {\n    array[10] = value1;\n    *(short *)(array + 0xb) = (short)value2;\n    *(short *)((int)array + 0x2e) = (short)value2;\n    array[0xf] = 0;\n    *(undefined *)((int)array + 0x3a) = 0x22;\n    *(undefined *)(array + 0xe) = 0;\n    *(uint *)(*array + 0x14) = *(uint *)(*array + 0x14) | 1;\n    *(uint *)(*array + 0xc) = *(uint *)(*array + 0xc) | 0x120;\n    return 0;\n  }\n  return 2;\n}\n\n",
            "renaming": {
                "FUN_08002efa": "check_and_modify_values_08002efa",
                "param_1": "array",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f4c": {
            "entrypoint": "0x08002f4c",
            "current_name": "clear_interrupt_flag_08002f4c",
            "code": "\nundefined4 clearInterruptFlag_08002f4c(int *interruptPtr)\n\n{\n  *(uint *)(*interruptPtr + 0xc) = *(uint *)(*interruptPtr + 0xc) & 0xffffffbf;\n  *(undefined *)((int)interruptPtr + 0x39) = 0x20;\n  transmissionCompleteCallback();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002f4c": "clear_interrupt_flag_08002f4c",
                "param_1": "interruptPtr",
                "HAL_UART_TxCpltCallback()": "transmissionCompleteCallback()"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f66": {
            "entrypoint": "0x08002f66",
            "current_name": "process_input_string_08002f66",
            "code": "\nundefined4 processInputString_08002f66(int *inputBuffer)\n\n{\n  byte *outputByte;\n  short remainingBytes;\n  undefined *outputBytePtr;\n  \n  if (*(char *)((int)inputBuffer + 0x3a) != '\\\"') {\n    return 2;\n  }\n  if (inputBuffer[2] == 0x1000) {\n    if (inputBuffer[4] == 0) {\n      *(ushort *)inputBuffer[10] = (ushort)((uint)(*(int *)(*inputBuffer + 4) << 0x17) >> 0x17);\n      inputBuffer[10] = inputBuffer[10] + 2;\n    }\n    else {\n      *(ushort *)inputBuffer[10] = (ushort)*(undefined4 *)(*inputBuffer + 4) & 0xff;\n      inputBuffer[10] = inputBuffer[10] + 1;\n    }\n  }\n  else if (inputBuffer[4] == 0) {\n    outputBytePtr = (undefined *)inputBuffer[10];\n    inputBuffer[10] = (int)(outputBytePtr + 1);\n    *outputBytePtr = (char)*(undefined4 *)(*inputBuffer + 4);\n  }\n  else {\n    outputByte = (byte *)inputBuffer[10];\n    inputBuffer[10] = (int)(outputByte + 1);\n    *outputByte = (byte)*(undefined4 *)(*inputBuffer + 4) & 0x7f;\n  }\n  remainingBytes = *(short *)((int)inputBuffer + 0x2e) + -1;\n  *(short *)((int)inputBuffer + 0x2e) = remainingBytes;\n  if (remainingBytes != 0) {\n    return 0;\n  }\n  *(uint *)(*inputBuffer + 0xc) = *(uint *)(*inputBuffer + 0xc) & 0xfffffedf;\n  *(uint *)(*inputBuffer + 0x14) = *(uint *)(*inputBuffer + 0x14) & 0xfffffffe;\n  *(undefined *)((int)inputBuffer + 0x3a) = 0x20;\n  HAL_UART_RxCpltCallback();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002f66": "process_input_string_08002f66",
                "param_1": "inputBuffer",
                "pbVar1": "outputByte",
                "sVar2": "remainingBytes",
                "puVar3": "outputBytePtr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ffc": {
            "entrypoint": "0x08002ffc",
            "current_name": "process_flags_08002ffc",
            "code": "\nvoid processFlags_08002ffc(uint **flags)\n\n{\n  int result;\n  uint flag2;\n  uint *ptrFlags;\n  uint flag4;\n  uint flag5;\n  \n  ptrFlags = *flags;\n  flag5 = *ptrFlags;\n  flag2 = ptrFlags[3];\n  if ((((flag5 & 0xf) == 0) && ((flag5 & 0x20) != 0)) && ((flag2 & 0x20) != 0)) {\n    startReceive(flags);\n    return;\n  }\n  if (((flag5 & 0xf) == 0) || ((flag4 = ptrFlags[5] & 1, flag4 == 0 && ((flag2 & 0x120) == 0)))) {\n    if (((flag5 & 0x80) != 0) && ((flag2 & 0x80) != 0)) {\n      startTransmit(flags);\n      return;\n    }\n    if (((flag5 & 0x40) != 0) && ((flag2 & 0x40) != 0)) {\n      endTransmit(flags);\n    }\n  }\n  else {\n    if (((flag5 & 1) != 0) && ((flag2 & 0x100) != 0)) {\n      flags[0xf] = (uint *)((uint)flags[0xf] | 1);\n    }\n    if (((flag5 & 4) != 0) && (flag4 != 0)) {\n      flags[0xf] = (uint *)((uint)flags[0xf] | 2);\n    }\n    if (((flag5 & 2) != 0) && (flag4 != 0)) {\n      flags[0xf] = (uint *)((uint)flags[0xf] | 4);\n    }\n    if (((flag5 & 8) != 0) && (flag4 != 0)) {\n      flags[0xf] = (uint *)((uint)flags[0xf] | 8);\n    }\n    if (flags[0xf] != (uint *)0x0) {\n      if (((flag5 & 0x20) != 0) && ((flag2 & 0x20) != 0)) {\n        startReceive(flags);\n      }\n      if ((((uint)flags[0xf] & 8) == 0) && (((*flags)[5] & 0x40) == 0)) {\n        handleError(flags);\n        flags[0xf] = (uint *)0x0;\n        return;\n      }\n      endReceiveTransfer(flags);\n      ptrFlags = *flags;\n      if ((ptrFlags[5] & 0x40) == 0) {\n        handleError(flags);\n        return;\n      }\n      ptrFlags[5] = ptrFlags[5] & 0xffffffbf;\n      if (flags[0xd] == (uint *)0x0) {\n        handleError(flags);\n        return;\n      }\n      flags[0xd][0x14] = (uint)&errorHandler;\n      result = abortDMA(flags[0xd]);\n      if (result != 0) {\n        (*(code *)flags[0xd][0x14])();\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ffc": "process_flags_08002ffc",
                "param_1": "flags",
                "iVar1": "result",
                "uVar2": "flag2",
                "uVar4": "flag4",
                "uVar5": "flag5",
                "puVar3": "ptrFlags",
                "UART_Receive_IT": "startReceive",
                "UART_Transmit_IT": "startTransmit",
                "UART_EndTransmit_IT": "endTransmit",
                "HAL_UART_ErrorCallback": "handleError",
                "UART_EndRxTransfer": "endReceiveTransfer",
                "HAL_DMA_Abort_IT": "abortDMA",
                "LAB_0800311c_1": "errorHandler"
            },
            "calling": [],
            "called": [
                "UART_Transmit_IT",
                "HAL_DMA_Abort_IT",
                "HAL_UART_ErrorCallback",
                "UART_Receive_IT",
                "UART_EndTransmit_IT",
                "UART_EndRxTransfer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800312c": {
            "entrypoint": "0x0800312c",
            "current_name": "combine_bytes_0800312c",
            "code": "\nbyte combineBytes_0800312c(int input)\n\n{\n  return *(byte *)(input + 0x3a) | *(byte *)(input + 0x39);\n}\n\n",
            "renaming": {
                "FUN_0800312c": "combine_bytes_0800312c",
                "param_1": "input"
            },
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003138": {
            "entrypoint": "0x08003138",
            "current_name": "check_bit_08003138",
            "code": "\nuint checkBit_08003138(uint value,int arrayPtr)\n\n{\n  return *(uint *)(arrayPtr + ((value << 0x18) >> 0x1c) * 4) >> (value & 0xf) & 1;\n}\n\n",
            "renaming": {
                "FUN_08003138": "check_bit_08003138",
                "param_1": "value",
                "param_2": "arrayPtr"
            },
            "calling": [
                "pinMode",
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800314e": {
            "entrypoint": "0x0800314e",
            "current_name": "update_bit_0800314e",
            "code": "\nvoid updateBit_0800314e(uint bitIndex,int arrayAddress)\n\n{\n  uint shiftedIndex;\n  \n  shiftedIndex = (bitIndex << 0x18) >> 0x1c;\n  *(uint *)(arrayAddress + shiftedIndex * 4) = *(uint *)(arrayAddress + shiftedIndex * 4) | 1 << (bitIndex & 0xf);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800314e": "update_bit_0800314e",
                "param_1": "bitIndex",
                "param_2": "arrayAddress",
                "uVar1": "shiftedIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800316c": {
            "entrypoint": "0x0800316c",
            "current_name": "update_bit_in_memory_0800316c",
            "code": "\nvoid updateBitInMemory_0800316c(uint input,int memory)\n\n{\n  uint shiftedIndex;\n  \n  shiftedIndex = (input << 0x18) >> 0x1c;\n  *(uint *)(memory + shiftedIndex * 4) = *(uint *)(memory + shiftedIndex * 4) & ~(1 << (input & 0xf));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316c": "update_bit_in_memory_0800316c",
                "param_1": "input",
                "param_2": "memory",
                "uVar1": "shiftedIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800318c": {
            "entrypoint": "0x0800318c",
            "current_name": "get_memory_address_0800318c",
            "code": "\nundefined4 getMemoryAddress_0800318c(undefined4 index)\n\n{\n  switch(index) {\n  case 0:\n    return 0x40020000;\n  case 1:\n    return 0x40020400;\n  case 2:\n    return 0x40020800;\n  case 3:\n    return 0x40020c00;\n  case 4:\n    return 0x40021000;\n  case 5:\n    return 0x40021400;\n  case 6:\n    return 0x40021800;\n  case 7:\n    return 0x40021c00;\n  case 8:\n    return 0x40022000;\n  case 9:\n    return 0x40022400;\n  case 10:\n    return 0x40022800;\n  default:\n    return 0;\n  }\n}\n\n",
            "renaming": {
                "FUN_0800318c": "get_memory_address_0800318c",
                "param_1": "index"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080031fc": {
            "entrypoint": "0x080031fc",
            "current_name": "set_memory_address_flag_080031fc",
            "code": "\n\n\nundefined4 setMemoryAddressFlag_080031fc(undefined4 addressIndex)\n\n{\n  undefined4 newAddress;\n  \n  switch(addressIndex) {\n  case 0:\n    _DAT_40023830 = _DAT_40023830 | 1;\n    newAddress = 0x40020000;\n    break;\n  case 1:\n    _DAT_40023830 = _DAT_40023830 | 2;\n    newAddress = 0x40020400;\n    break;\n  case 2:\n    _DAT_40023830 = _DAT_40023830 | 4;\n    newAddress = 0x40020800;\n    break;\n  case 3:\n    _DAT_40023830 = _DAT_40023830 | 8;\n    newAddress = 0x40020c00;\n    break;\n  case 4:\n    _DAT_40023830 = _DAT_40023830 | 0x10;\n    newAddress = 0x40021000;\n    break;\n  case 5:\n    _DAT_40023830 = _DAT_40023830 | 0x20;\n    newAddress = 0x40021400;\n    break;\n  case 6:\n    _DAT_40023830 = _DAT_40023830 | 0x40;\n    newAddress = 0x40021800;\n    break;\n  case 7:\n    _DAT_40023830 = _DAT_40023830 | 0x80;\n    newAddress = 0x40021c00;\n    break;\n  case 8:\n    _DAT_40023830 = _DAT_40023830 | 0x100;\n    newAddress = 0x40022000;\n    break;\n  case 9:\n    _DAT_40023830 = _DAT_40023830 | 0x200;\n    newAddress = 0x40022400;\n    break;\n  case 10:\n    _DAT_40023830 = _DAT_40023830 | 0x400;\n    newAddress = 0x40022800;\n    break;\n  default:\n    newAddress = 0;\n  }\n  return newAddress;\n}\n\n",
            "renaming": {
                "FUN_080031fc": "set_memory_address_flag_080031fc",
                "param_1": "addressIndex",
                "uVar1": "newAddress"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003380": {
            "entrypoint": "0x08003380",
            "current_name": "check_pinmap_function_08003380",
            "code": "\nundefined4 check_pinmap_function_08003380(undefined4 pin,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  int result;\n  \n  result = pinmap_function(pin,&DAT_08005a18,param3,param4,param4);\n  if ((uint)(result << 0xc) >> 0x1b != 2) {\n    return 0;\n  }\n  return 0x10;\n}\n\n",
            "renaming": {
                "FUN_08003380": "check_pinmap_function_08003380",
                "param_1": "pin",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "result"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800339c": {
            "entrypoint": "0x0800339c",
            "current_name": "pinmap_check_0800339c",
            "code": "\nundefined4 pinmap_check_0800339c(undefined4 pin,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int result;\n  uint shifted_result;\n  \n  result = pinmap_function(pin,&DAT_08005a3c,param_3,param_4,param_4);\n  shifted_result = (uint)(result << 0xc) >> 0x1b;\n  if (shifted_result == 3) {\n    return 8;\n  }\n  if (shifted_result != 4) {\n    if (shifted_result != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_0800339c": "pinmap_check_0800339c",
                "param_1": "pin",
                "iVar1": "result",
                "uVar2": "shifted_result"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033c8": {
            "entrypoint": "0x080033c8",
            "current_name": "clear_reserved_bit_080033c8",
            "code": "\n\n\nvoid clearReservedBit_080033c8(void)\n\n{\n  _DAT_40023840 = _DAT_40023840 & 0xdfffffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033c8": "clear_reserved_bit_080033c8"
            },
            "calling": [
                "HAL_DAC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033d8": {
            "entrypoint": "0x080033d8",
            "current_name": "stop_and_deinit_dac_080033d8",
            "code": "\nvoid stopAndDeinitDac_080033d8(undefined4 peripheral)\n\n{\n  int dacChannel;\n  int peripheralArray [5];\n  \n  peripheralArray[0] = pinmap_peripheral(peripheral,&DAT_08005a18);\n  if ((peripheralArray[0] != 0) && ((dacChannel = get_dac_channel(peripheral), dacChannel == 0 || (dacChannel == 0x10)))) {\n    HAL_DAC_Stop(peripheralArray,dacChannel);\n    HAL_DAC_DeInit(peripheralArray);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033d8": "stop_and_deinit_dac_080033d8",
                "param_1": "peripheral",
                "iVar1": "dacChannel",
                "local_1c": "peripheralArray"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_DAC_DeInit",
                "pinmap_peripheral",
                "HAL_DAC_Stop",
                "get_dac_channel"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800340c": {
            "entrypoint": "0x0800340c",
            "current_name": "disable_timer_clock_0800340c",
            "code": "\nvoid disable_timer_clock_0800340c(void)\n\n{\n  timer_disable_clock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800340c": "disable_timer_clock_0800340c"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003414": {
            "entrypoint": "0x08003414",
            "current_name": "stop_pwm_if_valid_peripheral_08003414",
            "code": "\nvoid stopPWMIfValidPeripheral_08003414(undefined4 peripheral)\n\n{\n  int channel;\n  uint functionValue;\n  int peripheralArray [16];\n  \n  peripheralArray[0] = pinmap_peripheral(peripheral,&DAT_08005a3c);\n  if ((peripheralArray[0] != 0) &&\n     ((((channel = get_pwm_channel(peripheral), channel == 0 || (channel == 4)) || (channel == 8)) ||\n      ((channel == 0xc || (channel == 0x18)))))) {\n    functionValue = pinmap_function(peripheral,&DAT_08005a3c);\n    if ((functionValue & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(peripheralArray,channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(peripheralArray,channel);\n    }\n    HAL_TIM_PWM_DeInit(peripheralArray);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003414": "stop_pwm_if_valid_peripheral_08003414",
                "param_1": "peripheral",
                "iVar1": "channel",
                "uVar2": "functionValue",
                "local_4c": "peripheralArray"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "pinmap_peripheral",
                "pinmap_function",
                "HAL_TIMEx_PWMN_Stop",
                "HAL_TIM_PWM_DeInit",
                "get_pwm_channel",
                "HAL_TIM_PWM_Stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800346c": {
            "entrypoint": "0x0800346c",
            "current_name": "get_current_tick_0800346c",
            "code": "\nvoid get_current_tick_0800346c(void)\n\n{\n  current_tick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800346c": "get_current_tick_0800346c",
                "HAL_GetTick": "current_tick"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003474": {
            "entrypoint": "0x08003474",
            "current_name": "FUNC_08003474",
            "code": "\nvoid FUNC_08003474(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003474": "FUNC_08003474"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003476": {
            "entrypoint": "0x08003476",
            "current_name": "handle_system_tick_08003476",
            "code": "\nvoid handleSystemTick_08003476(void)\n\n{\n  incrementSystemTick();\n  handleSystickInterrupt();\n  handleNoOsSystick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003476": "handle_system_tick_08003476",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSystickInterrupt",
                "noOsSystickHandler": "handleNoOsSystick"
            },
            "calling": [],
            "called": [
                "noOsSystickHandler",
                "HAL_SYSTICK_IRQHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003486": {
            "entrypoint": "0x08003486",
            "current_name": "initialize_gpio_08003486",
            "code": "\nvoid initialize_GPIO_08003486(uint pin_number,undefined4 config_param1,undefined4 config_param2)\n\n{\n  undefined4 clock_value;\n  uint pin_mask;\n  undefined4 config_value1;\n  undefined4 config_value2;\n  undefined4 config_flag;\n  \n  clock_value = set_GPIO_Port_Clock((pin_number << 0x18) >> 0x1c);\n  pin_mask = 1 << (pin_number & 0xf) & 0xffff;\n  config_flag = 2;\n  config_value1 = config_param1;\n  config_value2 = config_param2;\n  HAL_GPIO_Init(clock_value,&pin_mask);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003486": "initialize_gpio_08003486",
                "param_1": "pin_number",
                "param_2": "config_param1",
                "param_3": "config_param2",
                "uVar1": "clock_value",
                "local_24": "pin_mask",
                "local_20": "config_value1",
                "local_1c": "config_value2",
                "local_18": "config_flag"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034b6": {
            "entrypoint": "0x080034b6",
            "current_name": "toggle_gpio_state_080034b6",
            "code": "\nvoid toggleGPIOState_080034b6(undefined4 gpioPort,undefined2 gpioPin,int state,undefined4 param1)\n\n{\n  if (state == 0) {\n    setGPIOState(gpioPort,gpioPin,0,param1,param1);\n    return;\n  }\n  setGPIOState(gpioPort,gpioPin,1,param1,param1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034b6": "toggle_gpio_state_080034b6",
                "param_1": "gpioPort",
                "param_2": "gpioPin",
                "param_3": "state",
                "param_4": "param1",
                "HAL_GPIO_WritePin": "setGPIOState"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034ce": {
            "entrypoint": "0x080034ce",
            "current_name": "initialize_hardware_080034ce",
            "code": "\nvoid initializeHardware_080034ce(void)\n\n{\n  initializeHAL();\n  configureSystemClock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034ce": "initialize_hardware_080034ce",
                "HAL_Init": "initializeHAL",
                "SystemClock_Config": "configureSystemClock"
            },
            "calling": [
                "FUN_08000d8e"
            ],
            "called": [
                "SystemClock_Config",
                "HAL_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034da": {
            "entrypoint": "0x080034da",
            "current_name": "find_value_index_080034da",
            "code": "\nundefined4 find_value_index_080034da(int value,short *array)\n\n{\n  while( true ) {\n    if (*array == -1) {\n      return 0;\n    }\n    if (*array == value) break;\n    array = array + 6;\n  }\n  return *(undefined4 *)(array + 2);\n}\n\n",
            "renaming": {
                "FUN_080034da": "find_value_index_080034da",
                "param_1": "value",
                "param_2": "array"
            },
            "calling": [
                "pinmap_peripheral",
                "pinmap_find_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034f4": {
            "entrypoint": "0x080034f4",
            "current_name": "find_peripheral_080034f4",
            "code": "\nundefined4 find_peripheral_080034f4(int input_value)\n\n{\n  undefined4 peripheral;\n  \n  if (input_value != -1) {\n    peripheral = pinmap_find_peripheral_080034f4();\n    return peripheral;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080034f4": "find_peripheral_080034f4",
                "param_1": "input_value",
                "uVar1": "peripheral"
            },
            "calling": [
                "dac_stop",
                "pwm_stop",
                "uart_debug_write",
                "uart_debug_init",
                "uart_init"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003506": {
            "entrypoint": "0x08003506",
            "current_name": "find_value_index_08003506",
            "code": "\nint find_value_index_08003506(int target_value,short *data_array)\n\n{\n  while( true ) {\n    if (*(int *)(data_array + 2) == 0) {\n      return -1;\n    }\n    if (*(int *)(data_array + 2) == target_value) break;\n    data_array = data_array + 6;\n  }\n  return (int)*data_array;\n}\n\n",
            "renaming": {
                "FUN_08003506": "find_value_index_08003506",
                "param_1": "target_value",
                "param_2": "data_array"
            },
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800351e": {
            "entrypoint": "0x0800351e",
            "current_name": "find_pin_or_default_0800351e",
            "code": "\nundefined4 findPinOrDefault_0800351e(int inputValue)\n\n{\n  undefined4 pinResult;\n  \n  if (inputValue != 0) {\n    pinResult = pinmap_find_pin();\n    return pinResult;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800351e": "find_pin_or_default_0800351e",
                "param_1": "inputValue",
                "uVar1": "pinResult"
            },
            "calling": [
                "HardwareSerial",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800352e": {
            "entrypoint": "0x0800352e",
            "current_name": "find_value_index_0800352e",
            "code": "\nundefined4 find_value_index_0800352e(int target_value,short *value_array)\n\n{\n  while( true ) {\n    if (*value_array == -1) {\n      return 0xffffffff;\n    }\n    if (*value_array == target_value) break;\n    value_array = value_array + 6;\n  }\n  return *(undefined4 *)(value_array + 4);\n}\n\n",
            "renaming": {
                "FUN_0800352e": "find_value_index_0800352e",
                "param_1": "target_value",
                "param_2": "value_array"
            },
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800354a": {
            "entrypoint": "0x0800354a",
            "current_name": "find_function_0800354a",
            "code": "\nundefined4 findFunction_0800354a(int input)\n\n{\n  undefined4 result;\n  \n  if (input == -1) {\n    return 0xffffffff;\n  }\n  result = pinmap_find_function();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800354a": "find_function_0800354a",
                "param_1": "input",
                "uVar1": "result"
            },
            "calling": [
                "pwm_stop",
                "get_dac_channel",
                "get_pwm_channel",
                "uart_init"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800355e": {
            "entrypoint": "0x0800355e",
            "current_name": "find_value_in_array_0800355e",
            "code": "\nundefined4 find_value_in_array_0800355e(int value,short *array)\n\n{\n  if (value == -1) {\n    return 0;\n  }\n  while( true ) {\n    if (*array == -1) {\n      return 0;\n    }\n    if (value == *array) break;\n    array = array + 6;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800355e": "find_value_in_array_0800355e",
                "param_1": "value",
                "param_2": "array"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003582": {
            "entrypoint": "0x08003582",
            "current_name": "compare_and_return_if_equal_08003582",
            "code": "\nint compareAndReturnIfEqual_08003582(int value1,int value2)\n\n{\n  if (value1 != value2) {\n    if (value1 == 0) {\n      return value2;\n    }\n    if (value2 == 0) {\n      return value1;\n    }\n    value1 = 0;\n  }\n  return value1;\n}\n\n",
            "renaming": {
                "FUN_08003582": "compare_and_return_if_equal_08003582",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003594": {
            "entrypoint": "0x08003594",
            "current_name": "execute_callback_if_not_null_08003594",
            "code": "\nvoid executeCallbackIfNotNull_08003594(void)\n\n{\n  if (DAT_20000188 != (code *)0x0) {\n    (*DAT_20000188)(DAT_200001ac);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003594": "execute_callback_if_not_null_08003594"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035bc": {
            "entrypoint": "0x080035bc",
            "current_name": "initialize_data_080035bc",
            "code": "\n\n\nvoid initializeData_080035bc(void)\n\n{\n  _DAT_40023808 = 0;\n  _DAT_40023804 = 0x24003010;\n  _DAT_40023800 = _DAT_40023800 & 0xfef2ffff | 1;\n  _DAT_4002380c = 0;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035bc": "initialize_data_080035bc"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fc": {
            "entrypoint": "0x080035fc",
            "current_name": "update_configuration_080035fc",
            "code": "\n\n\nvoid updateConfiguration_080035fc(int *configuration)\n\n{\n  if (*configuration == 0x40010000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffe;\n  }\n  if (*configuration == 0x40000000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffe;\n  }\n  if (*configuration == 0x40000400) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffd;\n  }\n  if (*configuration == 0x40000800) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffb;\n  }\n  if (*configuration == 0x40000c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffff7;\n  }\n  if (*configuration == 0x40001000) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffef;\n  }\n  if (*configuration == 0x40001400) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffdf;\n  }\n  if (*configuration == 0x40010400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffd;\n  }\n  if (*configuration == 0x40014000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffeffff;\n  }\n  if (*configuration == 0x40014400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffdffff;\n  }\n  if (*configuration == 0x40014800) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffbffff;\n  }\n  if (*configuration == 0x40001800) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffbf;\n  }\n  if (*configuration == 0x40001c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffff7f;\n  }\n  if (*configuration == 0x40002000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffeff;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fc": "update_configuration_080035fc",
                "param_1": "configuration"
            },
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003750": {
            "entrypoint": "0x08003750",
            "current_name": "subtract_four_08003750",
            "code": "\nint subtract_four_08003750(int input_value)\n\n{\n  return input_value + -4;\n}\n\n",
            "renaming": {
                "FUN_08003750": "subtract_four_08003750",
                "param_1": "input_value"
            },
            "calling": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003754": {
            "entrypoint": "0x08003754",
            "current_name": "execute_timer_function_08003754",
            "code": "\nvoid executeTimerFunction_08003754(int timerIndex)\n\n{\n  int timerObj;\n  \n  timerObj = getTimerObject();\n  if ((*(functionPointer **)(timerObj + 0x48) != (functionPointer *)0x0) && (*(char *)(timerIndex + 0x18) == '\\x01')) {\n    (**(functionPointer **)(timerObj + 0x48))(timerObj,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003754": "execute_timer_function_08003754",
                "param_1": "timerIndex",
                "iVar1": "timerObj",
                "get_timer_obj": "getTimerObject",
                "code": "functionPointer"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800376e": {
            "entrypoint": "0x0800376e",
            "current_name": "execute_timer_function_0800376e",
            "code": "\nvoid execute_timer_function_0800376e(void)\n\n{\n  int timerObject;\n  \n  timerObject = get_timer_object();\n  if (*(code **)(timerObject + 0x44) != (code *)0x0) {\n    (**(code **)(timerObject + 0x44))();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800376e": "execute_timer_function_0800376e",
                "iVar1": "timerObject",
                "get_timer_obj": "get_timer_object"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800377c": {
            "entrypoint": "0x0800377c",
            "current_name": "handle_timers_0800377c",
            "code": "\nvoid handleTimers_0800377c(void)\n\n{\n  if (DAT_200001b0 != 0) {\n    HAL_TIM_IRQHandler();\n  }\n  if (DAT_200001d4 != 0) {\n    HAL_TIM_IRQHandler();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800377c": "handle_timers_0800377c"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800387c": {
            "entrypoint": "0x0800387c",
            "current_name": "subtract_four_0800387c",
            "code": "\nint subtract_four_0800387c(int input_num)\n\n{\n  return input_num + -4;\n}\n\n",
            "renaming": {
                "FUN_0800387c": "subtract_four_0800387c",
                "param_1": "input_num"
            },
            "calling": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003880": {
            "entrypoint": "0x08003880",
            "current_name": "transmit_receive_data_08003880",
            "code": "\nvoid transmitReceiveData_08003880(int dataBuffer,int isReceiveMode,int length,undefined4 callbackFunction)\n\n{\n  int i2cObject;\n  \n  i2cObject = getI2CObject();\n  if (length == *(int *)(dataBuffer + 0xc)) {\n    if (isReceiveMode == 0) {\n      *(undefined *)(i2cObject + 0x88) = 0;\n      *(undefined *)(i2cObject + 0x5e) = 0;\n      if (*(code **)(i2cObject + 100) != (code *)0x0) {\n        (**(code **)(i2cObject + 100))();\n      }\n      transmitDataSeqIT(dataBuffer,i2cObject + 0x68,*(undefined *)(i2cObject + 0x88),8);\n      return;\n    }\n    *(undefined *)(i2cObject + 0x5e) = 1;\n    receiveDataSeqIT(dataBuffer,i2cObject + 0x68,0x20,8,callbackFunction);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003880": "transmit_receive_data_08003880",
                "param_1": "dataBuffer",
                "param_2": "isReceiveMode",
                "param_3": "length",
                "param_4": "callbackFunction",
                "iVar1": "i2cObject",
                "get_i2c_obj": "getI2CObject",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "transmitDataSeqIT",
                "HAL_I2C_Slave_Sequential_Receive_IT": "receiveDataSeqIT"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080038d0": {
            "entrypoint": "0x080038d0",
            "current_name": "enable_i2_c_listen_080038d0",
            "code": "\nvoid enableI2CListen_080038d0(undefined4 param)\n\n{\n  int i2cObj;\n  \n  i2cObj = getI2CObj();\n  if (((*(callback **)(i2cObj + 0x60) != (callback *)0x0) && (*(char *)(i2cObj + 0x5e) == '\\x01')) &&\n     (*(char *)(i2cObj + 0x2c) != ' ')) {\n    (**(callback **)(i2cObj + 0x60))(i2cObj + 0x68);\n  }\n  enableI2CListen_080038d0IT(param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080038d0": "enable_i2_c_listen_080038d0",
                "param_1": "param",
                "iVar1": "i2cObj",
                "get_i2c_obj": "getI2CObj",
                "code": "callback",
                "HAL_I2C_EnableListen_IT": "enableI2CListenIT"
            },
            "calling": [
                "I2C_ITError",
                "I2C_Slave_STOPF",
                "I2C_Slave_AF"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003900": {
            "entrypoint": "0x08003900",
            "current_name": "enable_listen_interrupt_08003900",
            "code": "\nvoid enableListenInterrupt_08003900(undefined4 i2cObject)\n\n{\n  int i2cObjAddr;\n  \n  i2cObjAddr = get_i2c_obj();\n  if (*(char *)(i2cObjAddr + 0x5f) == '\\0') {\n    HAL_I2C_EnableListen_IT(i2cObject);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003900": "enable_listen_interrupt_08003900",
                "param_1": "i2cObject",
                "iVar1": "i2cObjAddr"
            },
            "calling": [
                "I2C_ITError"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003978": {
            "entrypoint": "0x08003978",
            "current_name": "initialize_uart_peripheral_08003978",
            "code": "\n\n\nvoid initializeUartPeripheral_08003978(int *uartConfig)\n\n{\n  int peripheral1;\n  int peripheral2;\n  undefined4 gpioPortClock1;\n  uint pinFunction;\n  uint gpioPin1;\n  uint gpioAlternateFunction;\n  uint gpioPinMode;\n  undefined4 gpioPullUpDown;\n  uint gpioSpeed;\n  \n  if (uartConfig != (int *)0x0) {\n    peripheral1 = pinmap_peripheral((int)*(short *)(uartConfig + 0x16),&DAT_08005ca0);\n    peripheral2 = pinmap_peripheral((int)*(short *)((int)uartConfig + 0x5a),&DAT_08005c10);\n    if ((peripheral2 == 0) || (peripheral1 == 0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\",peripheral2);\n    }\n    else {\n      peripheral1 = pinmap_merge_peripheral(peripheral1);\n      *uartConfig = peripheral1;\n      if (peripheral1 == 0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (peripheral1 == 0x40011000) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffef;\n          _DAT_40023844 = _DAT_40023844 | 0x10;\n          *(undefined *)(uartConfig + 0x11) = 0;\n          *(undefined *)(uartConfig + 0x17) = 0x25;\n        }\n        else if (peripheral1 == 0x40004400) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffdffff;\n          _DAT_40023840 = _DAT_40023840 | 0x20000;\n          *(undefined *)(uartConfig + 0x11) = 1;\n          *(undefined *)(uartConfig + 0x17) = 0x26;\n        }\n        else if (peripheral1 == 0x40004800) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffbffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000;\n          *(undefined *)(uartConfig + 0x11) = 2;\n          *(undefined *)(uartConfig + 0x17) = 0x27;\n        }\n        else if (peripheral1 == 0x40004c00) {\n          _DAT_40023820 = _DAT_40023820 & 0xfff7ffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000;\n          *(undefined *)(uartConfig + 0x11) = 3;\n          *(undefined *)(uartConfig + 0x17) = 0x34;\n        }\n        else if (peripheral1 == 0x40005000) {\n          _DAT_40023820 = _DAT_40023820 & 0xffefffff;\n          _DAT_40023840 = _DAT_40023840 | 0x100000;\n          *(undefined *)(uartConfig + 0x11) = 4;\n          *(undefined *)(uartConfig + 0x17) = 0x35;\n        }\n        else if (peripheral1 == 0x40011400) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffdf;\n          _DAT_40023844 = _DAT_40023844 | 0x20;\n          *(undefined *)(uartConfig + 0x11) = 5;\n          *(undefined *)(uartConfig + 0x17) = 0x47;\n        }\n        else if (peripheral1 == 0x40007800) {\n          _DAT_40023820 = _DAT_40023820 & 0xbfffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000000;\n          *(undefined *)(uartConfig + 0x11) = 6;\n          *(undefined *)(uartConfig + 0x17) = 0x52;\n        }\n        else if (peripheral1 == 0x40007c00) {\n          _DAT_40023820 = _DAT_40023820 & 0x7fffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000000;\n          *(undefined *)(uartConfig + 0x11) = 7;\n          *(undefined *)(uartConfig + 0x17) = 0x53;\n        }\n        gpioPortClock1 = set_GPIO_Port_Clock((uint)((int)*(short *)((int)uartConfig + 0x5a) << 0x18) >> 0x1c);\n        pinFunction = pinmap_function((int)*(short *)((int)uartConfig + 0x5a),&DAT_08005c10);\n        gpioPin1 = 1 << (*(ushort *)((int)uartConfig + 0x5a) & 0xf) & 0xffff;\n        gpioAlternateFunction = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioPinMode = (pinFunction << 0x1a) >> 0x1e;\n        gpioSpeed = (pinFunction << 0x11) >> 0x19;\n        gpioPullUpDown = 3;\n        initializeGpio(gpioPortClock1,&gpioPin1);\n        gpioPortClock1 = set_GPIO_Port_Clock((uint)((int)*(short *)(uartConfig + 0x16) << 0x18) >> 0x1c);\n        pinFunction = pinmap_function((int)*(short *)(uartConfig + 0x16),&DAT_08005ca0);\n        gpioPin1 = 1 << (*(ushort *)(uartConfig + 0x16) & 0xf) & 0xffff;\n        gpioAlternateFunction = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioPinMode = (pinFunction << 0x1a) >> 0x1e;\n        initializeGpio(gpioPortClock1,&gpioPin1);\n        (&DAT_200002b4)[*(byte *)(uartConfig + 0x11)] = uartConfig + 1;\n        uartConfig[1] = *uartConfig;\n        uartConfig[2] = uartConfig[0x12];\n        uartConfig[3] = uartConfig[0x13];\n        uartConfig[4] = uartConfig[0x14];\n        uartConfig[5] = uartConfig[0x15];\n        uartConfig[6] = 0xc;\n        uartConfig[7] = 0;\n        uartConfig[8] = 0;\n        HAL_UART_Init(uartConfig + 1);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003978": "initialize_uart_peripheral_08003978",
                "param_1": "uartConfig",
                "iVar1": "peripheral1",
                "iVar2": "peripheral2",
                "uVar3": "gpioPortClock1",
                "uVar4": "pinFunction",
                "local_2c": "gpioPin1",
                "local_28": "gpioAlternateFunction",
                "local_24": "gpioPinMode",
                "local_20": "gpioPullUpDown",
                "local_1c": "gpioSpeed",
                "HAL_GPIO_Init": "initializeGpio"
            },
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_peripheral",
                "pinmap_function",
                "HAL_UART_Init",
                "HAL_GPIO_Init",
                "pinmap_merge_peripheral",
                "iprintf",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003cc8": {
            "entrypoint": "0x08003cc8",
            "current_name": "initialize_uart_08003cc8",
            "code": "\nvoid initializeUART_08003cc8(void)\n\n{\n  int result;\n  undefined4 peripheral;\n  \n  result = pinmap_peripheral(0x38,&DAT_08005ca0);\n  if (result != 0) {\n    peripheral = pinmap_peripheral(0x38,&DAT_08005ca0);\n    DAT_2000008a = pinmap_pin(peripheral,&DAT_08005c10);\n    DAT_20000088 = 0x38;\n    DAT_20000078 = 0x2580;\n    DAT_20000084 = 0;\n    DAT_2000007c = 0;\n    DAT_20000080 = 0;\n    initializeUART_08003cc8Peripheral(&DAT_20000030);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003cc8": "initialize_uart_08003cc8",
                "iVar1": "result",
                "uVar2": "peripheral",
                "uart_init": "initializeUARTPeripheral"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "pinmap_peripheral",
                "pinmap_pin",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d18": {
            "entrypoint": "0x08003d18",
            "current_name": "send_data_08003d18",
            "code": "\nuint sendData_08003d18(undefined4 data,uint size)\n\n{\n  int startTime;\n  int peripheral;\n  uint index;\n  \n  startTime = HAL_GetTick();\n  peripheral = pinmap_peripheral(0x38,&DAT_08005ca0);\n  if (peripheral == 0) {\n    return 0;\n  }\n  for (index = 0;\n      (index < 10 &&\n      (((&DAT_200002b4)[index] == 0 ||\n       (peripheral = pinmap_peripheral(0x38,&DAT_08005ca0), *(int *)(&DAT_200002b4)[index] != peripheral))));\n      index = index + 1 & 0xff) {\n  }\n  if (9 < index) {\n    if ((9 < DAT_20000074) && (uart_debug_init(), 9 < DAT_20000074)) {\n      return 0;\n    }\n    index = (uint)DAT_20000074;\n  }\n  do {\n    peripheral = HAL_UART_Transmit((&DAT_200002b4)[index],data,size & 0xffff,1000);\n    if (peripheral == 0) {\n      return size;\n    }\n    peripheral = HAL_GetTick();\n  } while ((uint)(peripheral - startTime) < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003d18": "send_data_08003d18",
                "param_1": "data",
                "param_2": "size",
                "iVar1": "startTime",
                "iVar2": "peripheral",
                "uVar3": "index"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "pinmap_peripheral",
                "HAL_GetTick",
                "HAL_UART_Transmit",
                "uart_debug_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003dd0": {
            "entrypoint": "0x08003dd0",
            "current_name": "check_uart_state_08003dd0",
            "code": "\nbool check_uart_state_08003dd0(int input_value)\n\n{\n  uint uart_state;\n  \n  uart_state = HAL_UART_GetState((&DAT_200002b4)[*(byte *)(input_value + 0x44)]);\n  return (uart_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_08003dd0": "check_uart_state_08003dd0",
                "param_1": "input_value",
                "uVar1": "uart_state"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003df4": {
            "entrypoint": "0x08003df4",
            "current_name": "is_uart_transmit_complete_08003df4",
            "code": "\nbool is_uart_transmit_complete_08003df4(int device_index)\n\n{\n  uint uart_state;\n  \n  uart_state = HAL_UART_GetState((&DAT_200002b4)[*(byte *)(device_index + 0x44)]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_08003df4": "is_uart_transmit_complete_08003df4",
                "param_1": "device_index",
                "uVar1": "uart_state"
            },
            "calling": [
                "FUN_080042e8"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e18": {
            "entrypoint": "0x08003e18",
            "current_name": "extract_serial_data_08003e18",
            "code": "\nundefined4 extract_serial_data_08003e18(int data_length,undefined *data_buffer,undefined4 param1,undefined4 param2)\n\n{\n  int is_rx_active;\n  \n  if (data_length == 0) {\n    return 0xffffffff;\n  }\n  is_rx_active = serial_rx_active();\n  if (is_rx_active == 0) {\n    *data_buffer = *(undefined *)(data_length + 0x45);\n    HAL_UART_Receive_IT((&DAT_200002b4)[*(byte *)(data_length + 0x44)],data_length + 0x45,1,&DAT_200002b4,\n                        param2);\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08003e18": "extract_serial_data_08003e18",
                "param_1": "data_length",
                "param_2": "data_buffer",
                "param_3": "param1",
                "param_4": "param2",
                "iVar1": "is_rx_active"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e54": {
            "entrypoint": "0x08003e54",
            "current_name": "initialize_serial_communication_08003e54",
            "code": "\nvoid initializeSerialCommunication_08003e54(int serialPort,undefined4 baudRate,undefined4 dataBits,undefined4 stopBits)\n\n{\n  int isRXActive;\n  uint serialIndex;\n  \n  if (serialPort != 0) {\n    isRXActive = serial_rx_active();\n    if (isRXActive == 0) {\n      serialIndex = (uint)*(byte *)(serialPort + 0x44);\n      *(undefined4 *)(&DAT_20000214 + serialIndex * 4) = baudRate;\n      *(int *)(&DAT_2000023c + serialIndex * 4) = serialPort;\n      HAL_NVIC_SetPriority((int)*(char *)(serialPort + 0x5c),0,1,serialIndex,stopBits);\n      HAL_NVIC_EnableIRQ((int)*(char *)(serialPort + 0x5c));\n      HAL_UART_Receive_IT((&DAT_200002b4)[*(byte *)(serialPort + 0x44)],serialPort + 0x45,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e54": "initialize_serial_communication_08003e54",
                "param_1": "serialPort",
                "param_2": "baudRate",
                "param_3": "dataBits",
                "param_4": "stopBits",
                "iVar1": "isRXActive",
                "uVar2": "serialIndex"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eac": {
            "entrypoint": "0x08003eac",
            "current_name": "initialize_peripheral_08003eac",
            "code": "\nvoid initializePeripheral_08003eac(int peripheralBaseAddress,undefined4 priorityLevel)\n\n{\n  byte interruptIndex;\n  \n  if (peripheralBaseAddress != 0) {\n    interruptIndex = *(byte *)(peripheralBaseAddress + 0x44);\n    *(undefined4 *)(&DAT_20000264 + (uint)interruptIndex * 4) = priorityLevel;\n    *(int *)(&DAT_2000028c + (uint)interruptIndex * 4) = peripheralBaseAddress;\n    setInterruptPriority((int)*(char *)(peripheralBaseAddress + 0x5c),0,2);\n    enableInterrupt((int)*(char *)(peripheralBaseAddress + 0x5c));\n    transmitData\n              ((&DAT_200002b4)[*(byte *)(peripheralBaseAddress + 0x44)],\n               *(int *)(peripheralBaseAddress + 0x68) + (uint)*(ushort *)(peripheralBaseAddress + 0x6e),1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003eac": "initialize_peripheral_08003eac",
                "param_1": "peripheralBaseAddress",
                "param_2": "priorityLevel",
                "bVar1": "interruptIndex",
                "HAL_NVIC_SetPriority": "setInterruptPriority",
                "HAL_NVIC_EnableIRQ": "enableInterrupt",
                "HAL_UART_Transmit_IT": "transmitData"
            },
            "calling": [
                "FUN_080042e8"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f00": {
            "entrypoint": "0x08003f00",
            "current_name": "find_index_08003f00",
            "code": "\nuint find_index_08003f00(int value)\n\n{\n  uint index;\n  \n  if (value == 0) {\n    index = 10;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (9 < index) {\n        return index;\n      }\n      if (value == (&DAT_200002b4)[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return index;\n}\n\n",
            "renaming": {
                "FUN_08003f00": "find_index_08003f00",
                "param_1": "value",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f24": {
            "entrypoint": "0x08003f24",
            "current_name": "execute_uart_command_08003f24",
            "code": "\nvoid execute_uart_command_08003f24(void)\n\n{\n  uint uartIndex;\n  \n  uartIndex = uart_index();\n  if (uartIndex < 10) {\n    (**(code **)(&DAT_20000214 + uartIndex * 4))(*(undefined4 *)(&DAT_2000023c + uartIndex * 4));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f24": "execute_uart_command_08003f24",
                "uVar1": "uartIndex"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f48": {
            "entrypoint": "0x08003f48",
            "current_name": "transmit_uart_data_08003f48",
            "code": "\nvoid transmitUartData_08003f48(void)\n\n{\n  uint uartIndex;\n  int returnValue;\n  int uartAddress;\n  \n  uartIndex = uart_index();\n  uartAddress = *(int *)(&DAT_2000028c + uartIndex * 4);\n  if ((uartIndex < 10) && (returnValue = (**(code **)(&DAT_20000264 + uartIndex * 4))(uartAddress), returnValue != -1)) {\n    HAL_UART_Transmit_IT\n              ((&DAT_200002b4)[*(byte *)(uartAddress + 0x44)],\n               *(int *)(uartAddress + 0x68) + (uint)*(ushort *)(uartAddress + 0x6e),1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f48": "transmit_uart_data_08003f48",
                "uVar1": "uartIndex",
                "iVar2": "returnValue",
                "iVar3": "uartAddress"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f94": {
            "entrypoint": "0x08003f94",
            "current_name": "FUNC_08003f94",
            "code": "\nvoid FUNC_08003f94(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f94": "FUNC_08003f94"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004094": {
            "entrypoint": "0x08004094",
            "current_name": "allocate_memory_08004094",
            "code": "\nundefined * allocateMemory_08004094(int size)\n\n{\n  undefined *allocatedMemory;\n  \n  if (DAT_200002dc == (undefined *)0x0) {\n    DAT_200002dc = &DAT_20000678;\n  }\n  allocatedMemory = DAT_200002dc;\n  if (DAT_200002dc + size <= stackBase) {\n    DAT_200002dc = DAT_200002dc + size;\n    return allocatedMemory;\n  }\n  DAT_20000674 = 0xc;\n  return (undefined *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004094": "allocate_memory_08004094",
                "param_1": "size",
                "puVar1": "allocatedMemory",
                "&stack0x00000000": "stackBase"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d0": {
            "entrypoint": "0x080040d0",
            "current_name": "get_error_code_080040d0",
            "code": "\nundefined4 get_error_code_080040d0(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080040d0": "get_error_code_080040d0"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d6": {
            "entrypoint": "0x080040d6",
            "current_name": "set_memory_value_080040d6",
            "code": "\nundefined4 setMemoryValue_080040d6(undefined4 value,int address)\n\n{\n  *(undefined4 *)(address + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040d6": "set_memory_value_080040d6",
                "param_1": "value",
                "param_2": "address"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e0": {
            "entrypoint": "0x080040e0",
            "current_name": "initialize_app_080040e0",
            "code": "\nundefined4 initializeApp_080040e0(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080040e0": "initialize_app_080040e0"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e4": {
            "entrypoint": "0x080040e4",
            "current_name": "initialize_program_080040e4",
            "code": "\nundefined4 initializeProgram_080040e4(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e4": "initialize_program_080040e4"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "initialize_application_080040e8",
            "code": "\nundefined4 initializeApplication_080040e8(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e8": "initialize_application_080040e8"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040ec": {
            "entrypoint": "0x080040ec",
            "current_name": "write_debug_message_080040ec",
            "code": "\nvoid write_debug_message_080040ec(undefined4 arg1,undefined4 arg2,undefined4 arg3,undefined4 arg4)\n\n{\n  uart_debug_write(arg2,arg3,arg3,arg4,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040ec": "write_debug_message_080040ec",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040f8": {
            "entrypoint": "0x080040f8",
            "current_name": "infinite_loop_080040f8",
            "code": "\nvoid infiniteLoop_080040f8(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080040f8": "infinite_loop_080040f8"
            },
            "calling": [
                "_exit",
                "abort"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040fc": {
            "entrypoint": "0x080040fc",
            "current_name": "initialize_data_080040fc",
            "code": "\nundefined4 initializeData_080040fc(void)\n\n{\n  DAT_20000674 = 0x16;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080040fc": "initialize_data_080040fc"
            },
            "calling": [
                "raise"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800410c": {
            "entrypoint": "0x0800410c",
            "current_name": "get_return_value_0800410c",
            "code": "\nint getReturnValue_0800410c(void)\n\n{\n  result 1;\n}\n\n",
            "renaming": {
                "FUN_0800410c": "get_return_value_0800410c",
                "undefined4": "int",
                "return": "result"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004110": {
            "entrypoint": "0x08004110",
            "current_name": "configure_pin_08004110",
            "code": "\nvoid configure_pin_08004110(uint pin_index,undefined4 pin_mode,undefined4 pin_attr,undefined *pin_config)\n\n{\n  int is_configured;\n  undefined *pin_data;\n  int pin_data_value;\n  \n  if (pin_index < 0x60) {\n    pin_data_value = (int)*(short *)(&DAT_08005d3c + pin_index * 2);\n    pin_data = &DAT_08005d3c;\n  }\n  else {\n    pin_data_value = -1;\n    pin_data = pin_config;\n  }\n  if (pin_data_value != -1) {\n    is_configured = is_pin_configured(pin_data_value,&DAT_200002e0,pin_attr,pin_data,pin_config);\n    if (is_configured != 0) {\n      is_configured = pin_in_pinmap(pin_data_value,&DAT_08005a18);\n      if (is_configured == 0) {\n        is_configured = pin_in_pinmap(pin_data_value,&DAT_08005a3c);\n        if (is_configured != 0) {\n          pwm_stop(pin_data_value);\n        }\n      }\n      else {\n        dac_stop(pin_data_value);\n      }\n      reset_pin_configured(pin_data_value,&DAT_200002e0);\n    }\n    switch(pin_mode) {\n    case 0:\n      digital_io_init(pin_data_value,0);\n      break;\n    case 1:\n      digital_io_init(pin_data_value,1,0);\n      break;\n    case 2:\n      digital_io_init(pin_data_value,0,1);\n      break;\n    case 3:\n      digital_io_init(pin_data_value,0,2);\n    }\n    set_pin_configured(pin_data_value,&DAT_2000030c);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004110": "configure_pin_08004110",
                "param_1": "pin_index",
                "param_2": "pin_mode",
                "param_3": "pin_attr",
                "param_4": "pin_config",
                "iVar1": "is_configured",
                "puVar2": "pin_data",
                "iVar3": "pin_data_value"
            },
            "calling": [
                "FUN_08000600"
            ],
            "called": [
                "dac_stop",
                "reset_pin_configured",
                "pwm_stop",
                "digital_io_init",
                "set_pin_configured",
                "is_pin_configured",
                "pin_in_pinmap"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041bc": {
            "entrypoint": "0x080041bc",
            "current_name": "configure_pin_080041bc",
            "code": "\nvoid configurePin_080041bc(uint pinIndex,undefined4 value,undefined4 config1,undefined *config2)\n\n{\n  int isConfigured;\n  undefined4 GPIO_Port;\n  undefined *pinData;\n  uint pinValue;\n  \n  if (pinIndex < 0x60) {\n    pinValue = (uint)*(short *)(&DAT_08005d3c + pinIndex * 2);\n    pinData = &DAT_08005d3c;\n  }\n  else {\n    pinValue = 0xffffffff;\n    pinData = config2;\n  }\n  if ((pinValue != 0xffffffff) &&\n     (isConfigured = is_pin_configured(pinValue,&DAT_2000030c,config1,pinData,config2), isConfigured != 0)) {\n    GPIO_Port = get_GPIO_Port((pinValue << 0x18) >> 0x1c);\n    digital_io_write(GPIO_Port,1 << (pinValue & 0xf) & 0xffff,value);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041bc": "configure_pin_080041bc",
                "param_1": "pinIndex",
                "param_2": "value",
                "param_3": "config1",
                "param_4": "config2",
                "uVar4": "pinValue",
                "puVar3": "pinData",
                "iVar1": "isConfigured",
                "uVar2": "GPIO_Port"
            },
            "calling": [
                "FUN_08000600",
                "getRxBuffer",
                "sendTxBuffer"
            ],
            "called": [
                "digital_io_write",
                "is_pin_configured",
                "get_GPIO_Port"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004204": {
            "entrypoint": "0x08004204",
            "current_name": "get_current_milliseconds_08004204",
            "code": "\nvoid get_current_milliseconds_08004204(void)\n\n{\n  current_milliseconds();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004204": "get_current_milliseconds_08004204",
                "GetCurrentMilli": "current_milliseconds"
            },
            "calling": [
                "poll",
                "sendTxBuffer"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004240": {
            "entrypoint": "0x08004240",
            "current_name": "calculate_offset_08004240",
            "code": "\nushort calculateOffset_08004240(int inputValue)\n\n{\n  return (*(short *)(inputValue + 0x138) + 0x40) - *(short *)(inputValue + 0x13a) & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_08004240": "calculate_offset_08004240",
                "param_1": "inputValue"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042ac": {
            "entrypoint": "0x080042ac",
            "current_name": "process_uart_input_080042ac",
            "code": "\nvoid process_uart_input_080042ac(int uart_handle)\n\n{\n  int input_status;\n  ushort new_position;\n  undefined input_value;\n  \n  input_status = uart_getc(uart_handle,&input_value);\n  if ((input_status == 0) &&\n     (new_position = *(short *)(uart_handle + 100) + 1U & 0x3f, new_position != *(ushort *)(uart_handle + 0x66))) {\n    *(undefined *)(*(int *)(uart_handle + 0x60) + (uint)*(ushort *)(uart_handle + 100)) = input_value;\n    *(ushort *)(uart_handle + 100) = new_position;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080042ac": "process_uart_input_080042ac",
                "param_1": "uart_handle",
                "iVar1": "input_status",
                "uVar2": "new_position",
                "local_9": "input_value"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042e8": {
            "entrypoint": "0x080042e8",
            "current_name": "set_flag_and_send_data_080042e8",
            "code": "\nundefined4 setFlagAndSendData_080042e8(int dataStruct,undefined data)\n\n{\n  byte counter;\n  byte modifiedCounter;\n  int txActive;\n  \n  *(undefined *)(dataStruct + 0x10) = 1;\n  txActive = *(ushort *)(dataStruct + 0x140) + 1;\n  counter = (byte)txActive;\n  modifiedCounter = counter & 0x7f;\n  if (txActive == 0) {\n    modifiedCounter = -(-counter & 0x7f);\n  }\n  do {\n  } while (*(ushort *)(dataStruct + 0x142) == (ushort)modifiedCounter);\n  *(undefined *)(*(int *)(dataStruct + 0x13c) + (uint)*(ushort *)(dataStruct + 0x140)) = data;\n  *(ushort *)(dataStruct + 0x140) = (ushort)modifiedCounter;\n  txActive = isTxActive(dataStruct + 0xd4);\n  if (txActive == 0) {\n    attachTxCallback(dataStruct + 0xd4,&LAB_0800420c_1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080042e8": "set_flag_and_send_data_080042e8",
                "param_1": "dataStruct",
                "param_2": "data",
                "bVar1": "counter",
                "bVar2": "modifiedCounter",
                "iVar3": "txActive",
                "serial_tx_active": "isTxActive",
                "uart_attach_tx_callback": "attachTxCallback"
            },
            "calling": [],
            "called": [
                "serial_tx_active",
                "uart_attach_tx_callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004338": {
            "entrypoint": "0x08004338",
            "current_name": "FUNC_08004338",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800433e) */\n/* WARNING: Removing unreachable block (ram,0x08004350) */\n/* WARNING: Removing unreachable block (ram,0x08004346) */\n/* WARNING: Removing unreachable block (ram,0x08004358) */\n\nvoid FUNC_08004338(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004338": "FUNC_08004338"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004364": {
            "entrypoint": "0x08004364",
            "current_name": "initialize_memory_08004364",
            "code": "\nvoid initializeMemory_08004364(int baseAddress)\n\n{\n  *(int *)(baseAddress + 0x134) = baseAddress + 0x11;\n  *(undefined2 *)(baseAddress + 0x138) = 0;\n  *(undefined2 *)(baseAddress + 0x13a) = 0;\n  *(int *)(baseAddress + 0x13c) = baseAddress + 0x51;\n  *(undefined2 *)(baseAddress + 0x140) = 0;\n  *(undefined2 *)(baseAddress + 0x142) = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004364": "initialize_memory_08004364",
                "param_1": "baseAddress"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004388": {
            "entrypoint": "0x08004388",
            "current_name": "configure_serial_08004388",
            "code": "\nvoid configureSerial_08004388(int serialPort,undefined4 baudRate,byte mode)\n\n{\n  uint status;\n  byte modeBits;\n  int configBits;\n  code *jumpTable;\n  \n  *(undefined4 *)(serialPort + 0x11c) = baudRate;\n  *(byte *)(serialPort + 0x144) = mode;\n  modeBits = mode & 7;\n  if (modeBits == 4) {\n    configBits = 7;\n  }\n  else if (modeBits == 6) {\n    configBits = 8;\n  }\n  else if (modeBits == 2) {\n    configBits = 6;\n  }\n  else {\n    configBits = 0;\n  }\n  if ((mode & 0x30) == 0x30) {\n    *(undefined4 *)(serialPort + 0x128) = 0x600;\n    configBits = configBits + 1;\n  }\n  else if ((mode & 0x20) == 0) {\n    *(undefined4 *)(serialPort + 0x128) = 0;\n  }\n  else {\n    *(undefined4 *)(serialPort + 0x128) = 0x400;\n    configBits = configBits + 1;\n  }\n  if ((mode & 8) == 0) {\n    *(undefined4 *)(serialPort + 0x124) = 0;\n  }\n  else {\n    *(undefined4 *)(serialPort + 0x124) = 0x2000;\n  }\n  if (configBits == 8) {\n    *(undefined4 *)(serialPort + 0x120) = 0;\n  }\n  else if (configBits == 9) {\n    *(undefined4 *)(serialPort + 0x120) = 0x1000;\n  }\n  else {\n    configBits = 0;\n  }\n  if (configBits != 0) {\n    uart_init(serialPort + 0xd4);\n    uart_attach_rx_callback(serialPort + 0xd4,0x80042ad);\n    return;\n  }\n  jumpTable = (code *)0x8004432;\n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\");\n  if (status < 0x60) {\n    uRam0000012e = *(undefined2 *)(&DAT_08005d3c + status * 2);\n  }\n  else {\n    uRam0000012e = 0xffff;\n  }\n                    /* WARNING: Could not recover jumptable at 0x08004452. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004388": "configure_serial_08004388",
                "param_1": "serialPort",
                "param_2": "baudRate",
                "param_3": "mode",
                "extraout_r1": "status",
                "bVar1": "modeBits",
                "iVar2": "configBits",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [
                "FUN_08000600"
            ],
            "called": [
                "uart_attach_rx_callback",
                "uart_init",
                "__assert_func"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004444": {
            "entrypoint": "0x08004444",
            "current_name": "update_param_value_08004444",
            "code": "\nvoid updateParamValue_08004444(int paramAddress,uint paramValue)\n\n{\n  undefined2 updatedValue;\n  code *jumpTableFunc;\n  \n  if (paramValue < 0x60) {\n    updatedValue = *(undefined2 *)(&DAT_08005d3c + paramValue * 2);\n  }\n  else {\n    updatedValue = 0xffff;\n  }\n  *(undefined2 *)(paramAddress + 0x12e) = updatedValue;\n                    /* WARNING: Could not recover jumptable at 0x08004452. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTableFunc)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004444": "update_param_value_08004444",
                "param_1": "paramAddress",
                "param_2": "paramValue",
                "uVar1": "updatedValue",
                "UNRECOVERED_JUMPTABLE": "jumpTableFunc"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004460": {
            "entrypoint": "0x08004460",
            "current_name": "update_parameter_value_08004460",
            "code": "\nvoid updateParameterValue_08004460(int baseAddress,uint offset)\n\n{\n  undefined2 value;\n  \n  if (offset < 0x60) {\n    value = *(undefined2 *)(&DAT_08005d3c + offset * 2);\n  }\n  else {\n    value = 0xffff;\n  }\n  *(undefined2 *)(baseAddress + 300) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004460": "update_parameter_value_08004460",
                "param_1": "baseAddress",
                "param_2": "offset",
                "uVar1": "value"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800447c": {
            "entrypoint": "0x0800447c",
            "current_name": "initialize_communication_0800447c",
            "code": "\nundefined4 *\ninitializeCommunication_0800447c(undefined4 *communicationData,undefined4 pinNumber,undefined4 parameter3,undefined4 parameter4)\n\n{\n  undefined2 pinValue;\n  \n  communicationData[1] = 0;\n  communicationData[2] = 1000;\n  *communicationData = &PTR_FUN_080042e8_1_08005ed4;\n  if (communicationData == &DAT_20000338) {\n    setRx(&DAT_20000338,0x4c,parameter3,&DAT_20000338,parameter4);\n    setTx(&DAT_20000338,0x4d);\n  }\n  else {\n    pinValue = pinmap_pin(pinNumber,&DAT_08005c10);\n    *(undefined2 *)((int)communicationData + 0x12e) = pinValue;\n    pinValue = pinmap_pin(pinNumber,&DAT_08005ca0);\n    *(undefined2 *)(communicationData + 0x4b) = pinValue;\n  }\n  init(communicationData);\n  return communicationData;\n}\n\n",
            "renaming": {
                "FUN_0800447c": "initialize_communication_0800447c",
                "param_1": "communicationData",
                "param_2": "pinNumber",
                "param_3": "parameter3",
                "param_4": "parameter4",
                "uVar1": "pinValue"
            },
            "calling": [
                "FUN_080044d8"
            ],
            "called": [
                "setRx",
                "init",
                "pinmap_pin",
                "setTx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044d8": {
            "entrypoint": "0x080044d8",
            "current_name": "initialize_serial_communication_080044d8",
            "code": "\nvoid initializeSerialCommunication_080044d8(int status,int value,undefined4 config,undefined4 extraParam)\n\n{\n  if (status != 1) {\n    return;\n  }\n  if (value == 0xffff) {\n    initializeHardwareSerial(&DAT_20000338,0x40004800,config,0xffff,extraParam);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044d8": "initialize_serial_communication_080044d8",
                "param_1": "status",
                "param_2": "value",
                "param_3": "config",
                "param_4": "extraParam",
                "HardwareSerial": "initializeHardwareSerial"
            },
            "calling": [],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004544": {
            "entrypoint": "0x08004544",
            "current_name": "initialize_data_08004544",
            "code": "\nvoid initializeData_08004544(undefined4 *dataPointer,undefined value1,undefined value2,undefined value3,\n                 undefined value4)\n\n{\n  *dataPointer = &DAT_08005f28;\n  *(undefined *)(dataPointer + 1) = value1;\n  *(undefined *)((int)dataPointer + 5) = value2;\n  *(undefined *)((int)dataPointer + 6) = value3;\n  *(undefined *)((int)dataPointer + 7) = value4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004544": "initialize_data_08004544",
                "param_1": "dataPointer",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3",
                "param_5": "value4"
            },
            "calling": [
                "FUN_08004560"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004560": {
            "entrypoint": "0x08004560",
            "current_name": "initialize_ip_address_08004560",
            "code": "\nvoid initializeIPAddress_08004560(int option,int value)\n\n{\n  if ((option == 1) && (value == 0xffff)) {\n    IPAddress(&DAT_20000480,0,0,0,0);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004560": "initialize_ip_address_08004560",
                "param_1": "option",
                "param_2": "value"
            },
            "calling": [],
            "called": [
                "IPAddress"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004640": {
            "entrypoint": "0x08004640",
            "current_name": "combine_bits_08004640",
            "code": "\nuint combineBits_08004640(int bit1,uint bit2)\n\n{\n  return bit2 | bit1 << 8;\n}\n\n",
            "renaming": {
                "FUN_08004640": "combine_bits_08004640",
                "param_1": "bit1",
                "param_2": "bit2"
            },
            "calling": [
                "process_FC3",
                "process_FC15",
                "validateRequest",
                "process_FC6",
                "process_FC5",
                "process_FC16",
                "process_FC1"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004646": {
            "entrypoint": "0x08004646",
            "current_name": "FUNC_08004646",
            "code": "\nvoid FUNC_08004646(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004646": "FUNC_08004646"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004648": {
            "entrypoint": "0x08004648",
            "current_name": "initialize_hardware_and_set_priority_08004648",
            "code": "\nvoid initialize_hardware_and_set_priority_08004648(void)\n\n{\n  set_priority_grouping(3);\n  initialize_hardware();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004648": "initialize_hardware_and_set_priority_08004648",
                "HAL_NVIC_SetPriorityGrouping": "set_priority_grouping",
                "initialize_hardware_08000d8e": "initialize_hardware"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "FUN_08000d8e",
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004658": {
            "entrypoint": "0x08004658",
            "current_name": "initialize_and_run_08004658",
            "code": "\nvoid initializeAndRun_08004658(void)\n\n{\n  initializeVariant();\n  setupEnvironment();\n  do {\n    executeLoop();\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004658": "initialize_and_run_08004658",
                "initVariant": "initializeVariant",
                "setup": "setupEnvironment",
                "loop": "executeLoop",
                "serialEventRun": "runSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "setup",
                "serialEventRun",
                "initVariant",
                "loop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004678": {
            "entrypoint": "0x08004678",
            "current_name": "count_set_bits_08004678",
            "code": "\nchar count_set_bits_08004678(uint input)\n\n{\n  char bit_count;\n  \n  bit_count = '\\0';\n  for (; input != 1; input = input >> 1) {\n    bit_count = bit_count + '\\x01';\n  }\n  return bit_count;\n}\n\n",
            "renaming": {
                "FUN_08004678": "count_set_bits_08004678",
                "param_1": "input",
                "cVar1": "bit_count"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046b4": {
            "entrypoint": "0x080046b4",
            "current_name": "initialize_data_080046b4",
            "code": "\nvoid initializeData_080046b4(int value,int flag,undefined4 unused1,undefined4 unused2)\n\n{\n  if (value != 1) {\n    return;\n  }\n  if (flag == 0xffff) {\n    DAT_20000488 = 6;\n    DAT_20000494 = 0;\n    DAT_2000049c = 7;\n    DAT_200004a8 = 0;\n    DAT_200004b0 = 8;\n    DAT_200004bc = 0;\n    DAT_200004c4 = 9;\n    DAT_200004d0 = 0;\n    DAT_200004d8 = 10;\n    DAT_200004e4 = 0;\n    DAT_200004ec = 0x17;\n    DAT_200004f8 = 0;\n    DAT_20000500 = 0x17;\n    DAT_2000050c = 0;\n    DAT_20000514 = 0x17;\n    DAT_20000520 = 0;\n    DAT_20000528 = 0x17;\n    DAT_20000534 = 0;\n    DAT_2000053c = 0x17;\n    DAT_20000548 = 0;\n    DAT_20000550 = 0x28;\n    DAT_2000055c = 0;\n    DAT_20000564 = 0x28;\n    DAT_20000570 = 0;\n    DAT_20000578 = 0x28;\n    DAT_20000584 = 0;\n    DAT_2000058c = 0x28;\n    DAT_20000598 = 0;\n    DAT_200005a0 = 0x28;\n    DAT_200005ac = 0;\n    DAT_200005b4 = 0x28;\n    DAT_200005c0 = 0;\n    __aeabi_atexit(0,&LAB_0800468c_1,&DAT_20000000,&DAT_20000488,unused2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046b4": "initialize_data_080046b4",
                "param_1": "value",
                "param_2": "flag",
                "param_3": "unused1",
                "param_4": "unused2"
            },
            "calling": [],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047c0": {
            "entrypoint": "0x080047c0",
            "current_name": "check_and_execute_function_080047c0",
            "code": "\nvoid checkAndExecuteFunction_080047c0(int data)\n\n{\n  int pinId;\n  \n  if (*(int *)(data + 8) != 0) {\n    (**(code **)(data + 0xc))();\n    return;\n  }\n  __throw_bad_function_call();\n  pinId = get_pin_id();\n  if ((&DAT_20000494)[pinId * 5] != 0) {\n    checkAndExecuteFunction_080047c0();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047c0": "check_and_execute_function_080047c0",
                "param_1": "data",
                "iVar1": "pinId"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047d0": {
            "entrypoint": "0x080047d0",
            "current_name": "check_and_execute_function_080047d0",
            "code": "\nvoid checkAndExecuteFunction_080047d0(void)\n\n{\n  int pinId;\n  \n  pinId = getPinId();\n  if ((&DAT_20000494)[pinId * 5] != 0) {\n    executeOperation();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047d0": "check_and_execute_function_080047d0",
                "iVar1": "pinId",
                "get_pin_id": "getPinId",
                "operator()": "executeOperation"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047fe": {
            "entrypoint": "0x080047fe",
            "current_name": "register_exit_handler_080047fe",
            "code": "\nvoid registerExitHandler_080047fe(undefined4 exitFunction,undefined4 cleanupFunction)\n\n{\n  __cxa_atexit(cleanupFunction,exitFunction);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047fe": "register_exit_handler_080047fe",
                "param_1": "exitFunction",
                "param_2": "cleanupFunction"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004808": {
            "entrypoint": "0x08004808",
            "current_name": "print_assertion_failure_08004808",
            "code": "\nvoid printAssertionFailure_08004808(undefined4 file,undefined4 lineNumber,char *functionName,undefined4 assertionCondition)\n\n{\n  undefined4 fileDescriptor;\n  char *additionalText;\n  undefined8 abortResult;\n  undefined4 assertionConditionCopy;\n  \n  fileDescriptor = *(undefined4 *)(DAT_200000a0 + 0xc);\n  assertionConditionCopy = assertionCondition;\n  if (functionName == (char *)0x0) goto LAB_0800482c;\n  additionalText = \", function: \";\n  do {\n    fiprintf(fileDescriptor,\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",assertionCondition,file,lineNumber,\n             additionalText,functionName,assertionConditionCopy);\n    abortResult = abort();\n    lineNumber = (undefined4)((ulonglong)abortResult >> 0x20);\n    fileDescriptor = (undefined4)abortResult;\nLAB_0800482c:\n    functionName = \"\";\n    additionalText = functionName;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004808": "print_assertion_failure_08004808",
                "param_1": "file",
                "param_2": "lineNumber",
                "param_3": "functionName",
                "param_4": "assertionCondition",
                "uVar1": "fileDescriptor",
                "pcVar2": "additionalText",
                "uVar3": "abortResult",
                "uVar4": "assertionConditionCopy"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "fiprintf",
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004844": {
            "entrypoint": "0x08004844",
            "current_name": "shift_left64_bits_08004844",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800484c) */\n\nlonglong shiftLeft64Bits_08004844(undefined4 value,uint numberOfBits)\n\n{\n  return (unsignedLongLong)numberOfBits << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08004844": "shift_left64_bits_08004844",
                "param_1": "value",
                "param_2": "numberOfBits",
                "ulonglong": "unsignedLongLong"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004860": {
            "entrypoint": "0x08004860",
            "current_name": "print_using_stack_08004860",
            "code": "\nvoid printUsingStack_08004860(undefined4 formatString,undefined4 value1,undefined4 value2,undefined4 value3)\n\n{\n  undefined4 value2Copy;\n  undefined4 value3Copy;\n  \n  value2Copy = value2;\n  value3Copy = value3;\n  _vfiprintf_r(DAT_200000a0,formatString,value1,&value2Copy,formatString,&value2Copy);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004860": "print_using_stack_08004860",
                "param_1": "formatString",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3",
                "uStack_8": "value2Copy",
                "uStack_4": "value3Copy"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004884": {
            "entrypoint": "0x08004884",
            "current_name": "execute_functions_08004884",
            "code": "\nvoid execute_functions_08004884(void)\n\n{\n  int counter;\n  \n  for (counter = 0; counter != 0; counter = counter + 1) {\n    (*(code *)(&DAT_08006008)[counter])();\n  }\n  _init();\n  for (counter = 0; counter != 10; counter = counter + 1) {\n    (*(code *)(&DAT_08006008)[counter])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004884": "execute_functions_08004884",
                "iVar1": "counter"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "premain",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048cc": {
            "entrypoint": "0x080048cc",
            "current_name": "fill_memory_with_080048cc",
            "code": "\nvoid fillMemoryWith_080048cc(undefined *memoryPointer,undefined value,int size)\n\n{\n  undefined *endPointer;\n  \n  endPointer = memoryPointer + size;\n  for (; memoryPointer != endPointer; memoryPointer = memoryPointer + 1) {\n    *memoryPointer = value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080048cc": "fill_memory_with_080048cc",
                "param_1": "memoryPointer",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "endPointer"
            },
            "calling": [
                "__sfp",
                "__sfmoreglue",
                "std.isra.0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048dc": {
            "entrypoint": "0x080048dc",
            "current_name": "rearrange_memory_blocks_080048dc",
            "code": "\nvoid rearrangeMemoryBlocks_080048dc(undefined4 *result,int size,undefined4 lock,undefined4 unlock)\n\n{\n  int *currentBlock;\n  int **tempBlockPtr;\n  int **previousBlockPtr;\n  int **currentBlockPtr;\n  int **nextBlockPtr;\n  int **newBlockPtr;\n  bool isSameBlockPtr;\n  \n  if (size == 0) {\n    return;\n  }\n  newBlockPtr = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    newBlockPtr = (int **)((int)newBlockPtr + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  currentBlockPtr = (int **)&DAT_200005c8;\n  if (DAT_200005c8 == (int **)0x0) {\n    newBlockPtr[1] = (int *)0x0;\n    previousBlockPtr = tempBlockPtr;\n    DAT_200005c8 = newBlockPtr;\n  }\n  else {\n    currentBlockPtr = DAT_200005c8;\n    if (newBlockPtr < DAT_200005c8) {\n      previousBlockPtr = (int **)*newBlockPtr;\n      currentBlockPtr = (int **)((int)newBlockPtr + (int)previousBlockPtr);\n      isSameBlockPtr = DAT_200005c8 == currentBlockPtr;\n      if (isSameBlockPtr) {\n        currentBlockPtr = (int **)*DAT_200005c8;\n        DAT_200005c8 = (int **)DAT_200005c8[1];\n      }\n      newBlockPtr[1] = (int *)DAT_200005c8;\n      DAT_200005c8 = newBlockPtr;\n      if (isSameBlockPtr) {\n        currentBlockPtr = (int **)((int)currentBlockPtr + (int)previousBlockPtr);\n        *newBlockPtr = (int *)currentBlockPtr;\n      }\n    }\n    else {\n      do {\n        nextBlockPtr = currentBlockPtr;\n        currentBlockPtr = (int **)nextBlockPtr[1];\n        if (currentBlockPtr == (int **)0x0) break;\n      } while (currentBlockPtr <= newBlockPtr);\n      previousBlockPtr = (int **)*nextBlockPtr;\n      if ((int **)((int)nextBlockPtr + (int)previousBlockPtr) == newBlockPtr) {\n        previousBlockPtr = (int **)((int)previousBlockPtr + (int)*newBlockPtr);\n        *nextBlockPtr = (int *)previousBlockPtr;\n        if (currentBlockPtr == (int **)((int)nextBlockPtr + (int)previousBlockPtr)) {\n          currentBlock = *currentBlockPtr;\n          currentBlockPtr = (int **)currentBlockPtr[1];\n          nextBlockPtr[1] = (int *)currentBlockPtr;\n          previousBlockPtr = (int **)((int)previousBlockPtr + (int)currentBlock);\n          *nextBlockPtr = (int *)previousBlockPtr;\n        }\n      }\n      else if (newBlockPtr < (int **)((int)nextBlockPtr + (int)previousBlockPtr)) {\n        *result = 0xc;\n      }\n      else {\n        previousBlockPtr = (int **)((int)newBlockPtr + (int)*newBlockPtr);\n        isSameBlockPtr = currentBlockPtr == previousBlockPtr;\n        if (isSameBlockPtr) {\n          previousBlockPtr = (int **)*currentBlockPtr;\n          currentBlockPtr = (int **)currentBlockPtr[1];\n        }\n        newBlockPtr[1] = (int *)currentBlockPtr;\n        if (isSameBlockPtr) {\n          previousBlockPtr = (int **)((int)previousBlockPtr + (int)*newBlockPtr);\n          *newBlockPtr = (int *)previousBlockPtr;\n        }\n        nextBlockPtr[1] = (int *)newBlockPtr;\n      }\n    }\n  }\n  __malloc_unlock(result,previousBlockPtr,currentBlockPtr,unlock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080048dc": "rearrange_memory_blocks_080048dc",
                "param_1": "result",
                "param_2": "size",
                "param_3": "lock",
                "param_4": "unlock",
                "piVar1": "currentBlock",
                "extraout_r1": "tempBlockPtr",
                "ppiVar2": "previousBlockPtr",
                "ppiVar3": "currentBlockPtr",
                "ppiVar4": "nextBlockPtr",
                "ppiVar5": "newBlockPtr",
                "bVar6": "isSameBlockPtr"
            },
            "calling": [
                "__swsetup_r",
                "abort"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004978": {
            "entrypoint": "0x08004978",
            "current_name": "allocate_memory_08004978",
            "code": "\nuint allocate_memory_08004978(undefined4 *size,uint alignment)\n\n{\n  uint *current_node;\n  int padding;\n  uint *next_node;\n  uint difference;\n  uint *previous_node;\n  uint allocated_size;\n  \n  allocated_size = (alignment + 3 & 0xfffffffc) + 8;\n  if (allocated_size < 0xc) {\n    allocated_size = 0xc;\n  }\n  if (((int)allocated_size < 0) || (allocated_size < alignment)) {\n    *size = 0xc;\n  }\n  else {\n    __malloc_lock();\n    current_node = DAT_200005c8;\n    previous_node = DAT_200005c8;\n    while (next_node = current_node, next_node != (uint *)0x0) {\n      difference = *next_node - allocated_size;\n      if (-1 < (int)difference) {\n        if (difference < 0xc) {\n          if (previous_node == next_node) {\n            current_node = (uint *)previous_node[1];\n          }\n          else {\n            current_node = (uint *)next_node[1];\n          }\n          if (previous_node != next_node) {\n            previous_node[1] = (uint)current_node;\n            previous_node = next_node;\n            current_node = DAT_200005c8;\n          }\n        }\n        else {\n          *next_node = difference;\n          *(uint *)((int)next_node + difference) = allocated_size;\n          previous_node = (uint *)((int)next_node + difference);\n          current_node = DAT_200005c8;\n        }\n        goto LAB_080049dc;\n      }\n      previous_node = next_node;\n      current_node = (uint *)next_node[1];\n    }\n    if (DAT_200005cc == 0) {\n      DAT_200005cc = _sbrk_r(size);\n    }\n    current_node = (uint *)_sbrk_r(size,allocated_size);\n    if ((current_node != (uint *)0xffffffff) &&\n       ((previous_node = (uint *)((int)current_node + 3U & 0xfffffffc), current_node == previous_node ||\n        (padding = _sbrk_r(size,(int)previous_node - (int)current_node), padding != -1)))) {\n      *previous_node = allocated_size;\n      current_node = DAT_200005c8;\nLAB_080049dc:\n      DAT_200005c8 = current_node;\n      __malloc_unlock(size);\n      allocated_size = (int)previous_node + 0xbU & 0xfffffff8;\n      padding = allocated_size - (int)(previous_node + 1);\n      if (padding != 0) {\n        *(int *)((int)previous_node + padding) = -padding;\n        return allocated_size;\n      }\n      return allocated_size;\n    }\n    *size = 0xc;\n    __malloc_unlock(size);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004978": "allocate_memory_08004978",
                "param_1": "size",
                "param_2": "alignment",
                "puVar1": "current_node",
                "iVar2": "padding",
                "puVar3": "next_node",
                "uVar4": "difference",
                "puVar5": "previous_node",
                "uVar6": "allocated_size"
            },
            "calling": [
                "__smakebuf_r",
                "__sfmoreglue"
            ],
            "called": [
                "__malloc_lock",
                "_sbrk_r",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a34": {
            "entrypoint": "0x08004a34",
            "current_name": "process_input_data_08004a34",
            "code": "\nuint process_input_data_08004a34(int input_data,byte byte_value,byte **input_buffer)\n\n{\n  int temp_var1;\n  byte *temp_var2;\n  byte *temp_var3;\n  uint result;\n  \n  temp_var2 = input_buffer[2] + -1;\n  input_buffer[2] = temp_var2;\n  if ((-1 < (int)temp_var2) ||\n     (((int)input_buffer[6] <= (int)temp_var2 && (temp_var2 = (byte *)(uint)byte_value, temp_var2 != (byte *)0xa))))\n  {\n    temp_var2 = *input_buffer;\n    *input_buffer = temp_var2 + 1;\n    *temp_var2 = byte_value;\n    return (uint)byte_value;\n  }\n  if ((input_data != 0) && (*(int *)(input_data + 0x18) == 0)) {\n    __sinit();\n  }\n  if (input_buffer == (byte **)&DAT_08005fc0) {\n    input_buffer = *(byte ***)(input_data + 4);\n  }\n  else if (input_buffer == (byte **)&DAT_08005fe0) {\n    input_buffer = *(byte ***)(input_data + 8);\n  }\n  else if (input_buffer == (byte **)&DAT_08005fa0) {\n    input_buffer = *(byte ***)(input_data + 0xc);\n  }\n  input_buffer[2] = input_buffer[6];\n  temp_var3 = (byte *)(uint)*(ushort *)(input_buffer + 3);\n  temp_var1 = (int)temp_var3 << 0x1c;\n  if (((temp_var1 < 0) && (temp_var3 = input_buffer[4], temp_var3 != (byte *)0x0)) ||\n     (temp_var1 = __swsetup_r(input_data,input_buffer,temp_var1,temp_var3,temp_var2), temp_var1 == 0)) {\n    temp_var1 = (int)*input_buffer - (int)input_buffer[4];\n    result = (uint)byte_value;\n    if ((temp_var1 < (int)input_buffer[5]) || (temp_var1 = _fflush_r(input_data,input_buffer), temp_var1 == 0)) {\n      input_buffer[2] = input_buffer[2] + -1;\n      temp_var2 = *input_buffer;\n      *input_buffer = temp_var2 + 1;\n      *temp_var2 = byte_value;\n      if ((byte *)(temp_var1 + 1) != input_buffer[5]) {\n        if (-1 < (int)((uint)*(ushort *)(input_buffer + 3) << 0x1f)) {\n          return result;\n        }\n        if (result != 10) {\n          return result;\n        }\n      }\n      temp_var1 = _fflush_r(input_data,input_buffer);\n      if (temp_var1 == 0) {\n        return result;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004a34": "process_input_data_08004a34",
                "param_1": "input_data",
                "param_2": "byte_value",
                "param_3": "input_buffer",
                "iVar1": "temp_var1",
                "pbVar2": "temp_var2",
                "pbVar3": "temp_var3",
                "uVar4": "result"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swsetup_r",
                "_fflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a60": {
            "entrypoint": "0x08004a60",
            "current_name": "write_to_stream_08004a60",
            "code": "\nint writeToStream_08004a60(undefined4 stream,undefined4 param,undefined *data,int length)\n\n{\n  int result;\n  undefined *endPtr;\n  int currentLength;\n  \n  endPtr = data + length;\n  currentLength = length;\n  do {\n    if (data == endPtr) {\n      return 0;\n    }\n    result = __sfputc_r(stream,*data,param,length,currentLength);\n    length = result + 1;\n    data = data + 1;\n  } while (length != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004a60": "write_to_stream_08004a60",
                "param_1": "stream",
                "param_2": "param",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "endPtr",
                "iVar3": "currentLength"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a84": {
            "entrypoint": "0x08004a84",
            "current_name": "print_formatted_text_08004a84",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08004c58) */\n\nint printFormattedText_08004a84(int stream,undefined4 *format,byte *argList,int *ptrArgList)\n\n{\n  int result;\n  int *ptrArgs;\n  bool isNumeric;\n  byte *currChar;\n  byte *nextChar;\n  int status;\n  int count;\n  int *ptrArgValues;\n  uint flags;\n  int precision;\n  undefined4 width;\n  int argIndex;\n  int totalCharsWritten;\n  byte conversionSpecifier;\n  undefined spaceFlag;\n  undefined zeroPadFlag;\n  undefined signFlag;\n  undefined4 prefixFlag;\n  \n  ptrArgValues = ptrArgList;\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (format == &DAT_08005fc0) {\n    format = *(undefined4 **)(stream + 4);\n  }\n  else if (format == (undefined4 *)&DAT_08005fe0) {\n    format = *(undefined4 **)(stream + 8);\n  }\n  else if (format == (undefined4 *)&DAT_08005fa0) {\n    format = *(undefined4 **)(stream + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(format + 3) << 0x1c)) || (format[4] == 0)) &&\n     (count = __swsetup_r(stream,format), count != 0)) {\n    return -1;\n  }\n  totalCharsWritten = 0;\n  spaceFlag = 0x20;\n  zeroPadFlag = 0x30;\n  currChar = argList;\nLAB_08004ac6:\n  nextChar = currChar;\n  if (*nextChar != 0) goto LAB_08004b7c;\n  goto LAB_08004ad0;\nLAB_08004b7c:\n  currChar = nextChar + 1;\n  if (*nextChar != 0x25) goto LAB_08004ac6;\nLAB_08004ad0:\n  count = (int)nextChar - (int)argList;\n  if (count != 0) {\n    result = __sfputs_r(stream,format,argList,count);\n    if (result == -1) {\nLAB_08004c70:\n      if ((int)((uint)*(ushort *)(format + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalCharsWritten;\n    }\n    totalCharsWritten = totalCharsWritten + count;\n  }\n  if (*nextChar == 0) goto LAB_08004c70;\n  flags = 0;\n  argIndex = 0;\n  precision = -1;\n  width = 0;\n  signFlag = 0;\n  prefixFlag = 0;\n  currChar = nextChar + 1;\n  while( true ) {\n    count = memchr(\"#-0+ \",*currChar);\n    argList = currChar + 1;\n    if (count == 0) break;\n    flags = 1 << (count + 0xf7ffa094U & 0xff) | flags;\n    currChar = argList;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    signFlag = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    signFlag = 0x2b;\n  }\n  if (*currChar == 0x2a) {\n    ptrArgs = ptrArgValues + 1;\n    count = *ptrArgValues;\n    ptrArgValues = ptrArgs;\n    if (count < 0) {\n      argIndex = -count;\n      flags = flags | 2;\n      goto LAB_08004bae;\n    }\n  }\n  else {\n    isNumeric = false;\n    count = argIndex;\n    argList = currChar;\n    while( true ) {\n      if (9 < *argList - 0x30) break;\n      count = count * 10 + (*argList - 0x30);\n      isNumeric = true;\n      argList = argList + 1;\n    }\n    if (!isNumeric) goto LAB_08004bae;\n  }\n  argIndex = count;\nLAB_08004bae:\n  if (*argList == 0x2e) {\n    if (argList[1] == 0x2a) {\n      precision = *ptrArgValues;\n      if (precision < 0) {\n        precision = -1;\n      }\n      argList = argList + 2;\n      ptrArgValues = ptrArgValues + 1;\n    }\n    else {\n      isNumeric = false;\n      precision = 0;\n      count = 0;\n      while( true ) {\n        argList = argList + 1;\n        if (9 < *argList - 0x30) break;\n        count = count * 10 + (*argList - 0x30);\n        isNumeric = true;\n      }\n      if (isNumeric) {\n        precision = count;\n      }\n    }\n  }\n  count = memchr(&DAT_08005f72,*argList,3);\n  if (count != 0) {\n    flags = flags | 0x40 << (count + 0xf7ffa08eU & 0xff);\n    argList = argList + 1;\n  }\n  conversionSpecifier = *argList;\n  argList = argList + 1;\n  count = memchr(\"efgEFG\",conversionSpecifier,6);\n  if (count == 0) {\n    status = _printf_i(stream,&flags,format,0x8004a61,&ptrArgValues);\n    if (status == -1) goto LAB_08004c70;\n  }\n  else {\n    ptrArgValues = (int *)(((int)ptrArgValues + 7U & 0xfffffff8) + 8);\n  }\n  totalCharsWritten = totalCharsWritten + status;\n  currChar = argList;\n  goto LAB_08004ac6;\n}\n\n",
            "renaming": {
                "FUN_08004a84": "print_formatted_text_08004a84",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "argList",
                "param_4": "ptrArgList",
                "iVar1": "result",
                "piVar2": "ptrArgs",
                "bVar3": "isNumeric",
                "pbVar4": "currChar",
                "pbVar5": "nextChar",
                "unaff_r9": "status",
                "iVar6": "count",
                "local_8c": "ptrArgValues",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "width",
                "local_7c": "argIndex",
                "local_74": "totalCharsWritten",
                "local_70": "conversionSpecifier",
                "local_6f": "spaceFlag",
                "local_6e": "zeroPadFlag",
                "local_45": "signFlag",
                "local_30": "prefixFlag"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "memchr",
                "__swsetup_r",
                "_printf_i",
                "__sinit",
                "__sfputs_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cb0": {
            "entrypoint": "0x08004cb0",
            "current_name": "update_parameters_08004cb0",
            "code": "\nundefined4\nupdateParameters_08004cb0(undefined4 inputValue,uint *parameterArray,uint *outputValue,undefined4 someValue,code *callbackFunction)\n\n{\n  int index1;\n  int index2;\n  uint maxValue;\n  uint count;\n  bool isConditionMet;\n  \n  maxValue = parameterArray[4];\n  if ((int)parameterArray[4] < (int)parameterArray[2]) {\n    maxValue = parameterArray[2];\n  }\n  *outputValue = maxValue;\n  if (*(char *)((int)parameterArray + 0x43) != '\\0') {\n    *outputValue = maxValue + 1;\n  }\n  if ((int)(*parameterArray << 0x1a) < 0) {\n    *outputValue = *outputValue + 2;\n  }\n  if ((*parameterArray & 6) == 0) {\n    for (index1 = 0; index1 < (int)(parameterArray[3] - *outputValue); index1 = index1 + 1) {\n      index2 = (*callbackFunction)(inputValue,someValue,(int)parameterArray + 0x19,1);\n      if (index2 == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  maxValue = (uint)*(byte *)((int)parameterArray + 0x43);\n  if (maxValue != 0) {\n    maxValue = 1;\n  }\n  if ((int)(*parameterArray << 0x1a) < 0) {\n    *(undefined *)((int)parameterArray + maxValue + 0x43) = 0x30;\n    *(undefined *)((int)parameterArray + maxValue + 0x44) = *(undefined *)((int)parameterArray + 0x45);\n    maxValue = maxValue + 2;\n  }\n  index1 = (*callbackFunction)(inputValue,someValue,(int)parameterArray + 0x43,maxValue);\n  if (index1 != -1) {\n    maxValue = parameterArray[3];\n    isConditionMet = (*parameterArray & 6) == 4;\n    if (isConditionMet) {\n      maxValue = maxValue - *outputValue;\n    }\n    if (isConditionMet) {\n      maxValue = maxValue & ~((int)maxValue >> 0x1f);\n    }\n    else {\n      maxValue = 0;\n    }\n    if ((int)parameterArray[4] < (int)parameterArray[2]) {\n      maxValue = maxValue + (parameterArray[2] - parameterArray[4]);\n    }\n    count = 0;\n    while( true ) {\n      if (maxValue == count) {\n        return 0;\n      }\n      index1 = (*callbackFunction)(inputValue,someValue,(int)parameterArray + 0x1a,1);\n      if (index1 == -1) break;\n      count = count + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004cb0": "update_parameters_08004cb0",
                "param_1": "inputValue",
                "param_2": "parameterArray",
                "param_3": "outputValue",
                "param_4": "someValue",
                "param_5": "callbackFunction",
                "iVar1": "index1",
                "iVar2": "index2",
                "uVar3": "maxValue",
                "uVar4": "count",
                "bVar5": "isConditionMet"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d9c": {
            "entrypoint": "0x08004d9c",
            "current_name": "print_formatted_text_08004d9c",
            "code": "\nuint print_formatted_text_08004d9c(undefined4 format_string,uint *arguments,undefined4 output_file_descriptor,code *formatter,uint **arg_pointer)\n\n{\n  byte byte_value;\n  int loop_variable;\n  uint *ptr;\n  int inner_loop_variable;\n  char *hex_string;\n  uint base;\n  uint **ppuVar7;\n  char **ppcVar8;\n  uint num_value;\n  uint copy_value;\n  char *output_string;\n  char *formatted_string;\n  uint output_sizes [2];\n  \n  byte_value = *(byte *)(arguments + 6);\n  formatted_string = (char *)((int)arguments + 0x43);\n  if (byte_value != 0x6e) {\n    if (byte_value < 0x6f) {\n      if (byte_value != 99) {\n        if (byte_value < 100) {\n          if (byte_value == 0) goto LAB_08004f56;\n          if (byte_value != 0x58) goto LAB_08004dcc;\n          *(undefined *)((int)arguments + 0x45) = 0x58;\n          hex_string = \"0123456789ABCDEF\";\nLAB_08004ee6:\n          base = *arguments;\n          ptr = *arg_pointer;\n          *arg_pointer = ptr + 1;\n          if (((base & 0x80) == 0) && ((int)(base << 0x19) < 0)) {\n            num_value = (uint)*(ushort *)ptr;\n          }\n          else {\n            num_value = *ptr;\n          }\n          if ((int)(base << 0x1f) < 0) {\n            *arguments = base | 0x20;\n          }\n          if (num_value == 0) {\n            *arguments = *arguments & 0xffffffdf;\n          }\n          base = 0x10;\nLAB_08004e7c:\n          *(undefined *)((int)arguments + 0x43) = 0;\n        }\n        else {\n          if ((byte_value != 100) && (byte_value != 0x69)) goto LAB_08004dcc;\n          num_value = *arguments;\n          ptr = *arg_pointer;\n          if ((num_value & 0x80) == 0) {\n            *arg_pointer = ptr + 1;\n            if ((num_value & 0x40) == 0) goto LAB_08004dec;\n            num_value = (uint)(short)*(ushort *)ptr;\n          }\n          else {\n            *arg_pointer = ptr + 1;\nLAB_08004dec:\n            num_value = *ptr;\n          }\n          if ((int)num_value < 0) {\n            num_value = -num_value;\n            *(undefined *)((int)arguments + 0x43) = 0x2d;\n          }\n          hex_string = \"0123456789ABCDEF\";\n          base = 10;\n        }\n        copy_value = arguments[1];\n        arguments[2] = copy_value;\n        output_string = formatted_string;\n        if ((int)copy_value < 0) {\n          if (num_value != 0) goto LAB_08004f1a;\nLAB_08004fc8:\n          *(char *)((int)arguments + 0x42) = *hex_string;\n          output_string = (char *)((int)arguments + 0x42);\n        }\n        else {\n          *arguments = *arguments & 0xfffffffb;\n          if (num_value == 0) {\n            if (copy_value != 0) goto LAB_08004fc8;\n          }\n          else {\nLAB_08004f1a:\n            do {\n              copy_value = num_value / base;\n              output_string = output_string + -1;\n              *output_string = hex_string[num_value - base * copy_value];\n              num_value = copy_value;\n            } while (copy_value != 0);\n          }\n        }\n        if (((base == 8) && ((int)(*arguments << 0x1f) < 0)) && ((int)arguments[1] <= (int)arguments[4]))\n        {\n          output_string[-1] = '0';\n          output_string = output_string + -1;\n        }\n        arguments[4] = (int)formatted_string - (int)output_string;\n        formatted_string = output_string;\n        goto LAB_08004ec2;\n      }\n      ptr = *arg_pointer;\n      *arg_pointer = ptr + 1;\n      *(char *)((int)arguments + 0x42) = (char)*ptr;\nLAB_08004e2c:\n      formatted_string = (char *)((int)arguments + 0x42);\n      num_value = 1;\n    }\n    else {\n      if (byte_value != 0x73) {\n        if (byte_value < 0x74) {\n          if (byte_value == 0x6f) {\nLAB_08004e52:\n            num_value = *arguments;\n            ptr = *arg_pointer;\n            if ((num_value & 0x80) == 0) {\n              *arg_pointer = ptr + 1;\n              if ((num_value & 0x40) == 0) goto LAB_08004e60;\n              num_value = (uint)*(ushort *)ptr;\n            }\n            else {\n              *arg_pointer = ptr + 1;\nLAB_08004e60:\n              num_value = *ptr;\n            }\n            hex_string = \"0123456789ABCDEF\";\n            if (byte_value == 0x6f) {\n              base = 8;\n            }\n            else {\n              base = 10;\n            }\n            goto LAB_08004e7c;\n          }\n          if (byte_value == 0x70) {\n            *arguments = *arguments | 0x20;\nLAB_08004e12:\n            *(undefined *)((int)arguments + 0x45) = 0x78;\n            hex_string = \"0123456789abcdef\";\n            goto LAB_08004ee6;\n          }\n        }\n        else {\n          if (byte_value == 0x75) goto LAB_08004e52;\n          if (byte_value == 0x78) goto LAB_08004e12;\n        }\nLAB_08004dcc:\n        *(byte *)((int)arguments + 0x42) = byte_value;\n        goto LAB_08004e2c;\n      }\n      ppcVar8 = (char **)*arg_pointer;\n      *arg_pointer = (uint *)(ppcVar8 + 1);\n      formatted_string = *ppcVar8;\n      loop_variable = memchr(formatted_string,0,arguments[1]);\n      if (loop_variable != 0) {\n        arguments[1] = loop_variable - (int)formatted_string;\n      }\n      num_value = arguments[1];\n    }\n    arguments[4] = num_value;\n    *(undefined *)((int)arguments + 0x43) = 0;\n    goto LAB_08004ec2;\n  }\n  num_value = *arguments;\n  ppuVar7 = (uint **)*arg_pointer;\n  base = arguments[5];\n  if ((num_value & 0x80) == 0) {\n    *arg_pointer = (uint *)(ppuVar7 + 1);\n    ptr = *ppuVar7;\n    if ((num_value & 0x40) == 0) goto LAB_08004f42;\n    *(short *)ptr = (short)base;\n  }\n  else {\n    *arg_pointer = (uint *)(ppuVar7 + 1);\n    ptr = *ppuVar7;\nLAB_08004f42:\n    *ptr = base;\n  }\nLAB_08004f56:\n  arguments[4] = 0;\nLAB_08004ec2:\n  loop_variable = _printf_common(format_string,arguments,output_sizes,output_file_descriptor,formatter);\n  if ((loop_variable == -1) || (loop_variable = (*formatter)(format_string,output_file_descriptor,formatted_string,arguments[4]), loop_variable == -1)) {\nLAB_08004ed6:\n    num_value = 0xffffffff;\n  }\n  else {\n    if ((int)(*arguments << 0x1e) < 0) {\n      for (loop_variable = 0; loop_variable < (int)(arguments[3] - output_sizes[0]); loop_variable = loop_variable + 1) {\n        inner_loop_variable = (*formatter)(format_string,output_file_descriptor,(int)arguments + 0x19,1);\n        if (inner_loop_variable == -1) goto LAB_08004ed6;\n      }\n    }\n    num_value = arguments[3];\n    if ((int)arguments[3] < (int)output_sizes[0]) {\n      num_value = output_sizes[0];\n    }\n  }\n  return num_value;\n}\n\n",
            "renaming": {
                "FUN_08004d9c": "print_formatted_text_08004d9c",
                "param_1": "format_string",
                "param_2": "arguments",
                "param_3": "output_file_descriptor",
                "param_4": "formatter",
                "param_5": "arg_pointer",
                "bVar1": "byte_value",
                "iVar2": "loop_variable",
                "puVar3": "ptr",
                "iVar4": "inner_loop_variable",
                "pcVar5": "hex_string",
                "uVar6": "base",
                "uVar9": "num_value",
                "uVar10": "copy_value",
                "pcVar11": "output_string",
                "pcVar12": "formatted_string",
                "local_24": "output_sizes"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "memchr",
                "_printf_common"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fdc": {
            "entrypoint": "0x08004fdc",
            "current_name": "print_formatted_string_08004fdc",
            "code": "\nvoid printFormattedString_08004fdc(undefined4 formatString,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  int dataAddress;\n  undefined4 formatStringPtr;\n  undefined4 arg1Ptr;\n  undefined4 arg2Ptr;\n  undefined4 arg3Ptr;\n  \n  dataAddress = DAT_200000a0;\n  formatStringPtr = formatString;\n  arg1Ptr = arg1;\n  arg2Ptr = arg2;\n  arg3Ptr = arg3;\n  if ((DAT_200000a0 != 0) && (*(int *)(DAT_200000a0 + 0x18) == 0)) {\n    __sinit(DAT_200000a0);\n  }\n  _vfiprintf_r(dataAddress,*(undefined4 *)(dataAddress + 8),formatString,&arg1Ptr,formatStringPtr,&arg1Ptr);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004fdc": "print_formatted_string_08004fdc",
                "param_1": "formatString",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "iVar1": "dataAddress",
                "uVar2": "formatStringPtr",
                "uStack_c": "arg1Ptr",
                "uStack_8": "arg2Ptr",
                "uStack_4": "arg3Ptr"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800500c": {
            "entrypoint": "0x0800500c",
            "current_name": "allocate_memory_0800500c",
            "code": "\nvoid allocateMemory_0800500c(int *result,undefined4 size)\n\n{\n  int allocationResult;\n  \n  DAT_20000674 = 0;\n  allocationResult = _sbrk(size);\n  if ((allocationResult == -1) && (DAT_20000674 != 0)) {\n    *result = DAT_20000674;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800500c": "allocate_memory_0800500c",
                "param_1": "result",
                "param_2": "size",
                "iVar1": "allocationResult"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080050d0": {
            "entrypoint": "0x080050d0",
            "current_name": "decode_and_update_080050d0",
            "code": "\nuint decode_and_update_080050d0(undefined4 *output_ptr,undefined4 *input_ptr)\n\n{\n  int iVar1;\n  uint decoded_value;\n  ushort input_value;\n  \n  iVar1 = DAT_200000a0;\n  if ((DAT_200000a0 != 0) && (*(int *)(DAT_200000a0 + 0x18) == 0)) {\n    __sinit(DAT_200000a0);\n  }\n  if (input_ptr == &DAT_08005fc0) {\n    input_ptr = *(undefined4 **)(iVar1 + 4);\n  }\n  else if (input_ptr == (undefined4 *)&DAT_08005fe0) {\n    input_ptr = *(undefined4 **)(iVar1 + 8);\n  }\n  else if (input_ptr == (undefined4 *)&DAT_08005fa0) {\n    input_ptr = *(undefined4 **)(iVar1 + 0xc);\n  }\n  input_value = *(ushort *)(input_ptr + 3);\n  decoded_value = (uint)input_value;\n  if (-1 < (int)(decoded_value << 0x1c)) {\n    if (-1 < (int)(decoded_value << 0x1b)) {\n      *output_ptr = 9;\n      goto LAB_08005100;\n    }\n    if ((int)(decoded_value << 0x1d) < 0) {\n      if ((undefined4 *)input_ptr[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)input_ptr[0xd] != input_ptr + 0x11) {\n          _free_r(output_ptr);\n        }\n        input_ptr[0xd] = 0;\n      }\n      *(ushort *)(input_ptr + 3) = *(ushort *)(input_ptr + 3) & 0xffdb;\n      input_ptr[1] = 0;\n      *input_ptr = input_ptr[4];\n    }\n    *(ushort *)(input_ptr + 3) = *(ushort *)(input_ptr + 3) | 8;\n  }\n  if ((input_ptr[4] == 0) && ((*(ushort *)(input_ptr + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(output_ptr,input_ptr);\n  }\n  input_value = *(ushort *)(input_ptr + 3);\n  decoded_value = input_value & 1;\n  if ((input_value & 1) == 0) {\n    if (-1 < (int)((uint)input_value << 0x1e)) {\n      decoded_value = input_ptr[5];\n    }\n    input_ptr[2] = decoded_value;\n  }\n  else {\n    input_ptr[2] = 0;\n    input_ptr[6] = -input_ptr[5];\n  }\n  if (input_ptr[4] == 0) {\n    input_value = *(ushort *)(input_ptr + 3);\n    decoded_value = (int)(short)input_value & 0x80;\n    if (decoded_value != 0) {\nLAB_08005100:\n      *(ushort *)(input_ptr + 3) = input_value | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    decoded_value = 0;\n  }\n  return decoded_value;\n}\n\n",
            "renaming": {
                "FUN_080050d0": "decode_and_update_080050d0",
                "param_1": "output_ptr",
                "param_2": "input_ptr",
                "uVar2": "decoded_value",
                "uVar3": "input_value"
            },
            "calling": [
                "__sfputc_r",
                "_vfiprintf_r"
            ],
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051ac": {
            "entrypoint": "0x080051ac",
            "current_name": "decompiled_function_080051ac",
            "code": "\nvoid decompiled_function_080051ac(void)\n\n{\n  uint *pointer_variable_2;\n  int integer_variable_1;\n  int *pointer_variable_1;\n  int *piVar4;\n  uint unsigned_variable_1;\n  ushort unsigned_variable_2;\n  int integer_variable_2;\n  code *pointer_to_code;\n  int integer_variable_3;\n  uint unsigned_variable_3;\n  code *recovery_jumptable;\n  bool boolean_variable;\n  undefined8 uVar12;\n  \n  raise(6);\n  recovery_jumptable = (code *)0x80051bb;\n  uVar12 = _exit(1);\n  pointer_variable_1 = (int *)((ulonglong)uVar12 >> 0x20);\n  pointer_variable_2 = (uint *)uVar12;\n  unsigned_variable_2 = *(ushort *)(pointer_variable_1 + 3);\n  unsigned_variable_1 = (uint)unsigned_variable_2;\n  if ((int)(unsigned_variable_1 << 0x1c) < 0) {\n    integer_variable_1 = pointer_variable_1[4];\n    if (integer_variable_1 != 0) {\n      integer_variable_2 = unsigned_variable_1 << 0x1e;\n      boolean_variable = integer_variable_2 == 0;\n      integer_variable_3 = *pointer_variable_1;\n      if (boolean_variable) {\n        integer_variable_2 = pointer_variable_1[5];\n      }\n      *pointer_variable_1 = integer_variable_1;\n      if (!boolean_variable) {\n        integer_variable_2 = 0;\n      }\n      pointer_variable_1[2] = integer_variable_2;\n      for (integer_variable_3 = integer_variable_3 - integer_variable_1; 0 < integer_variable_3; integer_variable_3 = integer_variable_3 - integer_variable_2) {\n        integer_variable_2 = (*(code *)pointer_variable_1[10])(pointer_variable_2,pointer_variable_1[8],integer_variable_1,integer_variable_3);\n        if (integer_variable_2 < 1) {\n          unsigned_variable_2 = *(ushort *)(pointer_variable_1 + 3);\n          goto LAB_080052b2;\n        }\n        integer_variable_1 = integer_variable_1 + integer_variable_2;\n      }\n    }\n  }\n  else if (((0 < pointer_variable_1[1]) || (0 < pointer_variable_1[0x10])) &&\n          (pointer_to_code = (code *)pointer_variable_1[0xb], pointer_to_code != (code *)0x0)) {\n    unsigned_variable_3 = *pointer_variable_2;\n    *pointer_variable_2 = 0;\n    if ((unsigned_variable_2 & 0x1000) == 0) {\n      integer_variable_1 = (*pointer_to_code)(pointer_variable_2,pointer_variable_1[8],unsigned_variable_1 & 0x1000,1);\n      if ((integer_variable_1 == -1) && (unsigned_variable_1 = *pointer_variable_2, unsigned_variable_1 != 0)) {\n        if ((unsigned_variable_1 != 0x1d) && (unsigned_variable_1 != 0x16)) {\n          *(ushort *)(pointer_variable_1 + 3) = *(ushort *)(pointer_variable_1 + 3) | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x0800527c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          (*recovery_jumptable)();\n          return;\n        }\n        *pointer_variable_2 = unsigned_variable_3;\n        goto LAB_080051d6;\n      }\n    }\n    else {\n      integer_variable_1 = pointer_variable_1[0x15];\n    }\n    if (((int)((uint)*(ushort *)(pointer_variable_1 + 3) << 0x1d) < 0) &&\n       (integer_variable_1 = integer_variable_1 - pointer_variable_1[1], pointer_variable_1[0xd] != 0)) {\n      integer_variable_1 = integer_variable_1 - pointer_variable_1[0x10];\n    }\n    integer_variable_1 = (*(code *)pointer_variable_1[0xb])(pointer_variable_2,pointer_variable_1[8],integer_variable_1,0);\n    unsigned_variable_2 = *(ushort *)(pointer_variable_1 + 3);\n    if ((integer_variable_1 == -1) &&\n       ((0x1d < *pointer_variable_2 || (-1 < (int)((0x20400001U >> (*pointer_variable_2 & 0xff)) << 0x1f))))) {\nLAB_080052b2:\n      *(ushort *)(pointer_variable_1 + 3) = unsigned_variable_2 | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x080052bc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*recovery_jumptable)(0xffffffff);\n      return;\n    }\n    pointer_variable_1[1] = 0;\n    *pointer_variable_1 = pointer_variable_1[4];\n    if (((int)((uint)unsigned_variable_2 << 0x13) < 0) && ((integer_variable_1 != -1 || (*pointer_variable_2 == 0)))) {\n      pointer_variable_1[0x15] = integer_variable_1;\n    }\n    piVar4 = (int *)pointer_variable_1[0xd];\n    *pointer_variable_2 = unsigned_variable_3;\n    if (piVar4 != (int *)0x0) {\n      if (piVar4 != pointer_variable_1 + 0x11) {\n        _free_r(pointer_variable_2);\n      }\n      pointer_variable_1[0xd] = 0;\n                    /* WARNING: Could not recover jumptable at 0x08005252. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*recovery_jumptable)();\n      return;\n    }\n  }\nLAB_080051d6:\n                    /* WARNING: Could not recover jumptable at 0x080051d8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*recovery_jumptable)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080051ac": "decompiled_function_080051ac",
                "piVar3": "pointer_variable_1",
                "puVar1": "pointer_variable_2",
                "uVar5": "unsigned_variable_1",
                "uVar6": "unsigned_variable_2",
                "iVar2": "integer_variable_1",
                "iVar7": "integer_variable_2",
                "iVar9": "integer_variable_3",
                "bVar11": "boolean_variable",
                "pcVar8": "pointer_to_code",
                "uVar10": "unsigned_variable_3",
                "UNRECOVERED_JUMPTABLE_00": "recovery_jumptable"
            },
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "called": [
                "_exit",
                "_free_r",
                "raise"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052cc": {
            "entrypoint": "0x080052cc",
            "current_name": "process_data_080052cc",
            "code": "\nundefined4 processData_080052cc(uint *dataList,int *configList)\n\n{\n  undefined4 result;\n  int configLength;\n  int *tempPtr;\n  uint ushortValue;\n  ushort tempValue;\n  int tempVar;\n  undefined4 param4;\n  undefined4 param5;\n  code *callback;\n  int tempVar2;\n  uint tempValue2;\n  code *unrecovered_jump_table;\n  bool condition;\n  \n  if (configList[4] != 0) {\n    if ((dataList != (uint *)0x0) && (dataList[6] == 0)) {\n      __sinit();\n    }\n    if (configList == &DAT_08005fc0) {\n      configList = (int *)dataList[1];\n    }\n    else if (configList == (int *)&DAT_08005fe0) {\n      configList = (int *)dataList[2];\n    }\n    else if (configList == (int *)&DAT_08005fa0) {\n      configList = (int *)dataList[3];\n    }\n    if (*(short *)(configList + 3) != 0) {\n      tempValue = *(ushort *)(configList + 3);\n      ushortValue = (uint)tempValue;\n      if ((int)(ushortValue << 0x1c) < 0) {\n        configLength = configList[4];\n        if (configLength != 0) {\n          tempVar = ushortValue << 0x1e;\n          condition = tempVar == 0;\n          tempVar2 = *configList;\n          if (condition) {\n            tempVar = configList[5];\n          }\n          *configList = configLength;\n          if (!condition) {\n            tempVar = 0;\n          }\n          configList[2] = tempVar;\n          for (tempVar2 = tempVar2 - configLength; 0 < tempVar2; tempVar2 = tempVar2 - tempVar) {\n            tempVar = (*(code *)configList[10])(dataList,configList[8],configLength,tempVar2,param4,param5);\n            if (tempVar < 1) {\n              tempValue = *(ushort *)(configList + 3);\n              goto LAB_080052b2;\n            }\n            configLength = configLength + tempVar;\n          }\n        }\n      }\n      else if (((0 < configList[1]) || (0 < configList[0x10])) &&\n              (callback = (code *)configList[0xb], callback != (code *)0x0)) {\n        tempValue2 = *dataList;\n        *dataList = 0;\n        if ((tempValue & 0x1000) == 0) {\n          configLength = (*callback)(dataList,configList[8],ushortValue & 0x1000,1);\n          if ((configLength == -1) && (ushortValue = *dataList, ushortValue != 0)) {\n            if ((ushortValue != 0x1d) && (ushortValue != 0x16)) {\n              *(ushort *)(configList + 3) = *(ushort *)(configList + 3) | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x0800527c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n              result = (*unrecovered_jump_table)();\n              return result;\n            }\n            *dataList = tempValue2;\n            goto LAB_080051d6;\n          }\n        }\n        else {\n          configLength = configList[0x15];\n        }\n        if (((int)((uint)*(ushort *)(configList + 3) << 0x1d) < 0) &&\n           (configLength = configLength - configList[1], configList[0xd] != 0)) {\n          configLength = configLength - configList[0x10];\n        }\n        configLength = (*(code *)configList[0xb])(dataList,configList[8],configLength,0);\n        tempValue = *(ushort *)(configList + 3);\n        if ((configLength == -1) &&\n           ((0x1d < *dataList || (-1 < (int)((0x20400001U >> (*dataList & 0xff)) << 0x1f))))) {\nLAB_080052b2:\n          *(ushort *)(configList + 3) = tempValue | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x080052bc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          result = (*unrecovered_jump_table)(0xffffffff);\n          return result;\n        }\n        configList[1] = 0;\n        *configList = configList[4];\n        if (((int)((uint)tempValue << 0x13) < 0) && ((configLength != -1 || (*dataList == 0)))) {\n          configList[0x15] = configLength;\n        }\n        tempPtr = (int *)configList[0xd];\n        *dataList = tempValue2;\n        if (tempPtr != (int *)0x0) {\n          if (tempPtr != configList + 0x11) {\n            _free_r(dataList);\n          }\n          configList[0xd] = 0;\n                    /* WARNING: Could not recover jumptable at 0x08005252. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          result = (*unrecovered_jump_table)();\n          return result;\n        }\n      }\nLAB_080051d6:\n                    /* WARNING: Could not recover jumptable at 0x080051d8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      result = (*unrecovered_jump_table)(0);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080052cc": "process_data_080052cc",
                "param_1": "dataList",
                "param_2": "configList",
                "uVar1": "result",
                "iVar2": "configLength",
                "piVar3": "tempPtr",
                "uVar4": "ushortValue",
                "uVar5": "tempValue",
                "iVar6": "tempVar",
                "unaff_r4": "param4",
                "unaff_r5": "param5",
                "pcVar7": "callback",
                "iVar8": "tempVar2",
                "uVar9": "tempValue2",
                "UNRECOVERED_JUMPTABLE_00": "unrecovered_jump_table",
                "bVar10": "condition"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800532c": {
            "entrypoint": "0x0800532c",
            "current_name": "initialize_data_structure_0800532c",
            "code": "\nvoid initializeDataStructure_0800532c(undefined4 *dataStructure,undefined2 value_1,undefined2 value_2)\n\n{\n  *dataStructure = 0;\n  dataStructure[1] = 0;\n  dataStructure[2] = 0;\n  *(undefined2 *)(dataStructure + 3) = value_1;\n  dataStructure[0x19] = 0;\n  *(undefined2 *)((int)dataStructure + 0xe) = value_2;\n  dataStructure[4] = 0;\n  dataStructure[5] = 0;\n  dataStructure[6] = 0;\n  memset(dataStructure + 0x17,0,8);\n  dataStructure[9] = 0x8005609;\n  dataStructure[10] = 0x800562b;\n  dataStructure[0xb] = 0x8005663;\n  dataStructure[8] = dataStructure;\n  dataStructure[0xc] = &label_1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800532c": "initialize_data_structure_0800532c",
                "param_1": "dataStructure",
                "param_2": "value_1",
                "param_3": "value_2",
                "LAB_08005686_1": "label_1"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005374": {
            "entrypoint": "0x08005374",
            "current_name": "allocate_memory_08005374",
            "code": "\nundefined4 * allocateMemory_08005374(undefined4 size,int num_elements)\n\n{\n  undefined4 *ptr;\n  int mem_size;\n  \n  mem_size = (num_elements + -1) * 0x68;\n  ptr = (undefined4 *)_malloc_r(size,mem_size + 0x74);\n  if (ptr != (undefined4 *)0x0) {\n    *ptr = 0;\n    ptr[1] = num_elements;\n    ptr[2] = ptr + 3;\n    memset(ptr + 3,0,mem_size + 0x68);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08005374": "allocate_memory_08005374",
                "param_1": "size",
                "param_2": "num_elements",
                "puVar1": "ptr",
                "iVar2": "mem_size"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "memset",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053a0": {
            "entrypoint": "0x080053a0",
            "current_name": "initialize_data_080053a0",
            "code": "\nvoid initializeData_080053a0(undefined4 *dataPointer)\n\n{\n  undefined4 returnValue;\n  undefined4 *fixedDataPointer;\n  \n  if (dataPointer[6] == 0) {\n    dataPointer[0x12] = 0;\n    dataPointer[0x13] = 0;\n    dataPointer[0x14] = 0;\n    fixedDataPointer = &DAT_200000a4;\n    dataPointer[10] = &LAB_08005320_1;\n    if (dataPointer == &DAT_200000a4) {\n      fixedDataPointer = (undefined4 *)0x1;\n    }\n    if (dataPointer == &DAT_200000a4) {\n      dataPointer[6] = fixedDataPointer;\n    }\n    returnValue = __sfp();\n    dataPointer[1] = returnValue;\n    returnValue = __sfp(dataPointer);\n    dataPointer[2] = returnValue;\n    returnValue = __sfp(dataPointer);\n    dataPointer[3] = returnValue;\n    std_isra_0(dataPointer[1],4,0);\n    std_isra_0(dataPointer[2],9,1);\n    std_isra_0(dataPointer[3],0x12,2);\n    dataPointer[6] = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053a0": "initialize_data_080053a0",
                "param_1": "dataPointer",
                "uVar1": "returnValue",
                "puVar2": "fixedDataPointer"
            },
            "calling": [
                "__swsetup_r",
                "__sfputc_r",
                "__sfp",
                "iprintf",
                "_fflush_r",
                "_vfiprintf_r"
            ],
            "called": [
                "__sfp",
                "std.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005400": {
            "entrypoint": "0x08005400",
            "current_name": "initialize_data_08005400",
            "code": "\nint * initializeData_08005400(undefined4 *outputPointer,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  int *currentNestedPointer;\n  int *nestedPointer;\n  int **dataPointerPtr;\n  \n  if (DAT_200000bc == 0) {\n    __sinit(&DAT_200000a4);\n  }\n  dataPointerPtr = (int **)&DAT_200000ec;\n  do {\n    nestedPointer = dataPointerPtr[2];\n    currentNestedPointer = dataPointerPtr[1];\n    while (currentNestedPointer = (int *)((int)currentNestedPointer + -1), -1 < (int)currentNestedPointer) {\n      if (*(short *)(nestedPointer + 3) == 0) {\n        *(undefined2 *)((int)nestedPointer + 0xe) = 0xffff;\n        *(undefined2 *)(nestedPointer + 3) = 1;\n        nestedPointer[0x19] = 0;\n        *nestedPointer = 0;\n        nestedPointer[2] = 0;\n        nestedPointer[1] = 0;\n        nestedPointer[4] = 0;\n        nestedPointer[5] = 0;\n        nestedPointer[6] = 0;\n        memset(nestedPointer + 0x17,0,8,1,param4);\n        nestedPointer[0xd] = 0;\n        nestedPointer[0xe] = 0;\n        nestedPointer[0x12] = 0;\n        nestedPointer[0x13] = 0;\n        return nestedPointer;\n      }\n      nestedPointer = nestedPointer + 0x1a;\n    }\n    if (*dataPointerPtr == (int *)0x0) {\n      currentNestedPointer = (int *)__sfmoreglue(outputPointer,4);\n      *dataPointerPtr = currentNestedPointer;\n      if (currentNestedPointer == (int *)0x0) {\n        *outputPointer = 0xc;\n        return (int *)0x0;\n      }\n    }\n    dataPointerPtr = (int **)*dataPointerPtr;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005400": "initialize_data_08005400",
                "param_1": "outputPointer",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "piVar1": "currentNestedPointer",
                "piVar2": "nestedPointer",
                "ppiVar3": "dataPointerPtr"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset",
                "__sfmoreglue",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054b4": {
            "entrypoint": "0x080054b4",
            "current_name": "check_file_permissions_080054b4",
            "code": "\nundefined4 checkFilePermissions_080054b4(undefined4 fileDescriptor,int fileInfo,undefined4 *permissionFlag,uint *isExecutable)\n\n{\n  int status;\n  undefined4 flag;\n  undefined statBuffer [4];\n  uint fileMode;\n  \n  if ((*(short *)(fileInfo + 0xe) < 0) ||\n     (status = _fstat_r(fileDescriptor,(int)*(short *)(fileInfo + 0xe),statBuffer), status < 0)) {\n    *isExecutable = 0;\n    if ((int)((uint)*(ushort *)(fileInfo + 0xc) << 0x18) < 0) {\n      flag = 0x40;\n      goto LAB_080054f4;\n    }\n  }\n  else {\n    *isExecutable = (uint)((fileMode & 0xf000) == 0x2000);\n  }\n  flag = 0x400;\nLAB_080054f4:\n  *permissionFlag = flag;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080054b4": "check_file_permissions_080054b4",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "param_3": "permissionFlag",
                "param_4": "isExecutable",
                "auStack_4c": "statBuffer",
                "local_48": "fileMode",
                "iVar1": "status",
                "uVar2": "flag"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054fc": {
            "entrypoint": "0x080054fc",
            "current_name": "process_data_080054fc",
            "code": "\nvoid processData_080054fc(int dataSize,int *data)\n\n{\n  ushort result;\n  int allocatedMemory;\n  int tempDataSize;\n  int *tempData;\n  \n  if (-1 < (int)((uint)*(ushort *)(data + 3) << 0x1e)) {\n    tempDataSize = dataSize;\n    tempData = data;\n    result = __swhatbuf_r(dataSize,data,&tempDataSize,&tempData);\n    allocatedMemory = _malloc_r(dataSize,tempDataSize);\n    if (allocatedMemory != 0) {\n      *(undefined **)(dataSize + 0x28) = &LAB_08005320_1;\n      *data = allocatedMemory;\n      *(ushort *)(data + 3) = *(ushort *)(data + 3) | 0x80;\n      data[5] = tempDataSize;\n      data[4] = allocatedMemory;\n      if ((tempData != (int *)0x0) &&\n         (allocatedMemory = _isatty_r(dataSize,(int)*(short *)((int)data + 0xe)), allocatedMemory != 0)) {\n        *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(data + 3) = result | *(ushort *)(data + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(data + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xfffc | 2;\n  }\n  *data = (int)data + 0x47;\n  data[4] = (int)data + 0x47;\n  data[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080054fc": "process_data_080054fc",
                "param_1": "dataSize",
                "param_2": "data",
                "uVar1": "result",
                "iVar2": "allocatedMemory",
                "local_18": "tempDataSize",
                "local_14": "tempData"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_isatty_r",
                "__swhatbuf_r",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800557c": {
            "entrypoint": "0x0800557c",
            "current_name": "FUNC_0800557c",
            "code": "\nvoid FUNC_0800557c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557c": "FUNC_0800557c"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800557e": {
            "entrypoint": "0x0800557e",
            "current_name": "FUNC_0800557e",
            "code": "\nvoid FUNC_0800557e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557e": "FUNC_0800557e"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080055d0": {
            "entrypoint": "0x080055d0",
            "current_name": "kill_process_080055d0",
            "code": "\nint killProcess_080055d0(uint processID)\n\n{\n  int *errorCode;\n  undefined4 pid;\n  int handler;\n  code *functionPtr;\n  undefined4 unaff_reg4;\n  undefined4 unaff_reg5;\n  undefined4 in_linkRegister;\n  undefined4 *dataPtr;\n  \n  errorCode = DAT_200000a0;\n  dataPtr = &DAT_200000a0;\n  if (0x1f < processID) {\n    *DAT_200000a0 = 0x16;\n    return -1;\n  }\n  handler = DAT_200000a0[0x11];\n  if ((handler != 0) && (functionPtr = *(code **)(handler + processID * 4), functionPtr != (code *)0x0)) {\n    if (functionPtr != (code *)0x1) {\n      if (functionPtr == (code *)0xffffffff) {\n        *DAT_200000a0 = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(handler + processID * 4) = 0;\n      (*functionPtr)(processID);\n    }\n    return 0;\n  }\n  pid = _getpid_r(DAT_200000a0);\n  DAT_20000674 = 0;\n  handler = _kill(pid,processID,processID,0,dataPtr,unaff_reg4,unaff_reg5,in_linkRegister);\n  if ((handler == -1) && (DAT_20000674 != 0)) {\n    *errorCode = DAT_20000674;\n  }\n  return handler;\n}\n\n",
            "renaming": {
                "FUN_080055d0": "kill_process_080055d0",
                "param_1": "processID",
                "piVar1": "errorCode",
                "uVar2": "pid",
                "iVar3": "handler",
                "pcVar4": "functionPtr",
                "unaff_r4": "unaff_reg4",
                "unaff_r5": "unaff_reg5",
                "in_lr": "in_linkRegister",
                "puVar5": "dataPtr"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_kill",
                "_getpid_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005604": {
            "entrypoint": "0x08005604",
            "current_name": "FUN_08005604",
            "code": "\nundefined4 _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "raise"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005608": {
            "entrypoint": "0x08005608",
            "current_name": "update_data_08005608",
            "code": "\nvoid updateData_08005608(undefined4 dataBuffer,int dataPointer)\n\n{\n  int readResult;\n  uint newValue;\n  bool isSuccessful;\n  \n  readResult = _read_r(dataBuffer,(int)*(short *)(dataPointer + 0xe));\n  isSuccessful = -1 < readResult;\n  if (isSuccessful) {\n    newValue = *(int *)(dataPointer + 0x54) + readResult;\n  }\n  else {\n    newValue = *(ushort *)(dataPointer + 0xc) & 0xffffefff;\n  }\n  if (isSuccessful) {\n    *(uint *)(dataPointer + 0x54) = newValue;\n  }\n  if (!isSuccessful) {\n    *(short *)(dataPointer + 0xc) = (short)newValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005608": "update_data_08005608",
                "param_1": "dataBuffer",
                "param_2": "dataPointer",
                "iVar1": "readResult",
                "uVar2": "newValue",
                "bVar3": "isSuccessful"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800562a": {
            "entrypoint": "0x0800562a",
            "current_name": "write_data_to_file_0800562a",
            "code": "\nvoid writeDataToFile_0800562a(int *fileDescriptor,int buffer,undefined4 data,undefined4 size)\n\n{\n  int writeResult;\n  undefined4 unused1;\n  undefined4 unused2;\n  undefined4 unused3;\n  \n  if ((int)((uint)*(ushort *)(buffer + 0xc) << 0x17) < 0) {\n    _lseek_r(fileDescriptor,(int)*(short *)(buffer + 0xe),0,2);\n  }\n  *(ushort *)(buffer + 0xc) = *(ushort *)(buffer + 0xc) & 0xefff;\n  DAT_20000674 = 0;\n  writeResult = _write((int)*(short *)(buffer + 0xe),data,size,size,size,unused1,unused2,\n                 unused3);\n  if ((writeResult == -1) && (DAT_20000674 != 0)) {\n    *fileDescriptor = DAT_20000674;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800562a": "write_data_to_file_0800562a",
                "param_1": "fileDescriptor",
                "param_2": "buffer",
                "param_3": "data",
                "param_4": "size",
                "iVar1": "writeResult",
                "unaff_r4": "unused1",
                "unaff_r5": "unused2",
                "in_lr": "unused3"
            },
            "calling": [],
            "called": [
                "_lseek_r",
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005662": {
            "entrypoint": "0x08005662",
            "current_name": "update_file_status_08005662",
            "code": "\nvoid updateFileStatus_08005662(undefined4 fileDescriptor,int structPointer)\n\n{\n  int seekResult;\n  ushort updatedFlags;\n  bool isSeekError;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(structPointer + 0xe));\n  isSeekError = seekResult == -1;\n  if (isSeekError) {\n    updatedFlags = *(ushort *)(structPointer + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(structPointer + 0x54) = seekResult;\n    updatedFlags = *(ushort *)(structPointer + 0xc) | 0x1000;\n  }\n  if (isSeekError) {\n    *(ushort *)(structPointer + 0xc) = updatedFlags;\n  }\n  if (!isSeekError) {\n    *(ushort *)(structPointer + 0xc) = updatedFlags;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005662": "update_file_status_08005662",
                "param_1": "fileDescriptor",
                "param_2": "structPointer",
                "iVar1": "seekResult",
                "uVar2": "updatedFlags",
                "bVar3": "isSeekError"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d4": {
            "entrypoint": "0x080056d4",
            "current_name": "get_file_size_080056d4",
            "code": "\nvoid getFileSize_080056d4(int *fileSize,undefined4 fileDescriptor,undefined4 statBuffer,undefined4 bufferSize)\n\n{\n  int status;\n  \n  DAT_20000674 = 0;\n  status = _fstat(fileDescriptor,statBuffer,statBuffer,0,bufferSize);\n  if ((status == -1) && (DAT_20000674 != 0)) {\n    *fileSize = DAT_20000674;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056d4": "get_file_size_080056d4",
                "param_1": "fileSize",
                "param_2": "fileDescriptor",
                "param_3": "statBuffer",
                "param_4": "bufferSize",
                "iVar1": "status"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056f8": {
            "entrypoint": "0x080056f8",
            "current_name": "check_and_assign_tty_value_080056f8",
            "code": "\nvoid checkAndAssignTTYValue_080056f8(int *result,undefined4 fileDescriptor)\n\n{\n  int isTTY;\n  \n  DAT_20000674 = 0;\n  isTTY = _isatty(fileDescriptor);\n  if ((isTTY == -1) && (DAT_20000674 != 0)) {\n    *result = DAT_20000674;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056f8": "check_and_assign_tty_value_080056f8",
                "param_1": "result",
                "param_2": "fileDescriptor",
                "iVar1": "isTTY"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005718": {
            "entrypoint": "0x08005718",
            "current_name": "update_file_pointer_08005718",
            "code": "\nvoid updateFilePointer_08005718(int *output,undefined4 fileDescriptor,undefined4 offset,undefined4 origin)\n\n{\n  int seekResult;\n  \n  DAT_20000674 = 0;\n  seekResult = _lseek(fileDescriptor,offset,origin,origin,origin);\n  if ((seekResult == -1) && (DAT_20000674 != 0)) {\n    *output = DAT_20000674;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005718": "update_file_pointer_08005718",
                "param_1": "output",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "origin",
                "iVar1": "seekResult"
            },
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800573c": {
            "entrypoint": "0x0800573c",
            "current_name": "read_and_assign_value_0800573c",
            "code": "\nvoid readAndAssignValue_0800573c(int *output,undefined4 fileDescriptor,undefined4 buffer,undefined4 size)\n\n{\n  int returnValue;\n  \n  DAT_20000674 = 0;\n  returnValue = _read(fileDescriptor,buffer,size,size,size);\n  if ((returnValue == -1) && (DAT_20000674 != 0)) {\n    *output = DAT_20000674;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800573c": "read_and_assign_value_0800573c",
                "param_1": "output",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "size",
                "iVar1": "returnValue"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005760": {
            "entrypoint": "0x08005760",
            "current_name": "initialize_data_08005760",
            "code": "\nvoid initializeData_08005760(void)\n\n{\n  code *jumpTable;\n  \n  jumpTable = initializeData_08005760;\n  abort();\n  if (-1 < DAT_200005fc << 0x1f) {\n    DAT_200005fc = 1;\n  }\n  if (-1 < DAT_200005f8 << 0x1f) {\n    DAT_200005f8 = 1;\n  }\n  if (-1 < DAT_200005f4 << 0x1f) {\n    DAT_200005f4 = 1;\n  }\n  if (-1 < DAT_200005f0 << 0x1f) {\n    DAT_200005f0 = 1;\n  }\n  if (-1 < DAT_200005ec << 0x1f) {\n    DAT_200005ec = 1;\n  }\n  if (-1 < DAT_200005e8 << 0x1f) {\n    DAT_200005e8 = 1;\n  }\n  if (-1 < DAT_200005e4 << 0x1f) {\n    DAT_200005e4 = 1;\n  }\n  if (-1 < DAT_200005e0 << 0x1f) {\n    DAT_200005e0 = 1;\n  }\n  if (-1 < DAT_200005dc << 0x1f) {\n    DAT_200005dc = 1;\n  }\n  if (-1 < DAT_200005d8 << 0x1f) {\n    DAT_200005d8 = 1;\n  }\n  if (-1 < DAT_200005d4 << 0x1f) {\n    DAT_200005d4 = 1;\n  }\n  if (-1 < DAT_200005d0 << 0x1f) {\n    DAT_200005d0 = 1;\n  }\n                    /* WARNING: Could not recover jumptable at 0x080057f8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005760": "initialize_data_08005760",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f8": {
            "entrypoint": "0x080059f8",
            "current_name": "FUNC_080059f8",
            "code": "\nvoid FUNC_080059f8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080059f8": "FUNC_080059f8"
            },
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a04": {
            "entrypoint": "0x08005a04",
            "current_name": "FUNC_08005a04",
            "code": "\nvoid FUNC_08005a04(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a04": "FUNC_08005a04"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 118942,
    "layers": [
        [
            "FUN_080001ac",
            "FUN_08000230",
            "FUN_080002d0",
            "FUN_08000300",
            "FUN_080005e0",
            "FUN_080005e4",
            "FUN_08000600",
            "FUN_0800066c",
            "FUN_08000690",
            "FUN_080006b4",
            "FUN_08000728",
            "FUN_0800076c",
            "FUN_080007f0",
            "FUN_080008cc",
            "FUN_080008e2",
            "FUN_08000998",
            "FUN_08000a00",
            "FUN_08000a4e",
            "FUN_08000a7a",
            "FUN_08000b04",
            "FUN_08000b54",
            "FUN_08000c64",
            "FUN_08000c8c",
            "FUN_08000d3c",
            "FUN_08000d8e",
            "FUN_08000d98",
            "FUN_08000de4",
            "FUN_08000e18",
            "FUN_08000e30",
            "FUN_08000e3c",
            "FUN_08000e60",
            "FUN_08000ec4",
            "FUN_08000ee0",
            "FUN_08000f0c",
            "FUN_08000f2c",
            "FUN_08000f4e",
            "FUN_08000f56",
            "FUN_08000f72",
            "FUN_08000f8c",
            "FUN_08000fb4",
            "FUN_08001198",
            "FUN_080011a4",
            "FUN_080011c0",
            "FUN_0800124a",
            "FUN_08001256",
            "FUN_08001420",
            "FUN_08001440",
            "FUN_08001460",
            "FUN_080014ec",
            "FUN_08001578",
            "FUN_080015bc",
            "FUN_0800160e",
            "FUN_0800165a",
            "FUN_08001684",
            "FUN_0800171a",
            "FUN_08001864",
            "FUN_08001904",
            "FUN_080019a0",
            "FUN_08001ab0",
            "FUN_08001bfc",
            "FUN_08001d00",
            "FUN_08001e68",
            "FUN_08001f9c",
            "FUN_0800201c",
            "FUN_080023b4",
            "FUN_08002488",
            "FUN_080025e0",
            "FUN_080025ec",
            "FUN_0800260c",
            "FUN_0800262c",
            "FUN_0800268e",
            "FUN_080026ce",
            "FUN_08002848",
            "FUN_08002864",
            "FUN_080028d4",
            "FUN_080028f0",
            "FUN_08002940",
            "FUN_0800295c",
            "FUN_080029c8",
            "FUN_08002d0c",
            "FUN_08002d72",
            "FUN_08002dd0",
            "FUN_08002eb2",
            "FUN_08002efa",
            "FUN_08002f4c",
            "FUN_08002f66",
            "FUN_08002ffc",
            "FUN_0800312c",
            "FUN_08003138",
            "FUN_0800314e",
            "FUN_0800316c",
            "FUN_0800318c",
            "FUN_080031fc",
            "FUN_08003380",
            "FUN_0800339c",
            "FUN_080033c8",
            "FUN_080033d8",
            "FUN_0800340c",
            "FUN_08003414",
            "FUN_0800346c",
            "FUN_08003476",
            "FUN_08003486",
            "FUN_080034b6",
            "FUN_080034ce",
            "FUN_080034da",
            "FUN_080034f4",
            "FUN_08003506",
            "FUN_0800351e",
            "FUN_0800352e",
            "FUN_0800354a",
            "FUN_0800355e",
            "FUN_08003582",
            "FUN_08003594",
            "FUN_080035bc",
            "FUN_080035fc",
            "FUN_08003750",
            "FUN_08003754",
            "FUN_0800376e",
            "FUN_0800377c",
            "FUN_0800387c",
            "FUN_08003880",
            "FUN_080038d0",
            "FUN_08003900",
            "FUN_08003978",
            "FUN_08003cc8",
            "FUN_08003d18",
            "FUN_08003dd0",
            "FUN_08003df4",
            "FUN_08003e18",
            "FUN_08003e54",
            "FUN_08003eac",
            "FUN_08003f00",
            "FUN_08003f24",
            "FUN_08003f48",
            "FUN_08004094",
            "FUN_080040d0",
            "FUN_080040d6",
            "FUN_080040e0",
            "FUN_080040e4",
            "FUN_080040e8",
            "FUN_080040ec",
            "FUN_080040f8",
            "FUN_080040fc",
            "FUN_0800410c",
            "FUN_08004110",
            "FUN_080041bc",
            "FUN_08004204",
            "FUN_08004240",
            "FUN_080042ac",
            "FUN_080042e8",
            "FUN_08004364",
            "FUN_08004388",
            "FUN_08004444",
            "FUN_08004460",
            "FUN_0800447c",
            "FUN_080044d8",
            "FUN_08004544",
            "FUN_08004560",
            "FUN_08004640",
            "FUN_08004658",
            "FUN_08004678",
            "FUN_080046b4",
            "FUN_080047d0",
            "FUN_080047fe",
            "FUN_08004808",
            "FUN_08004844",
            "FUN_08004860",
            "FUN_08004884",
            "FUN_080048cc",
            "FUN_080048dc",
            "FUN_08004978",
            "FUN_08004a34",
            "FUN_08004a60",
            "FUN_08004a84",
            "FUN_08004cb0",
            "FUN_08004d9c",
            "FUN_08004fdc",
            "FUN_0800500c",
            "FUN_080050d0",
            "FUN_080051ac",
            "FUN_080052cc",
            "FUN_0800532c",
            "FUN_08005374",
            "FUN_080053a0",
            "FUN_08005400",
            "FUN_080054b4",
            "FUN_080054fc",
            "FUN_080055d0",
            "FUN_08005608",
            "FUN_0800562a",
            "FUN_08005662",
            "FUN_080056d4",
            "FUN_080056f8",
            "FUN_08005718",
            "FUN_0800573c"
        ],
        [
            "FUN_08000682",
            "FUN_08000c4c",
            "FUN_08004648"
        ],
        [
            "FUN_080047c0",
            "FUN_08005760"
        ]
    ],
    "locked_functions": []
}