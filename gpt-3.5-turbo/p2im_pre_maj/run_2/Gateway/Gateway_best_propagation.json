{
    "functions": {
        "FUN_0800010c": {
            "entrypoint": "0x0800010c",
            "current_name": "initialize_flag_0800010c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000118) */\n\nundefined4 initializeFlag_0800010c(undefined4 inputValue)\n\n{\n  if ((char)DAT_200000f4 == '\\0') {\n    DAT_200000f4._0_1_ = '\\x01';\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_0800010c": "initialize_flag_0800010c",
                "param_1": "inputValue"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000178": {
            "entrypoint": "0x08000178",
            "current_name": "calculate_string_length_08000178",
            "code": "\nchar * calculateStringLength_08000178(char *str)\n\n{\n  char currentChar;\n  char *nextCharPtr;\n  char *currentCharPtr;\n  \n  currentCharPtr = str;\n  do {\n    nextCharPtr = currentCharPtr + 1;\n    currentChar = *currentCharPtr;\n    currentCharPtr = nextCharPtr;\n  } while (currentChar != '\\0');\n  return nextCharPtr + (-1 - (int)str);\n}\n\n",
            "renaming": {
                "FUN_08000178": "calculate_string_length_08000178",
                "param_1": "str",
                "cVar1": "currentChar",
                "pcVar2": "nextCharPtr",
                "pcVar3": "currentCharPtr"
            },
            "calling": [
                "sendString",
                "setFirmwareNameAndVersion"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000188": {
            "entrypoint": "0x08000188",
            "current_name": "invoke_system_interrupt_08000188",
            "code": "\nvoid invokeSystemInterrupt_08000188(void)\n\n{\n  software_interrupt(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000188": "invoke_system_interrupt_08000188"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800018c": {
            "entrypoint": "0x0800018c",
            "current_name": "execute_afl_call_0800018c",
            "code": "\nundefined4 executeAflCall_0800018c(undefined4 inputParam,undefined4 unusedParam1,undefined4 unusedParam2,undefined4 inputFlag)\n\n{\n  undefined4 result;\n  \n  if (DAT_20000110 != 0) {\n    return 0;\n  }\n  result = aflCall(1,inputParam,0,0,inputFlag);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800018c": "execute_afl_call_0800018c",
                "param_1": "inputParam",
                "param_2": "unusedParam1",
                "param_3": "unusedParam2",
                "param_4": "inputFlag",
                "uVar1": "result"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000214": {
            "entrypoint": "0x08000214",
            "current_name": "process_pin_function_08000214",
            "code": "\nvoid processPinFunction_08000214(uint pinNumber,undefined4 outputValue,undefined4 param3,undefined4 param4)\n\n{\n  bool isServo;\n  int pinMode;\n  \n  if (0x3b < (int)pinNumber) {\n    return;\n  }\n  pinMode = getPinMode(&DAT_200003d4,pinNumber,param3,param4,param4);\n  if (pinMode == 3) {\n    if (pinNumber < 0x3c) {\n      if ((&DAT_0800a908)[pinNumber] == -1) {\n        pinMode = 0;\n      }\n      else {\n        pinMode = pinNametoDigitalPin();\n        if (pinMode == 0) {\n          pinMode = 0;\n        }\n        else {\n          pinMode = pinNametoDigitalPin((int)(character)(&DAT_0800a908)[pinNumber]);\n          if (pinMode == 1) {\n            pinMode = 0;\n          }\n          else {\n            pinMode = pin_in_pinmap((int)(character)(&DAT_0800a908)[pinNumber],&DAT_0800a6cc);\n          }\n        }\n      }\n    }\n    else {\n      pinMode = 0;\n    }\n    if (pinMode != 0) {\n      writeAnalogValue(pinNumber,outputValue);\n    }\n    updatePinState(&DAT_200003d4,pinNumber,outputValue);\n  }\n  else if (pinMode == 4) {\n    if (pinNumber < 0x3c) {\n      if ((&DAT_0800a908)[pinNumber] == -1) {\n        isServo = false;\n      }\n      else {\n        pinMode = pinNametoDigitalPin();\n        if (pinMode == 0) {\n          isServo = false;\n        }\n        else {\n          pinMode = pinNametoDigitalPin((int)(character)(&DAT_0800a908)[pinNumber]);\n          if (pinMode == 1) {\n            isServo = false;\n          }\n          else {\n            isServo = true;\n          }\n        }\n      }\n    }\n    else {\n      isServo = false;\n    }\n    if (isServo) {\n      setServoPosition(&DAT_2000022c + (uint)(byte)(&DAT_200001f0)[pinNumber] * 3,outputValue);\n    }\n    updatePinState(&DAT_200003d4,pinNumber,outputValue);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000214": "process_pin_function_08000214",
                "param_1": "pinNumber",
                "param_2": "outputValue",
                "param_3": "param3",
                "param_4": "param4",
                "bVar1": "isServo",
                "iVar2": "pinMode",
                "char": "character",
                "analogWrite": "writeAnalogValue",
                "setPinState": "updatePinState",
                "set_servo_position_080026b0": "setServoPosition"
            },
            "calling": [
                "sysexCallback"
            ],
            "called": [
                "FUN_0800021a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800021a": {
            "entrypoint": "0x0800021a",
            "current_name": "handle_pin_operation_0800021a",
            "code": "\nvoid handlePinOperation_0800021a(uint pin,undefined4 value,undefined4 mode,undefined4 param_4)\n\n{\n  bool isPinValid;\n  int pinMode;\n  \n  pinMode = getPinMode(&DAT_200003d4,pin,mode,param_4,param_4);\n  if (pinMode == 3) {\n    if (pin < 0x3c) {\n      if ((&DAT_0800a908)[pin] == -1) {\n        pinMode = 0;\n      }\n      else {\n        pinMode = resolveDigitalPin();\n        if (pinMode == 0) {\n          pinMode = 0;\n        }\n        else {\n          pinMode = resolveDigitalPin((int)(char)(&DAT_0800a908)[pin]);\n          if (pinMode == 1) {\n            pinMode = 0;\n          }\n          else {\n            pinMode = pin_in_pinmap((int)(char)(&DAT_0800a908)[pin],&DAT_0800a6cc);\n          }\n        }\n      }\n    }\n    else {\n      pinMode = 0;\n    }\n    if (pinMode != 0) {\n      analogWrite(pin,value);\n    }\n    setPinState(&DAT_200003d4,pin,value);\n  }\n  else if (pinMode == 4) {\n    if (pin < 0x3c) {\n      if ((&DAT_0800a908)[pin] == -1) {\n        isPinValid = false;\n      }\n      else {\n        pinMode = resolveDigitalPin();\n        if (pinMode == 0) {\n          isPinValid = false;\n        }\n        else {\n          pinMode = resolveDigitalPin((int)(char)(&DAT_0800a908)[pin]);\n          if (pinMode == 1) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = true;\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      setServoPosition(&DAT_2000022c + (uint)(byte)(&DAT_200001f0)[pin] * 3,value);\n    }\n    setPinState(&DAT_200003d4,pin,value);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800021a": "handle_pin_operation_0800021a",
                "param_1": "pin",
                "param_2": "value",
                "param_3": "mode",
                "bVar1": "isPinValid",
                "iVar2": "pinMode",
                "pinNametoDigitalPin": "resolveDigitalPin",
                "set_servo_position_080026b0": "setServoPosition"
            },
            "calling": [
                "analogWriteCallback"
            ],
            "called": [
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "analogWrite",
                "FUN_080026b0",
                "setPinState",
                "getPinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000488": {
            "entrypoint": "0x08000488",
            "current_name": "update_data_08000488",
            "code": "\nvoid updateData_08000488(uint index,int flag)\n\n{\n  undefined4 analogValue;\n  \n  if ((int)index < 0xe) {\n    if (flag == 0) {\n      DAT_20000114 = DAT_20000114 & ~(1 << (index & 0xff));\n      return;\n    }\n    DAT_20000114 = 1 << (index & 0xff) | DAT_20000114;\n    if (DAT_20000171 == '\\0') {\n      analogValue = analogRead();\n      send_analog_data_08002ef2(&DAT_200003d4,index,analogValue);\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000488": "update_data_08000488",
                "param_1": "index",
                "param_2": "flag",
                "uVar1": "analogValue"
            },
            "calling": [
                "setPinModeCallback"
            ],
            "called": [
                "analogRead",
                "FUN_08002ef2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004d4": {
            "entrypoint": "0x080004d4",
            "current_name": "activate_servos_080004d4",
            "code": "\nvoid activateServos_080004d4(int status,int value)\n\n{\n  int count;\n  undefined *servoPtr;\n  \n  if (status != 1) {\n    return;\n  }\n  if (value == 0xffff) {\n    servoPtr = &DAT_2000022c;\n    for (count = 0xb; -1 < count; count = count + -1) {\n      Servo(servoPtr);\n      servoPtr = servoPtr + 3;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080004d4": "activate_servos_080004d4",
                "param_1": "status",
                "param_2": "value",
                "iVar1": "count",
                "puVar2": "servoPtr"
            },
            "calling": [],
            "called": [
                "Servo"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000500": {
            "entrypoint": "0x08000500",
            "current_name": "attach_servo_08000500",
            "code": "\nvoid attachServo_08000500(int servoIndex,int pinNumber,int timerInterval,undefined4 undefinedParam)\n\n{\n  if (0xb < DAT_200001ed) {\n    send_string_with_offset_08002f14(&DAT_200003d4,\"Max servos attached\",timerInterval,undefinedParam,undefinedParam);\n    return;\n  }\n  if (DAT_2000011c == 0) {\n    (&DAT_200001f0)[servoIndex] = DAT_200001ed;\n    DAT_200001ed = DAT_200001ed + 1;\n  }\n  else {\n    (&DAT_200001f0)[servoIndex] = (&DAT_2000011f)[DAT_2000011c];\n    DAT_2000011c = DAT_2000011c - 1;\n  }\n  if ((0 < pinNumber) && (0 < timerInterval)) {\n    configure_pin_and_activate_timer_080025ac(&DAT_2000022c + (uint)(byteVal)(&DAT_200001f0)[servoIndex] * 3,servoIndex,pinNumber,timerInterval);\n    return;\n  }\n  initialize_timer_08002634(&DAT_2000022c + (uint)(byteVal)(&DAT_200001f0)[servoIndex] * 3,servoIndex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000500": "attach_servo_08000500",
                "param_1": "servoIndex",
                "param_2": "pinNumber",
                "param_3": "timerInterval",
                "param_4": "undefinedParam",
                "byte": "byteVal"
            },
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "called": [
                "FUN_080025ac",
                "FUN_08002634",
                "FUN_08002f14"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000588": {
            "entrypoint": "0x08000588",
            "current_name": "detach_and_update_value_08000588",
            "code": "\nvoid detachAndUpdateValue_08000588(int inputIndex)\n\n{\n  detach(&DAT_2000022c + (uint)(byte)(&DAT_200001f0)[inputIndex] * 3);\n  if (((&DAT_200001f0)[inputIndex] == DAT_200001ed) && (DAT_200001ed != '\\0')) {\n    DAT_200001ed = DAT_200001ed + -1;\n  }\n  else if (DAT_200001ed != '\\0') {\n    DAT_2000011c = DAT_2000011c + 1;\n    (&DAT_2000011f)[DAT_2000011c] = (&DAT_200001f0)[inputIndex];\n  }\n  (&DAT_200001f0)[inputIndex] = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000588": "detach_and_update_value_08000588",
                "param_1": "inputIndex"
            },
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "called": [
                "detach"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005e0": {
            "entrypoint": "0x080005e0",
            "current_name": "initialize_data_080005e0",
            "code": "\nvoid initializeData_080005e0(void)\n\n{\n  DAT_20000170 = 0;\n  DAT_20000004 = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080005e0": "initialize_data_080005e0"
            },
            "calling": [
                "systemResetCallback",
                "setPinModeCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005f8": {
            "entrypoint": "0x080005f8",
            "current_name": "pin_mode_and_state_control_080005f8",
            "code": "\nvoid pinModeAndStateControl_080005f8(uint pinNumber,int mode)\n\n{\n  int pinModeResult;\n  char digitalMode;\n  bool isPinValid;\n  uint analogPinNumber;\n  \n  pinModeResult = getPinMode(&DAT_200003d4,pinNumber);\n  if (pinModeResult != 0x7f) {\n    pinModeResult = getPinMode(&DAT_200003d4,pinNumber);\n    if (pinModeResult == 6) {\n      if (DAT_20000170 == '\\0') {\n        digitalMode = '\\0';\n      }\n      else {\n        digitalMode = DAT_20000170;\n        if (mode == 6) {\n          digitalMode = '\\0';\n        }\n      }\n    }\n    else {\n      digitalMode = '\\0';\n    }\n    if (digitalMode != '\\0') {\n      disableI2CPins();\n    }\n    if (pinNumber < 0x3c) {\n      if ((&DAT_0800a908)[pinNumber] == -1) {\n        isPinValid = false;\n      }\n      else {\n        pinModeResult = pinNametoDigitalPin();\n        if (pinModeResult == 0) {\n          isPinValid = false;\n        }\n        else {\n          pinModeResult = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[pinNumber]);\n          if (pinModeResult == 1) {\n            isPinValid = false;\n          }\n          else if (mode == 4) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = true;\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      if ((byte)(&DAT_200001f0)[pinNumber] < 0xc) {\n        pinModeResult = attached(&DAT_2000022c + (uint)(byte)(&DAT_200001f0)[pinNumber] * 3);\n      }\n      else {\n        pinModeResult = 0;\n      }\n      if (pinModeResult != 0) {\n        detachServo(pinNumber);\n      }\n    }\n    analogPinNumber = pinNumber - 0x2e & 0xff;\n    if (analogPinNumber < 0xe) {\n      if (pinNumber < 0x3c) {\n        pinModeResult = (int)(char)(&DAT_0800a908)[pinNumber];\n      }\n      else {\n        pinModeResult = -1;\n      }\n      pinModeResult = pinNametoDigitalPin(pinModeResult);\n      if (pinModeResult == 0) {\n        isPinValid = false;\n      }\n      else {\n        if (pinNumber < 0x3c) {\n          pinModeResult = (int)(char)(&DAT_0800a908)[pinNumber];\n        }\n        else {\n          pinModeResult = -1;\n        }\n        pinModeResult = pinNametoDigitalPin(pinModeResult);\n        if (pinModeResult == 1) {\n          isPinValid = false;\n        }\n        else {\n          isPinValid = true;\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      reportAnalogCallback(analogPinNumber,mode == 2);\n    }\n    if (pinNumber < 0x3c) {\n      if ((&DAT_0800a908)[pinNumber] == -1) {\n        isPinValid = false;\n      }\n      else {\n        pinModeResult = pinNametoDigitalPin();\n        if (pinModeResult == 0) {\n          isPinValid = false;\n        }\n        else {\n          pinModeResult = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[pinNumber]);\n          if (pinModeResult == 1) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = true;\n          }\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      if ((mode == 0) || (mode == 0xb)) {\n        (&DAT_20000174)[pinNumber >> 3] = (&DAT_20000174)[pinNumber >> 3] | (byte)(1 << (pinNumber & 7));\n      }\n      else {\n        (&DAT_20000174)[pinNumber >> 3] = (&DAT_20000174)[pinNumber >> 3] & ~(byte)(1 << (pinNumber & 7));\n      }\n    }\n    setPinState(&DAT_200003d4,pinNumber,0);\n    switch(mode) {\n    case 0:\n      if (pinNumber < 0x3c) {\n        if ((&DAT_0800a908)[pinNumber] == -1) {\n          isPinValid = false;\n        }\n        else {\n          pinModeResult = pinNametoDigitalPin();\n          if (pinModeResult == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinModeResult = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[pinNumber]);\n            if (pinModeResult == 1) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        pinMode(pinNumber,0);\n        setPinMode(&DAT_200003d4,pinNumber,0);\n        return;\n      }\n      break;\n    case 1:\n      if (pinNumber < 0x3c) {\n        if ((&DAT_0800a908)[pinNumber] == -1) {\n          isPinValid = false;\n        }\n        else {\n          pinModeResult = pinNametoDigitalPin();\n          if (pinModeResult == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinModeResult = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[pinNumber]);\n            if (pinModeResult == 1) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        pinModeResult = getPinMode(&DAT_200003d4,pinNumber);\n        if (pinModeResult == 3) {\n          digitalWrite(pinNumber,0);\n        }\n        pinMode(pinNumber,1);\n        setPinMode(&DAT_200003d4,pinNumber,1);\n        return;\n      }\n      break;\n    case 2:\n      if (analogPinNumber < 0xe) {\n        if (pinNumber < 0x3c) {\n          pinModeResult = (int)(char)(&DAT_0800a908)[pinNumber];\n        }\n        else {\n          pinModeResult = -1;\n        }\n        pinModeResult = pinNametoDigitalPin(pinModeResult);\n        if (pinModeResult == 0) {\n          isPinValid = false;\n        }\n        else {\n          if (pinNumber < 0x3c) {\n            pinModeResult = (int)(char)(&DAT_0800a908)[pinNumber];\n          }\n          else {\n            pinModeResult = -1;\n          }\n          pinModeResult = pinNametoDigitalPin(pinModeResult);\n          if (pinModeResult == 1) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = true;\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        if (pinNumber < 0x3c) {\n          if ((&DAT_0800a908)[pinNumber] == -1) {\n            isPinValid = false;\n          }\n          else {\n            pinModeResult = pinNametoDigitalPin();\n            if (pinModeResult == 0) {\n              isPinValid = false;\n            }\n            else {\n              pinModeResult = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[pinNumber]);\n              if (pinModeResult == 1) {\n                isPinValid = false;\n              }\n            }\n          }\n        }\n        else {\n          isPinValid = false;\n        }\n        if (isPinValid) {\n          pinMode(pinNumber,0);\n        }\n        setPinMode(&DAT_200003d4,pinNumber,2);\n        return;\n      }\n      break;\n    case 3:\n      if (pinNumber < 0x3c) {\n        if ((&DAT_0800a908)[pinNumber] == -1) {\n          pinModeResult = 0;\n        }\n        else {\n          pinModeResult = pinNametoDigitalPin();\n          if (pinModeResult == 0) {\n            pinModeResult = 0;\n          }\n          else {\n            pinModeResult = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[pinNumber]);\n            if (pinModeResult == 1) {\n              pinModeResult = 0;\n            }\n            else {\n              pinModeResult = pin_in_pinmap((int)(char)(&DAT_0800a908)[pinNumber],&DAT_0800a6cc);\n            }\n          }\n        }\n      }\n      else {\n        pinModeResult = 0;\n      }\n      if (pinModeResult != 0) {\n        pinMode(pinNumber,1);\n        analogWrite(pinNumber,0);\n        setPinMode(&DAT_200003d4,pinNumber,3);\n        return;\n      }\n      break;\n    case 4:\n      if (pinNumber < 0x3c) {\n        if ((&DAT_0800a908)[pinNumber] == -1) {\n          isPinValid = false;\n        }\n        else {\n          pinModeResult = pinNametoDigitalPin();\n          if (pinModeResult == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinModeResult = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[pinNumber]);\n            if (pinModeResult == 1) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        setPinMode(&DAT_200003d4,pinNumber,4);\n        if (((byte)(&DAT_200001f0)[pinNumber] != 0xff) &&\n           (pinModeResult = attached(&DAT_2000022c + (uint)(byte)(&DAT_200001f0)[pinNumber] * 3), pinModeResult != 0))\n        {\n          isPinValid = false;\n        }\n        if (isPinValid) {\n          attachServo(pinNumber,0xffffffff);\n          return;\n        }\n      }\n      break;\n    default:\n      send_string_with_offset_08002f14(&DAT_200003d4,\"Unknown pin mode\");\n      break;\n    case 6:\n      if (pinNumber < 0x3c) {\n        if ((&DAT_0800a908)[pinNumber] == -1) {\n          pinModeResult = 0;\n        }\n        else {\n          pinModeResult = pinNametoDigitalPin();\n          if (pinModeResult == 0) {\n            pinModeResult = 0;\n          }\n          else {\n            pinModeResult = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[pinNumber]);\n            if (pinModeResult == 1) {\n              pinModeResult = 0;\n            }\n            else {\n              pinModeResult = pin_in_pinmap((int)(char)(&DAT_0800a908)[pinNumber],&DAT_0800a69c);\n              if (pinModeResult == 0) {\n                pinModeResult = pin_in_pinmap((int)(char)(&DAT_0800a908)[pinNumber],&DAT_0800a66c);\n              }\n            }\n          }\n        }\n      }\n      else {\n        pinModeResult = 0;\n      }\n      if (pinModeResult != 0) {\n        setPinMode(&DAT_200003d4,pinNumber,6);\n        return;\n      }\n      break;\n    case 10:\n      break;\n    case 0xb:\n      if (pinNumber < 0x3c) {\n        if ((&DAT_0800a908)[pinNumber] == -1) {\n          isPinValid = false;\n        }\n        else {\n          pinModeResult = pinNametoDigitalPin();\n          if (pinModeResult == 0) {\n            isPinValid = false;\n          }\n          else {\n            pinModeResult = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[pinNumber]);\n            if (pinModeResult == 1) {\n              isPinValid = false;\n            }\n            else {\n              isPinValid = true;\n            }\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        pinMode(pinNumber,2);\n        setPinMode(&DAT_200003d4,pinNumber,0xb);\n        setPinState(&DAT_200003d4,pinNumber,1);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080005f8": "pin_mode_and_state_control_080005f8",
                "param_1": "pinNumber",
                "param_2": "mode",
                "iVar1": "pinModeResult",
                "cVar2": "digitalMode",
                "bVar3": "isPinValid",
                "uVar4": "analogPinNumber"
            },
            "calling": [
                "sysexCallback",
                "enableI2CPins",
                "systemResetCallback"
            ],
            "called": [
                "pin_in_pinmap",
                "analogWrite",
                "FUN_08002f14",
                "digitalWrite",
                "setPinState",
                "setPinMode",
                "attachServo",
                "pinNametoDigitalPin",
                "reportAnalogCallback",
                "disableI2CPins",
                "getPinMode",
                "attached",
                "pinMode",
                "detachServo"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a64": {
            "entrypoint": "0x08000a64",
            "current_name": "initialize_pins_08000a64",
            "code": "\nvoid initialize_pins_08000a64(void)\n\n{\n  int result;\n  uint index;\n  \n  for (index = 0; index < 0x3c; index = index + 1 & 0xff) {\n    if (index < 0x3c) {\n      if ((&DAT_0800a908)[index] == -1) {\n        result = 0;\n      }\n      else {\n        result = pinNametoDigitalPin();\n        if (result == 0) {\n          result = 0;\n        }\n        else {\n          result = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[index]);\n          if (result == 1) {\n            result = 0;\n          }\n          else {\n            result = pin_in_pinmap((int)(char)(&DAT_0800a908)[index],&DAT_0800a69c);\n            if (result == 0) {\n              result = pin_in_pinmap((int)(char)(&DAT_0800a908)[index],&DAT_0800a66c);\n            }\n          }\n        }\n      }\n    }\n    else {\n      result = 0;\n    }\n    if (result != 0) {\n      setPinModeCallback(index,6);\n    }\n  }\n  DAT_20000170 = 1;\n  initialize_i2_c_08002a26(&DAT_20000314);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000a64": "initialize_pins_08000a64",
                "iVar1": "result",
                "uVar2": "index"
            },
            "calling": [
                "sysexCallback"
            ],
            "called": [
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "FUN_08002a26",
                "setPinModeCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aec": {
            "entrypoint": "0x08000aec",
            "current_name": "initialize_08000aec",
            "code": "\nvoid initialize_08000aec(void)\n\n{\n  bool isPinValid;\n  int currentPin;\n  uint i;\n  \n  DAT_20000171 = 1;\n  if (DAT_20000170 != '\\0') {\n    disableI2CPins();\n  }\n  for (i = 0; i < 5; i = i + 1 & 0xff) {\n    (&DAT_200001e8)[i] = 0;\n    (&DAT_20000174)[i] = 0;\n    (&DAT_20000180)[i] = 0;\n  }\n  for (i = 0; i < 0x3c; i = i + 1 & 0xff) {\n    if ((i - 0x2e & 0xff) < 0xe) {\n      if (i < 0x3c) {\n        currentPin = (int)(char)(&DAT_0800a908)[i];\n      }\n      else {\n        currentPin = -1;\n      }\n      currentPin = pinNametoDigitalPin(currentPin);\n      if (currentPin == 0) {\n        isPinValid = false;\n      }\n      else {\n        if (i < 0x3c) {\n          currentPin = (int)(char)(&DAT_0800a908)[i];\n        }\n        else {\n          currentPin = -1;\n        }\n        currentPin = pinNametoDigitalPin(currentPin);\n        if (currentPin == 1) {\n          isPinValid = false;\n        }\n        else {\n          isPinValid = true;\n        }\n      }\n    }\n    else {\n      isPinValid = false;\n    }\n    if (isPinValid) {\n      setPinModeCallback(i,2);\n    }\n    else {\n      if ((((i < 0x3c) && ((&DAT_0800a908)[i] != -1)) &&\n          (currentPin = pinNametoDigitalPin(), currentPin != 0)) &&\n         (currentPin = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[i]), currentPin != 1)) {\n        isPinValid = true;\n      }\n      if (isPinValid) {\n        setPinModeCallback(i,1);\n      }\n    }\n    (&DAT_200001f0)[i] = 0xff;\n  }\n  DAT_20000114 = 0;\n  DAT_2000011c = 0;\n  DAT_200001ed = 0;\n  DAT_20000171 = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000aec": "initialize_08000aec",
                "uVar3": "i",
                "iVar2": "currentPin",
                "bVar1": "isPinValid"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "pinNametoDigitalPin",
                "disableI2CPins",
                "setPinModeCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000be8": {
            "entrypoint": "0x08000be8",
            "current_name": "send_port_data_08000be8",
            "code": "\nvoid send_port_data_08000be8(int port_index,uint mask,int flag,undefined4 param)\n\n{\n  undefined1 *data_ptr_1;\n  undefined1 *data_ptr_2;\n  \n  data_ptr_1 = &DAT_20000174;\n  data_ptr_2 = (undefined1 *)((byte)(&DAT_20000174)[port_index] & mask);\n  if ((flag != 0) ||\n     (data_ptr_1 = (undefined1 *)(uint)(byte)(&DAT_20000180)[port_index], data_ptr_2 != data_ptr_1)) {\n    send_digital_port_data_08002efe(&DAT_200003d4,port_index,data_ptr_2,data_ptr_1,param);\n    (&DAT_20000180)[port_index] = (char)data_ptr_2;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000be8": "send_port_data_08000be8",
                "param_1": "port_index",
                "param_2": "mask",
                "param_3": "flag",
                "param_4": "param",
                "puVar1": "data_ptr_1",
                "puVar2": "data_ptr_2"
            },
            "calling": [
                "checkDigitalInputs"
            ],
            "called": [
                "FUN_08002efe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ef8": {
            "entrypoint": "0x08000ef8",
            "current_name": "update_io_status_08000ef8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001ade) */\n/* WARNING: Removing unreachable block (ram,0x08001a4a) */\n/* WARNING: Removing unreachable block (ram,0x080019b6) */\n/* WARNING: Removing unreachable block (ram,0x08001912) */\n/* WARNING: Removing unreachable block (ram,0x08001866) */\n/* WARNING: Removing unreachable block (ram,0x080017d2) */\n/* WARNING: Removing unreachable block (ram,0x0800173e) */\n/* WARNING: Removing unreachable block (ram,0x0800169a) */\n/* WARNING: Removing unreachable block (ram,0x080015ee) */\n/* WARNING: Removing unreachable block (ram,0x0800155a) */\n/* WARNING: Removing unreachable block (ram,0x08001490) */\n/* WARNING: Removing unreachable block (ram,0x080014a2) */\n/* WARNING: Removing unreachable block (ram,0x080014e4) */\n/* WARNING: Removing unreachable block (ram,0x080014b0) */\n/* WARNING: Removing unreachable block (ram,0x080014ba) */\n/* WARNING: Removing unreachable block (ram,0x080014e8) */\n/* WARNING: Removing unreachable block (ram,0x080014c2) */\n/* WARNING: Removing unreachable block (ram,0x080014b6) */\n/* WARNING: Removing unreachable block (ram,0x08001496) */\n/* WARNING: Removing unreachable block (ram,0x08001430) */\n/* WARNING: Removing unreachable block (ram,0x08001376) */\n/* WARNING: Removing unreachable block (ram,0x080012e2) */\n/* WARNING: Removing unreachable block (ram,0x0800124e) */\n/* WARNING: Removing unreachable block (ram,0x080011b8) */\n/* WARNING: Removing unreachable block (ram,0x08001100) */\n/* WARNING: Removing unreachable block (ram,0x0800106c) */\n/* WARNING: Removing unreachable block (ram,0x08000fd8) */\n/* WARNING: Removing unreachable block (ram,0x08000f42) */\n/* WARNING: Removing unreachable block (ram,0x08000f8e) */\n/* WARNING: Removing unreachable block (ram,0x08001022) */\n/* WARNING: Removing unreachable block (ram,0x080010b6) */\n/* WARNING: Removing unreachable block (ram,0x0800114a) */\n/* WARNING: Removing unreachable block (ram,0x08001204) */\n/* WARNING: Removing unreachable block (ram,0x08001298) */\n/* WARNING: Removing unreachable block (ram,0x0800132c) */\n/* WARNING: Removing unreachable block (ram,0x080013c0) */\n/* WARNING: Removing unreachable block (ram,0x0800147c) */\n/* WARNING: Removing unreachable block (ram,0x08001510) */\n/* WARNING: Removing unreachable block (ram,0x080015a4) */\n/* WARNING: Removing unreachable block (ram,0x08001638) */\n/* WARNING: Removing unreachable block (ram,0x080016f4) */\n/* WARNING: Removing unreachable block (ram,0x08001788) */\n/* WARNING: Removing unreachable block (ram,0x0800181c) */\n/* WARNING: Removing unreachable block (ram,0x080018b0) */\n/* WARNING: Removing unreachable block (ram,0x0800196c) */\n/* WARNING: Removing unreachable block (ram,0x08001a00) */\n/* WARNING: Removing unreachable block (ram,0x08001a94) */\n/* WARNING: Removing unreachable block (ram,0x08001b28) */\n/* WARNING: Removing unreachable block (ram,0x080014ca) */\n\nvoid updateIOStatus_08000ef8(void)\n\n{\n  byte portByte;\n  int digitalPinIndex;\n  bool isPinHigh;\n  byte portValue;\n  \n  portByte = DAT_20000174;\n  if (DAT_200001e8 != '\\0') {\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      portValue = 0;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(3);\n      if (digitalPinIndex == 1) {\n        portValue = 0;\n      }\n      else if ((portByte & 1) == 0) {\n        portValue = 0;\n      }\n      else {\n        digitalPinIndex = digitalRead(0);\n        if (digitalPinIndex == 0) {\n          portValue = 0;\n        }\n        else {\n          portValue = 1;\n        }\n      }\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(2);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 2) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(1);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 2;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(10);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 4) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(2);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 4;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x13);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 8) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(3);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 8;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x15);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x10) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(4);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x10;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x14);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x20) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(5);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x20;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x1a);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x40) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(6);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x40;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(8);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x80) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(7);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x80;\n    }\n    outputPort(0,portValue);\n  }\n  portByte = DAT_20000175;\n  if (DAT_200001e9 != '\\0') {\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      portValue = 0;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(9);\n      if (digitalPinIndex == 1) {\n        portValue = 0;\n      }\n      else if ((portByte & 1) == 0) {\n        portValue = 0;\n      }\n      else {\n        digitalPinIndex = digitalRead(8);\n        if (digitalPinIndex == 0) {\n          portValue = 0;\n        }\n        else {\n          portValue = 1;\n        }\n      }\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x27);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 2) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(9);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 2;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x16);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 4) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(10);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 4;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(7);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 8) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0xb);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 8;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(6);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x10) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0xc);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x10;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(5);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x20) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0xd);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x20;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x19);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x40) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0xe);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x40;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x18);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x80) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0xf);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x80;\n    }\n    outputPort(1,portValue,0);\n  }\n  portByte = DAT_20000176;\n  if (DAT_200001ea != '\\0') {\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      portValue = 0;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x2a);\n      if (digitalPinIndex == 1) {\n        portValue = 0;\n      }\n      else if ((portByte & 1) == 0) {\n        portValue = 0;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x10);\n        if (digitalPinIndex == 0) {\n          portValue = 0;\n        }\n        else {\n          portValue = 1;\n        }\n      }\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x2c);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 2) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x11);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 2;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0xd);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 8) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x13);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 8;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0xe);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x10) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x14);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x10;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0xf);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x20) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x15);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x20;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x17);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x40) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x16);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x40;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x2d);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x80) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x17);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x80;\n    }\n    outputPort(2,portValue,0);\n  }\n  portByte = DAT_20000177;\n  if (DAT_200001eb != '\\0') {\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      portValue = 0;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x2e);\n      if (digitalPinIndex == 1) {\n        portValue = 0;\n      }\n      else if ((portByte & 1) == 0) {\n        portValue = 0;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x18);\n        if (digitalPinIndex == 0) {\n          portValue = 0;\n        }\n        else {\n          portValue = 1;\n        }\n      }\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x2f);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 2) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x19);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 2;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x30);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 4) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x1a);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 4;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x31);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 8) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x1b);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 8;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x22);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x10) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x1c);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x10;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x23);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x20) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x1d);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x20;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x2b);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x40) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x1e);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x40;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x32);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x80) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x1f);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x80;\n    }\n    outputPort(3,portValue,0);\n  }\n  portByte = DAT_20000178;\n  if (DAT_200001ec != '\\0') {\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      portValue = 0;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x29);\n      if (digitalPinIndex == 1) {\n        portValue = 0;\n      }\n      else if ((portByte & 1) == 0) {\n        portValue = 0;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x20);\n        if (digitalPinIndex == 0) {\n          portValue = 0;\n        }\n        else {\n          portValue = 1;\n        }\n      }\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x28);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 2) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x21);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 2;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x26);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 4) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x22);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 4;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x25);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 8) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x23);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 8;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0xc);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x10) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x24);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x10;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0xb);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x20) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x25);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x20;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x1c);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x40) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x26);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x40;\n    }\n    digitalPinIndex = pinNametoDigitalPin();\n    if (digitalPinIndex == 0) {\n      isPinHigh = false;\n    }\n    else {\n      digitalPinIndex = pinNametoDigitalPin(0x1b);\n      if (digitalPinIndex == 1) {\n        isPinHigh = false;\n      }\n      else if ((portByte & 0x80) == 0) {\n        isPinHigh = false;\n      }\n      else {\n        digitalPinIndex = digitalRead(0x27);\n        if (digitalPinIndex == 0) {\n          isPinHigh = false;\n        }\n        else {\n          isPinHigh = true;\n        }\n      }\n    }\n    if (isPinHigh) {\n      portValue = portValue | 0x80;\n    }\n    outputPort(4,portValue,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ef8": "update_io_status_08000ef8",
                "bVar1": "portByte",
                "iVar2": "digitalPinIndex",
                "bVar3": "isPinHigh",
                "bVar4": "portValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "outputPort",
                "pinNametoDigitalPin",
                "digitalRead"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b48": {
            "entrypoint": "0x08001b48",
            "current_name": "initialize_gateway_08001b48",
            "code": "\nvoid initializeGateway_08001b48(void)\n\n{\n  setFirmwareNameAndVersion\n            (&DAT_200003d4,\"/home/bo/p2im/p2im-real_firmware_scratch/Gateway/StandardFirmata.ino\",2,\n             5);\n  update_parameter_08002f2c(&DAT_200003d4,0xe0,0x8000215);\n  update_parameter_08002f2c(&DAT_200003d4,0x90,parameterPtr1);\n  update_parameter_08002f2c(&DAT_200003d4,0xc0,0x8000489);\n  update_parameter_08002f2c(&DAT_200003d4,0xd0,parameterPtr2);\n  update_parameter_08002f2c(&DAT_200003d4,0xf4,0x80005f9);\n  update_parameter_08002f2c(&DAT_200003d4,0xf5,parameterPtr3);\n  initializeData(&DAT_200003d4,0xf0,0x8001cd1);\n  updateData(&DAT_200003d4,0xff,0x8000aed);\n  initializeDeviceInfo(&DAT_200003d4,0xe100);\n  performSystemReset();\n  startForkServer(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001b48": "initialize_gateway_08001b48",
                "&LAB_080002ec_1": "parameterPtr1",
                "&LAB_08000c18_1": "parameterPtr2",
                "&LAB_080001a8_1": "parameterPtr3",
                "initialize_data_08002f94": "initializeData",
                "update_data_08002f84": "updateData",
                "initialize_device_info_08003048": "initializeDeviceInfo",
                "systemResetCallback": "performSystemReset",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "FUN_08002f2c",
                "FUN_08003048",
                "FUN_08002f84",
                "FUN_08002f94",
                "startForkserver",
                "setFirmwareNameAndVersion",
                "systemResetCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001bf8": {
            "entrypoint": "0x08001bf8",
            "current_name": "write_data_08001bf8",
            "code": "\nvoid write_data_08001bf8(undefined4 data_buffer,undefined4 param_2,undefined4 param_3,undefined4 repeated_param)\n\n{\n  i2c_write_data_08001bf8_0800288c(&DAT_20000314,data_buffer,param_3,repeated_param,repeated_param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001bf8": "write_data_08001bf8",
                "param_1": "data_buffer",
                "param_4": "repeated_param"
            },
            "calling": [
                "readAndReportData",
                "sysexCallback"
            ],
            "called": [
                "FUN_0800288c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c08": {
            "entrypoint": "0x08001c08",
            "current_name": "read_byte_from_memory_08001c08",
            "code": "\nundefined readByteFromMemory_08001c08(void)\n\n{\n  undefined byte;\n  \n  byte = read_byte_from_memory_08002720(&DAT_20000314);\n  return byte;\n}\n\n",
            "renaming": {
                "FUN_08001c08": "read_byte_from_memory_08001c08",
                "uVar1": "byte"
            },
            "calling": [
                "readAndReportData"
            ],
            "called": [
                "FUN_08002720"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c18": {
            "entrypoint": "0x08001c18",
            "current_name": "process_i2_c_data_08001c18",
            "code": "\nvoid processI2CData_08001c18(undefined4 deviceAddress,uint registerAddress,int expectedBytes,undefined4 statusRegister)\n\n{\n  undefined data;\n  int receivedBytes;\n  int currentByte;\n  bool hasMoreData;\n  \n  if (registerAddress == 0xffffffff) {\n    registerAddress = 0;\n  }\n  else {\n    beginTransmission(&DAT_20000314,deviceAddress);\n    wireWrite(registerAddress & 0xff);\n    check_i2_c_status_08002a58(&DAT_20000314,statusRegister);\n  }\n  requestFrom(&DAT_20000314,deviceAddress,expectedBytes);\n  receivedBytes = calculate_difference_0800270c(&DAT_20000314);\n  if (expectedBytes < receivedBytes) {\n    send_string_with_offset_08002f14(&DAT_200003d4,\"I2C: Too many bytes received\");\n  }\n  else {\n    receivedBytes = calculate_difference_0800270c(&DAT_20000314);\n    if (receivedBytes < expectedBytes) {\n      send_string_with_offset_08002f14(&DAT_200003d4,\"I2C: Too few bytes received\");\n    }\n  }\n  DAT_20000130 = (undefined)deviceAddress;\n  DAT_20000131 = (undefined)registerAddress;\n  receivedBytes = 0;\n  while( true ) {\n    if (receivedBytes < expectedBytes) {\n      currentByte = calculate_difference_0800270c(&DAT_20000314);\n      if (currentByte == 0) {\n        hasMoreData = false;\n      }\n      else {\n        hasMoreData = true;\n      }\n    }\n    else {\n      hasMoreData = false;\n    }\n    if (!hasMoreData) break;\n    data = wireRead();\n    (&DAT_20000132)[receivedBytes] = data;\n    receivedBytes = receivedBytes + 1;\n  }\n  send_sysex_with_offset_08002f0a(&DAT_200003d4,0x77,expectedBytes + 2U & 0xff,&DAT_20000130);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001c18": "process_i2_c_data_08001c18",
                "param_1": "deviceAddress",
                "param_2": "registerAddress",
                "param_3": "expectedBytes",
                "param_4": "statusRegister",
                "uVar1": "data",
                "iVar2": "receivedBytes",
                "iVar3": "currentByte",
                "bVar4": "hasMoreData"
            },
            "calling": [
                "loop",
                "sysexCallback"
            ],
            "called": [
                "FUN_08002a58",
                "requestFrom",
                "FUN_08002f14",
                "FUN_0800270c",
                "beginTransmission",
                "FUN_08002f0a",
                "wireRead",
                "wireWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cd0": {
            "entrypoint": "0x08001cd0",
            "current_name": "process_command_08001cd0",
            "code": "\nvoid processCommand_08001cd0(undefined4 commandType,int paramLength,byte *commandParams,undefined4 additionalParam)\n\n{\n  byte param1;\n  byte param2;\n  byte param3;\n  undefined4 result;\n  byte param4;\n  char tempChar;\n  int tempInt1;\n  int tempInt2;\n  uint tempUInt1;\n  uint tempUInt2;\n  int tempInt3;\n  bool flag;\n  \n  switch(commandType) {\n  case 0x69:\n    execute_function_08002f1e(&DAT_200003d4,0xf0);\n    execute_function_08002f1e(&DAT_200003d4,0x6a);\n    for (tempUInt1 = 0; tempUInt1 < 0x3c; tempUInt1 = tempUInt1 + 1 & 0xff) {\n      tempUInt2 = tempUInt1 - 0x2e & 0xff;\n      if (tempUInt2 < 0xe) {\n        if (tempUInt1 < 0x3c) {\n          tempInt1 = (int)(char)(&DAT_0800a908)[tempUInt1];\n        }\n        else {\n          tempInt1 = -1;\n        }\n        tempInt1 = pinNametoDigitalPin(tempInt1);\n        if (tempInt1 == 0) {\n          tempUInt2 = 0x7f;\n        }\n        else {\n          if (tempUInt1 < 0x3c) {\n            tempInt1 = (int)(char)(&DAT_0800a908)[tempUInt1];\n          }\n          else {\n            tempInt1 = -1;\n          }\n          tempInt1 = pinNametoDigitalPin(tempInt1);\n          if (tempInt1 == 1) {\n            tempUInt2 = 0x7f;\n          }\n        }\n      }\n      else {\n        tempUInt2 = 0x7f;\n      }\n      execute_function_08002f1e(&DAT_200003d4,tempUInt2);\n    }\n    execute_function_08002f1e(&DAT_200003d4,0xf7);\n    break;\n  case 0x6b:\n    execute_function_08002f1e(&DAT_200003d4,0xf0);\n    execute_function_08002f1e(&DAT_200003d4,0x6c);\n    for (tempUInt1 = 0; tempUInt1 < 0x3c; tempUInt1 = tempUInt1 + 1 & 0xff) {\n      if (tempUInt1 < 0x3c) {\n        if ((&DAT_0800a908)[tempUInt1] == -1) {\n          flag = false;\n        }\n        else {\n          tempInt1 = pinNametoDigitalPin();\n          if (tempInt1 == 0) {\n            flag = false;\n          }\n          else {\n            tempInt1 = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[tempUInt1]);\n            if (tempInt1 == 1) {\n              flag = false;\n            }\n            else {\n              flag = true;\n            }\n          }\n        }\n      }\n      else {\n        flag = false;\n      }\n      if (flag) {\n        execute_function_08002f1e(&DAT_200003d4,0);\n        execute_function_08002f1e(&DAT_200003d4,1);\n        execute_function_08002f1e(&DAT_200003d4,0xb);\n        execute_function_08002f1e(&DAT_200003d4,1);\n        execute_function_08002f1e(&DAT_200003d4,1);\n        execute_function_08002f1e(&DAT_200003d4,1);\n      }\n      if ((tempUInt1 - 0x2e & 0xff) < 0xe) {\n        if (tempUInt1 < 0x3c) {\n          tempInt1 = (int)(char)(&DAT_0800a908)[tempUInt1];\n        }\n        else {\n          tempInt1 = -1;\n        }\n        tempInt1 = pinNametoDigitalPin(tempInt1);\n        if (tempInt1 == 0) {\n          flag = false;\n        }\n        else {\n          if (tempUInt1 < 0x3c) {\n            tempInt1 = (int)(char)(&DAT_0800a908)[tempUInt1];\n          }\n          else {\n            tempInt1 = -1;\n          }\n          tempInt1 = pinNametoDigitalPin(tempInt1);\n          if (tempInt1 == 1) {\n            flag = false;\n          }\n          else {\n            flag = true;\n          }\n        }\n      }\n      else {\n        flag = false;\n      }\n      if (flag) {\n        execute_function_08002f1e(&DAT_200003d4,2);\n        execute_function_08002f1e(&DAT_200003d4,10);\n      }\n      if (tempUInt1 < 0x3c) {\n        if ((&DAT_0800a908)[tempUInt1] == -1) {\n          tempInt1 = 0;\n        }\n        else {\n          tempInt1 = pinNametoDigitalPin();\n          if (tempInt1 == 0) {\n            tempInt1 = 0;\n          }\n          else {\n            tempInt1 = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[tempUInt1]);\n            if (tempInt1 == 1) {\n              tempInt1 = 0;\n            }\n            else {\n              tempInt1 = pin_in_pinmap((int)(char)(&DAT_0800a908)[tempUInt1],&DAT_0800a6cc);\n            }\n          }\n        }\n      }\n      else {\n        tempInt1 = 0;\n      }\n      if (tempInt1 != 0) {\n        execute_function_08002f1e(&DAT_200003d4,3);\n        execute_function_08002f1e(&DAT_200003d4,8);\n      }\n      if (tempUInt1 < 0x3c) {\n        if ((&DAT_0800a908)[tempUInt1] == -1) {\n          flag = false;\n        }\n        else {\n          tempInt1 = pinNametoDigitalPin();\n          if (tempInt1 == 0) {\n            flag = false;\n          }\n          else {\n            tempInt1 = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[tempUInt1]);\n            if (tempInt1 == 1) {\n              flag = false;\n            }\n            else {\n              flag = true;\n            }\n          }\n        }\n      }\n      else {\n        flag = false;\n      }\n      if (flag) {\n        execute_function_08002f1e(&DAT_200003d4,4);\n        execute_function_08002f1e(&DAT_200003d4,0xe);\n      }\n      if (tempUInt1 < 0x3c) {\n        if ((&DAT_0800a908)[tempUInt1] == -1) {\n          tempInt1 = 0;\n        }\n        else {\n          tempInt1 = pinNametoDigitalPin();\n          if (tempInt1 == 0) {\n            tempInt1 = 0;\n          }\n          else {\n            tempInt1 = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[tempUInt1]);\n            if (tempInt1 == 1) {\n              tempInt1 = 0;\n            }\n            else {\n              tempInt1 = pin_in_pinmap((int)(char)(&DAT_0800a908)[tempUInt1],&DAT_0800a69c);\n              if (tempInt1 == 0) {\n                tempInt1 = pin_in_pinmap((int)(char)(&DAT_0800a908)[tempUInt1],&DAT_0800a66c);\n              }\n            }\n          }\n        }\n      }\n      else {\n        tempInt1 = 0;\n      }\n      if (tempInt1 != 0) {\n        execute_function_08002f1e(&DAT_200003d4,6);\n        execute_function_08002f1e(&DAT_200003d4,1);\n      }\n      execute_function_08002f1e(&DAT_200003d4,0x7f);\n    }\n    execute_function_08002f1e(&DAT_200003d4,0xf7);\n    return;\n  case 0x6d:\n    if (paramLength != 0) {\n      param1 = *commandParams;\n      execute_function_08002f1e(&DAT_200003d4,0xf0);\n      execute_function_08002f1e(&DAT_200003d4,0x6e);\n      execute_function_08002f1e(&DAT_200003d4,param1);\n      if (param1 < 0x3c) {\n        result = getPinMode(&DAT_200003d4,param1);\n        execute_function_08002f1e(&DAT_200003d4,result);\n        tempUInt1 = getPinState(&DAT_200003d4,param1);\n        execute_function_08002f1e(&DAT_200003d4,tempUInt1 & 0x7f);\n        tempUInt1 = getPinState(&DAT_200003d4,param1);\n        if ((tempUInt1 & 0xff80) != 0) {\n          tempInt1 = getPinState(&DAT_200003d4,param1);\n          execute_function_08002f1e(&DAT_200003d4,(uint)(tempInt1 << 0x12) >> 0x19);\n        }\n        tempUInt1 = getPinState(&DAT_200003d4,param1);\n        if ((tempUInt1 & 0xc000) != 0) {\n          tempInt1 = getPinState(&DAT_200003d4,param1);\n          execute_function_08002f1e(&DAT_200003d4,(uint)(tempInt1 << 0xb) >> 0x19);\n        }\n      }\n      execute_function_08002f1e(&DAT_200003d4,0xf7);\n      return;\n    }\n    break;\n  case 0x6f:\n    if (1 < paramLength) {\n      tempUInt1 = (uint)commandParams[1];\n      if (2 < paramLength) {\n        tempUInt1 = tempUInt1 | (uint)commandParams[2] << 7;\n      }\n      if (3 < paramLength) {\n        tempUInt1 = tempUInt1 | (uint)commandParams[3] << 0xe;\n      }\n      analogWriteCallback(*commandParams,tempUInt1);\n      return;\n    }\n    break;\n  case 0x70:\n    if (4 < paramLength) {\n      tempUInt1 = (uint)*commandParams;\n      param1 = commandParams[1];\n      param4 = commandParams[2];\n      param2 = commandParams[3];\n      param3 = commandParams[4];\n      if (tempUInt1 < 0x3c) {\n        if ((&DAT_0800a908)[tempUInt1] == -1) {\n          flag = false;\n        }\n        else {\n          tempInt1 = pinNametoDigitalPin();\n          if (tempInt1 == 0) {\n            flag = false;\n          }\n          else {\n            tempInt1 = pinNametoDigitalPin((int)(char)(&DAT_0800a908)[tempUInt1]);\n            if (tempInt1 == 1) {\n              flag = false;\n            }\n            else {\n              flag = true;\n            }\n          }\n        }\n      }\n      else {\n        flag = false;\n      }\n      if (flag) {\n        if ((byte)(&DAT_200001f0)[tempUInt1] < 0xc) {\n          tempInt1 = attached(&DAT_2000022c + (uint)(byte)(&DAT_200001f0)[tempUInt1] * 3);\n        }\n        else {\n          tempInt1 = 0;\n        }\n        if (tempInt1 != 0) {\n          detachServo(tempUInt1);\n        }\n        attachServo(tempUInt1,(uint)param1 + (uint)param4 * 0x80,(uint)param2 + (uint)param3 * 0x80);\n        setPinModeCallback(tempUInt1,4);\n        return;\n      }\n    }\n    break;\n  case 0x76:\n    param1 = commandParams[1];\n    param4 = param1 & 0x18;\n    if ((param1 & 0x20) != 0) {\n      send_string_with_offset_08002f14(&DAT_200003d4,\"10-bit addressing not supported\",param4,param1,additionalParam);\n      return;\n    }\n    param2 = *commandParams;\n    flag = (param1 & 0x40) == 0;\n    if (param4 < 0x19) {\n      switch(param4) {\n      case 0:\n        beginTransmission(&DAT_20000314,param2);\n        for (tempUInt1 = 2; (int)tempUInt1 < paramLength; tempUInt1 = tempUInt1 + 2 & 0xff) {\n          wireWrite(commandParams[tempUInt1 + 1] * -0x80 + commandParams[tempUInt1]);\n        }\n        endTransmission(&DAT_20000314);\n        return;\n      case 8:\n        if (paramLength == 6) {\n          tempInt1 = (uint)commandParams[2] + (uint)commandParams[3] * 0x80;\n          tempChar = commandParams[4] + commandParams[5] * -0x80;\n        }\n        else {\n          tempChar = commandParams[2] + commandParams[3] * -0x80;\n          tempInt1 = -1;\n        }\n        readAndReportData(param2,tempInt1,tempChar);\n        return;\n      case 0x10:\n        if (DAT_20000004 + 1 < 8) {\n          if (paramLength == 6) {\n            tempInt1 = (uint)commandParams[2] + (uint)commandParams[3] * 0x80;\n            tempChar = commandParams[4] + commandParams[5] * -0x80;\n          }\n          else {\n            tempChar = commandParams[2] + commandParams[3] * -0x80;\n            tempInt1 = -1;\n          }\n          DAT_20000004 = DAT_20000004 + '\\x01';\n          tempInt2 = (int)DAT_20000004;\n          tempInt3 = tempInt2 * 0xc;\n          (&DAT_20000188)[tempInt3] = param2;\n          (&DAT_2000018c)[tempInt2 * 3] = tempInt1;\n          (&DAT_20000190)[tempInt3] = tempChar;\n          (&DAT_20000191)[tempInt3] = flag;\n          return;\n        }\n        send_string_with_offset_08002f14(&DAT_200003d4,\"too many queries\",(int)DAT_20000004,flag,additionalParam);\n        return;\n      case 0x18:\n        if (DAT_20000004 < 1) {\n          DAT_20000004 = 0xff;\n          return;\n        }\n      }\n      for (tempUInt1 = 0; tempInt1 = DAT_20000004 + 1, (int)tempUInt1 < tempInt1; tempUInt1 = tempUInt1 + 1 & 0xff) {\n        if (param2 == (&DAT_20000188)[tempUInt1 * 0xc]) goto LAB_08001e66;\n      }\n      tempUInt1 = 0;\nLAB_08001e66:\n      for (; (int)tempUInt1 < tempInt1; tempUInt1 = tempUInt1 + 1 & 0xff) {\n        if (tempUInt1 < 8) {\n          tempInt2 = (tempUInt1 + 1) * 0xc;\n          tempInt3 = tempUInt1 * 0xc;\n          (&DAT_20000188)[tempInt3] = (&DAT_20000188)[tempInt2];\n          (&DAT_2000018c)[tempUInt1 * 3] = (&DAT_2000018c)[(tempUInt1 + 1) * 3];\n          (&DAT_20000190)[tempInt3] = (&DAT_20000190)[tempInt2];\n          (&DAT_20000191)[tempInt3] = (&DAT_20000191)[tempInt2];\n        }\n      }\n      DAT_20000004 = DAT_20000004 + -1;\n      return;\n    }\n    break;\n  case 0x78:\n    tempInt1 = (uint)*commandParams + (uint)commandParams[1] * 0x80;\n    if ((1 < paramLength) && (tempInt1 != 0)) {\n      DAT_2000012c = tempInt1;\n    }\n    if (DAT_20000170 == '\\0') {\n      enableI2CPins();\n      return;\n    }\n    break;\n  case 0x7a:\n    if ((1 < paramLength) &&\n       (DAT_20000008 = (uint)*commandParams + (uint)commandParams[1] * 0x80, DAT_20000008 == 0)) {\n      DAT_20000008 = 1;\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cd0": "process_command_08001cd0",
                "param_1": "commandType",
                "param_2": "paramLength",
                "param_3": "commandParams",
                "param_4": "additionalParam",
                "bVar1": "param1",
                "bVar2": "param2",
                "bVar3": "param3",
                "uVar4": "result",
                "bVar5": "param4",
                "cVar6": "tempChar",
                "iVar7": "tempInt1",
                "iVar8": "tempInt2",
                "uVar9": "tempUInt1",
                "uVar10": "tempUInt2",
                "iVar11": "tempInt3",
                "bVar12": "flag"
            },
            "calling": [],
            "called": [
                "pin_in_pinmap",
                "FUN_08002f14",
                "readAndReportData",
                "attachServo",
                "pinNametoDigitalPin",
                "FUN_08002f1e",
                "endTransmission",
                "getPinState",
                "enableI2CPins",
                "analogWriteCallback",
                "beginTransmission",
                "getPinMode",
                "attached",
                "setPinModeCallback",
                "wireWrite",
                "detachServo"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080022f8": {
            "entrypoint": "0x080022f8",
            "current_name": "process_sensor_data_080022f8",
            "code": "\nvoid processSensorData_080022f8(void)\n\n{\n  bool bVar1;\n  int iVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  uint uVar5;\n  \n  checkDigitalInputs();\n  while (iVar2 = processInputLoop(&DAT_200003d4), iVar2 != 0) {\n    processInput(&DAT_200003d4);\n  }\n  DAT_20000118 = millis();\n  if (DAT_20000008 < (uint)(DAT_20000118 - DAT_2000017c)) {\n    DAT_2000017c = DAT_2000017c + DAT_20000008;\n    for (uVar4 = 0; uVar4 < 0x3c; uVar4 = uVar4 + 1 & 0xff) {\n      uVar5 = uVar4 - 0x2e & 0xff;\n      if (uVar5 < 0xe) {\n        if (uVar4 < 0x3c) {\n          iVar2 = (int)(char)(&DAT_0800a908)[uVar4];\n        }\n        else {\n          iVar2 = -1;\n        }\n        iVar2 = nameToDigitalPin(iVar2);\n        if (iVar2 == 0) {\n          bVar1 = false;\n        }\n        else {\n          if (uVar4 < 0x3c) {\n            iVar2 = (int)(char)(&DAT_0800a908)[uVar4];\n          }\n          else {\n            iVar2 = -1;\n          }\n          iVar2 = nameToDigitalPin(iVar2);\n          if (iVar2 == 1) {\n            bVar1 = false;\n          }\n          else {\n            iVar2 = getPinMode(&DAT_200003d4,uVar4);\n            if (iVar2 == 2) {\n              bVar1 = true;\n            }\n            else {\n              bVar1 = false;\n            }\n          }\n        }\n      }\n      else {\n        bVar1 = false;\n      }\n      if ((bVar1) && ((DAT_20000114 >> uVar5 & 1U) != 0)) {\n        uVar3 = readAnalogValue(uVar5);\n        sendAnalogData(&DAT_200003d4,uVar5,uVar3);\n      }\n    }\n    if (-1 < DAT_20000004) {\n      for (uVar4 = 0; (int)uVar4 < DAT_20000004 + 1; uVar4 = uVar4 + 1 & 0xff) {\n        iVar2 = uVar4 * 0xc;\n        readAndReportData((&DAT_20000188)[iVar2],(&DAT_2000018c)[uVar4 * 3],(&DAT_20000190)[iVar2],\n                          (&DAT_20000191)[iVar2]);\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080022f8": "process_sensor_data_080022f8",
                "execute_function_08002ec4": "processInputLoop",
                "pinNametoDigitalPin": "nameToDigitalPin",
                "analogRead": "readAnalogValue",
                "send_analog_data_08002ef2": "sendAnalogData"
            },
            "calling": [
                "main"
            ],
            "called": [
                "processInput",
                "analogRead",
                "readAndReportData",
                "FUN_08002ec4",
                "pinNametoDigitalPin",
                "millis",
                "checkDigitalInputs",
                "getPinMode",
                "FUN_08002ef2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002400": {
            "entrypoint": "0x08002400",
            "current_name": "check_flagged_bytes_08002400",
            "code": "\nundefined4 check_flagged_bytes_08002400(int index)\n\n{\n  uint counter;\n  \n  counter = 0;\n  while( true ) {\n    if (0xb < counter) {\n      return 0;\n    }\n    if (((&DAT_20000258)[(index * 0xc + counter) * 8] & 0x40) != 0) break;\n    counter = counter + 1 & 0xff;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002400": "check_flagged_bytes_08002400",
                "param_1": "index",
                "uVar1": "counter"
            },
            "calling": [
                "FUN_080025ac",
                "detach"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800242c": {
            "entrypoint": "0x0800242c",
            "current_name": "initialize_timer_0800242c",
            "code": "\nvoid initializeTimer_0800242c(undefined4 param1,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  initializeTimer_0800242cPulse(param1,60000,0x5dc,&timerCallback,param4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800242c": "initialize_timer_0800242c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "TimerPulseInit": "initializeTimerPulse",
                "LAB_08002444_1": "timerCallback"
            },
            "calling": [
                "FUN_080025ac"
            ],
            "called": [
                "TimerPulseInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002578": {
            "entrypoint": "0x08002578",
            "current_name": "deinit_timer_pulse_08002578",
            "code": "\nvoid deinitTimerPulse_08002578(void)\n\n{\n  deinitTimerPulse_08002578();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002578": "deinit_timer_pulse_08002578",
                "TimerPulseDeinit": "deinitTimerPulse"
            },
            "calling": [
                "detach"
            ],
            "called": [
                "TimerPulseDeinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002580": {
            "entrypoint": "0x08002580",
            "current_name": "initialize_value_08002580",
            "code": "\nvoid initializeValue_08002580(byte *outputByte)\n\n{\n  char incrementedValue;\n  uint dataValue;\n  \n  dataValue = (uint)DAT_20000250;\n  if (0xb < dataValue) {\n    *outputByte = 0xff;\n    return;\n  }\n  incrementedValue = DAT_20000250 + 1;\n  *outputByte = DAT_20000250;\n  DAT_20000250 = incrementedValue;\n  *(undefined4 *)(&DAT_2000025c + dataValue * 8) = 0x5dc;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002580": "initialize_value_08002580",
                "param_1": "outputByte",
                "cVar1": "incrementedValue",
                "uVar2": "dataValue"
            },
            "calling": [
                "FUN_080004d4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025ac": {
            "entrypoint": "0x080025ac",
            "current_name": "configure_pin_and_activate_timer_080025ac",
            "code": "\nbyte configurePinAndActivateTimer_080025ac(byte *pinState,uint pinNumber,int value1,int value2)\n\n{\n  uint newPinState;\n  uint shiftedPinNumber;\n  uint dividedPinState;\n  int temp;\n  \n  if (*pinState < 0xc) {\n    setPinMode(pinNumber,1,value1,*pinState,value2);\n    shiftedPinNumber = (uint)*pinState;\n    newPinState = (byte)(&DAT_20000258)[shiftedPinNumber * 8] & 0xffffffc0 | pinNumber & 0x3f;\n    (&DAT_20000258)[shiftedPinNumber * 8] = (char)newPinState;\n    temp = -value1 + 0x220;\n    if (temp < 0) {\n      temp = -value1 + 0x223;\n    }\n    pinState[1] = (byte)((uint)(temp << 0x16) >> 0x18);\n    temp = -value2 + 0x960;\n    if (temp < 0) {\n      temp = -value2 + 0x963;\n    }\n    pinState[2] = (byte)((uint)(temp << 0x16) >> 0x18);\n    dividedPinState = *pinState / 0xc;\n    temp = checkIfTimerIsActive(dividedPinState,newPinState,shiftedPinNumber,(uint)*pinState * -0x55555555);\n    if (temp == 0) {\n      DAT_200002fc = (undefined)dividedPinState;\n      initializeISR();\n    }\n    (&DAT_20000258)[(uint)*pinState * 8] = (&DAT_20000258)[(uint)*pinState * 8] | 0x40;\n  }\n  return *pinState;\n}\n\n",
            "renaming": {
                "FUN_080025ac": "configure_pin_and_activate_timer_080025ac",
                "param_1": "pinState",
                "param_2": "pinNumber",
                "param_3": "value1",
                "param_4": "value2",
                "pinMode": "setPinMode",
                "uVar1": "newPinState",
                "uVar2": "shiftedPinNumber",
                "uVar3": "dividedPinState",
                "iVar4": "temp",
                "isTimerActive": "checkIfTimerIsActive",
                "initISR": "initializeISR"
            },
            "calling": [
                "attachServo",
                "FUN_08002634"
            ],
            "called": [
                "initISR",
                "isTimerActive",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002634": {
            "entrypoint": "0x08002634",
            "current_name": "initialize_timer_08002634",
            "code": "\nvoid initialize_timer_08002634(undefined4 pin_config_1,undefined4 pin_config_2,undefined4 timer_frequency,undefined4 timer_config)\n\n{\n  configure_and_activate_timer(pin_config_1,pin_config_2,0x220,0x960,timer_config);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002634": "initialize_timer_08002634",
                "param_1": "pin_config_1",
                "param_2": "pin_config_2",
                "param_3": "timer_frequency",
                "param_4": "timer_config",
                "configure_pin_and_activate_timer_080025ac": "configure_and_activate_timer"
            },
            "calling": [
                "attachServo"
            ],
            "called": [
                "FUN_080025ac"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002644": {
            "entrypoint": "0x08002644",
            "current_name": "handle_byte_08002644",
            "code": "\nvoid handleByte_08002644(byte *byteArray,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  byte originalByte;\n  uint byteValue;\n  int timerStatus;\n  \n  byteValue = (uint)*byteArray;\n  originalByte = (&DAT_20000258)[byteValue * 8];\n  (&DAT_20000258)[byteValue * 8] = originalByte & 0xbf;\n  timerStatus = isTimerActive(byteValue / 0xc,param2,originalByte & 0xbf,byteValue * -0x55555555,param4);\n  if (timerStatus == 0) {\n    finISR(&DAT_200002b8);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002644": "handle_byte_08002644",
                "param_1": "byteArray",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "bVar1": "originalByte",
                "uVar2": "byteValue",
                "iVar3": "timerStatus"
            },
            "calling": [
                "detachServo"
            ],
            "called": [
                "finISR",
                "isTimerActive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800267c": {
            "entrypoint": "0x0800267c",
            "current_name": "update_value_based_on_conditions_0800267c",
            "code": "\nvoid updateValueBasedOnConditions_0800267c(byte *dataBuffer,int valueToCheck)\n\n{\n  int adjustedValue;\n  \n  if (*dataBuffer < 0xc) {\n    adjustedValue = (0x88 - (char)dataBuffer[1]) * 4;\n    if ((adjustedValue - valueToCheck == 0 || adjustedValue < valueToCheck) &&\n       (adjustedValue = (600 - (char)dataBuffer[2]) * 4,\n       valueToCheck == adjustedValue || valueToCheck + (600 - (char)dataBuffer[2]) * -4 < 0 != SBORROW4(valueToCheck,adjustedValue)))\n    {\n      adjustedValue = valueToCheck;\n    }\n    *(int *)(&DAT_2000025c + (uint)*dataBuffer * 8) = adjustedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800267c": "update_value_based_on_conditions_0800267c",
                "param_1": "dataBuffer",
                "param_2": "valueToCheck",
                "iVar1": "adjustedValue"
            },
            "calling": [
                "FUN_080026b0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080026b0": {
            "entrypoint": "0x080026b0",
            "current_name": "set_servo_position_080026b0",
            "code": "\nvoid setServoPosition_080026b0(int servoPin,int angle)\n\n{\n  if (angle < 0x220) {\n    if (angle < 0) {\n      angle = 0;\n    }\n    else if (0xb4 < angle) {\n      angle = 0xb4;\n    }\n    angle = mapAngleRange(angle,0,0xb4,(0x88 - *(char *)(servoPin + 1)) * 4,\n                  (600 - *(char *)(servoPin + 2)) * 4);\n  }\n  setServoMicroseconds(servoPin,angle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026b0": "set_servo_position_080026b0",
                "param_1": "servoPin",
                "param_2": "angle",
                "map": "mapAngleRange",
                "writeMicroseconds": "setServoMicroseconds"
            },
            "calling": [
                "FUN_0800021a"
            ],
            "called": [
                "writeMicroseconds",
                "map"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080026f8": {
            "entrypoint": "0x080026f8",
            "current_name": "get_bit_value_080026f8",
            "code": "\nuint getBitValue_080026f8(byte *inputByte)\n\n{\n  return ((uint)(byte)(&DAT_20000258)[(uint)*inputByte * 8] << 0x19) >> 0x1f;\n}\n\n",
            "renaming": {
                "FUN_080026f8": "get_bit_value_080026f8",
                "param_1": "inputByte"
            },
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800270c": {
            "entrypoint": "0x0800270c",
            "current_name": "calculate_difference_0800270c",
            "code": "\nint calculate_difference_0800270c(void)\n\n{\n  return (uint)DAT_200003b7 - (uint)DAT_200003b5;\n}\n\n",
            "renaming": {
                "FUN_0800270c": "calculate_difference_0800270c"
            },
            "calling": [
                "readAndReportData"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002720": {
            "entrypoint": "0x08002720",
            "current_name": "read_byte_from_memory_08002720",
            "code": "\nuint readByteFromMemory_08002720(void)\n\n{\n  uint currentIndex;\n  \n  currentIndex = (uint)DAT_200003b5;\n  if (currentIndex < DAT_200003b7) {\n    DAT_200003b5 = DAT_200003b5 + 1;\n    return (uint)*(byte *)(DAT_200003c8 + currentIndex);\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08002720": "read_byte_from_memory_08002720",
                "uVar1": "currentIndex"
            },
            "calling": [
                "wireRead"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f0": {
            "entrypoint": "0x080027f0",
            "current_name": "write_data_080027f0",
            "code": "\nuint write_data_080027f0(int base_address,undefined4 buffer,uint length)\n\n{\n  int result;\n  uint new_length;\n  \n  if (DAT_200003b4 == '\\0') {\n    result = i2c_slave_write_IT(base_address + 0x14,buffer,length & 0xffff);\n    if (result == 0) {\n      return length;\n    }\n    return 0;\n  }\n  new_length = DAT_200003b8 + length;\n  if (DAT_200003c5 < new_length) {\n    if (new_length < 0x20) {\n      new_length = 0x20;\n    }\n    DAT_200003cc = realloc(DAT_200003cc,new_length);\n    if (DAT_200003cc == 0) {\n      DAT_200003c5 = 0;\n    }\n    else {\n      DAT_200003c5 = (byte)new_length;\n    }\n  }\n  if (DAT_200003cc == 0) {\n    *(undefined4 *)(base_address + 4) = 1;\n    return 0;\n  }\n  memcpy((uint)DAT_200003b6 + DAT_200003cc,buffer,length);\n  DAT_200003b6 = DAT_200003b6 + (char)length;\n  DAT_200003b8 = DAT_200003b6;\n  return length;\n}\n\n",
            "renaming": {
                "FUN_080027f0": "write_data_080027f0",
                "param_1": "base_address",
                "param_2": "buffer",
                "param_3": "length",
                "iVar1": "result",
                "uVar2": "new_length"
            },
            "calling": [],
            "called": [
                "memcpy",
                "realloc",
                "i2c_slave_write_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800288c": {
            "entrypoint": "0x0800288c",
            "current_name": "i2c_write_data_0800288c",
            "code": "\nundefined4 i2c_write_data_0800288c(int device_address,undefined data)\n\n{\n  undefined4 is_success;\n  int write_result;\n  uint new_data_length;\n  undefined data_byte;\n  \n  data_byte = data;\n  if (DAT_200003b4 == '\\0') {\n    write_result = i2c_slave_write_IT(device_address + 0x14,&data_byte,1);\n    if (write_result == 0) {\n      is_success = 1;\n    }\n    else {\n      is_success = 0;\n    }\n  }\n  else {\n    new_data_length = DAT_200003b8 + 1;\n    if (DAT_200003c5 < new_data_length) {\n      if (new_data_length < 0x20) {\n        new_data_length = 0x20;\n      }\n      DAT_200003cc = realloc(DAT_200003cc,new_data_length);\n      if (DAT_200003cc == 0) {\n        DAT_200003c5 = 0;\n      }\n      else {\n        DAT_200003c5 = (byte)new_data_length;\n      }\n    }\n    if (DAT_200003cc == 0) {\n      *(undefined4 *)(device_address + 4) = 1;\n      is_success = 0;\n    }\n    else {\n      *(undefined *)(DAT_200003cc + (uint)DAT_200003b6) = data_byte;\n      DAT_200003b6 = DAT_200003b6 + 1;\n      is_success = 1;\n      DAT_200003b8 = DAT_200003b6;\n    }\n  }\n  return is_success;\n}\n\n",
            "renaming": {
                "FUN_0800288c": "i2c_write_data_0800288c",
                "param_1": "device_address",
                "param_2": "data",
                "uVar1": "is_success",
                "iVar2": "write_result",
                "uVar3": "new_data_length",
                "local_11": "data_byte"
            },
            "calling": [
                "wireWrite"
            ],
            "called": [
                "realloc",
                "i2c_slave_write_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800291c": {
            "entrypoint": "0x0800291c",
            "current_name": "initialize_function_0800291c",
            "code": "\nvoid initializeFunction_0800291c(undefined4 *functionParams)\n\n{\n  functionParams[1] = 0;\n  functionParams[2] = 1000;\n  *functionParams = &PTR_FUN_0800288c_1_0800a5a0;\n  *(undefined *)(functionParams + 0x1b) = 0x19;\n  *(undefined *)((int)functionParams + 0x6d) = 0x18;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800291c": "initialize_function_0800291c",
                "param_1": "functionParams"
            },
            "calling": [
                "FUN_08002948"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002948": {
            "entrypoint": "0x08002948",
            "current_name": "process_param_08002948",
            "code": "\nvoid processParam_08002948(int inputParam,int flag)\n\n{\n  if (inputParam != 1) {\n    return;\n  }\n  if (flag == 0xffff) {\n    executeDataTransfer(&DAT_20000314);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002948": "process_param_08002948",
                "param_1": "inputParam",
                "param_2": "flag",
                "TwoWire": "executeDataTransfer"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN7TwoWire8rxBufferE"
            ],
            "called": [
                "TwoWire"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002968": {
            "entrypoint": "0x08002968",
            "current_name": "initialize_i2_c_08002968",
            "code": "\nvoid initializeI2C_08002968(int deviceAddress,uint configBits)\n\n{\n  int shiftedConfigBits;\n  int devicePort;\n  \n  DAT_200003b5 = 0;\n  DAT_200003b7 = 0;\n  if (DAT_200003c8 != 0) {\n    memset(DAT_200003c8,0,DAT_200003c4);\n  }\n  DAT_200003b6 = 0;\n  DAT_200003b8 = 0;\n  if (DAT_200003cc != 0) {\n    memset(DAT_200003cc,0,DAT_200003c5);\n  }\n  DAT_200003b4 = 0;\n  shiftedConfigBits = (configBits & 0x7f) << 1;\n  *(char *)(deviceAddress + 0x10) = (char)shiftedConfigBits;\n  if (configBits == 0x33) {\n    *(undefined *)(deviceAddress + 0x11) = 1;\n  }\n  else {\n    *(undefined *)(deviceAddress + 0x11) = 0;\n  }\n  devicePort = deviceAddress + 0x14;\n  i2c_custom_init(devicePort,100000,0x4000,shiftedConfigBits,*(undefined *)(deviceAddress + 0x11));\n  if (*(char *)(deviceAddress + 0x11) == '\\0') {\n    i2c_attachSlaveTxEvent(devicePort,&LAB_08002774_1);\n    i2c_attachSlaveRxEvent(devicePort,&LAB_08002b00_1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002968": "initialize_i2_c_08002968",
                "param_1": "deviceAddress",
                "param_2": "configBits",
                "iVar1": "shiftedConfigBits",
                "iVar2": "devicePort"
            },
            "calling": [
                "FUN_08002a1c"
            ],
            "called": [
                "i2c_attachSlaveRxEvent",
                "i2c_custom_init",
                "memset",
                "i2c_attachSlaveTxEvent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a1c": {
            "entrypoint": "0x08002a1c",
            "current_name": "initialize_i2_c_08002a1c",
            "code": "\nvoid initialize_I2C_08002a1c(undefined4 param1,undefined param2,undefined4 param3,undefined4 param4)\n\n{\n  initialize_i2_c_08002968(param1,param2,param3,param4,param4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002a1c": "initialize_i2_c_08002a1c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "calling": [
                "FUN_08002a26"
            ],
            "called": [
                "FUN_08002968"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a26": {
            "entrypoint": "0x08002a26",
            "current_name": "initialize_i2_c_08002a26",
            "code": "\nvoid initialize_i2_c_08002a26(undefined4 device_address,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  initialize_i2_c_08002a26_08002a1c(device_address,0x33,param_3,param_4,param_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002a26": "initialize_i2_c_08002a26",
                "param_1": "device_address"
            },
            "calling": [
                "enableI2CPins"
            ],
            "called": [
                "FUN_08002a1c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a30": {
            "entrypoint": "0x08002a30",
            "current_name": "initialize_data_08002a30",
            "code": "\nvoid initializeData_08002a30(undefined4 status,int inputValue)\n\n{\n  DAT_200003b4 = 1;\n  DAT_200003d0 = (char)(inputValue << 1);\n  DAT_200003b6 = 0;\n  DAT_200003b8 = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002a30": "initialize_data_08002a30",
                "param_1": "status",
                "param_2": "inputValue"
            },
            "calling": [
                "readAndReportData",
                "FUN_08002b68",
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a58": {
            "entrypoint": "0x08002a58",
            "current_name": "check_i2_c_status_08002a58",
            "code": "\nundefined4 checkI2CStatus_08002a58(int inputAddress)\n\n{\n  int resultCode;\n  undefined4 status;\n  \n  if (*(char *)(inputAddress + 0x11) == '\\0') {\n    status = 4;\n  }\n  else {\n    resultCode = i2c_master_write(inputAddress + 0x14,DAT_200003d0,DAT_200003cc,DAT_200003b8);\n    if (resultCode == 0) {\n      status = 0;\n    }\n    else if (resultCode == 1) {\n      status = 1;\n    }\n    else {\n      status = 4;\n    }\n    if (DAT_200003cc != 0) {\n      memset(DAT_200003cc,0,DAT_200003c5);\n    }\n    DAT_200003b6 = 0;\n    DAT_200003b8 = 0;\n    DAT_200003b4 = 0;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002a58": "check_i2_c_status_08002a58",
                "param_1": "inputAddress",
                "iVar1": "resultCode",
                "uVar2": "status"
            },
            "calling": [
                "readAndReportData",
                "FUN_08002b68",
                "endTransmission"
            ],
            "called": [
                "i2c_master_write",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ac0": {
            "entrypoint": "0x08002ac0",
            "current_name": "check_i2c_status_08002ac0",
            "code": "\nvoid check_i2c_status_08002ac0(undefined4 device_address,undefined4 register_address,undefined4 data,undefined4 status)\n\n{\n  check_i2_c_status_08002a58(device_address,1,data,status,status);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ac0": "check_i2c_status_08002ac0",
                "param_1": "device_address",
                "param_2": "register_address",
                "param_3": "data",
                "param_4": "status"
            },
            "calling": [
                "sysexCallback"
            ],
            "called": [
                "FUN_08002a58"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002acc": {
            "entrypoint": "0x08002acc",
            "current_name": "resize_array_08002acc",
            "code": "\nvoid resizeArray_08002acc(uint newSize,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  if (DAT_200003c4 < newSize) {\n    if (newSize < 0x20) {\n      newSize = 0x20;\n    }\n    DAT_200003c8 = realloc(DAT_200003c8,newSize,param3,(uint)DAT_200003c4,param4);\n    if (DAT_200003c8 == 0) {\n      DAT_200003c4 = 0;\n    }\n    else {\n      DAT_200003c4 = (byte)newSize;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002acc": "resize_array_08002acc",
                "param_1": "newSize",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "calling": [
                "FUN_08002b68"
            ],
            "called": [
                "realloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b68": {
            "entrypoint": "0x08002b68",
            "current_name": "perform_i2_c_transfer_08002b68",
            "code": "\nundefined4\nperformI2CTransfer_08002b68(undefined4 *i2cController,uint slaveAddress,undefined4 rxBufferSize,uint txData,byte txByteCount)\n\n{\n  int status;\n  uint tempByteCount;\n  uint tempTxData;\n  \n  tempByteCount = (uint)txByteCount;\n  if (*(char *)((int)i2cController + 0x11) == '\\0') {\n    return 0;\n  }\n  tempTxData = txData;\n  allocateRxBuffer(rxBufferSize);\n  if (DAT_200003c8 != 0) {\n    if (tempByteCount != 0) {\n      beginTransmission(i2cController,slaveAddress);\n      if (3 < tempByteCount) {\n        tempByteCount = 3;\n      }\n      while( true ) {\n        if (tempByteCount == 0) break;\n        (**(code **)*i2cController)(i2cController,txData >> ((tempByteCount - 1 & 0x1f) << 3) & 0xff);\n        tempByteCount = tempByteCount - 1 & 0xff;\n      }\n      check_i2_c_status_08002a58(i2cController,0);\n    }\n    status = i2c_master_read(i2cController + 5,(slaveAddress & 0x7f) << 1,DAT_200003c8,rxBufferSize,tempTxData);\n    if (status != 0) {\n      rxBufferSize = 0;\n    }\n    DAT_200003b5 = 0;\n    DAT_200003b7 = (char)rxBufferSize;\n    return rxBufferSize;\n  }\n  i2cController[1] = 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002b68": "perform_i2_c_transfer_08002b68",
                "param_1": "i2cController",
                "param_2": "slaveAddress",
                "param_3": "rxBufferSize",
                "param_4": "txData",
                "param_5": "txByteCount",
                "iVar1": "status",
                "uVar2": "tempByteCount",
                "uVar3": "tempTxData"
            },
            "calling": [
                "FUN_08002c00"
            ],
            "called": [
                "FUN_08002a58",
                "beginTransmission",
                "i2c_master_read",
                "allocateRxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c00": {
            "entrypoint": "0x08002c00",
            "current_name": "execute_i2c_transfer_08002c00",
            "code": "\nvoid execute_i2c_transfer_08002c00(void)\n\n{\n  perform_i2c_transfer();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c00": "execute_i2c_transfer_08002c00",
                "perform_i2_c_transfer_08002b68": "perform_i2c_transfer"
            },
            "calling": [
                "requestFrom"
            ],
            "called": [
                "FUN_08002b68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c14": {
            "entrypoint": "0x08002c14",
            "current_name": "execute_i2c_transfer_08002c14",
            "code": "\nvoid execute_i2c_transfer_08002c14(void)\n\n{\n  execute_i2c_transfer_08002c14_08002c00();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c14": "execute_i2c_transfer_08002c14"
            },
            "calling": [
                "readAndReportData"
            ],
            "called": [
                "FUN_08002c00"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c1e": {
            "entrypoint": "0x08002c1e",
            "current_name": "process_parameters_08002c1e",
            "code": "\nvoid processParameters_08002c1e(undefined4 param1,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  process_param_08002948(1,0xffff,param3,param4,param4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c1e": "process_parameters_08002c1e",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "calling": [],
            "called": [
                "FUN_08002948"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2c": {
            "entrypoint": "0x08002c2c",
            "current_name": "execute_callback_08002c2c",
            "code": "\nvoid executeCallback_08002c2c(undefined4 argument1,undefined4 argument2,undefined4 argument3,undefined4 argument4)\n\n{\n  if (DAT_200005d4 != (code *)0x0) {\n    (*DAT_200005d4)(argument2,argument3,argument3,DAT_200005d4,argument4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c2c": "execute_callback_08002c2c",
                "param_1": "argument1",
                "param_2": "argument2",
                "param_3": "argument3",
                "param_4": "argument4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ce0": {
            "entrypoint": "0x08002ce0",
            "current_name": "initialize_firmata_08002ce0",
            "code": "\nint initializeFirmata_08002ce0(int baseAddress)\n\n{\n  int offset;\n  \n  FirmataMarshaller(baseAddress + 0x40);\n  offset = baseAddress + 0x44;\n  FirmataParser(offset,baseAddress,0x40);\n  *(undefined *)(baseAddress + 0xc4) = 0;\n  *(undefined4 *)(baseAddress + 200) = 0;\n  *(undefined *)(baseAddress + 0x1f8) = 0;\n  setParameters(offset,0xe0,analogCallback1 + 1,0);\n  setParameters(offset,0x90,callbackFunction1,0);\n  setParameters(offset,0xc0,callbackFunction2,0);\n  setParameters(offset,0xd0,callbackFunction3,0);\n  setParameters(offset,0xf4,callbackFunction4,0);\n  setParameters(offset,0xf5,callbackFunction5,0);\n  setParametersAlt(offset,0x71,callbackFunction6,0);\n  attachCallback(offset,0xf0,callbackFunction7,0);\n  updateParameters1(offset,0x79,callbackFunction8,baseAddress);\n  updateParameters2(offset,0xf9,callbackFunction9,baseAddress);\n  updateParameters2(offset,0xff,callbackFunction10,0);\n  return baseAddress;\n}\n\n",
            "renaming": {
                "FUN_08002ce0": "initialize_firmata_08002ce0",
                "param_1": "baseAddress",
                "iVar1": "offset",
                "set_parameters_08003306": "setParameters",
                "set_parameters_08003366": "setParametersAlt",
                "attach": "attachCallback",
                "update_parameters_08003346": "updateParameters1",
                "update_parameters_08003350": "updateParameters2",
                "staticAnalogCallback": "analogCallback1",
                "&LAB_08002c40_1": "callbackFunction1",
                "&LAB_08002c7c_1": "callbackFunction2",
                "&LAB_08002c90_1": "callbackFunction3",
                "&LAB_08002c54_1": "callbackFunction4",
                "&LAB_08002c68_1": "callbackFunction5",
                "&LAB_08002ca4_1": "callbackFunction6",
                "&LAB_08002cb8_1": "callbackFunction7",
                "&LAB_08002e1a_1": "callbackFunction8",
                "&LAB_08002dea_1": "callbackFunction9",
                "&LAB_08002cd0_1": "callbackFunction10"
            },
            "calling": [
                "FUN_08002dbc"
            ],
            "called": [
                "FUN_08003350",
                "FirmataMarshaller",
                "FUN_08003346",
                "FUN_08003306",
                "FirmataParser",
                "FUN_08003366",
                "attach"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002dbc": {
            "entrypoint": "0x08002dbc",
            "current_name": "check_and_execute_firmata_command_08002dbc",
            "code": "\nvoid checkAndExecuteFirmataCommand_08002dbc(int commandType,int parameter)\n\n{\n  if (commandType != 1) {\n    return;\n  }\n  if (parameter == 0xffff) {\n    FirmataClass(&DAT_200003d4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002dbc": "check_and_execute_firmata_command_08002dbc",
                "param_1": "commandType",
                "param_2": "parameter"
            },
            "calling": [],
            "called": [
                "FirmataClass"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ddc": {
            "entrypoint": "0x08002ddc",
            "current_name": "send_version_with_offset_08002ddc",
            "code": "\nvoid send_version_with_offset_08002ddc(int base_address,undefined4 param_a,undefined4 param_b,undefined4 param_c)\n\n{\n  sendVersion(base_address + 0x40,2,5,param_c,param_c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ddc": "send_version_with_offset_08002ddc",
                "param_1": "base_address",
                "param_2": "param_a",
                "param_3": "param_b",
                "param_4": "param_c"
            },
            "calling": [
                "FUN_08002e26"
            ],
            "called": [
                "sendVersion"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002df6": {
            "entrypoint": "0x08002df6",
            "current_name": "send_firmware_version_if_not_zero_08002df6",
            "code": "\nvoid send_firmware_version_if_not_zero_08002df6(int device_address)\n\n{\n  undefined *firmware_data_ptr;\n  \n  if (*(byte *)(device_address + 0xc4) == 0) {\n    return;\n  }\n  firmware_data_ptr = *(undefined **)(device_address + 200);\n  sendFirmwareVersion(device_address + 0x40,*firmware_data_ptr,firmware_data_ptr[1],*(byte *)(device_address + 0xc4) - 2,firmware_data_ptr + 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002df6": "send_firmware_version_if_not_zero_08002df6",
                "param_1": "device_address",
                "puVar1": "firmware_data_ptr"
            },
            "calling": [
                "FUN_08002e26"
            ],
            "called": [
                "sendFirmwareVersion"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002e26": {
            "entrypoint": "0x08002e26",
            "current_name": "update_device_info_08002e26",
            "code": "\nvoid updateDeviceInfo_08002e26(int deviceInfoAddress,undefined4 newParamValue)\n\n{\n  *(undefined4 *)(deviceInfoAddress + 0xc0) = newParamValue;\n  copy_value_08003154(deviceInfoAddress + 0x40);\n  printDeviceVersion(deviceInfoAddress);\n  printDeviceFirmwareVersion(deviceInfoAddress);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002e26": "update_device_info_08002e26",
                "param_1": "deviceInfoAddress",
                "param_2": "newParamValue",
                "printVersion(param_1)": "printDeviceVersion(deviceInfoAddress)",
                "printFirmwareVersion(param_1)": "printDeviceFirmwareVersion(deviceInfoAddress)"
            },
            "calling": [
                "FUN_08003048"
            ],
            "called": [
                "FUN_08003154",
                "printFirmwareVersion",
                "printVersion"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002e44": {
            "entrypoint": "0x08002e44",
            "current_name": "extract_and_modify_file_name_08002e44",
            "code": "\nvoid extractAndModifyFileName_08002e44(int inputStructure,int filePath,undefined undefined1,undefined undefined2)\n\n{\n  byte byteValue;\n  char charValue;\n  int cppIndex;\n  int lastSlashIndex;\n  undefined *dynamicDataPointer;\n  \n  cppIndex = strstr(filePath,\".cpp\");\n  lastSlashIndex = strrchr(filePath,0x2f);\n  if (lastSlashIndex == 0) {\n    lastSlashIndex = strrchr(filePath,0x5c);\n  }\n  if (lastSlashIndex != 0) {\n    filePath = lastSlashIndex + 1;\n  }\n  if (cppIndex == 0) {\n    charValue = strlen(filePath);\n    *(char *)(inputStructure + 0xc4) = charValue + '\\x02';\n  }\n  else {\n    *(char *)(inputStructure + 0xc4) = ((char)cppIndex - (char)filePath) + '\\x02';\n  }\n  free(*(undefined4 *)(inputStructure + 200));\n  byteValue = *(byte *)(inputStructure + 0xc4);\n  dynamicDataPointer = (undefined *)malloc(byteValue + 1);\n  *(undefined **)(inputStructure + 200) = dynamicDataPointer;\n  dynamicDataPointer[byteValue] = 0;\n  *dynamicDataPointer = undefined1;\n  dynamicDataPointer[1] = undefined2;\n  strncpy(dynamicDataPointer + 2,filePath,*(byte *)(inputStructure + 0xc4) - 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002e44": "extract_and_modify_file_name_08002e44",
                "param_1": "inputStructure",
                "param_2": "filePath",
                "param_3": "undefined1",
                "param_4": "undefined2",
                "bVar1": "byteValue",
                "cVar2": "charValue",
                "iVar3": "cppIndex",
                "iVar4": "lastSlashIndex",
                "puVar5": "dynamicDataPointer"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "strlen",
                "free",
                "strrchr",
                "strstr",
                "malloc",
                "strncpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ec4": {
            "entrypoint": "0x08002ec4",
            "current_name": "execute_function_08002ec4",
            "code": "\nvoid executeFunction_08002ec4(int functionPointer)\n\n{\n  (**(code **)(**(int **)(functionPointer + 0xc0) + 8))();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ec4": "execute_function_08002ec4",
                "param_1": "functionPointer"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ed2": {
            "entrypoint": "0x08002ed2",
            "current_name": "parse_and_process_08002ed2",
            "code": "\nvoid parse_and_process_08002ed2(int input_param)\n\n{\n  uint result;\n  \n  result = (**(code **)(**(int **)(input_param + 0xc0) + 0xc))();\n  if (result != 0xffffffff) {\n    handle_parse(input_param + 0x44,result & 0xff);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ed2": "parse_and_process_08002ed2",
                "param_1": "input_param",
                "uVar1": "result",
                "parse": "handle_parse"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "parse"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ef2": {
            "entrypoint": "0x08002ef2",
            "current_name": "send_analog_data_08002ef2",
            "code": "\nvoid sendAnalogData_08002ef2(int baseAddress,undefined4 param2,undefined2 param3,undefined4 param4)\n\n{\n  sendAnalog(baseAddress + 0x40,param2,param3,param4,param4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ef2": "send_analog_data_08002ef2",
                "param_1": "baseAddress",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "calling": [
                "loop",
                "reportAnalogCallback"
            ],
            "called": [
                "sendAnalog"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efe": {
            "entrypoint": "0x08002efe",
            "current_name": "send_digital_port_data_08002efe",
            "code": "\nvoid send_digital_port_data_08002efe(int port_offset,undefined4 param_2,undefined2 param_3,undefined4 param_4)\n\n{\n  sendDigitalPort(port_offset + 0x40,param_2,param_3,param_4,param_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002efe": "send_digital_port_data_08002efe",
                "param_1": "port_offset"
            },
            "calling": [
                "outputPort"
            ],
            "called": [
                "sendDigitalPort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f0a": {
            "entrypoint": "0x08002f0a",
            "current_name": "send_sysex_with_offset_08002f0a",
            "code": "\nvoid send_sysex_with_offset_08002f0a(int offset)\n\n{\n  sendSysex(offset + 0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f0a": "send_sysex_with_offset_08002f0a",
                "param_1": "offset"
            },
            "calling": [
                "readAndReportData"
            ],
            "called": [
                "sendSysex"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f14": {
            "entrypoint": "0x08002f14",
            "current_name": "send_string_with_offset_08002f14",
            "code": "\nvoid sendStringWithOffset_08002f14(int input)\n\n{\n  sendString(input + 0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f14": "send_string_with_offset_08002f14",
                "param_1": "input"
            },
            "calling": [
                "readAndReportData",
                "sysexCallback",
                "attachServo",
                "setPinModeCallback"
            ],
            "called": [
                "sendString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f1e": {
            "entrypoint": "0x08002f1e",
            "current_name": "execute_function_08002f1e",
            "code": "\nvoid executeFunction_08002f1e(int functionPointer)\n\n{\n  (**(code **)**(undefined4 **)(functionPointer + 0xc0))();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f1e": "execute_function_08002f1e",
                "param_1": "functionPointer"
            },
            "calling": [
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f2c": {
            "entrypoint": "0x08002f2c",
            "current_name": "update_parameter_08002f2c",
            "code": "\nvoid updateParameter_08002f2c(undefined4 param_1,uint param_2,undefined4 param_3)\n\n{\n  undefined4 updatedValue;\n  \n  if (param_2 == 0xd0) {\n    DAT_200005f0 = param_3;\n    return;\n  }\n  if (0xd0 < param_2) {\n    if (param_2 == 0xf4) {\n      DAT_200005e0 = param_3;\n      return;\n    }\n    updatedValue = param_3;\n    if ((param_2 != 0xf5) && (updatedValue = DAT_200005e4, param_2 == 0xe0)) {\n      DAT_200005d4 = param_3;\n      return;\n    }\n    DAT_200005e4 = updatedValue;\n    return;\n  }\n  if (param_2 == 0x90) {\n    DAT_200005dc = param_3;\n    return;\n  }\n  if (param_2 != 0xc0) {\n    return;\n  }\n  DAT_200005ec = param_3;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f2c": "update_parameter_08002f2c",
                "uVar1": "updatedValue"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f84": {
            "entrypoint": "0x08002f84",
            "current_name": "update_data_08002f84",
            "code": "\nvoid updateData_08002f84(undefined4 input1,int input2,undefined4 input3)\n\n{\n  if (input2 == 0xff) {\n    DAT_200005e8 = input3;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f84": "update_data_08002f84",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f94": {
            "entrypoint": "0x08002f94",
            "current_name": "initialize_data_08002f94",
            "code": "\nvoid initializeData_08002f94(undefined4 input1,undefined4 input2,undefined4 input3)\n\n{\n  DAT_200005d0 = input3;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f94": "initialize_data_08002f94",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fa0": {
            "entrypoint": "0x08002fa0",
            "current_name": "retrieve_value_from_offset_08002fa0",
            "code": "\nundefined retrieve_value_from_offset_08002fa0(int offset,int base_address)\n\n{\n  return *(undefined *)(base_address + offset + 0xcc);\n}\n\n",
            "renaming": {
                "FUN_08002fa0": "retrieve_value_from_offset_08002fa0",
                "param_1": "offset",
                "param_2": "base_address"
            },
            "calling": [
                "loop",
                "sysexCallback",
                "FUN_0800021a",
                "setPinModeCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fa8": {
            "entrypoint": "0x08002fa8",
            "current_name": "update_character_byte_08002fa8",
            "code": "\nvoid updateCharacterByte_08002fa8(int baseAddress,int offset,undefined newValue)\n\n{\n  if (*(char *)(baseAddress + offset + 0xcc) != '\\x7f') {\n    *(undefined *)(baseAddress + offset + 0xcc) = newValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002fa8": "update_character_byte_08002fa8",
                "param_1": "baseAddress",
                "param_2": "offset",
                "param_3": "newValue"
            },
            "calling": [
                "setPinModeCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fba": {
            "entrypoint": "0x08002fba",
            "current_name": "get_element_at_index_08002fba",
            "code": "\nundefined4 get_element_at_index_08002fba(int array_address,int index)\n\n{\n  return *(undefined4 *)(array_address + (index + 0x42) * 4);\n}\n\n",
            "renaming": {
                "FUN_08002fba": "get_element_at_index_08002fba",
                "param_1": "array_address",
                "param_2": "index"
            },
            "calling": [
                "sysexCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fc2": {
            "entrypoint": "0x08002fc2",
            "current_name": "store_value_in_array_08002fc2",
            "code": "\nvoid storeValueInArray_08002fc2(int arrayBase,int index,undefined4 value)\n\n{\n  *(undefined4 *)(arrayBase + (index + 0x42) * 4) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002fc2": "store_value_in_array_08002fc2",
                "param_1": "arrayBase",
                "param_2": "index",
                "param_3": "value"
            },
            "calling": [
                "FUN_0800021a",
                "setPinModeCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fca": {
            "entrypoint": "0x08002fca",
            "current_name": "blink_led_08002fca",
            "code": "\nvoid blinkLED_08002fca(undefined4 pinNumber,undefined4 LEDpin,int blinkCount,undefined4 onTime,\n                 undefined4 offTime)\n\n{\n  uint blinkIndex;\n  \n  for (blinkIndex = 0; (int)blinkIndex < blinkCount; blinkIndex = blinkIndex + 1 & 0xff) {\n    delay(offTime);\n    digitalWrite(LEDpin,1);\n    delay(onTime);\n    digitalWrite(LEDpin,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002fca": "blink_led_08002fca",
                "param_1": "pinNumber",
                "param_2": "LEDpin",
                "param_3": "blinkCount",
                "param_4": "onTime",
                "param_5": "offTime",
                "uVar1": "blinkIndex"
            },
            "calling": [
                "blinkVersion"
            ],
            "called": [
                "delay",
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003002": {
            "entrypoint": "0x08003002",
            "current_name": "initialize_strobe_blink_pin_08003002",
            "code": "\nvoid initializeStrobeBlinkPin_08003002(int pinNumber)\n\n{\n  if (*(char *)(pinNumber + 0x1f8) != '\\0') {\n    return;\n  }\n  setPinMode(0xd,1);\n  strobeBlinkPinWithDelay(pinNumber,0xd,2,0x28,0xd2);\n  delayInMillis(0xfa);\n  strobeBlinkPinWithDelay(pinNumber,0xd,5,0x28,0xd2);\n  delayInMillis(0x7d);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003002": "initialize_strobe_blink_pin_08003002",
                "param_1": "pinNumber",
                "pinMode": "setPinMode",
                "strobeBlinkPin": "strobeBlinkPinWithDelay",
                "delay": "delayInMillis"
            },
            "calling": [
                "FUN_08003048"
            ],
            "called": [
                "strobeBlinkPin",
                "delay",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003048": {
            "entrypoint": "0x08003048",
            "current_name": "initialize_device_info_08003048",
            "code": "\nvoid initializeDeviceInfo_08003048(undefined4 deviceInfo,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  begin(&DAT_20000700,param2,6,param4,param4);\n  blinkVersion(deviceInfo);\n  updateDeviceInfo(deviceInfo,&DAT_20000700);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003048": "initialize_device_info_08003048",
                "param_1": "deviceInfo",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "update_device_info_08002e26": "updateDeviceInfo"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "FUN_08002e26",
                "blinkVersion",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800307a": {
            "entrypoint": "0x0800307a",
            "current_name": "decode_data_0800307a",
            "code": "\nvoid decode_data_0800307a(undefined4 *data_ptr,uint data_length,byte *encoded_data,uint max_output_length)\n\n{\n  uint current_byte;\n  uint bit_offset;\n  uint output_length;\n  uint input_index;\n  \n  current_byte = (uint)*encoded_data;\n  if (max_output_length == 0) {\n    max_output_length = 0xffffffff;\n  }\n  input_index = 0;\n  bit_offset = 0;\n  output_length = 0;\n  while ((input_index < data_length && (output_length < max_output_length))) {\n    (***(code ***)(undefined4 *)*data_ptr)\n              ((undefined4 *)*data_ptr,((uint)encoded_data[input_index] << (bit_offset & 0xff) | current_byte) & 0x7f);\n    current_byte = (int)(uint)encoded_data[input_index] >> (7 - bit_offset & 0xff) & 0xff;\n    bit_offset = bit_offset + 1;\n    while ((output_length = output_length + 1, 6 < bit_offset && (output_length < max_output_length))) {\n      (***(code ***)(undefined4 *)*data_ptr)((undefined4 *)*data_ptr,current_byte & 0x7f);\n      current_byte = current_byte >> 7;\n      bit_offset = bit_offset - 7;\n    }\n    input_index = input_index + 1;\n  }\n  if ((bit_offset != 0) && (output_length < max_output_length)) {\n    (***(code ***)(undefined4 *)*data_ptr)((undefined4 *)*data_ptr,(1 << (bit_offset & 0xff)) - 1U & current_byte)\n    ;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800307a": "decode_data_0800307a",
                "param_1": "data_ptr",
                "param_2": "data_length",
                "param_3": "encoded_data",
                "param_4": "max_output_length",
                "uVar1": "current_byte",
                "uVar2": "bit_offset",
                "uVar3": "output_length",
                "uVar4": "input_index"
            },
            "calling": [
                "sendExtendedAnalog",
                "sendDigitalPort",
                "sendFirmwareVersion",
                "sendSysex",
                "sendAnalog"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003106": {
            "entrypoint": "0x08003106",
            "current_name": "encode_08003106",
            "code": "\nvoid execute-and-execute-and-encode_08003106(undefined4 *function_ptr,undefined4 param_a,undefined4 param_b,undefined4 param_c)\n\n{\n  undefined4 *pointer_to_function;\n  \n  pointer_to_function = (undefined4 *)*function_ptr;\n  if (pointer_to_function != (undefined4 *)0x0) {\n    (**(code **)*pointer_to_function)(pointer_to_function,0xf0);\n    (***(code ***)(undefined4 *)*function_ptr)((undefined4 *)*function_ptr,0x6f);\n    (***(code ***)(undefined4 *)*function_ptr)((undefined4 *)*function_ptr,param_a);\n    execute-and-encode_08003106_byte_stream(function_ptr,param_b,param_c,param_b);\n    (***(code ***)(undefined4 *)*function_ptr)((undefined4 *)*function_ptr,0xf7);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003106": "encode_08003106",
                "param_1": "function_ptr",
                "param_2": "param_a",
                "param_3": "param_b",
                "param_4": "param_c",
                "puVar1": "pointer_to_function",
                "encodeByteStream": "encode_byte_stream"
            },
            "calling": [
                "sendAnalog"
            ],
            "called": [
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800314e": {
            "entrypoint": "0x0800314e",
            "current_name": "initialize_pointer_0800314e",
            "code": "\nvoid initializePointer_0800314e(undefined4 *outputPointer)\n\n{\n  *outputPointer = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800314e": "initialize_pointer_0800314e",
                "param_1": "outputPointer"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003154": {
            "entrypoint": "0x08003154",
            "current_name": "copy_value_08003154",
            "code": "\nvoid copyValue_08003154(undefined4 *destPtr,undefined4 srcValue)\n\n{\n  *destPtr = srcValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003154": "copy_value_08003154",
                "param_1": "destPtr",
                "param_2": "srcValue"
            },
            "calling": [
                "FUN_08002e26"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003158": {
            "entrypoint": "0x08003158",
            "current_name": "process_data_08003158",
            "code": "\nvoid processData_08003158(undefined4 *dataPtr,uint size,ushort value)\n\n{\n  undefined4 *ptrVal;\n  ushort encodedValue;\n  \n  ptrVal = (undefined4 *)*dataPtr;\n  if (ptrVal != (undefined4 *)0x0) {\n    encodedValue = value;\n    if (((int)size < 0x10) && (value < 0x4000)) {\n      (**(code **)*ptrVal)(ptrVal,size | 0xe0);\n      encodeByteStream(dataPtr,2,&encodedValue);\n    }\n    else {\n      sendExtendedAnalog(dataPtr,size,2,&encodedValue);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003158": "process_data_08003158",
                "param_1": "dataPtr",
                "param_2": "size",
                "param_3": "value",
                "puVar1": "ptrVal",
                "local_a": "encodedValue"
            },
            "calling": [
                "FUN_08002ef2"
            ],
            "called": [
                "sendExtendedAnalog",
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800319e": {
            "entrypoint": "0x0800319e",
            "current_name": "call_and_encode_0800319e",
            "code": "\nvoid callAndEncode_0800319e(undefined4 *pointer,uint number,undefined2 value)\n\n{\n  undefined4 *pointer1;\n  undefined2 tempValue;\n  \n  pointer1 = (undefined4 *)*pointer;\n  if (pointer1 != (undefined4 *)0x0) {\n    tempValue = value;\n    (**(code **)*pointer1)(pointer1,number & 0xf | 0x90);\n    encodeByteStream(pointer,2,&tempValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800319e": "call_and_encode_0800319e",
                "param_1": "pointer",
                "param_2": "number",
                "param_3": "value",
                "puVar1": "pointer1",
                "local_a": "tempValue"
            },
            "calling": [
                "FUN_08002efe"
            ],
            "called": [
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080031ce": {
            "entrypoint": "0x080031ce",
            "current_name": "process_data_080031ce",
            "code": "\nvoid processData_080031ce(undefined4 *dataPointer,undefined4 param2,undefined4 param3,uint numIterations,int offset\n                 )\n\n{\n  undefined4 *pointer;\n  uint index;\n  \n  pointer = (undefined4 *)*dataPointer;\n  if (pointer != (undefined4 *)0x0) {\n    (**(code **)*pointer)(pointer,0xf0,param3,*(code **)*pointer,numIterations);\n    (***(code ***)(undefined4 *)*dataPointer)((undefined4 *)*dataPointer,0x79);\n    (***(code ***)(undefined4 *)*dataPointer)((undefined4 *)*dataPointer,param2);\n    (***(code ***)(undefined4 *)*dataPointer)((undefined4 *)*dataPointer,param3);\n    for (index = 0; index < numIterations; index = index + 1) {\n      encodeByteStream(dataPointer,1,offset + index,0);\n    }\n    (***(code ***)(undefined4 *)*dataPointer)((undefined4 *)*dataPointer,0xf7);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080031ce": "process_data_080031ce",
                "param_1": "dataPointer",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "numIterations",
                "param_5": "offset",
                "puVar1": "pointer",
                "uVar2": "index"
            },
            "calling": [
                "printFirmwareVersion"
            ],
            "called": [
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800322c": {
            "entrypoint": "0x0800322c",
            "current_name": "execute_function_chain_0800322c",
            "code": "\nvoid executeFunctionChain_0800322c(undefined4 *functionPointer,undefined4 parameter2,undefined4 parameter3)\n\n{\n  undefined4 *functionPtr;\n  \n  functionPtr = (undefined4 *)*functionPointer;\n  if (functionPtr != (undefined4 *)0x0) {\n    (**(code **)*functionPtr)(functionPtr,0xf9);\n    (***(code ***)(undefined4 *)*functionPointer)((undefined4 *)*functionPointer,parameter2);\n    (***(code ***)(undefined4 *)*functionPointer)((undefined4 *)*functionPointer,parameter3);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800322c": "execute_function_chain_0800322c",
                "param_1": "functionPointer",
                "param_2": "parameter2",
                "param_3": "parameter3",
                "puVar1": "functionPtr"
            },
            "calling": [
                "printVersion"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800325a": {
            "entrypoint": "0x0800325a",
            "current_name": "execute_encoded_byte_stream_0800325a",
            "code": "\nvoid executeEncodedByteStream_0800325a(undefined4 *stream,undefined4 value,uint length,int offset)\n\n{\n  undefined4 *streamPtr;\n  uint index;\n  \n  streamPtr = (undefined4 *)*stream;\n  if (streamPtr != (undefined4 *)0x0) {\n    (**(code **)*streamPtr)(streamPtr,0xf0);\n    (***(code ***)(undefined4 *)*stream)((undefined4 *)*stream,value);\n    for (index = 0; index < length; index = index + 1) {\n      encodeByteStream(stream,1,offset + index,0);\n    }\n    (***(code ***)(undefined4 *)*stream)((undefined4 *)*stream,0xf7);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800325a": "execute_encoded_byte_stream_0800325a",
                "param_1": "stream",
                "param_2": "value",
                "param_3": "length",
                "param_4": "offset",
                "puVar1": "streamPtr",
                "uVar2": "index"
            },
            "calling": [
                "sendString",
                "FUN_08002f0a"
            ],
            "called": [
                "encodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080032a2": {
            "entrypoint": "0x080032a2",
            "current_name": "send_sysex_with_length_080032a2",
            "code": "\nvoid sendSysexWithLength_080032a2(undefined4 device,undefined4 sysexMessage,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 messageLength;\n  \n  messageLength = strlen(sysexMessage);\n  sendSysex(device,0x71,messageLength,sysexMessage,param_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080032a2": "send_sysex_with_length_080032a2",
                "param_1": "device",
                "param_2": "sysexMessage",
                "uVar1": "messageLength"
            },
            "calling": [
                "FUN_08002f14"
            ],
            "called": [
                "strlen",
                "sendSysex"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080032bc": {
            "entrypoint": "0x080032bc",
            "current_name": "initialize_data_080032bc",
            "code": "\nvoid initializeData_080032bc(int dataAddress,int paramValue,undefined4 anotherParam)\n\n{\n  *(int *)(dataAddress + 4) = paramValue;\n  *(undefined4 *)(dataAddress + 8) = anotherParam;\n  *(undefined *)(dataAddress + 0xc) = 0;\n  *(undefined *)(dataAddress + 0xd) = 0;\n  *(undefined4 *)(dataAddress + 0x10) = 0;\n  *(undefined *)(dataAddress + 0x14) = 0;\n  *(undefined4 *)(dataAddress + 0x18) = 0;\n  *(undefined4 *)(dataAddress + 0x1c) = 0;\n  *(undefined4 *)(dataAddress + 0x20) = 0;\n  *(undefined4 *)(dataAddress + 0x24) = 0;\n  *(undefined4 *)(dataAddress + 0x28) = 0;\n  *(undefined4 *)(dataAddress + 0x2c) = 0;\n  *(undefined4 *)(dataAddress + 0x30) = 0;\n  *(undefined4 *)(dataAddress + 0x34) = 0;\n  *(undefined4 *)(dataAddress + 0x38) = 0;\n  *(undefined4 *)(dataAddress + 0x3c) = 0;\n  *(undefined4 *)(dataAddress + 0x40) = 0;\n  *(undefined4 *)(dataAddress + 0x44) = 0;\n  *(undefined4 *)(dataAddress + 0x48) = 0;\n  *(undefined4 *)(dataAddress + 0x4c) = 0;\n  *(undefined4 *)(dataAddress + 0x50) = 0;\n  *(undefined4 *)(dataAddress + 0x54) = 0;\n  *(undefined4 *)(dataAddress + 0x58) = 0;\n  *(undefined4 *)(dataAddress + 0x5c) = 0;\n  *(undefined4 *)(dataAddress + 0x60) = 0;\n  *(undefined4 *)(dataAddress + 100) = 0;\n  *(undefined4 *)(dataAddress + 0x68) = 0;\n  *(undefined4 *)(dataAddress + 0x6c) = 0;\n  *(undefined4 *)(dataAddress + 0x70) = 0;\n  *(undefined4 *)(dataAddress + 0x74) = 0;\n  *(undefined4 *)(dataAddress + 0x78) = 0;\n  *(bool *)dataAddress = paramValue == 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080032bc": "initialize_data_080032bc",
                "param_1": "dataAddress",
                "param_2": "paramValue",
                "param_3": "anotherParam"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003306": {
            "entrypoint": "0x08003306",
            "current_name": "set_parameters_08003306",
            "code": "\nvoid setParameters_08003306(int ptr,uint value,undefined4 param3,undefined4 param4)\n\n{\n  if (value == 0xd0) {\n    *(undefined4 *)(ptr + 0x58) = param3;\n    *(undefined4 *)(ptr + 0x28) = param4;\n    return;\n  }\n  if (0xd0 < value) {\n    if (value == 0xf4) {\n      *(undefined4 *)(ptr + 0x5c) = param3;\n      *(undefined4 *)(ptr + 0x2c) = param4;\n      return;\n    }\n    if (value == 0xf5) {\n      *(undefined4 *)(ptr + 0x60) = param3;\n      *(undefined4 *)(ptr + 0x30) = param4;\n    }\n    else if (value == 0xe0) {\n      *(undefined4 *)(ptr + 0x4c) = param3;\n      *(undefined4 *)(ptr + 0x1c) = param4;\n      return;\n    }\n    return;\n  }\n  if (value == 0x90) {\n    *(undefined4 *)(ptr + 0x50) = param3;\n    *(undefined4 *)(ptr + 0x20) = param4;\n    return;\n  }\n  if (value == 0xc0) {\n    *(undefined4 *)(ptr + 0x54) = param3;\n    *(undefined4 *)(ptr + 0x24) = param4;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003306": "set_parameters_08003306",
                "param_1": "ptr",
                "param_2": "value",
                "param_3": "param3",
                "param_4": "param4"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003346": {
            "entrypoint": "0x08003346",
            "current_name": "update_parameters_08003346",
            "code": "\nvoid updateParameters_08003346(int inputObject,int condition,undefined4 newValue1,undefined4 newValue2)\n\n{\n  if (condition == 0x79) {\n    *(undefined4 *)(inputObject + 0x70) = newValue1;\n    *(undefined4 *)(inputObject + 0x34) = newValue2;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003346": "update_parameters_08003346",
                "param_1": "inputObject",
                "param_2": "condition",
                "param_3": "newValue1",
                "param_4": "newValue2"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003350": {
            "entrypoint": "0x08003350",
            "current_name": "update_parameters_08003350",
            "code": "\nvoid updateParameters_08003350(int baseAddress,int condition,undefined4 value1,undefined4 value2)\n\n{\n  if (condition == 0xf9) {\n    *(undefined4 *)(baseAddress + 0x74) = value1;\n    *(undefined4 *)(baseAddress + 0x38) = value2;\n    return;\n  }\n  if (condition != 0xff) {\n    return;\n  }\n  *(undefined4 *)(baseAddress + 0x78) = value1;\n  *(undefined4 *)(baseAddress + 0x48) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003350": "update_parameters_08003350",
                "param_1": "baseAddress",
                "param_2": "condition",
                "param_3": "value1",
                "param_4": "value2"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003366": {
            "entrypoint": "0x08003366",
            "current_name": "set_parameters_08003366",
            "code": "\nvoid setParameters_08003366(int dataStructure,int value,undefined4 newValue1,undefined4 newValue2)\n\n{\n  if (value == 0x71) {\n    *(undefined4 *)(dataStructure + 0x68) = newValue1;\n    *(undefined4 *)(dataStructure + 0x40) = newValue2;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003366": "set_parameters_08003366",
                "param_1": "dataStructure",
                "param_2": "value",
                "param_3": "newValue1",
                "param_4": "newValue2"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003370": {
            "entrypoint": "0x08003370",
            "current_name": "save_parameters_08003370",
            "code": "\nvoid saveParameters_08003370(int objectAddress,undefined4 newValue1,undefined4 newValue2,undefined4 newValue3)\n\n{\n  *(undefined4 *)(objectAddress + 0x6c) = newValue2;\n  *(undefined4 *)(objectAddress + 0x44) = newValue3;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003370": "save_parameters_08003370",
                "param_1": "objectAddress",
                "param_2": "newValue1",
                "param_3": "newValue2",
                "param_4": "newValue3"
            },
            "calling": [
                "FirmataClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003376": {
            "entrypoint": "0x08003376",
            "current_name": "update_memory_value_08003376",
            "code": "\nvoid updateMemoryValue_08003376(undefined *memory,undefined value,uint address)\n\n{\n  bool isWithinBounds;\n  \n  if (address < *(uint *)(memory + 8)) {\n    isWithinBounds = false;\n  }\n  else {\n    isWithinBounds = true;\n    if (*(code **)(memory + 100) != (code *)0x0) {\n      *memory = 1;\n      (**(code **)(memory + 100))(*(undefined4 *)(memory + 0x3c));\n      if (address < *(uint *)(memory + 8)) {\n        isWithinBounds = false;\n      }\n      else {\n        isWithinBounds = true;\n      }\n    }\n  }\n  if (!isWithinBounds) {\n    *(undefined *)(*(int *)(memory + 4) + address) = value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003376": "update_memory_value_08003376",
                "param_1": "memory",
                "param_2": "value",
                "param_3": "address",
                "bVar1": "isWithinBounds"
            },
            "calling": [
                "processSysexMessage",
                "parse"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033a8": {
            "entrypoint": "0x080033a8",
            "current_name": "copy_and_shift_bits_080033a8",
            "code": "\nvoid copyAndShiftBits_080033a8(undefined4 param1,uint param2,int param3)\n\n{\n  byte currentByte;\n  int index;\n  uint byteIndex;\n  \n  index = 0;\n  for (byteIndex = 0; byteIndex < param2; byteIndex = byteIndex + 2) {\n    currentByte = *(byte *)(param3 + byteIndex);\n    *(byte *)(param3 + index) = currentByte;\n    *(byte *)(param3 + index) = *(char *)(param3 + byteIndex + 1) << 7 | currentByte;\n    index = index + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033a8": "copy_and_shift_bits_080033a8",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "bVar1": "currentByte",
                "iVar2": "index",
                "uVar3": "byteIndex"
            },
            "calling": [
                "processSysexMessage"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033cc": {
            "entrypoint": "0x080033cc",
            "current_name": "process_input_data_080033cc",
            "code": "\nvoid processInputData_080033cc(int dataPtr,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  char currentChar;\n  int decodedLength;\n  char *charPtr;\n  \n  charPtr = *(char **)(dataPtr + 4);\n  currentChar = *charPtr;\n  if (currentChar == 'q') {\n    if (*(int *)(dataPtr + 0x68) != 0) {\n      decodedLength = decodeByteStream(dataPtr,*(int *)(dataPtr + 0x18) + -1,charPtr + 1,charPtr,param4);\n      bufferDataAtPosition(dataPtr,0,decodedLength + 1);\n      (**(code **)(dataPtr + 0x68))(*(undefined4 *)(dataPtr + 0x40),*(int *)(dataPtr + 4) + 1);\n      return;\n    }\n  }\n  else if (currentChar == 'y') {\n    if (*(code **)(dataPtr + 0x70) != (code *)0x0) {\n      if (*(uint *)(dataPtr + 0x18) < 3) {\n        (**(code **)(dataPtr + 0x70))(*(undefined4 *)(dataPtr + 0x34),0,0);\n        return;\n      }\n      decodedLength = decodeByteStream(dataPtr,*(uint *)(dataPtr + 0x18) - 3,charPtr + 3,charPtr,param4);\n      bufferDataAtPosition(dataPtr,0,decodedLength + 3);\n      decodedLength = *(int *)(dataPtr + 4);\n      (**(code **)(dataPtr + 0x70))\n                (*(undefined4 *)(dataPtr + 0x34),*(undefined *)(decodedLength + 1),*(undefined *)(decodedLength + 2)\n                 ,decodedLength + 3);\n      return;\n    }\n  }\n  else if (*(code **)(dataPtr + 0x6c) != (code *)0x0) {\n    (**(code **)(dataPtr + 0x6c))\n              (*(undefined4 *)(dataPtr + 0x44),currentChar,*(int *)(dataPtr + 0x18) + -1,charPtr + 1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033cc": "process_input_data_080033cc",
                "param_1": "dataPtr",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "cVar1": "currentChar",
                "iVar2": "decodedLength",
                "pcVar3": "charPtr"
            },
            "calling": [
                "parse"
            ],
            "called": [
                "bufferDataAtPosition",
                "decodeByteStream"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800344a": {
            "entrypoint": "0x0800344a",
            "current_name": "initialize_data_0800344a",
            "code": "\nvoid initializeData_0800344a(int dataStruct)\n\n{\n  uint index;\n  \n  *(undefined4 *)(dataStruct + 0x10) = 0;\n  *(undefined *)(dataStruct + 0xc) = 0;\n  *(undefined *)(dataStruct + 0xd) = 0;\n  for (index = 0; index < *(uint *)(dataStruct + 8); index = index + 1) {\n    *(undefined *)(*(int *)(dataStruct + 4) + index) = 0;\n  }\n  *(undefined *)(dataStruct + 0x14) = 0;\n  *(undefined4 *)(dataStruct + 0x18) = 0;\n  if (*(code **)(dataStruct + 0x78) != (code *)0x0) {\n    (**(code **)(dataStruct + 0x78))(*(undefined4 *)(dataStruct + 0x48));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800344a": "initialize_data_0800344a",
                "param_1": "dataStruct",
                "uVar1": "index"
            },
            "calling": [
                "parse"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003474": {
            "entrypoint": "0x08003474",
            "current_name": "process_midi_event_08003474",
            "code": "\nvoid processMIDIEvent_08003474(int midiContext,uint message)\n\n{\n  byte byteValue;\n  \n  if (*(char *)(midiContext + 0x14) != '\\0') {\n    if (message != 0xf7) {\n      storeDataAtPosition(midiContext,message,*(undefined4 *)(midiContext + 0x18));\n      *(int *)(midiContext + 0x18) = *(int *)(midiContext + 0x18) + 1;\n      return;\n    }\n    *(undefined *)(midiContext + 0x14) = 0;\n    processSystemExclusiveMessage();\n    return;\n  }\n  if ((*(int *)(midiContext + 0x10) == 0) || (0x7f < (int)message)) {\n    if ((int)message < 0xf0) {\n      *(byte *)(midiContext + 0xd) = (byte)message & 0xf;\n      message = message & 0xf0;\n    }\n    if (message == 0xf0) {\n      *(undefined *)(midiContext + 0x14) = 1;\n      *(undefined4 *)(midiContext + 0x18) = 0;\n      return;\n    }\n    if (message < 0xf1) {\n      if (message != 0xc0) {\n        if (message < 0xc1) {\n          if (message != 0x90) {\n            return;\n          }\n        }\n        else {\n          if (message == 0xd0) goto LAB_0800359c;\n          if (message != 0xe0) {\n            return;\n          }\n        }\nLAB_08003586:\n        *(undefined4 *)(midiContext + 0x10) = 2;\n        *(char *)(midiContext + 0xc) = (char)message;\n        return;\n      }\nLAB_0800359c:\n      *(undefined4 *)(midiContext + 0x10) = 1;\n      *(char *)(midiContext + 0xc) = (char)message;\n      return;\n    }\n    if (message != 0xf9) {\n      if (0xf9 < message) {\n        if (message == 0xff) {\n          performSystemReset(midiContext);\n          return;\n        }\n        return;\n      }\n      if (1 < message - 0xf4) {\n        return;\n      }\n      goto LAB_08003586;\n    }\n    if (*(code **)(midiContext + 0x74) != (code *)0x0) {\n      (**(code **)(midiContext + 0x74))(*(undefined4 *)(midiContext + 0x38));\n    }\n  }\n  else {\n    *(int *)(midiContext + 0x10) = *(int *)(midiContext + 0x10) + -1;\n    storeDataAtPosition();\n    if ((*(int *)(midiContext + 0x10) == 0) && (byteValue = *(byte *)(midiContext + 0xc), byteValue != 0)) {\n      if (byteValue == 0xd0) {\n        if (*(code **)(midiContext + 0x58) != (code *)0x0) {\n          (**(code **)(midiContext + 0x58))\n                    (*(undefined4 *)(midiContext + 0x28),*(undefined *)(midiContext + 0xd),\n                     **(undefined **)(midiContext + 4));\n        }\n      }\n      else if (byteValue < 0xd1) {\n        if (byteValue == 0x90) {\n          if (*(code **)(midiContext + 0x50) != (code *)0x0) {\n            (**(code **)(midiContext + 0x50))\n                      (*(undefined4 *)(midiContext + 0x20),*(undefined *)(midiContext + 0xd),\n                       (uint)(*(byte **)(midiContext + 4))[1] + (uint)**(byte **)(midiContext + 4) * 0x80);\n          }\n        }\n        else if ((byteValue == 0xc0) && (*(code **)(midiContext + 0x54) != (code *)0x0)) {\n          (**(code **)(midiContext + 0x54))\n                    (*(undefined4 *)(midiContext + 0x24),*(undefined *)(midiContext + 0xd),\n                     **(undefined **)(midiContext + 4));\n        }\n      }\n      else if (byteValue == 0xf4) {\n        if (*(code **)(midiContext + 0x5c) != (code *)0x0) {\n          (**(code **)(midiContext + 0x5c))\n                    (*(undefined4 *)(midiContext + 0x2c),(*(undefined **)(midiContext + 4))[1],\n                     **(undefined **)(midiContext + 4));\n        }\n      }\n      else if (byteValue == 0xf5) {\n        if (*(code **)(midiContext + 0x60) != (code *)0x0) {\n          (**(code **)(midiContext + 0x60))\n                    (*(undefined4 *)(midiContext + 0x30),(*(undefined **)(midiContext + 4))[1],\n                     **(undefined **)(midiContext + 4));\n        }\n      }\n      else if ((byteValue == 0xe0) && (*(code **)(midiContext + 0x4c) != (code *)0x0)) {\n        (**(code **)(midiContext + 0x4c))\n                  (*(undefined4 *)(midiContext + 0x1c),*(undefined *)(midiContext + 0xd),\n                   (uint)(*(byte **)(midiContext + 4))[1] + (uint)**(byte **)(midiContext + 4) * 0x80);\n      }\n      *(undefined *)(midiContext + 0xc) = 0;\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003474": "process_midi_event_08003474",
                "param_1": "midiContext",
                "param_2": "message",
                "bVar1": "byteValue",
                "bufferDataAtPosition": "storeDataAtPosition",
                "processSysexMessage": "processSystemExclusiveMessage",
                "systemReset": "performSystemReset"
            },
            "calling": [
                "processInput"
            ],
            "called": [
                "systemReset",
                "processSysexMessage",
                "bufferDataAtPosition"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035b8": {
            "entrypoint": "0x080035b8",
            "current_name": "initialize_system_080035b8",
            "code": "\nvoid initializeSystem_080035b8(void)\n\n{\n  int result;\n  uint hclkFrequency;\n  undefined4 periphConfig [2];\n  undefined4 rtcClockSource;\n  undefined4 clockConfig;\n  undefined4 sysCLKSource;\n  undefined4 ahbDivider;\n  undefined4 apb1Divider;\n  undefined4 apb2Divider;\n  undefined4 oscillatorConfig [4];\n  undefined4 clockSource;\n  undefined4 flashLatency;\n  undefined4 voltageScaling;\n  undefined4 mainPLLSource;\n  undefined4 mainPLLMul;\n  \n  oscillatorConfig[0] = 2;\n  clockSource = 1;\n  flashLatency = 0x10;\n  voltageScaling = 2;\n  mainPLLSource = 0;\n  mainPLLMul = 0x380000;\n  result = HAL_RCC_OscConfig(oscillatorConfig);\n  if (result != 0) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x88);\n  }\n  clockConfig = 0xf;\n  sysCLKSource = 2;\n  ahbDivider = 0;\n  apb1Divider = 0x400;\n  apb2Divider = 0;\n  result = HAL_RCC_ClockConfig(&clockConfig);\n  if (result != 0) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x95);\n  }\n  periphConfig[0] = 2;\n  rtcClockSource = 0x8000;\n  result = HAL_RCCEx_PeriphCLKConfig(periphConfig);\n  if (result != 0) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x9c);\n  }\n  hclkFrequency = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFrequency / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(0xffffffff,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035b8": "initialize_system_080035b8",
                "local_30": "oscillatorConfig",
                "local_20": "clockSource",
                "local_1c": "flashLatency",
                "local_14": "voltageScaling",
                "local_10": "mainPLLSource",
                "local_c": "mainPLLMul",
                "local_44": "clockConfig",
                "local_40": "sysCLKSource",
                "local_3c": "ahbDivider",
                "local_38": "apb1Divider",
                "local_34": "apb2Divider",
                "local_54": "periphConfig",
                "local_4c": "rtcClockSource",
                "iVar1": "result",
                "uVar2": "hclkFrequency"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_RCC_GetHCLKFreq",
                "_Error_Handler",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig",
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003658": {
            "entrypoint": "0x08003658",
            "current_name": "initialize_memory_08003658",
            "code": "\nvoid initializeMemory_08003658(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  code *jumpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &DAT_200000f4; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(index + 0x800ac18);\n  }\n  for (pointer = &DAT_200000f4; pointer < &DAT_20000a3c; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  initializeSystem();\n  initializeLibCArray();\n  jumpTable = (code *)0x800368a;\n  mainFunction();\n                    /* WARNING: Could not recover jumptable at 0x0800368a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003658": "initialize_memory_08003658",
                "iVar1": "index",
                "puVar2": "pointer",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "SystemInit": "initializeSystem",
                "__libc_init_array": "initializeLibCArray",
                "main": "mainFunction"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036a2": {
            "entrypoint": "0x080036a2",
            "current_name": "initialize_hardware_configuration_080036a2",
            "code": "\nvoid initializeHardwareConfiguration_080036a2(void)\n\n{\n  initializeHardwareConfig();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036a2": "initialize_hardware_configuration_080036a2",
                "hw_config_init": "initializeHardwareConfig"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036ac": {
            "entrypoint": "0x080036ac",
            "current_name": "find_char_in_array_080036ac",
            "code": "\nuint find_char_in_array_080036ac(int number)\n\n{\n  uint index;\n  \n  if ((uint)(number << 0x18) >> 0x1c < 5) {\n    for (index = 0; (index < 0x3c && (number != (char)(&DAT_0800a908)[index])); index = index + 1)\n    {\n    }\n  }\n  else {\n    index = 0xffffffff;\n  }\n  return index;\n}\n\n",
            "renaming": {
                "FUN_080036ac": "find_char_in_array_080036ac",
                "param_1": "number",
                "uVar1": "index"
            },
            "calling": [
                "loop",
                "sysexCallback",
                "checkDigitalInputs",
                "enableI2CPins",
                "FUN_0800021a",
                "systemResetCallback",
                "setPinModeCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036d4": {
            "entrypoint": "0x080036d4",
            "current_name": "FUNC_080036d4",
            "code": "\nvoid FUNC_080036d4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036d4": "FUNC_080036d4"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080036d8": {
            "entrypoint": "0x080036d8",
            "current_name": "initialize_sys_tick_080036d8",
            "code": "\nundefined4 initializeSysTick_080036d8(uint priorityLevel)\n\n{\n  int configStatus;\n  \n  configStatus = HAL_SYSTICK_Config(DAT_20000018 / (1000 / DAT_2000000c));\n  if (configStatus != 0) {\n    return 1;\n  }\n  if (0xf < priorityLevel) {\n    return 1;\n  }\n  HAL_NVIC_SetPriority(0xffffffff,priorityLevel,0);\n  DAT_20000010 = priorityLevel;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080036d8": "initialize_sys_tick_080036d8",
                "param_1": "priorityLevel",
                "iVar1": "configStatus"
            },
            "calling": [
                "FUN_080058d2",
                "HAL_Init"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003724": {
            "entrypoint": "0x08003724",
            "current_name": "initialize_hardware_08003724",
            "code": "\n\n\nundefined4 initializeHardware_08003724(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setPriorityGrouping(3);\n  initializeTick(0xf);\n  initializePeripheral();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003724": "initialize_hardware_08003724",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializePeripheral"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003748": {
            "entrypoint": "0x08003748",
            "current_name": "update_value_08003748",
            "code": "\nvoid updateValue_08003748(void)\n\n{\n  DAT_20000a34 = (uint)DAT_2000000c + DAT_20000a34;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003748": "update_value_08003748"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003760": {
            "entrypoint": "0x08003760",
            "current_name": "get_data_08003760",
            "code": "\nundefined4 get_data_08003760(void)\n\n{\n  return DAT_20000a34;\n}\n\n",
            "renaming": {
                "FUN_08003760": "get_data_08003760"
            },
            "calling": [
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_PollForConversion",
                "i2c_master_write",
                "FUN_080058d2",
                "ADC_Enable",
                "HAL_RCC_OscConfig",
                "HAL_UART_Transmit",
                "UART_WaitOnFlagUntilTimeout",
                "i2c_master_read",
                "uart_debug_write",
                "ADC_ConversionStop_Disable",
                "GetCurrentMilli"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800376c": {
            "entrypoint": "0x0800376c",
            "current_name": "calculate_delay_0800376c",
            "code": "\nundefined4 calculateDelay_0800376c(uint **inputParams,uint timeLimit)\n\n{\n  int startTime;\n  uint periphClockFreq;\n  int interval;\n  undefined4 result;\n  uint *flags;\n  uint delayLimit;\n  uint currentDelay;\n  \n  currentDelay = 0;\n  startTime = HAL_GetTick();\n  delayLimit = DAT_20000018;\n  flags = *inputParams;\n  if ((flags[2] & 0x100) == 0) {\n    if (((flags[1] & 0x100) == 0) && ((flags[0xb] & 0xf00000) == 0)) {\n      do {\n        if ((**inputParams & 2) != 0) goto LAB_0800387e;\n      } while ((timeLimit == 0xffffffff) ||\n              ((timeLimit != 0 && (interval = HAL_GetTick(), (uint)(interval - startTime) <= timeLimit))));\n      inputParams[10] = (uint *)((uint)inputParams[10] | 4);\n      *(undefined *)(inputParams + 9) = 0;\n      result = 3;\n    }\n    else {\n      periphClockFreq = HAL_RCCEx_GetPeriphCLKFreq(2);\n      flags = *inputParams;\n      if (((flags[4] & 0x24924924) == 0) && ((flags[3] & 0x924924) == 0)) {\n        if ((flags[4] & 0x12492492) == 0) {\n          if ((flags[3] & 0x492492) == 0) {\n            interval = 0x14;\n          }\n          else {\n            interval = 0x29;\n          }\n        }\n        else {\n          interval = 0x29;\n        }\n      }\n      else if (((flags[4] & 0x12492492) == 0) && ((flags[3] & 0x492492) == 0)) {\n        interval = 0x54;\n      }\n      else if ((flags[4] & 0x249249) == 0) {\n        if ((flags[3] & 0x249249) == 0) {\n          interval = 0x54;\n        }\n        else {\n          interval = 0xfc;\n        }\n      }\n      else {\n        interval = 0xfc;\n      }\n      delayLimit = (delayLimit / periphClockFreq) * interval;\n      for (; currentDelay <= delayLimit && delayLimit - currentDelay != 0; currentDelay = currentDelay + 1) {\n        if ((timeLimit != 0xffffffff) &&\n           ((timeLimit == 0 || (interval = HAL_GetTick(), timeLimit < (uint)(interval - startTime))))) {\n          inputParams[10] = (uint *)((uint)inputParams[10] | 4);\n          *(undefined *)(inputParams + 9) = 0;\n          return 3;\n        }\n      }\nLAB_0800387e:\n      **inputParams = 0xffffffed;\n      inputParams[10] = (uint *)((uint)inputParams[10] | 0x200);\n      if (((*inputParams)[2] & 0xe0000) == 0xe0000) {\n        if (inputParams[3] == (uint *)0x0) {\n          inputParams[10] = (uint *)((uint)inputParams[10] & 0xfffffeff);\n          if (((uint)inputParams[10] & 0x1000) == 0) {\n            inputParams[10] = (uint *)((uint)inputParams[10] | 1);\n            result = 0;\n          }\n          else {\n            result = 0;\n          }\n        }\n        else {\n          result = 0;\n        }\n      }\n      else {\n        result = 0;\n      }\n    }\n  }\n  else {\n    inputParams[10] = (uint *)((uint)inputParams[10] | 0x20);\n    *(undefined *)(inputParams + 9) = 0;\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800376c": "calculate_delay_0800376c",
                "param_1": "inputParams",
                "param_2": "timeLimit",
                "iVar1": "startTime",
                "uVar2": "periphClockFreq",
                "iVar3": "interval",
                "uVar4": "result",
                "puVar5": "flags",
                "uVar6": "delayLimit",
                "local_1c": "currentDelay"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_RCCEx_GetPeriphCLKFreq",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080038dc": {
            "entrypoint": "0x080038dc",
            "current_name": "get_offset_from_pointer_080038dc",
            "code": "\nundefined4 get_offset_from_pointer_080038dc(int *pointer)\n\n{\n  return *(undefined4 *)(*pointer + 0x4c);\n}\n\n",
            "renaming": {
                "FUN_080038dc": "get_offset_from_pointer_080038dc",
                "param_1": "pointer"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080038e4": {
            "entrypoint": "0x080038e4",
            "current_name": "update_configuration_080038e4",
            "code": "\nundefined4 updateConfiguration_080038e4(int *configPointer,uint *values)\n\n{\n  undefined4 status;\n  uint index;\n  int counter;\n  \n  if (*(char *)(configPointer + 9) == '\\x01') {\n    status = 2;\n  }\n  else {\n    *(undefined *)(configPointer + 9) = 1;\n    index = values[1];\n    if (index < 7) {\n      index = index * 5 - 5;\n      *(uint *)(*configPointer + 0x34) =\n           *values << (index & 0xff) | *(uint *)(*configPointer + 0x34) & ~(0x1f << (index & 0xff));\n    }\n    else if (index < 0xd) {\n      index = index * 5 - 0x23;\n      *(uint *)(*configPointer + 0x30) =\n           *values << (index & 0xff) | *(uint *)(*configPointer + 0x30) & ~(0x1f << (index & 0xff));\n    }\n    else {\n      index = index * 5 - 0x41;\n      *(uint *)(*configPointer + 0x2c) =\n           *values << (index & 0xff) | *(uint *)(*configPointer + 0x2c) & ~(0x1f << (index & 0xff));\n    }\n    index = *values;\n    if (index < 10) {\n      *(uint *)(*configPointer + 0x10) =\n           values[2] << (index * 3 & 0xff) |\n           *(uint *)(*configPointer + 0x10) & ~(7 << (index * 3 & 0xff));\n    }\n    else {\n      index = index * 3 - 0x1e;\n      *(uint *)(*configPointer + 0xc) =\n           values[2] << (index & 0xff) | *(uint *)(*configPointer + 0xc) & ~(7 << (index & 0xff));\n    }\n    if (*values - 0x10 < 2) {\n      if (*configPointer == 0x40012400) {\n        if ((uRam40012408 & 0x800000) == 0) {\n          uRam40012408 = uRam40012408 | 0x800000;\n          if (*values == 0x10) {\n            for (counter = (DAT_20000018 / 1000000) * 10; counter != 0; counter = counter + -1) {\n            }\n            status = 0;\n          }\n          else {\n            status = 0;\n          }\n        }\n        else {\n          status = 0;\n        }\n      }\n      else {\n        configPointer[10] = configPointer[10] | 0x20;\n        status = 1;\n      }\n    }\n    else {\n      status = 0;\n    }\n    *(undefined *)(configPointer + 9) = 0;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080038e4": "update_configuration_080038e4",
                "param_1": "configPointer",
                "param_2": "values",
                "uVar1": "status",
                "uVar2": "index",
                "local_c": "counter"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a1c": {
            "entrypoint": "0x08003a1c",
            "current_name": "get_pointer_offset_08003a1c",
            "code": "\nundefined4 getPointerOffset_08003a1c(int baseAddress)\n\n{\n  return *(undefined4 *)(baseAddress + 0x28);\n}\n\n",
            "renaming": {
                "FUN_08003a1c": "get_pointer_offset_08003a1c",
                "param_1": "baseAddress"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a20": {
            "entrypoint": "0x08003a20",
            "current_name": "set_flag_if_not_set_08003a20",
            "code": "\nundefined4 setFlagIfNotSet_08003a20(int *flagPtr,undefined4 value)\n\n{\n  int ticksStart;\n  undefined4 returnValue;\n  int flagValue;\n  uint delay;\n  \n  flagValue = *flagPtr;\n  if ((*(uint *)(flagValue + 8) & 1) == 0) {\n    *(uint *)(flagValue + 8) = *(uint *)(flagValue + 8) | 1;\n    for (delay = DAT_20000018 / 1000000; delay != 0; delay = delay - 1) {\n    }\n    flagValue = HAL_GetTick(flagPtr,value,DAT_20000018 * 0x431bde83);\n    do {\n      if ((*(uint *)(*flagPtr + 8) & 1) != 0) {\n        return 0;\n      }\n      ticksStart = HAL_GetTick();\n    } while ((uint)(ticksStart - flagValue) < 3);\n    flagPtr[10] = flagPtr[10] | 0x10;\n    flagPtr[0xb] = flagPtr[0xb] | 1;\n    *(undefined *)(flagPtr + 9) = 0;\n    returnValue = 1;\n  }\n  else {\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08003a20": "set_flag_if_not_set_08003a20",
                "param_1": "flagPtr",
                "param_2": "value",
                "iVar1": "ticksStart",
                "iVar3": "flagValue",
                "local_14": "delay",
                "uVar2": "returnValue"
            },
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003aa0": {
            "entrypoint": "0x08003aa0",
            "current_name": "enable_adc_08003aa0",
            "code": "\n\n\nint enableADC_08003aa0(int *paramArray)\n\n{\n  int result;\n  undefined4 *ptr;\n  int value;\n  \n  if (*(char *)(paramArray + 9) != '\\x01') {\n    *(undefined *)(paramArray + 9) = 1;\n    result = ADC_Enable();\n    if (result == 0) {\n      paramArray[10] = paramArray[10] & 0xfffffcfeU | 0x100;\n      ptr = (undefined4 *)*paramArray;\n      if ((ptr == (undefined4 *)0x40012800) && ((_DAT_40012404 & 0xf0000) != 0)) {\n        paramArray[10] = paramArray[10] | 0x100000;\n        if ((_DAT_40012404 & 0x400) != 0) {\n          paramArray[10] = paramArray[10] & 0xffffcfffU | 0x1000;\n        }\n      }\n      else {\n        paramArray[10] = paramArray[10] & 0xffefffff;\n        if ((ptr[1] & 0x400) != 0) {\n          paramArray[10] = paramArray[10] & 0xffffcfffU | 0x1000;\n        }\n      }\n      if ((paramArray[10] & 0x1000U) == 0) {\n        paramArray[0xb] = 0;\n      }\n      else {\n        paramArray[0xb] = paramArray[0xb] & 0xfffffff9;\n      }\n      *(undefined *)(paramArray + 9) = 0;\n      *ptr = 0xfffffffd;\n      value = *paramArray;\n      if (((*(uint *)(value + 8) & 0xe0000) == 0xe0000) &&\n         ((value != 0x40012800 || ((_DAT_40012404 & 0xf0000) == 0)))) {\n        *(uint *)(value + 8) = *(uint *)(value + 8) | 0x500000;\n      }\n      else {\n        *(uint *)(value + 8) = *(uint *)(value + 8) | 0x100000;\n      }\n    }\n    else {\n      *(undefined *)(paramArray + 9) = 0;\n    }\n    return result;\n  }\n  return 2;\n}\n\n",
            "renaming": {
                "FUN_08003aa0": "enable_adc_08003aa0",
                "param_1": "paramArray",
                "iVar1": "result",
                "puVar2": "ptr",
                "iVar3": "value"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003b8c": {
            "entrypoint": "0x08003b8c",
            "current_name": "update_data_and_flags_08003b8c",
            "code": "\nundefined4 updateDataAndFlags_08003b8c(int *dataPtr)\n\n{\n  int currentTick;\n  int initialTick;\n  \n  initialTick = *dataPtr;\n  if ((*(uint *)(initialTick + 8) & 1) == 0) {\n    return 0;\n  }\n  *(uint *)(initialTick + 8) = *(uint *)(initialTick + 8) & 0xfffffffe;\n  initialTick = HAL_GetTick();\n  do {\n    if ((*(uint *)(*dataPtr + 8) & 1) == 0) {\n      return 0;\n    }\n    currentTick = HAL_GetTick();\n  } while ((uint)(currentTick - initialTick) < 3);\n  dataPtr[10] = dataPtr[10] | 0x10;\n  dataPtr[0xb] = dataPtr[0xb] | 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08003b8c": "update_data_and_flags_08003b8c",
                "param_1": "dataPtr",
                "iVar1": "currentTick",
                "iVar2": "initialTick"
            },
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Init",
                "HAL_ADC_DeInit",
                "HAL_ADC_Stop"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003bd8": {
            "entrypoint": "0x08003bd8",
            "current_name": "initialize_adc_08003bd8",
            "code": "\nundefined4 initializeADC_08003bd8(int *adcParams)\n\n{\n  int conversionResult;\n  uint combinedParams;\n  uint multiplicationValue;\n  \n  if (adcParams == (int *)0x0) {\n    return 1;\n  }\n  if (adcParams[10] == 0) {\n    adcParams[0xb] = 0;\n    *(undefined *)(adcParams + 9) = 0;\n    HAL_ADC_MspInit();\n  }\n  conversionResult = ADC_ConversionStop_Disable(adcParams);\n  if (((adcParams[10] & 0x10U) == 0) && (conversionResult == 0)) {\n    adcParams[10] = adcParams[10] & 0xffffeefdU | 2;\n    combinedParams = adcParams[1] | adcParams[7] | adcParams[3] << 1;\n    if (adcParams[2] == 0x100) {\n      multiplicationValue = 0x100;\n    }\n    else {\n      multiplicationValue = 0;\n      if (adcParams[2] == 1) {\n        multiplicationValue = 0x100;\n      }\n    }\n    if (adcParams[5] == 1) {\n      if (adcParams[3] == 0) {\n        multiplicationValue = multiplicationValue | (adcParams[6] + -1) * 0x2000 | 0x800;\n      }\n      else {\n        adcParams[10] = adcParams[10] | 0x20;\n        adcParams[0xb] = adcParams[0xb] | 1;\n      }\n    }\n    *(uint *)(*adcParams + 4) = multiplicationValue | *(uint *)(*adcParams + 4) & 0xffff16ff;\n    *(uint *)(*adcParams + 8) = *(uint *)(*adcParams + 8) & 0xffe1f7fd | combinedParams;\n    if ((adcParams[2] == 0x100) || (adcParams[2] == 1)) {\n      multiplicationValue = (adcParams[4] + -1) * 0x100000;\n    }\n    else {\n      multiplicationValue = 0;\n    }\n    *(uint *)(*adcParams + 0x2c) = multiplicationValue | *(uint *)(*adcParams + 0x2c) & 0xff0fffff;\n    if (combinedParams != (*(uint *)(*adcParams + 8) & 0xff1f0efe)) {\n      adcParams[10] = adcParams[10] & 0xffffffedU | 0x10;\n      adcParams[0xb] = adcParams[0xb] | 1;\n      return 1;\n    }\n    adcParams[0xb] = 0;\n    adcParams[10] = adcParams[10] & 0xfffffffcU | 1;\n    return 0;\n  }\n  adcParams[10] = adcParams[10] | 0x10;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08003bd8": "initialize_adc_08003bd8",
                "param_1": "adcParams",
                "iVar1": "conversionResult",
                "uVar2": "combinedParams",
                "uVar3": "multiplicationValue"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ce8": {
            "entrypoint": "0x08003ce8",
            "current_name": "disable_adc_conversion_08003ce8",
            "code": "\nint disableADCConversion_08003ce8(int *adcParams)\n\n{\n  int errorFlag;\n  \n  if (adcParams == (int *)0x0) {\n    errorFlag = 1;\n  }\n  else {\n    adcParams[10] = adcParams[10] | 2;\n    errorFlag = ADC_ConversionStop_Disable();\n    if (errorFlag == 0) {\n      *(undefined4 *)*adcParams = 0xffffffe0;\n      *(uint *)(*adcParams + 4) = *(uint *)(*adcParams + 4) & 0xff3f0000;\n      *(uint *)(*adcParams + 8) = *(uint *)(*adcParams + 8) & 0xff0106f0;\n      *(uint *)(*adcParams + 0xc) = *(uint *)(*adcParams + 0xc) & 0xff000000;\n      *(uint *)(*adcParams + 0x10) = *(uint *)(*adcParams + 0x10) & 0xc0000000;\n      *(uint *)(*adcParams + 0x14) = *(uint *)(*adcParams + 0x14) & 0xfffff000;\n      *(uint *)(*adcParams + 0x18) = *(uint *)(*adcParams + 0x18) & 0xfffff000;\n      *(uint *)(*adcParams + 0x1c) = *(uint *)(*adcParams + 0x1c) & 0xfffff000;\n      *(uint *)(*adcParams + 0x20) = *(uint *)(*adcParams + 0x20) & 0xfffff000;\n      *(uint *)(*adcParams + 0x24) = *(uint *)(*adcParams + 0x24) & 0xfffff000;\n      *(uint *)(*adcParams + 0x28) = *(uint *)(*adcParams + 0x28) & 0xfffff000;\n      *(uint *)(*adcParams + 0x2c) = *(uint *)(*adcParams + 0x2c) & 0xff000000;\n      *(uint *)(*adcParams + 0x2c) = *(uint *)(*adcParams + 0x2c) & 0xff000000;\n      *(uint *)(*adcParams + 0x30) = *(uint *)(*adcParams + 0x30) & 0xc0000000;\n      *(uint *)(*adcParams + 0x34) = *(uint *)(*adcParams + 0x34) & 0xc0000000;\n      *(uint *)(*adcParams + 0x38) = *(uint *)(*adcParams + 0x38) & 0xffc00000;\n      *(uint *)(*adcParams + 0x38) = *(uint *)(*adcParams + 0x38) & 0xffc00000;\n      HAL_ADC_MspDeInit(adcParams);\n      adcParams[0xb] = 0;\n      adcParams[10] = 0;\n    }\n    *(undefined *)(adcParams + 9) = 0;\n  }\n  return errorFlag;\n}\n\n",
            "renaming": {
                "FUN_08003ce8": "disable_adc_conversion_08003ce8",
                "param_1": "adcParams",
                "iVar1": "errorFlag"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_ADC_MspDeInit",
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003de4": {
            "entrypoint": "0x08003de4",
            "current_name": "check_adc_and_update_value_08003de4",
            "code": "\nint check_adc_and_update_value_08003de4(int adc_value)\n\n{\n  int conversion_result;\n  \n  if (*(char *)(adc_value + 0x24) == '\\x01') {\n    return 2;\n  }\n  *(undefined *)(adc_value + 0x24) = 1;\n  conversion_result = ADC_ConversionStop_Disable();\n  if (conversion_result == 0) {\n    *(uint *)(adc_value + 0x28) = *(uint *)(adc_value + 0x28) & 0xffffeefe | 1;\n  }\n  *(undefined *)(adc_value + 0x24) = 0;\n  return conversion_result;\n}\n\n",
            "renaming": {
                "FUN_08003de4": "check_adc_and_update_value_08003de4",
                "param_1": "adc_value",
                "iVar1": "conversion_result"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e20": {
            "entrypoint": "0x08003e20",
            "current_name": "initialize_adc_08003e20",
            "code": "\nint initializeADC_08003e20(int *adcParams)\n\n{\n  uint clockFreq;\n  int stopResult;\n  uint pclk;\n  int startTime;\n  int curTime;\n  int delay;\n  \n  if (*(char *)(adcParams + 9) == '\\x01') {\n    return 2;\n  }\n  *(undefined *)(adcParams + 9) = 1;\n  stopResult = ADC_ConversionStop_Disable();\n  if (stopResult == 0) {\n    adcParams[10] = adcParams[10] & 0xffffeefdU | 2;\n    clockFreq = DAT_20000018;\n    pclk = HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (delay = clockFreq / pclk << 1; delay != 0; delay = delay + -1) {\n    }\n    ADC_Enable(adcParams);\n    *(uint *)(*adcParams + 8) = *(uint *)(*adcParams + 8) | 8;\n    startTime = HAL_GetTick();\n    while (curTime = *adcParams, (*(uint *)(curTime + 8) & 8) != 0) {\n      curTime = HAL_GetTick();\n      if (10 < (uint)(curTime - startTime)) {\n        adcParams[10] = adcParams[10] & 0xffffffedU | 0x10;\n        *(undefined *)(adcParams + 9) = 0;\n        return 1;\n      }\n    }\n    *(uint *)(curTime + 8) = *(uint *)(curTime + 8) | 4;\n    startTime = HAL_GetTick();\n    while ((*(uint *)(*adcParams + 8) & 4) != 0) {\n      curTime = HAL_GetTick();\n      if (10 < (uint)(curTime - startTime)) {\n        adcParams[10] = adcParams[10] & 0xffffffedU | 0x10;\n        *(undefined *)(adcParams + 9) = 0;\n        return 1;\n      }\n    }\n    adcParams[10] = adcParams[10] & 0xfffffffcU | 1;\n  }\n  *(undefined *)(adcParams + 9) = 0;\n  return stopResult;\n}\n\n",
            "renaming": {
                "FUN_08003e20": "initialize_adc_08003e20",
                "param_1": "adcParams",
                "uVar1": "clockFreq",
                "iVar2": "stopResult",
                "uVar3": "pclk",
                "iVar4": "startTime",
                "iVar5": "curTime",
                "local_14": "delay"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_RCCEx_GetPeriphCLKFreq",
                "ADC_Enable",
                "ADC_ConversionStop_Disable",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f0c": {
            "entrypoint": "0x08003f0c",
            "current_name": "update_register_value_08003f0c",
            "code": "\n\n\nvoid updateRegisterValue_08003f0c(uint inputValue)\n\n{\n  _DAT_e000ed0c = (inputValue & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f0c": "update_register_value_08003f0c",
                "param_1": "inputValue"
            },
            "calling": [
                "HAL_Init",
                "premain"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f30": {
            "entrypoint": "0x08003f30",
            "current_name": "apply_mask_and_store_08003f30",
            "code": "\n\n\nvoid applyMaskAndStore_08003f30(uint inputIndex,uint mask,uint data)\n\n{\n  uint minShift;\n  uint maxShift;\n  \n  minShift = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  maxShift = 7 - minShift;\n  if (3 < maxShift) {\n    maxShift = 4;\n  }\n  if (minShift + 4 < 7) {\n    minShift = 0;\n  }\n  else {\n    minShift = minShift - 3;\n  }\n  minShift = (mask & (1 << (maxShift & 0xff)) - 1U) << (minShift & 0xff) |\n          (1 << (minShift & 0xff)) - 1U & data;\n  if ((int)inputIndex < 0) {\n    *(char *)((inputIndex & 0xf) + 0xe000ed14) = (char)(minShift << 4);\n  }\n  else {\n    *(char *)(inputIndex + 0xe000e400) = (char)(minShift << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f30": "apply_mask_and_store_08003f30",
                "param_1": "inputIndex",
                "param_2": "mask",
                "param_3": "data",
                "uVar1": "minShift",
                "uVar2": "maxShift"
            },
            "calling": [
                "i2c_custom_init",
                "TimerPulseInit",
                "uart_attach_rx_callback",
                "HAL_InitTick",
                "SystemClock_Config",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f94": {
            "entrypoint": "0x08003f94",
            "current_name": "set_bit_value_08003f94",
            "code": "\nvoid setBitValue_08003f94(uint bitIndex)\n\n{\n  if (-1 < (int)bitIndex) {\n    *(int *)((bitIndex >> 5) * 4 + -0x1fff1f00) = 1 << (bitIndex & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f94": "set_bit_value_08003f94",
                "param_1": "bitIndex"
            },
            "calling": [
                "i2c_custom_init",
                "TimerPulseInit",
                "uart_attach_rx_callback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fb0": {
            "entrypoint": "0x08003fb0",
            "current_name": "set_bit_in_memory_08003fb0",
            "code": "\nvoid setBitInMemory_08003fb0(uint bitPosition)\n\n{\n  if (-1 < (int)bitPosition) {\n    *(int *)(((bitPosition >> 5) + 0x20) * 4 + -0x1fff1f00) = 1 << (bitPosition & 0x1f);\n    synchronizeData(0xf);\n    synchronizeInstructions(0xf);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fb0": "set_bit_in_memory_08003fb0",
                "param_1": "bitPosition",
                "DataSynchronizationBarrier": "synchronizeData",
                "InstructionSynchronizationBarrier": "synchronizeInstructions"
            },
            "calling": [
                "TimerPulseDeinit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fd8": {
            "entrypoint": "0x08003fd8",
            "current_name": "check_param_and_set_values_08003fd8",
            "code": "\n\n\nundefined4 check_param_and_set_values_08003fd8(int input_value)\n\n{\n  if (input_value - 1U < 0x1000000) {\n    _DAT_e000e014 = input_value - 1U;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08003fd8": "check_param_and_set_values_08003fd8",
                "param_1": "input_value"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004004": {
            "entrypoint": "0x08004004",
            "current_name": "set_bit_08004004",
            "code": "\nvoid setBit_08004004(uint input)\n\n{\n  if (-1 < (int)input) {\n    *(int *)(((input >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (input & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004004": "set_bit_08004004",
                "param_1": "input"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004024": {
            "entrypoint": "0x08004024",
            "current_name": "update_flag_08004024",
            "code": "\n\n\nvoid updateFlag_08004024(int flagValue)\n\n{\n  if (flagValue != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004024": "update_flag_08004024",
                "param_1": "flagValue"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004044": {
            "entrypoint": "0x08004044",
            "current_name": "FUNC_08004044",
            "code": "\nvoid FUNC_08004044(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004044": "FUNC_08004044"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004046": {
            "entrypoint": "0x08004046",
            "current_name": "initialize_systick_callback_08004046",
            "code": "\nvoid initializeSystickCallback_08004046(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004046": "initialize_systick_callback_08004046"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004050": {
            "entrypoint": "0x08004050",
            "current_name": "initialize_value_08004050",
            "code": "\n\n\nundefined4 initialize_value_08004050(uint **params)\n\n{\n  uint *temp_ptr;\n  \n  if (*(char *)((int)params + 0x21) != '\\x02') {\n    params[0xe] = (uint *)0x4;\n    return 1;\n  }\n  **params = **params & 0xfffffff1;\n  **params = **params & 0xfffffffe;\n  temp_ptr = *params;\n  if (temp_ptr == (uint *)0x40020008) {\n    _DAT_40020004 = 1;\n  }\n  else if (temp_ptr == (uint *)0x4002001c) {\n    _DAT_40020004 = 0x10;\n  }\n  else if (temp_ptr == (uint *)0x40020030) {\n    _DAT_40020004 = 0x100;\n  }\n  else if (temp_ptr == (uint *)0x40020044) {\n    _DAT_40020004 = 0x1000;\n  }\n  else if (temp_ptr == (uint *)0x40020058) {\n    _DAT_40020004 = 0x10000;\n  }\n  else if (temp_ptr == (uint *)0x4002006c) {\n    _DAT_40020004 = 0x100000;\n  }\n  else {\n    _DAT_40020004 = 0x1000000;\n  }\n  *(undefined *)((int)params + 0x21) = 1;\n  *(undefined *)(params + 8) = 0;\n  if (param_1_d != (uint *)0x0) {\n    (*(code *)param_1_d)();\n    return 0;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004050": "initialize_value_08004050",
                "param_1": "params",
                "puVar1": "temp_ptr",
                "param_1[0xd]": "param_1_d"
            },
            "calling": [
                "HAL_UART_IRQHandler",
                "I2C_ITError"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "update_config_flags_080040e8",
            "code": "\n\n\nvoid updateConfigFlags_080040e8(uint *configFlags,uint *inputValues)\n\n{\n  uint *currentConfigFlagPtr;\n  uint bitMask;\n  uint flagResult;\n  uint bitIndex;\n  uint conditionValue;\n  uint newConfigFlag;\n  int bitShift;\n  int index;\n  \n  newConfigFlag = 0;\n  bitIndex = 0;\n  do {\n    if (0xf < bitIndex) {\n      return;\n    }\n    bitMask = 1 << (bitIndex & 0xff);\n    flagResult = *inputValues & bitMask;\n    if (bitMask == flagResult) {\n      conditionValue = inputValues[1];\n      if (conditionValue == 0x12) {\n        newConfigFlag = inputValues[3] + 0xc;\n      }\n      else if (conditionValue < 0x13) {\n        if (conditionValue == 2) {\n          newConfigFlag = inputValues[3] + 8;\n        }\n        else if (conditionValue < 3) {\n          if (conditionValue == 0) goto LAB_0800423a;\n          if (conditionValue == 1) {\n            newConfigFlag = inputValues[3];\n          }\n        }\n        else if (conditionValue == 3) {\n          newConfigFlag = 0;\n        }\n        else if (conditionValue == 0x11) {\n          newConfigFlag = inputValues[3] + 4;\n        }\n      }\n      else if (conditionValue == 0x10210000) {\nLAB_0800423a:\n        if (inputValues[2] == 0) {\n          newConfigFlag = 4;\n        }\n        else if (inputValues[2] == 1) {\n          configFlags[4] = bitMask;\n          newConfigFlag = 8;\n        }\n        else {\n          configFlags[5] = bitMask;\n          newConfigFlag = 8;\n        }\n      }\n      else if (conditionValue < 0x10210001) {\n        if ((conditionValue == 0x10110000) || (conditionValue == 0x10120000)) goto LAB_0800423a;\n      }\n      else if ((conditionValue == 0x10310000) || ((conditionValue == 0x10320000 || (conditionValue == 0x10220000))))\n      goto LAB_0800423a;\n      bitMask = bitIndex;\n      currentConfigFlagPtr = configFlags;\n      if (0xff < flagResult) {\n        bitMask = bitIndex - 8;\n        currentConfigFlagPtr = configFlags + 1;\n      }\n      *currentConfigFlagPtr = *currentConfigFlagPtr & ~(0xf << (bitMask << 2 & 0xff)) | newConfigFlag << (bitMask << 2 & 0xff);\n      if ((inputValues[1] & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        bitShift = (bitIndex & 3) << 2;\n        if (configFlags == (uint *)0x40010800) {\n          index = 0;\n        }\n        else if (configFlags == (uint *)0x40010c00) {\n          index = 1;\n        }\n        else if (configFlags == (uint *)0x40011000) {\n          index = 2;\n        }\n        else if (configFlags == (uint *)0x40011400) {\n          index = 3;\n        }\n        else {\n          index = 4;\n        }\n        *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000) =\n             *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000) & ~(0xf << bitShift) | index << bitShift;\n        if ((inputValues[1] & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~flagResult;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | flagResult;\n        }\n        if ((inputValues[1] & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~flagResult;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | flagResult;\n        }\n        if ((inputValues[1] & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~flagResult;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | flagResult;\n        }\n        if ((inputValues[1] & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~flagResult;\n        }\n        else {\n          _DAT_4001040c = flagResult | _DAT_4001040c;\n        }\n      }\n    }\n    bitIndex = bitIndex + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080040e8": "update_config_flags_080040e8",
                "param_1": "configFlags",
                "param_2": "inputValues",
                "puVar1": "currentConfigFlagPtr",
                "uVar2": "bitMask",
                "uVar3": "flagResult",
                "uVar4": "bitIndex",
                "uVar5": "conditionValue",
                "uVar6": "newConfigFlag",
                "iVar7": "bitShift",
                "iVar8": "index"
            },
            "calling": [
                "uart_init",
                "i2c_custom_init",
                "HAL_TIM_PWM_MspInit",
                "HAL_ADC_MspInit",
                "digital_io_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042d4": {
            "entrypoint": "0x080042d4",
            "current_name": "check_bit_080042d4",
            "code": "\nundefined4 check_bit_080042d4(int input1,uint input2)\n\n{\n  if ((input2 & *(uint *)(input1 + 8)) == 0) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080042d4": "check_bit_080042d4",
                "param_1": "input1",
                "param_2": "input2"
            },
            "calling": [
                "digital_io_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042e2": {
            "entrypoint": "0x080042e2",
            "current_name": "set_param_value_080042e2",
            "code": "\nvoid setParamValue_080042e2(int objectAddress,int paramValue,int isShifted)\n\n{\n  if (isShifted == 0) {\n    *(int *)(objectAddress + 0x10) = paramValue << 0x10;\n    return;\n  }\n  *(int *)(objectAddress + 0x10) = paramValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080042e2": "set_param_value_080042e2",
                "param_1": "objectAddress",
                "param_2": "paramValue",
                "param_3": "isShifted"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042f0": {
            "entrypoint": "0x080042f0",
            "current_name": "update_interrupt_flag_080042f0",
            "code": "\n\n\nvoid update_interrupt_flag_080042f0(uint input_value)\n\n{\n  if ((_DAT_40010414 & input_value) != 0) {\n    _DAT_40010414 = input_value;\n    handle_external_interrupt();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080042f0": "update_interrupt_flag_080042f0",
                "param_1": "input_value",
                "HAL_GPIO_EXTI_Callback": "handle_external_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800430c": {
            "entrypoint": "0x0800430c",
            "current_name": "set_param_flag_0800430c",
            "code": "\nundefined4 setParamFlag_0800430c(int *paramList)\n\n{\n  if (*(char *)((int)paramList + 0x3e) == '@') {\n    if (paramList[0x14] == 0) {\n      *(uint *)(*paramList + 0x10) = paramList[0x11] & 0xfe;\n    }\n    else {\n      *(uint *)(*paramList + 0x10) = paramList[0x11] & 0xffU | 1;\n    }\n  }\n  else if (paramList[4] == 0x4000) {\n    if (*(char *)((int)paramList + 0x3d) == '!') {\n      *(uint *)(*paramList + 0x10) = paramList[0x11] & 0xfe;\n    }\n    else {\n      *(uint *)(*paramList + 0x10) = paramList[0x11] & 0xffU | 1;\n    }\n  }\n  else if (paramList[0x14] == 0) {\n    *(uint *)(*paramList + 0x10) = (uint)(paramList[0x11] << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (paramList[0x14] == 1) {\n    *(uint *)(*paramList + 0x10) = (uint)(paramList[0x11] << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800430c": "set_param_flag_0800430c",
                "param_1": "paramList"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004396": {
            "entrypoint": "0x08004396",
            "current_name": "set_byte_value_08004396",
            "code": "\nundefined4 setByteValue_08004396(int *inputBuffer)\n\n{\n  *(uint *)(*inputBuffer + 0x10) = inputBuffer[17] & 0xff;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004396": "set_byte_value_08004396",
                "param_1": "inputBuffer",
                "param_1[0x11]": "inputBuffer[17]"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043a2": {
            "entrypoint": "0x080043a2",
            "current_name": "set_flags_080043a2",
            "code": "\nundefined4 setFlags_080043a2(uint **parameters)\n\n{\n  uint *pointerVar1;\n  \n  pointerVar1 = parameters[0xb];\n  if ((*(char *)((int)parameters + 0x3d) == '\\\"') &&\n     ((parameters[0x14] != (uint *)0x0 || (*(char *)((int)parameters + 0x3e) != '@')))) {\n    if ((parameters[0x14] == (uint *)0x0) && (parameters[4] == (uint *)0xc000)) {\n      **parameters = **parameters | 0x100;\n      parameters[0x14] = (uint *)((int)parameters[0x14] + 1);\n    }\n    else {\n      if (*(short *)((int)parameters + 0x2a) == 0) {\n        **parameters = **parameters | 0x200;\n      }\n      else if (*(short *)((int)parameters + 0x2a) == 1) {\n        if (pointerVar1 == (uint *)0xffff0000) {\n          **parameters = **parameters & 0xfffffbff;\n          pointerVar1 = *parameters;\n          if ((pointerVar1[1] & 0x800) == 0) {\n            *pointerVar1 = *pointerVar1 | 0x200;\n          }\n          else {\n            *pointerVar1 = *pointerVar1 & 0xfffffbff;\n          }\n        }\n        else if (((pointerVar1 == (uint *)0x4) || (pointerVar1 == (uint *)0x8)) ||\n                (parameters[0xc] == (uint *)0x12)) {\n          **parameters = **parameters & 0xfffffbff;\n          **parameters = **parameters | 0x200;\n        }\n        else if (parameters[0xb] == (uint *)0x2) {\n          **parameters = **parameters | 0x400;\n        }\n        else {\n          **parameters = **parameters & 0xfffffbff;\n        }\n      }\n      else if (*(short *)((int)parameters + 0x2a) == 2) {\n        if (parameters[0xb] == (uint *)0x2) {\n          **parameters = **parameters | 0x400;\n        }\n        else {\n          **parameters = **parameters | 0x800;\n          **parameters = **parameters & 0xfffffbff;\n        }\n        pointerVar1 = *parameters;\n        if ((pointerVar1[1] & 0x800) != 0) {\n          pointerVar1[1] = pointerVar1[1] | 0x1000;\n        }\n      }\n      else {\n        **parameters = **parameters | 0x400;\n        pointerVar1 = *parameters;\n        if ((pointerVar1[1] & 0x800) != 0) {\n          pointerVar1[1] = pointerVar1[1] | 0x1000;\n        }\n      }\n      parameters[0x14] = (uint *)0x0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080043a2": "set_flags_080043a2",
                "param_1": "parameters",
                "puVar1": "pointerVar1"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800457c": {
            "entrypoint": "0x0800457c",
            "current_name": "update_pointer_0800457c",
            "code": "\nundefined4 updatePointer_0800457c(int *ptrArray)\n\n{\n  byte *bytePointer;\n  \n  if (*(short *)((int)ptrArray + 0x2a) != 0) {\n    bytePointer = (byte *)ptrArray[9];\n    ptrArray[9] = (int)(bytePointer + 1);\n    *(uint *)(*ptrArray + 0x10) = (uint)*bytePointer;\n    *(short *)((int)ptrArray + 0x2a) = *(short *)((int)ptrArray + 0x2a) + -1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800457c": "update_pointer_0800457c",
                "param_1": "ptrArray",
                "pbVar1": "bytePointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800459c": {
            "entrypoint": "0x0800459c",
            "current_name": "update_array_element_0800459c",
            "code": "\nundefined4 updateArrayElement_0800459c(int *array)\n\n{\n  undefined *element;\n  \n  if (*(short *)((int)array + 0x2a) != 0) {\n    element = (undefined *)arrayAddress;\n    arrayAddress = (int)(element + 1);\n    *element = (char)*(undefined4 *)(*array + 0x10);\n    *(short *)((int)array + 0x2a) = *(short *)((int)array + 0x2a) + -1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800459c": "update_array_element_0800459c",
                "param_1": "array",
                "puVar1": "element",
                "param_1[9]": "arrayAddress"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045bc": {
            "entrypoint": "0x080045bc",
            "current_name": "FUNC_080045bc",
            "code": "\nvoid FUNC_080045bc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080045bc": "FUNC_080045bc"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080045c0": {
            "entrypoint": "0x080045c0",
            "current_name": "initialize_i2_c_080045c0",
            "code": "\nundefined4 initializeI2C_080045c0(uint **param)\n\n{\n  bool isLowFrequency;\n  uint pclk1Frequency;\n  uint *param1;\n  uint calculationResult;\n  \n  if (param == (uint **)0x0) {\n    return 1;\n  }\n  if (*(char *)((int)param + 0x3d) == '\\0') {\n    *(undefined *)(param + 0xf) = 0;\n    HAL_I2C_MspInit();\n  }\n  *(undefined *)((int)param + 0x3d) = 0x24;\n  **param = **param & 0xfffffffe;\n  pclk1Frequency = HAL_RCC_GetPCLK1Freq();\n  if (param[1] < (uint *)0x186a1) {\n    if (pclk1Frequency < 2000000) {\n      isLowFrequency = true;\n    }\n    else {\n      isLowFrequency = false;\n    }\n  }\n  else {\n    isLowFrequency = pclk1Frequency < 4000000;\n  }\n  if (isLowFrequency) {\n    return 1;\n  }\n  calculationResult = pclk1Frequency / 1000000;\n  (*param)[1] = calculationResult;\n  if ((uint *)0x186a0 < param[1]) {\n    calculationResult = (calculationResult * 300) / 1000;\n  }\n  (*param)[8] = calculationResult + 1;\n  param1 = param[1];\n  if (param1 < (uint *)0x186a1) {\n    pclk1Frequency = (pclk1Frequency - 1) / (uint)((int)param1 << 1) + 1 & 0xfff;\n    if (pclk1Frequency < 4) {\n      pclk1Frequency = 4;\n    }\n  }\n  else {\n    if (param[2] == (uint *)0x0) {\n      calculationResult = (pclk1Frequency - 1) / (uint)((int)param1 * 3);\n    }\n    else {\n      calculationResult = (pclk1Frequency - 1) / (uint)((int)param1 * 0x19);\n    }\n    if ((calculationResult + 1 & 0xfff) == 0) {\n      pclk1Frequency = 1;\n    }\n    else if (param[2] == (uint *)0x0) {\n      pclk1Frequency = (pclk1Frequency - 1) / (uint)((int)param1 * 3) + 1 & 0xfff | 0x8000;\n    }\n    else {\n      pclk1Frequency = (pclk1Frequency - 1) / (uint)((int)param1 * 0x19) + 1 & 0xfff | 0xc000;\n    }\n  }\n  (*param)[7] = pclk1Frequency;\n  **param = (uint)param[7] | (uint)param[8];\n  (*param)[2] = (uint)param[4] | (uint)param[3];\n  (*param)[3] = (uint)param[5] | (uint)param[6];\n  **param = **param | 1;\n  param[0x10] = (uint *)0x0;\n  *(undefined *)((int)param + 0x3d) = 0x20;\n  param[0xc] = (uint *)0x0;\n  *(undefined *)((int)param + 0x3e) = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080045c0": "initialize_i2_c_080045c0",
                "param_1": "param",
                "bVar1": "isLowFrequency",
                "uVar2": "pclk1Frequency",
                "puVar3": "param1",
                "uVar4": "calculationResult"
            },
            "calling": [
                "i2c_custom_init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_I2C_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004728": {
            "entrypoint": "0x08004728",
            "current_name": "process_data_08004728",
            "code": "\nundefined4 processData_08004728(uint **dataPtr,uint *inputPtr,uint *outputPtr,undefined2 paramVal)\n\n{\n  undefined4 returnValue;\n  uint *ptrVar;\n  int counter;\n  \n  if (*(char *)((int)dataPtr + 0x3d) == ' ') {\n    counter = (DAT_20000018 / 25000) * 0x19;\n    do {\n      if (counter == 0) {\n        dataPtr[0xc] = (uint *)0x0;\n        *(undefined *)((int)dataPtr + 0x3d) = 0x20;\n        *(undefined *)(dataPtr + 0xf) = 0;\n        return 3;\n      }\n      ptrVar = *dataPtr;\n      counter = counter + -1;\n    } while ((ptrVar[6] & 2) != 0);\n    if (*(char *)(dataPtr + 0xf) == '\\x01') {\n      returnValue = 2;\n    }\n    else {\n      *(undefined *)(dataPtr + 0xf) = 1;\n      if ((*ptrVar & 1) == 0) {\n        *ptrVar = *ptrVar | 1;\n      }\n      **dataPtr = **dataPtr & 0xfffff7ff;\n      *(undefined *)((int)dataPtr + 0x3d) = 0x21;\n      *(undefined *)((int)dataPtr + 0x3e) = 0x10;\n      returnValue = 0;\n      dataPtr[0x10] = (uint *)0x0;\n      dataPtr[9] = outputPtr;\n      *(undefined2 *)((int)dataPtr + 0x2a) = paramVal;\n      dataPtr[0xb] = (uint *)0xffff0000;\n      *(undefined2 *)(dataPtr + 10) = *(undefined2 *)((int)dataPtr + 0x2a);\n      dataPtr[0x11] = inputPtr;\n      **dataPtr = **dataPtr | 0x100;\n      *(undefined *)(dataPtr + 0xf) = 0;\n      (*dataPtr)[1] = (*dataPtr)[1] | 0x700;\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004728": "process_data_08004728",
                "param_1": "dataPtr",
                "param_2": "inputPtr",
                "param_3": "outputPtr",
                "param_4": "paramVal",
                "uVar1": "returnValue",
                "puVar2": "ptrVar",
                "local_c": "counter"
            },
            "calling": [
                "i2c_master_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f4": {
            "entrypoint": "0x080047f4",
            "current_name": "handle_data_080047f4",
            "code": "\nundefined4 handle_data_080047f4(uint **data_ptr,uint *param_2,uint *param_3,undefined2 param_4)\n\n{\n  undefined4 result;\n  uint *ptr;\n  int counter;\n  \n  if (*(char *)((int)data_ptr + 0x3d) == ' ') {\n    counter = (DAT_20000018 / 25000) * 0x19;\n    do {\n      if (counter == 0) {\n        data_ptr[0xc] = (uint *)0x0;\n        *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n        *(undefined *)(data_ptr + 0xf) = 0;\n        return 3;\n      }\n      ptr = *data_ptr;\n      counter = counter + -1;\n    } while ((ptr[6] & 2) != 0);\n    if (*(char *)(data_ptr + 0xf) == '\\x01') {\n      result = 2;\n    }\n    else {\n      *(undefined *)(data_ptr + 0xf) = 1;\n      if ((*ptr & 1) == 0) {\n        *ptr = *ptr | 1;\n      }\n      **data_ptr = **data_ptr & 0xfffff7ff;\n      *(undefined *)((int)data_ptr + 0x3d) = 0x22;\n      *(undefined *)((int)data_ptr + 0x3e) = 0x10;\n      result = 0;\n      data_ptr[0x10] = (uint *)0x0;\n      data_ptr[9] = param_3;\n      *(undefined2 *)((int)data_ptr + 0x2a) = param_4;\n      data_ptr[0xb] = (uint *)0xffff0000;\n      *(undefined2 *)(data_ptr + 10) = *(undefined2 *)((int)data_ptr + 0x2a);\n      data_ptr[0x11] = param_2;\n      **data_ptr = **data_ptr | 0x400;\n      **data_ptr = **data_ptr | 0x100;\n      *(undefined *)(data_ptr + 0xf) = 0;\n      (*data_ptr)[1] = (*data_ptr)[1] | 0x700;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080047f4": "handle_data_080047f4",
                "param_1": "data_ptr",
                "uVar1": "result",
                "puVar2": "ptr",
                "local_c": "counter"
            },
            "calling": [
                "i2c_master_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048c8": {
            "entrypoint": "0x080048c8",
            "current_name": "validate_params_080048c8",
            "code": "\nundefined4 validate_params_080048c8(uint **param_ptr,uint *data_ptr,int data_size,uint *result_ptr)\n\n{\n  undefined4 status;\n  uint *ptr;\n  \n  if (*(char *)((int)param_ptr + 0x3d) == '(') {\n    if (data_ptr == (uint *)0x0) {\n      status = 1;\n    }\n    else if (data_size == 0) {\n      status = 1;\n    }\n    else if (*(char *)(param_ptr + 0xf) == '\\x01') {\n      status = 2;\n    }\n    else {\n      *(undefined *)(param_ptr + 0xf) = 1;\n      ptr = *param_ptr;\n      if ((*ptr & 1) == 0) {\n        *ptr = *ptr | 1;\n      }\n      **param_ptr = **param_ptr & 0xfffff7ff;\n      *(undefined *)((int)param_ptr + 0x3d) = 0x29;\n      *(undefined *)((int)param_ptr + 0x3e) = 0x20;\n      status = 0;\n      param_ptr_plus_0x10 = (uint *)0x0;\n      param_ptr_plus_9 = data_ptr;\n      *(short *)((int)param_ptr + 0x2a) = (short)data_size;\n      param_ptr_plus_0xb = result_ptr;\n      *(undefined2 *)(param_ptr + 10) = *(undefined2 *)((int)param_ptr + 0x2a);\n      *(undefined *)(param_ptr + 0xf) = 0;\n      (*param_ptr)[1] = (*param_ptr)[1] | 0x700;\n    }\n  }\n  else {\n    status = 2;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080048c8": "validate_params_080048c8",
                "param_1": "param_ptr",
                "param_2": "data_ptr",
                "param_3": "data_size",
                "param_4": "result_ptr",
                "uVar1": "status",
                "puVar2": "ptr",
                "param_1[0x10]": "param_ptr_plus_0x10",
                "param_1[9]": "param_ptr_plus_9",
                "param_1[0xb]": "param_ptr_plus_0xb"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004954": {
            "entrypoint": "0x08004954",
            "current_name": "check_param_and_initialize_08004954",
            "code": "\nundefined4 check_param_and_initialize_08004954(uint **input,uint *ptr,int size,uint *output)\n\n{\n  undefined4 result;\n  uint *ptr_tmp;\n  \n  if (*(char *)((int)input + 0x3d) == '(') {\n    if (ptr == (uint *)0x0) {\n      result = 1;\n    }\n    else if (size == 0) {\n      result = 1;\n    }\n    else if (*(char *)(input + 0xf) == '\\x01') {\n      result = 2;\n    }\n    else {\n      *(undefined *)(input + 0xf) = 1;\n      ptr_tmp = *input;\n      if ((*ptr_tmp & 1) == 0) {\n        *ptr_tmp = *ptr_tmp | 1;\n      }\n      **input = **input & 0xfffff7ff;\n      *(undefined *)((int)input + 0x3d) = 0x2a;\n      *(undefined *)((int)input + 0x3e) = 0x20;\n      result = 0;\n      input[0x10] = (uint *)0x0;\n      input[9] = ptr;\n      *(short *)((int)input + 0x2a) = (short)size;\n      input[0xb] = output;\n      *(undefined2 *)(input + 10) = *(undefined2 *)((int)input + 0x2a);\n      *(undefined *)(input + 0xf) = 0;\n      (*input)[1] = (*input)[1] | 0x700;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004954": "check_param_and_initialize_08004954",
                "param_1": "input",
                "param_2": "ptr",
                "param_3": "size",
                "param_4": "output",
                "uVar1": "result",
                "puVar2": "ptr_tmp"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049e0": {
            "entrypoint": "0x080049e0",
            "current_name": "initialize_data_080049e0",
            "code": "\nundefined4 initializeData_080049e0(uint **dataPointer)\n\n{\n  uint *valuePointer;\n  \n  if (*(char *)((int)dataPointer + 0x3d) != ' ') {\n    return 2;\n  }\n  *(undefined *)((int)dataPointer + 0x3d) = 0x28;\n  valuePointer = *dataPointer;\n  if ((*valuePointer & 1) == 0) {\n    *valuePointer = *valuePointer | 1;\n  }\n  **dataPointer = **dataPointer | 0x400;\n  (*dataPointer)[1] = (*dataPointer)[1] | 0x300;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080049e0": "initialize_data_080049e0",
                "param_1": "dataPointer",
                "puVar1": "valuePointer"
            },
            "calling": [
                "i2c_attachSlaveRxEvent",
                "HAL_I2C_ErrorCallback",
                "i2c_attachSlaveTxEvent",
                "HAL_I2C_ListenCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a1e": {
            "entrypoint": "0x08004a1e",
            "current_name": "FUNC_08004a1e",
            "code": "\nvoid FUNC_08004a1e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a1e": "FUNC_08004a1e"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004a20": {
            "entrypoint": "0x08004a20",
            "current_name": "FUNC_08004a20",
            "code": "\nvoid FUNC_08004a20(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a20": "FUNC_08004a20"
            },
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004a22": {
            "entrypoint": "0x08004a22",
            "current_name": "FUNC_08004a22",
            "code": "\nvoid FUNC_08004a22(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a22": "FUNC_08004a22"
            },
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004a24": {
            "entrypoint": "0x08004a24",
            "current_name": "process_data_08004a24",
            "code": "\nundefined4 processData_08004a24(int *data)\n\n{\n  char character;\n  byte *bytePointer;\n  \n  character = *(char *)((int)data + 0x3d);\n  if (*(short *)((int)data + 0x2a) != 0) {\n    bytePointer = (byte *)data[9];\n    data[9] = (int)(bytePointer + 1);\n    *(uint *)(*data + 0x10) = (uint)*bytePointer;\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    if ((*(short *)((int)data + 0x2a) == 0) && (character == ')')) {\n      *(uint *)(*data + 4) = *(uint *)(*data + 4) & 0xfffffbff;\n      data[0xc] = 0x21;\n      *(undefined *)((int)data + 0x3d) = 0x28;\n      HAL_I2C_SlaveTxCpltCallback();\n    }\n    return 0;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004a24": "process_data_08004a24",
                "param_1": "data",
                "cVar1": "character",
                "pbVar2": "bytePointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a74": {
            "entrypoint": "0x08004a74",
            "current_name": "FUNC_08004a74",
            "code": "\nvoid FUNC_08004a74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a74": "FUNC_08004a74"
            },
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004a76": {
            "entrypoint": "0x08004a76",
            "current_name": "update_i2_c_data_08004a76",
            "code": "\nundefined4 updateI2CData_08004a76(int *data)\n\n{\n  char character;\n  undefined *pointer;\n  \n  character = *(char *)((int)data + 0x3d);\n  if (*(short *)((int)data + 0x2a) != 0) {\n    pointer = (undefined *)pointer_9;\n    pointer_9 = (int)(pointer + 1);\n    *pointer = (char)*(undefined4 *)(*data + 0x10);\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    if ((*(short *)((int)data + 0x2a) == 0) && (character == '*')) {\n      *(uint *)(*data + 4) = *(uint *)(*data + 4) & 0xfffffbff;\n      value_c = 0x22;\n      *(undefined *)((int)data + 0x3d) = 0x28;\n      HAL_I2C_SlaveRxCpltCallback();\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004a76": "update_i2_c_data_08004a76",
                "param_1": "data",
                "cVar1": "character",
                "puVar2": "pointer",
                "param_1[9]": "pointer_9",
                "param_1[0xc]": "value_c"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ac2": {
            "entrypoint": "0x08004ac2",
            "current_name": "i2c_address_callback_08004ac2",
            "code": "\nundefined4 i2cAddressCallback_08004ac2(int *i2cData,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  undefined2 selectedData;\n  uint addressValue;\n  \n  addressValue = *(uint *)(*i2cData + 0x18);\n  if ((addressValue & 0x80) == 0) {\n    selectedData = *(undefined2 *)(i2cData + 3);\n  }\n  else {\n    selectedData = *(undefined2 *)(i2cData + 6);\n  }\n  HAL_I2C_AddrCallback(i2cData,(*(uint *)(*i2cData + 0x18) & 4) == 0,selectedData,addressValue,param4);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004ac2": "i2c_address_callback_08004ac2",
                "param_1": "i2cData",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "selectedData",
                "uVar2": "addressValue"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004aec": {
            "entrypoint": "0x08004aec",
            "current_name": "process_i2_c_data_08004aec",
            "code": "\nundefined4 processI2CData_08004aec(uint **data)\n\n{\n  if (((data[11] == (uint *)0x4) || (data[11] == (uint *)0x8)) &&\n     (*(char *)((int)data + 0x3d) == '(')) {\n    data[11] = (uint *)0xffff0000;\n    (*data)[1] = (*data)[1] & 0xfffff8ff;\n    (*data)[5] = 0xfffffbff;\n    **data = **data & 0xfffffbff;\n    data[12] = (uint *)0x0;\n    *(undefined *)((int)data + 0x3d) = 0x20;\n    *(undefined *)((int)data + 0x3e) = 0;\n    HAL_I2C_ListenCpltCallback();\n  }\n  else if (*(char *)((int)data + 0x3d) == '!') {\n    data[11] = (uint *)0xffff0000;\n    data[12] = (uint *)0x21;\n    *(undefined *)((int)data + 0x3d) = 0x20;\n    *(undefined *)((int)data + 0x3e) = 0;\n    (*data)[1] = (*data)[1] & 0xfffff8ff;\n    (*data)[5] = 0xfffffbff;\n    **data = **data & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback();\n  }\n  else {\n    (*data)[5] = 0xfffffbff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004aec": "process_i2_c_data_08004aec",
                "param_1": "data",
                "param_1[0xb]": "data[11]",
                "param_1[0xc]": "data[12]"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b80": {
            "entrypoint": "0x08004b80",
            "current_name": "FUNC_08004b80",
            "code": "\nvoid FUNC_08004b80(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b80": "FUNC_08004b80"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004b82": {
            "entrypoint": "0x08004b82",
            "current_name": "process_data_08004b82",
            "code": "\nundefined4 processData_08004b82(uint **data)\n\n{\n  char charValue;\n  uint *pointer2;\n  \n  charValue = *(char *)((int)data + 0x3d);\n  pointer2 = pointer3;\n  if ((*(short *)(data + 10) == 0) && (charValue == '!')) {\n    if ((pointer2 == (uint *)0x4) || ((pointer2 == (uint *)0x8 || (pointer2 == (uint *)0xffff0000)))) {\n      (*data)[1] = (*data)[1] & 0xfffff8ff;\n      **data = **data | 0x200;\n      pointer4 = (uint *)0x0;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      if (*(char *)((int)data + 0x3e) == '@') {\n        *(undefined *)((int)data + 0x3e) = 0;\n        HAL_I2C_MemTxCpltCallback();\n      }\n      else {\n        *(undefined *)((int)data + 0x3e) = 0;\n        HAL_I2C_MasterTxCpltCallback();\n      }\n    }\n    else {\n      (*data)[1] = (*data)[1] & 0xfffff8ff;\n      pointer4 = (uint *)0x11;\n      *(undefined *)((int)data + 0x3e) = 0;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      HAL_I2C_MasterTxCpltCallback();\n    }\n  }\n  else if ((charValue == '!') || ((*(char *)((int)data + 0x3e) == '@' && (charValue == '\\\"')))) {\n    if (*(short *)((int)data + 0x2a) == 0) {\n      (*data)[1] = (*data)[1] & 0xfffffbff;\n    }\n    else if (*(char *)((int)data + 0x3e) == '@') {\n      if (pointer5 == (uint *)0x0) {\n        if (pointer6 == (uint *)0x1) {\n          (*data)[4] = (uint)pointer7 & 0xff;\n          pointer5 = (uint *)((int)pointer5 + 2);\n        }\n        else {\n          (*data)[4] = (uint)((int)pointer7 << 0x10) >> 0x18;\n          pointer5 = (uint *)((int)pointer5 + 1);\n        }\n      }\n      else if (pointer5 == (uint *)0x1) {\n        (*data)[4] = (uint)pointer7 & 0xff;\n        pointer5 = (uint *)((int)pointer5 + 1);\n      }\n      else if (pointer5 == (uint *)0x2) {\n        if (*(char *)((int)data + 0x3d) == '\\\"') {\n          **data = **data | 0x100;\n        }\n        else if (*(char *)((int)data + 0x3d) == '!') {\n          pointer2 = data[9];\n          data[9] = (uint *)((int)pointer2 + 1);\n          (*data)[4] = (uint)*(byte *)pointer2;\n          *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n        }\n      }\n    }\n    else {\n      pointer2 = data[9];\n      data[9] = (uint *)((int)pointer2 + 1);\n      (*data)[4] = (uint)*(byte *)pointer2;\n      *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004b82": "process_data_08004b82",
                "param_1": "data",
                "cVar1": "charValue",
                "puVar2": "pointer2",
                "param_1[0xb]": "pointer3",
                "param_1[0xc]": "pointer4",
                "param_1[0x14]": "pointer5",
                "param_1[0x13]": "pointer6",
                "param_1[0x12]": "pointer7"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ccc": {
            "entrypoint": "0x08004ccc",
            "current_name": "handle_i2_c_transfer_08004ccc",
            "code": "\nundefined4 handleI2CTransfer_08004ccc(uint **inputParams)\n\n{\n  uint *param_b;\n  \n  param_b = param_1_b;\n  if (*(char *)((int)inputParams + 0x3d) == '!') {\n    if (*(short *)((int)inputParams + 0x2a) == 0) {\n      if (((param_b == (uint *)0x4) || (param_b == (uint *)0x8)) || (param_b == (uint *)0xffff0000)) {\n        (*inputParams)[1] = (*inputParams)[1] & 0xfffff8ff;\n        **inputParams = **inputParams | 0x200;\n        param_1_c = (uint *)0x0;\n        *(undefined *)((int)inputParams + 0x3d) = 0x20;\n        if (*(char *)((int)inputParams + 0x3e) == '@') {\n          *(undefined *)((int)inputParams + 0x3e) = 0;\n          HAL_I2C_MemTxCpltCallback();\n        }\n        else {\n          *(undefined *)((int)inputParams + 0x3e) = 0;\n          HAL_I2C_MasterTxCpltCallback();\n        }\n      }\n      else {\n        (*inputParams)[1] = (*inputParams)[1] & 0xfffff8ff;\n        param_1_c = (uint *)0x11;\n        *(undefined *)((int)inputParams + 0x3e) = 0;\n        *(undefined *)((int)inputParams + 0x3d) = 0x20;\n        HAL_I2C_MasterTxCpltCallback();\n      }\n    }\n    else {\n      param_b = inputParams[9];\n      inputParams[9] = (uint *)((int)param_b + 1);\n      (*inputParams)[4] = (uint)*(byte *)param_b;\n      *(short *)((int)inputParams + 0x2a) = *(short *)((int)inputParams + 0x2a) + -1;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004ccc": "handle_i2_c_transfer_08004ccc",
                "param_1": "inputParams",
                "puVar1": "param_b",
                "param_1[0xb]": "param_1_b",
                "param_1[0xc]": "param_1_c"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d6a": {
            "entrypoint": "0x08004d6a",
            "current_name": "FUNC_08004d6a",
            "code": "\nvoid FUNC_08004d6a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d6a": "FUNC_08004d6a"
            },
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004d6c": {
            "entrypoint": "0x08004d6c",
            "current_name": "decode_and_process_data_08004d6c",
            "code": "\nundefined4 decode_and_process_data_08004d6c(uint **data)\n\n{\n  uint *pointer;\n  \n  if (*(char *)((int)data + 0x3d) == '\\\"') {\n    if (*(ushort *)((int)data + 0x2a) < 4) {\n      if (*(ushort *)((int)data + 0x2a) - 2 < 2) {\n        if (ptr_value == (uint *)0x2) {\n          **data = **data | 0x400;\n        }\n        else {\n          **data = **data & 0xfffffbff;\n          **data = **data | 0x800;\n        }\n        (*data)[1] = (*data)[1] & 0xfffffbff;\n      }\n      else {\n        if (ptr_value == (uint *)0x2) {\n          **data = **data | 0x400;\n        }\n        else {\n          **data = **data & 0xfffffbff;\n        }\n        (*data)[1] = (*data)[1] & 0xfffff8ff;\n        pointer = ptr_offset_9;\n        ptr_offset_9 = (uint *)((int)pointer + 1);\n        *(char *)pointer = (char)(*data)[4];\n        *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n        *(undefined *)((int)data + 0x3d) = 0x20;\n        ptr_offset_c = (uint *)0x0;\n        if (*(char *)((int)data + 0x3e) == '@') {\n          *(undefined *)((int)data + 0x3e) = 0;\n          HAL_I2C_MemRxCpltCallback();\n        }\n        else {\n          *(undefined *)((int)data + 0x3e) = 0;\n          HAL_I2C_MasterRxCpltCallback();\n        }\n      }\n    }\n    else {\n      pointer = ptr_offset_9;\n      ptr_offset_9 = (uint *)((int)pointer + 1);\n      *(char *)pointer = (char)(*data)[4];\n      *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004d6c": "decode_and_process_data_08004d6c",
                "param_1": "data",
                "puVar1": "pointer",
                "param_1[0xb]": "ptr_value",
                "param_1[9]": "ptr_offset_9",
                "param_1[0xc]": "ptr_offset_c"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e3c": {
            "entrypoint": "0x08004e3c",
            "current_name": "process_data_08004e3c",
            "code": "\nundefined4 processData_08004e3c(uint **inputArray)\n\n{\n  uint *currentValue;\n  \n  currentValue = inputArray[0xb];\n  if (*(short *)((int)inputArray + 0x2a) == 3) {\n    if (((currentValue == (uint *)0x4) || (currentValue == (uint *)0x8)) || (currentValue == (uint *)0xffff0000)) {\n      **inputArray = **inputArray & 0xfffffbff;\n    }\n    currentValue = outputArray;\n    outputArray = (uint *)((int)currentValue + 1);\n    *(char *)currentValue = (char)(*inputArray)[4];\n    *(short *)((int)inputArray + 0x2a) = *(short *)((int)inputArray + 0x2a) + -1;\n  }\n  else if (*(short *)((int)inputArray + 0x2a) == 2) {\n    if (((currentValue == (uint *)0x4) || (currentValue == (uint *)0x8)) || (currentValue == (uint *)0xffff0000)) {\n      (*inputArray)[1] = (*inputArray)[1] & 0xfffffcff;\n      **inputArray = **inputArray | 0x200;\n    }\n    else {\n      if (currentValue == (uint *)0x2) {\n        **inputArray = **inputArray | 0x400;\n      }\n      else {\n        **inputArray = **inputArray & 0xfffffbff;\n      }\n      (*inputArray)[1] = (*inputArray)[1] & 0xfffffcff;\n    }\n    currentValue = outputArray;\n    outputArray = (uint *)((int)currentValue + 1);\n    *(char *)currentValue = (char)(*inputArray)[4];\n    *(short *)((int)inputArray + 0x2a) = *(short *)((int)inputArray + 0x2a) + -1;\n    currentValue = outputArray;\n    outputArray = (uint *)((int)currentValue + 1);\n    *(char *)currentValue = (char)(*inputArray)[4];\n    *(short *)((int)inputArray + 0x2a) = *(short *)((int)inputArray + 0x2a) + -1;\n    *(undefined *)((int)inputArray + 0x3d) = 0x20;\n    inputArray[0xc] = (uint *)0x0;\n    if (*(char *)((int)inputArray + 0x3e) == '@') {\n      *(undefined *)((int)inputArray + 0x3e) = 0;\n      memRxCpltCallback();\n    }\n    else {\n      *(undefined *)((int)inputArray + 0x3e) = 0;\n      masterRxCpltCallback();\n    }\n  }\n  else {\n    currentValue = outputArray;\n    outputArray = (uint *)((int)currentValue + 1);\n    *(char *)currentValue = (char)(*inputArray)[4];\n    *(short *)((int)inputArray + 0x2a) = *(short *)((int)inputArray + 0x2a) + -1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004e3c": "process_data_08004e3c",
                "param_1": "inputArray",
                "puVar1": "currentValue",
                "param_1[9]": "outputArray",
                "HAL_I2C_MemRxCpltCallback()": "memRxCpltCallback()",
                "HAL_I2C_MasterRxCpltCallback()": "masterRxCpltCallback()"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3a": {
            "entrypoint": "0x08004f3a",
            "current_name": "FUNC_08004f3a",
            "code": "\nvoid FUNC_08004f3a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3a": "FUNC_08004f3a"
            },
            "calling": [
                "I2C_ITError"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "handle_i2_c_interrupt_08004f3c",
            "code": "\nvoid handleI2CInterrupt_08004f3c(uint **param)\n\n{\n  int errorStatus;\n  uint *charPtr;\n  uint *paramPtr;\n  \n  if (*(byte *)((int)param + 0x3d) - 0x29 < 2) {\n    someValue2 = (uint *)0x0;\n    *(undefined *)((int)param + 0x3d) = 0x28;\n  }\n  else {\n    if ((*(char *)((int)param + 0x3d) != '`') && (((*param)[1] & 0x800) == 0)) {\n      *(undefined *)((int)param + 0x3d) = 0x20;\n    }\n    someValue2 = (uint *)0x0;\n    *(undefined *)((int)param + 0x3e) = 0;\n  }\n  **param = **param & 0xfffff7ff;\n  paramPtr = *param;\n  if ((paramPtr[1] & 0x800) == 0) {\n    if (*(char *)((int)param + 0x3d) == '`') {\n      *(undefined *)((int)param + 0x3d) = 0x20;\n      param[0x10] = (uint *)0x0;\n      if ((paramPtr[5] & 0x40) != 0) {\n        charPtr = param[9];\n        param[9] = (uint *)((int)charPtr + 1);\n        *(char *)charPtr = (char)paramPtr[4];\n      }\n      **param = **param & 0xfffffffe;\n      abortCompletionCallback(param);\n    }\n    else {\n      if ((paramPtr[5] & 0x40) != 0) {\n        charPtr = param[9];\n        param[9] = (uint *)((int)charPtr + 1);\n        *(char *)charPtr = (char)paramPtr[4];\n      }\n      errorCallback(param);\n    }\n  }\n  else {\n    paramPtr[1] = paramPtr[1] & 0xfffff7ff;\n    if (*(char *)((int)dmaStream1 + 0x21) == '\\x01') {\n      dmaStream2[0xd] = (uint)&dmaAbortHandler;\n      errorStatus = dmaAbort(dmaStream2);\n      if (errorStatus != 0) {\n        if (((*param)[5] & 0x40) != 0) {\n          paramPtr = param[9];\n          param[9] = (uint *)((int)paramPtr + 1);\n          *(char *)paramPtr = (char)(*param)[4];\n        }\n        **param = **param & 0xfffffffe;\n        *(undefined *)((int)param + 0x3d) = 0x20;\n        (*(code *)dmaStream2[0xd])();\n      }\n    }\n    else {\n      dmaStream1[0xd] = (uint)&dmaAbortHandler;\n      errorStatus = dmaAbort(dmaStream1);\n      if (errorStatus != 0) {\n        **param = **param & 0xfffffffe;\n        *(undefined *)((int)param + 0x3d) = 0x20;\n        (*(code *)dmaStream1[0xd])();\n      }\n    }\n  }\n  if ((*(char *)((int)param + 0x3d) == '(') && (((uint)param[0x10] & 4) != 0)) {\n    someValue1 = (uint *)0xffff0000;\n    someValue2 = (uint *)0x0;\n    *(undefined *)((int)param + 0x3d) = 0x20;\n    *(undefined *)((int)param + 0x3e) = 0;\n    listenCompletionCallback(param);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "handle_i2_c_interrupt_08004f3c",
                "param_1": "param",
                "iVar1": "errorStatus",
                "puVar2": "charPtr",
                "puVar3": "paramPtr",
                "HAL_I2C_AbortCpltCallback": "abortCompletionCallback",
                "HAL_I2C_ErrorCallback": "errorCallback",
                "param_1[0xd]": "dmaStream1",
                "param_1[0xe]": "dmaStream2",
                "LAB_080053cc_1": "dmaAbortHandler",
                "HAL_DMA_Abort_IT": "dmaAbort",
                "param_1[0xb]": "someValue1",
                "param_1[0xc]": "someValue2",
                "HAL_I2C_ListenCpltCallback": "listenCompletionCallback"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_I2C_ErrorCallback",
                "HAL_DMA_Abort_IT",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005084": {
            "entrypoint": "0x08005084",
            "current_name": "process_i2_c_data_08005084",
            "code": "\nundefined4 processI2CData_08005084(uint **data)\n\n{\n  char firstChar;\n  uint *ptrData;\n  uint *ptrIncrementedData;\n  \n  firstChar = *(char *)((int)data + 0x3d);\n  (*data)[1] = (*data)[1] & 0xfffff8ff;\n  **data = **data | 1;\n  **data = **data & 0xfffffbff;\n  ptrData = *data;\n  if ((ptrData[1] & 0x800) != 0) {\n    if ((*(char *)((int)data + 0x3d) == '\\\"') || (*(char *)((int)data + 0x3d) == '*')) {\n      *(short *)((int)data + 0x2a) = (short)*(undefined4 *)(*data[0xe] + 4);\n    }\n    else {\n      *(short *)((int)data + 0x2a) = (short)*(undefined4 *)(*data[0xd] + 4);\n    }\n  }\n  if (*(short *)((int)data + 0x2a) != 0) {\n    if ((ptrData[5] & 4) != 0) {\n      ptrIncrementedData = data[9];\n      data[9] = (uint *)((int)ptrIncrementedData + 1);\n      *(char *)ptrIncrementedData = (char)ptrData[4];\n      *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    }\n    if (((*data)[5] & 0x40) != 0) {\n      ptrData = data[9];\n      data[9] = (uint *)((int)ptrData + 1);\n      *(char *)ptrData = (char)(*data)[4];\n      *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    }\n    data[0x10] = (uint *)((uint)data[0x10] | 4);\n  }\n  if (data[0x10] == (uint *)0x0) {\n    if (((firstChar == '(') || (firstChar == '*')) || (firstChar == ')')) {\n      data[0xb] = (uint *)0xffff0000;\n      data[0xc] = (uint *)0x0;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      *(undefined *)((int)data + 0x3e) = 0;\n      HAL_I2C_ListenCpltCallback();\n    }\n    else if ((data[0xc] == (uint *)0x22) || (firstChar == '\\\"')) {\n      data[0xc] = (uint *)0x0;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      *(undefined *)((int)data + 0x3e) = 0;\n      HAL_I2C_SlaveRxCpltCallback();\n    }\n  }\n  else {\n    I2C_ITError();\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005084": "process_i2_c_data_08005084",
                "param_1": "data",
                "cVar1": "firstChar",
                "puVar2": "ptrData",
                "puVar3": "ptrIncrementedData"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback",
                "HAL_I2C_ListenCpltCallback",
                "I2C_ITError"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005188": {
            "entrypoint": "0x08005188",
            "current_name": "handle_i2_c_event_08005188",
            "code": "\nvoid handleI2CEvent_08005188(int *param_1)\n\n{\n  int eventValue;\n  uint eventMask;\n  uint eventFlag;\n  uint additionalFlag;\n  \n  eventValue = *param_1;\n  additionalFlag = *(uint *)(eventValue + 0x18);\n  eventMask = *(uint *)(eventValue + 0x14);\n  eventFlag = *(uint *)(eventValue + 4);\n  if ((*(char *)((int)param_1 + 0x3e) == '\\x10') || (*(char *)((int)param_1 + 0x3e) == '@')) {\n    if (((eventMask & 0x10001) == 0) || ((eventFlag & 0x200) == 0)) {\n      if (((eventMask & 0x10008) == 0) || ((eventFlag & 0x200) == 0)) {\n        if (((eventMask & 0x10002) != 0) && ((eventFlag & 0x200) != 0)) {\n          I2C_Master_ADDR(param_1);\n        }\n      }\n      else {\n        I2C_Master_ADD10(param_1);\n      }\n    }\n    else {\n      I2C_Master_SB(param_1);\n    }\n    if ((additionalFlag & 0x100004) == 0) {\n      if ((((eventMask & 0x10040) != 0) && ((eventFlag & 0x400) != 0)) && ((eventMask & 0x10004) == 0)) {\n        I2C_MasterReceive_RXNE(param_1);\n        return;\n      }\n      if (((eventMask & 0x10004) != 0) && ((eventFlag & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(param_1);\n        return;\n      }\n    }\n    else {\n      if ((((eventMask & 0x10080) != 0) && ((eventFlag & 0x400) != 0)) && ((eventMask & 0x10004) == 0)) {\n        I2C_MasterTransmit_TXE(param_1);\n        return;\n      }\n      if (((eventMask & 0x10004) != 0) && ((eventFlag & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(param_1);\n        return;\n      }\n    }\n  }\n  else {\n    if (((eventMask & 0x10002) != 0) && ((eventFlag & 0x200) != 0)) {\n      I2C_Slave_ADDR();\n      return;\n    }\n    if (((eventMask & 0x10010) != 0) && ((eventFlag & 0x200) != 0)) {\n      I2C_Slave_STOPF(param_1);\n      return;\n    }\n    if ((additionalFlag & 0x100004) == 0) {\n      if ((((eventMask & 0x10040) != 0) && ((eventFlag & 0x400) != 0)) && ((eventMask & 0x10004) == 0)) {\n        I2C_SlaveReceive_RXNE(param_1);\n        return;\n      }\n      if (((eventMask & 0x10004) != 0) && ((eventFlag & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(param_1);\n      }\n    }\n    else {\n      if ((((eventMask & 0x10080) != 0) && ((eventFlag & 0x400) != 0)) && ((eventMask & 0x10004) == 0)) {\n        I2C_SlaveTransmit_TXE(param_1);\n        return;\n      }\n      if (((eventMask & 0x10004) != 0) && ((eventFlag & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(param_1);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005188": "handle_i2_c_event_08005188",
                "iVar1": "eventValue",
                "uVar2": "eventMask",
                "uVar3": "eventFlag",
                "uVar4": "additionalFlag"
            },
            "calling": [],
            "called": [
                "I2C_MasterReceive_RXNE",
                "I2C_Master_ADD10",
                "I2C_SlaveReceive_RXNE",
                "I2C_SlaveReceive_BTF",
                "I2C_SlaveTransmit_BTF",
                "I2C_SlaveTransmit_TXE",
                "I2C_MasterReceive_BTF",
                "I2C_Slave_ADDR",
                "I2C_MasterTransmit_BTF",
                "I2C_Master_ADDR",
                "I2C_MasterTransmit_TXE",
                "I2C_Master_SB",
                "I2C_Slave_STOPF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052f0": {
            "entrypoint": "0x080052f0",
            "current_name": "process_params_080052f0",
            "code": "\nvoid processParams_080052f0(uint **params)\n\n{\n  char character;\n  uint *ptrToParams;\n  uint value1;\n  uint value2;\n  \n  ptrToParams = *params;\n  value1 = ptrToParams[5];\n  value2 = ptrToParams[1];\n  if (((value1 & 0x10100) != 0) && ((value2 & 0x100) != 0)) {\n    params[0x10] = (uint *)((uint)params[0x10] | 1);\n    ptrToParams[5] = 0xfffffeff;\n    **params = **params | 0x8000;\n  }\n  if (((value1 & 0x10200) != 0) && ((value2 & 0x100) != 0)) {\n    params[0x10] = (uint *)((uint)params[0x10] | 2);\n    (*params)[5] = 0xfffffdff;\n  }\n  if (((value1 & 0x10400) != 0) && ((value2 & 0x100) != 0)) {\n    character = *(char *)((int)params + 0x3d);\n    if (((*(char *)((int)params + 0x3e) == ' ') && (*(short *)((int)params + 0x2a) == 0)) &&\n       (((character == '!' || (character == ')')) || ((character == '(' && (params[0xc] == (uint *)0x21)))))) {\n      I2C_Slave_AF(params);\n    }\n    else {\n      params[0x10] = (uint *)((uint)params[0x10] | 4);\n      if (*(char *)((int)params + 0x3e) == '\\x10') {\n        **params = **params | 0x200;\n      }\n      (*params)[5] = 0xfffffbff;\n    }\n  }\n  if (((value1 & 0x10800) != 0) && ((value2 & 0x100) != 0)) {\n    params[0x10] = (uint *)((uint)params[0x10] | 8);\n    (*params)[5] = 0xfffff7ff;\n  }\n  if (params[0x10] != (uint *)0x0) {\n    I2C_ITError(params);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052f0": "process_params_080052f0",
                "param_1": "params",
                "cVar1": "character",
                "puVar2": "ptrToParams",
                "uVar3": "value1",
                "uVar4": "value2"
            },
            "calling": [],
            "called": [
                "I2C_Slave_AF",
                "I2C_ITError"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800542a": {
            "entrypoint": "0x0800542a",
            "current_name": "get_memory_value_0800542a",
            "code": "\nundefined getMemoryValue_0800542a(int memoryAddress)\n\n{\n  return *(undefined *)(memoryAddress + 0x3d);\n}\n\n",
            "renaming": {
                "FUN_0800542a": "get_memory_value_0800542a",
                "param_1": "memoryAddress"
            },
            "calling": [
                "i2c_master_write",
                "i2c_master_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005430": {
            "entrypoint": "0x08005430",
            "current_name": "get_pointer_value_08005430",
            "code": "\nundefined4 getPointerValue_08005430(int inputPointer)\n\n{\n  return *(undefined4 *)(inputPointer + 0x40);\n}\n\n",
            "renaming": {
                "FUN_08005430": "get_pointer_value_08005430",
                "param_1": "inputPointer"
            },
            "calling": [
                "i2c_master_write",
                "i2c_master_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005434": {
            "entrypoint": "0x08005434",
            "current_name": "count_down_08005434",
            "code": "\nvoid count_down_08005434(int input_value)\n\n{\n  bool continue_loop;\n  int num_iterations;\n  \n  num_iterations = input_value * (DAT_20000018 / 8000);\n  do {\n    continue_loop = num_iterations != 0;\n    num_iterations = num_iterations + -1;\n  } while (continue_loop);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005434": "count_down_08005434",
                "param_1": "input_value",
                "local_4": "num_iterations",
                "bVar1": "continue_loop"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005460": {
            "entrypoint": "0x08005460",
            "current_name": "check_and_control_protocol_08005460",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nundefined4 check_and_control_protocol_08005460(uint *protocol_flags)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  if ((*protocol_flags & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) != 0)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (protocol_flags[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      uVar4 = protocol_flags[1];\n      if (uVar4 == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (uVar4 == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (uVar4 == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (protocol_flags[1] == 0) {\n        iVar1 = get_current_time();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          iVar2 = get_current_time();\n          if (100 < (uint)(iVar2 - iVar1)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        iVar1 = get_current_time();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          iVar2 = get_current_time();\n          if (100 < (uint)(iVar2 - iVar1)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*protocol_flags & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (protocol_flags[4] != 1)) {\n        return 1;\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | protocol_flags[5] << 3;\n    }\n    else if (protocol_flags[4] == 0) {\n      _DAT_42420000 = 0;\n      iVar1 = get_current_time();\n      while ((_DAT_40021000 & 2) != 0) {\n        iVar2 = get_current_time();\n        if (2 < (uint)(iVar2 - iVar1)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      iVar1 = get_current_time();\n      while ((_DAT_40021000 & 2) == 0) {\n        iVar2 = get_current_time();\n        if (2 < (uint)(iVar2 - iVar1)) {\n          return 3;\n        }\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | protocol_flags[5] << 3;\n    }\n  }\n  if ((*protocol_flags & 8) != 0) {\n    if (protocol_flags[6] == 0) {\n      _DAT_42420480 = 0;\n      iVar1 = get_current_time();\n      while ((_DAT_40021024 & 2) != 0) {\n        iVar2 = get_current_time();\n        if (2 < (uint)(iVar2 - iVar1)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      iVar1 = get_current_time();\n      while ((_DAT_40021024 & 2) == 0) {\n        iVar2 = get_current_time();\n        if (2 < (uint)(iVar2 - iVar1)) {\n          return 3;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((*protocol_flags & 4) != 0) {\n    bVar5 = (_DAT_4002101c & 0x10000000) == 0;\n    if (bVar5) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      iVar1 = get_current_time();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        iVar2 = get_current_time();\n        if (100 < (uint)(iVar2 - iVar1)) {\n          return 3;\n        }\n      }\n    }\n    uVar4 = protocol_flags[3];\n    if (uVar4 == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (uVar4 == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (uVar4 == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (protocol_flags[3] == 0) {\n      iVar1 = get_current_time();\n      while ((_DAT_40021020 & 2) != 0) {\n        iVar2 = get_current_time();\n        if (5000 < (uint)(iVar2 - iVar1)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      iVar1 = get_current_time();\n      while ((_DAT_40021020 & 2) == 0) {\n        iVar2 = get_current_time();\n        if (5000 < (uint)(iVar2 - iVar1)) {\n          return 3;\n        }\n      }\n    }\n    if (bVar5) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if (protocol_flags[7] == 0) {\n    uVar3 = 0;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    uVar3 = 1;\n  }\n  else if (protocol_flags[7] == 2) {\n    _DAT_42420060 = 0;\n    iVar1 = get_current_time();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if (protocol_flags[8] == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | protocol_flags[2];\n        }\n        _DAT_40021004 = _DAT_40021004 & 0xffc2ffff | protocol_flags[8] | protocol_flags[9];\n        _DAT_42420060 = 1;\n        iVar1 = get_current_time();\n        do {\n          if ((_DAT_40021000 & 0x2000000) != 0) {\n            return 0;\n          }\n          iVar2 = get_current_time();\n        } while ((uint)(iVar2 - iVar1) < 3);\n        return 3;\n      }\n      iVar2 = get_current_time();\n    } while ((uint)(iVar2 - iVar1) < 3);\n    uVar3 = 3;\n  }\n  else {\n    _DAT_42420060 = 0;\n    iVar1 = get_current_time();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        return 0;\n      }\n      iVar2 = get_current_time();\n    } while ((uint)(iVar2 - iVar1) < 3);\n    uVar3 = 3;\n  }\n  return uVar3;\n}\n\n",
            "renaming": {
                "FUN_08005460": "check_and_control_protocol_08005460",
                "param_1": "protocol_flags",
                "HAL_GetTick": "get_current_time"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "RCC_Delay",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005840": {
            "entrypoint": "0x08005840",
            "current_name": "calculate_value_08005840",
            "code": "\n\n\nuint calculateValue_08005840(void)\n\n{\n  uint result;\n  undefined2 constant;\n  undefined4 array;\n  undefined4 array;\n  undefined4 array;\n  undefined4 array;\n  \n  array = 0x10100f0e;\n  array = 0xd0c0b0a;\n  array = 0x9080706;\n  array = 0x5040302;\n  constant = 0x201;\n  if ((_DAT_40021004 & 0xc) == 8) {\n    result = (uint)*(byte *)((int)&array + ((_DAT_40021004 << 10) >> 0x1c));\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      result = result * 4000000;\n    }\n    else {\n      result = (result * 8000000) /\n              (uint)*(byte *)((int)&constant - ((int)(_DAT_40021004 << 0xe) >> 0x1f));\n    }\n  }\n  else {\n    result = 8000000;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005840": "calculate_value_08005840",
                "uVar1": "result",
                "local_1c": "constant",
                "uStack_18": "array",
                "uStack_14": "array",
                "uStack_10": "array",
                "uStack_c": "array"
            },
            "calling": [
                "FUN_080058d2"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058ac": {
            "entrypoint": "0x080058ac",
            "current_name": "initialize_device_080058ac",
            "code": "\n\n\nundefined4 initializeDevice_080058ac(uint *configParams,uint configSize)\n\n{\n  int startTime;\n  int currentTime;\n  uint sysClockFreq;\n  \n  if ((_DAT_40022000 & 7) < configSize) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | configSize;\n    if (configSize != (configSize & 7)) {\n      return 1;\n    }\n  }\n  if ((*configParams & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffff0f | configParams[2];\n  }\n  if ((*configParams & 1) != 0) {\n    sysClockFreq = configParams[1];\n    if (sysClockFreq == 1) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        return 1;\n      }\n    }\n    else if ((sysClockFreq != 2) && ((_DAT_40021000 & 2) == 0)) {\n      return 1;\n    }\n    _DAT_40021004 = sysClockFreq | _DAT_40021004 & 0xfffffffc;\n    startTime = HAL_GetTick();\n    if (configParams[1] == 1) {\n      while ((_DAT_40021004 & 0xc) != 4) {\n        currentTime = HAL_GetTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else if (configParams[1] == 2) {\n      while ((_DAT_40021004 & 0xc) != 8) {\n        currentTime = HAL_GetTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      while ((_DAT_40021004 & 0xc) != 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n  }\n  if (configSize < (_DAT_40022000 & 7)) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | configSize;\n    if (configSize != (configSize & 7)) {\n      return 1;\n    }\n  }\n  if ((*configParams & 4) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | configParams[3];\n  }\n  if ((*configParams & 8) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | configParams[4] << 3;\n  }\n  sysClockFreq = HAL_RCC_GetSysClockFreq();\n  DAT_20000018 = sysClockFreq >> (&DAT_0800a944)[(_DAT_40021004 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080058ac": "initialize_device_080058ac",
                "param_1": "configParams",
                "param_2": "configSize",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "sysClockFreq"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "FUN_080058d2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058d2": {
            "entrypoint": "0x080058d2",
            "current_name": "initialize_system_080058d2",
            "code": "\n\n\nundefined4 initializeSystem_080058d2(uint *flags,uint clockSelect)\n\n{\n  int startTime;\n  int currentTime;\n  uint sysClockFreq;\n  \n  if ((*flags & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffff0f | flags[2];\n  }\n  if ((*flags & 1) != 0) {\n    sysClockFreq = flags[1];\n    if (sysClockFreq == 1) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        return 1;\n      }\n    }\n    else if ((sysClockFreq != 2) && ((_DAT_40021000 & 2) == 0)) {\n      return 1;\n    }\n    _DAT_40021004 = sysClockFreq | _DAT_40021004 & 0xfffffffc;\n    startTime = HAL_GetTick();\n    if (flags[1] == 1) {\n      while ((_DAT_40021004 & 0xc) != 4) {\n        currentTime = HAL_GetTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else if (flags[1] == 2) {\n      while ((_DAT_40021004 & 0xc) != 8) {\n        currentTime = HAL_GetTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      while ((_DAT_40021004 & 0xc) != 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n  }\n  if (clockSelect < (_DAT_40022000 & 7)) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | clockSelect;\n    if (clockSelect != (clockSelect & 7)) {\n      return 1;\n    }\n  }\n  if ((*flags & 4) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | flags[3];\n  }\n  if ((*flags & 8) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | flags[4] << 3;\n  }\n  sysClockFreq = HAL_RCC_GetSysClockFreq();\n  DAT_20000018 = sysClockFreq >> (&DAT_0800a944)[(_DAT_40021004 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080058d2": "initialize_system_080058d2",
                "param_1": "flags",
                "param_2": "clockSelect",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "sysClockFreq"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a1c": {
            "entrypoint": "0x08005a1c",
            "current_name": "get_global_data_08005a1c",
            "code": "\nundefined4 get_global_data_08005a1c(void)\n\n{\n  return DAT_20000018;\n}\n\n",
            "renaming": {
                "FUN_08005a1c": "get_global_data_08005a1c"
            },
            "calling": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a28": {
            "entrypoint": "0x08005a28",
            "current_name": "get_adjusted_hclk_freq_08005a28",
            "code": "\n\n\nuint getAdjustedHCLKFreq_08005a28(void)\n\n{\n  uint hclkFreq;\n  \n  hclkFreq = getHCLKFreq();\n  return hclkFreq >> (&DAT_0800a954)[(uint)(_DAT_40021004 << 0x15) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08005a28": "get_adjusted_hclk_freq_08005a28",
                "uVar1": "hclkFreq",
                "HAL_RCC_GetHCLKFreq": "getHCLKFreq"
            },
            "calling": [
                "UART_SetConfig",
                "getTimerClkFreq",
                "HAL_I2C_Init"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a48": {
            "entrypoint": "0x08005a48",
            "current_name": "get_adjusted_hclk_freq_08005a48",
            "code": "\n\n\nuint getAdjustedHCLKFreq_08005a48(void)\n\n{\n  uint adjustedHCLKFreq;\n  \n  adjustedHCLKFreq = getCurrentHCLKFreq();\n  return adjustedHCLKFreq >> (&DAT_0800a954)[(uint)(_DAT_40021004 << 0x12) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08005a48": "get_adjusted_hclk_freq_08005a48",
                "uVar1": "adjustedHCLKFreq",
                "HAL_RCC_GetHCLKFreq": "getCurrentHCLKFreq"
            },
            "calling": [
                "HAL_RCCEx_GetPeriphCLKFreq",
                "UART_SetConfig",
                "getTimerClkFreq"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a68": {
            "entrypoint": "0x08005a68",
            "current_name": "initialize_params_08005a68",
            "code": "\n\n\nvoid initialize_params_08005a68(undefined4 *output_array,uint *input_array)\n\n{\n  *output_array = 0xf;\n  output_array[1] = _DAT_40021004 & 3;\n  output_array[2] = _DAT_40021004 & 0xf0;\n  output_array[3] = _DAT_40021004 & 0x700;\n  output_array[4] = _DAT_40021004 >> 3 & 0x700;\n  *input_array = _DAT_40022000 & 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a68": "initialize_params_08005a68",
                "param_1": "output_array",
                "param_2": "input_array"
            },
            "calling": [
                "getTimerClkFreq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005aa4": {
            "entrypoint": "0x08005aa4",
            "current_name": "update_settings_08005aa4",
            "code": "\n\n\nundefined4 updateSettings_08005aa4(uint *settings)\n\n{\n  uint flags;\n  uint currentFlags;\n  int startTime;\n  int currentTime;\n  bool flagUpdated;\n  \n  if ((*settings & 1) != 0) {\n    flagUpdated = (_DAT_4002101c & 0x10000000) == 0;\n    if (flagUpdated) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = HAL_GetTick();\n        if (100 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (((_DAT_40021020 & 0x300) != 0) && ((_DAT_40021020 & 0x300) != (settings[1] & 0x300))) {\n      currentFlags = _DAT_40021020 & 0xfffffcff;\n      _DAT_42420440 = 0;\n      flags = _DAT_40021020 & 1;\n      _DAT_40021020 = currentFlags;\n      if (flags != 0) {\n        startTime = HAL_GetTick();\n        while ((_DAT_40021020 & 2) == 0) {\n          currentTime = HAL_GetTick();\n          if (5000 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffcff | settings[1];\n    if (flagUpdated) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if ((*settings & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffff3fff | settings[2];\n  }\n  if ((*settings & 0x10) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffbfffff | settings[3];\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005aa4": "update_settings_08005aa4",
                "param_1": "settings",
                "uVar1": "flags",
                "uVar2": "currentFlags",
                "iVar3": "startTime",
                "iVar4": "currentTime",
                "bVar5": "flagUpdated"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bb8": {
            "entrypoint": "0x08005bb8",
            "current_name": "get_system_clock_frequency_08005bb8",
            "code": "\n\n\nuint getSystemClockFrequency_08005bb8(int clock_source)\n\n{\n  uint frequency;\n  undefined2 prescaler;\n  undefined4 ahb_prescaler;\n  undefined4 apb2_prescaler;\n  undefined4 apb1_prescaler;\n  undefined4 flash_latency;\n  \n  flash_latency = 0x10100f0e;\n  apb1_prescaler = 0xd0c0b0a;\n  apb2_prescaler = 0x9080706;\n  ahb_prescaler = 0x5040302;\n  prescaler = 0x201;\n  if (clock_source == 2) {\n    frequency = HAL_RCC_GetPCLK2Freq();\n    frequency = frequency / ((((_DAT_40021004 << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (clock_source == 0x10) {\n    if ((_DAT_40021000 & 0x1000000) == 0) {\n      frequency = 0;\n    }\n    else {\n      if ((_DAT_40021004 & 0x10000) == 0) {\n        frequency = 4000000;\n      }\n      else {\n        frequency = 8000000 / *(byte *)((int)&prescaler - ((int)(_DAT_40021004 << 0xe) >> 0x1f));\n      }\n      frequency = frequency * *(byte *)((int)&ahb_prescaler + ((_DAT_40021004 << 10) >> 0x1c));\n      if ((_DAT_40021004 & 0x400000) == 0) {\n        frequency = (frequency * 2) / 3;\n      }\n    }\n  }\n  else if (clock_source == 1) {\n    if ((_DAT_40021020 & 0x302) == 0x102) {\n      frequency = 0x8000;\n    }\n    else if (((_DAT_40021020 & 0x300) == 0x200) && ((_DAT_40021024 & 2) != 0)) {\n      frequency = 32000;\n    }\n    else if ((_DAT_40021020 & 0x300) == 0x300) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        frequency = 0;\n      }\n      else {\n        frequency = 0xf424;\n      }\n    }\n    else {\n      frequency = 0;\n    }\n  }\n  else {\n    frequency = 0;\n  }\n  return frequency;\n}\n\n",
            "renaming": {
                "FUN_08005bb8": "get_system_clock_frequency_08005bb8",
                "param_1": "clock_source",
                "uVar1": "frequency",
                "local_24": "prescaler",
                "uStack_20": "ahb_prescaler",
                "uStack_1c": "apb2_prescaler",
                "uStack_18": "apb1_prescaler",
                "uStack_14": "flash_latency"
            },
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_PollForConversion"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cb4": {
            "entrypoint": "0x08005cb4",
            "current_name": "handle_alarm_event_08005cb4",
            "code": "\n\n\nvoid handleAlarmEvent_08005cb4(uint **inputParams)\n\n{\n  if (((**inputParams & 2) != 0) && (((*inputParams)[1] & 2) != 0)) {\n    HAL_RTC_AlarmAEventCallback();\n    (*inputParams)[1] = 0xfffffffd;\n  }\n  _DAT_40010414 = 0x20000;\n  *(undefined *)((int)inputParams + 0x11) = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005cb4": "handle_alarm_event_08005cb4",
                "param_1": "inputParams"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cec": {
            "entrypoint": "0x08005cec",
            "current_name": "update_parameters_08005cec",
            "code": "\nvoid updateParameters_08005cec(int paramAddress,uint *paramValues)\n\n{\n  uint updatedValue1;\n  uint updatedValue2;\n  uint updatedValue3;\n  \n  *(uint *)(paramAddress + 0x20) = *(uint *)(paramAddress + 0x20) & 0xfffffffe;\n  updatedValue2 = *(uint *)(paramAddress + 4);\n  updatedValue3 = *paramValues;\n  updatedValue1 = *(uint *)(paramAddress + 0x20) & 0xfffffffd | paramValues[2];\n  if (paramAddress == 0x40012c00) {\n    updatedValue1 = (updatedValue1 & 0xfffffff7 | paramValues[3]) & 0xfffffffb;\n    updatedValue2 = updatedValue2 & 0xfffffcff | paramValues[5] | paramValues[6];\n  }\n  *(uint *)(paramAddress + 4) = updatedValue2;\n  *(uint *)(paramAddress + 0x18) = *(uint *)(paramAddress + 0x18) & 0xffffff8c | updatedValue3;\n  *(uint *)(paramAddress + 0x34) = paramValues[1];\n  *(uint *)(paramAddress + 0x20) = updatedValue1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005cec": "update_parameters_08005cec",
                "param_1": "paramAddress",
                "param_2": "paramValues",
                "uVar1": "updatedValue1",
                "uVar2": "updatedValue2",
                "uVar3": "updatedValue3"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d48": {
            "entrypoint": "0x08005d48",
            "current_name": "update_data_08005d48",
            "code": "\nvoid updateData_08005d48(int dataAddress,uint *parameters)\n\n{\n  uint modifiedData1;\n  uint modifiedData2;\n  uint modifiedData3;\n  \n  *(uint *)(dataAddress + 0x20) = *(uint *)(dataAddress + 0x20) & 0xfffffeff;\n  modifiedData2 = *(uint *)(dataAddress + 4);\n  modifiedData3 = *parameters;\n  modifiedData1 = *(uint *)(dataAddress + 0x20) & 0xfffffdff | parameters[2] << 8;\n  if (dataAddress == 0x40012c00) {\n    modifiedData1 = (modifiedData1 & 0xfffff7ff | parameters[3] << 8) & 0xfffffbff;\n    modifiedData2 = modifiedData2 & 0xffffcfff | parameters[5] << 4 | parameters[6] << 4;\n  }\n  *(uint *)(dataAddress + 4) = modifiedData2;\n  *(uint *)(dataAddress + 0x1c) = *(uint *)(dataAddress + 0x1c) & 0xffffff8c | modifiedData3;\n  *(uint *)(dataAddress + 0x3c) = parameters[1];\n  *(uint *)(dataAddress + 0x20) = modifiedData1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d48": "update_data_08005d48",
                "param_1": "dataAddress",
                "param_2": "parameters",
                "uVar1": "modifiedData1",
                "uVar2": "modifiedData2",
                "uVar3": "modifiedData3"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dac": {
            "entrypoint": "0x08005dac",
            "current_name": "update_data_08005dac",
            "code": "\nvoid updateData_08005dac(int dataPtr,int *paramArr)\n\n{\n  uint flag;\n  int value1;\n  int value2;\n  \n  *(uint *)(dataPtr + 0x20) = *(uint *)(dataPtr + 0x20) & 0xffffefff;\n  flag = *(uint *)(dataPtr + 4);\n  value1 = *paramArr;\n  value2 = paramArr[2];\n  if (dataPtr == 0x40012c00) {\n    flag = flag & 0xffffbfff | paramArr[5] << 6;\n  }\n  *(uint *)(dataPtr + 4) = flag;\n  *(uint *)(dataPtr + 0x1c) = *(uint *)(dataPtr + 0x1c) & 0xffff8cff | value1 << 8;\n  *(int *)(dataPtr + 0x40) = paramArr[1];\n  *(uint *)(dataPtr + 0x20) = *(uint *)(dataPtr + 0x20) & 0xffffdfff | value2 << 0xc;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005dac": "update_data_08005dac",
                "param_1": "dataPtr",
                "param_2": "paramArr",
                "uVar1": "flag",
                "iVar2": "value1",
                "iVar3": "value2"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005df4": {
            "entrypoint": "0x08005df4",
            "current_name": "deinit_timers_08005df4",
            "code": "\nvoid deinitTimers_08005df4(uint **timer)\n\n{\n  uint *timerData;\n  \n  *(undefined *)((int)timer + 0x3d) = 2;\n  timerData = *timer;\n  if ((timerData[8] & 0x1111) == 0) {\n    if ((timerData[8] & 0x444) == 0) {\n      *timerData = *timerData & 0xfffffffe;\n    }\n  }\n  deinitTimerGPIO(timer);\n  *(undefined *)((int)timer + 0x3d) = 0;\n  *(undefined *)(timer + 0xf) = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005df4": "deinit_timers_08005df4",
                "param_1": "timer",
                "puVar1": "timerData",
                "HAL_TIM_OC_MspDeInit": "deinitTimerGPIO"
            },
            "calling": [
                "TimerPulseDeinit"
            ],
            "called": [
                "HAL_TIM_OC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e2e": {
            "entrypoint": "0x08005e2e",
            "current_name": "deinit_pwm_08005e2e",
            "code": "\nvoid deinit_pwm_08005e2e(uint **params)\n\n{\n  uint *param_1_val;\n  \n  *(undefined *)((int)params + 0x3d) = 2;\n  param_1_val = *params;\n  if ((param_1_val[8] & 0x1111) == 0) {\n    if ((param_1_val[8] & 0x444) == 0) {\n      *param_1_val = *param_1_val & 0xfffffffe;\n    }\n  }\n  deinit_hal_tim_pwm(params);\n  *(undefined *)((int)params + 0x3d) = 0;\n  *(undefined *)(params + 0xf) = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005e2e": "deinit_pwm_08005e2e",
                "param_1": "params",
                "puVar1": "param_1_val",
                "HAL_TIM_PWM_MspDeInit": "deinit_hal_tim_pwm"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e68": {
            "entrypoint": "0x08005e68",
            "current_name": "FUNC_08005e68",
            "code": "\nvoid FUNC_08005e68(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005e68": "FUNC_08005e68"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005e6a": {
            "entrypoint": "0x08005e6a",
            "current_name": "FUNC_08005e6a",
            "code": "\nvoid FUNC_08005e6a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005e6a": "FUNC_08005e6a"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005e6c": {
            "entrypoint": "0x08005e6c",
            "current_name": "FUNC_08005e6c",
            "code": "\nvoid FUNC_08005e6c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005e6c": "FUNC_08005e6c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005e6e": {
            "entrypoint": "0x08005e6e",
            "current_name": "process_timers_08005e6e",
            "code": "\nvoid processTimers_08005e6e(int *timerData)\n\n{\n  int currentTimer;\n  \n  currentTimer = *timerData;\n  if (((*(uint *)(currentTimer + 0x10) & 2) != 0) && ((*(uint *)(currentTimer + 0xc) & 2) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xfffffffd;\n    *(undefined *)(timerData + 7) = 1;\n    if ((*(uint *)(*timerData + 0x18) & 3) == 0) {\n      handleOC_DelayElapsedCallback();\n      handlePWM_PulseFinishedCallback(timerData);\n    }\n    else {\n      handleIC_CaptureCallback();\n    }\n    *(undefined *)(timerData + 7) = 0;\n  }\n  currentTimer = *timerData;\n  if (((*(uint *)(currentTimer + 0x10) & 4) != 0) && ((*(uint *)(currentTimer + 0xc) & 4) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xfffffffb;\n    *(undefined *)(timerData + 7) = 2;\n    if ((*(uint *)(*timerData + 0x18) & 0x300) == 0) {\n      handleOC_DelayElapsedCallback(timerData);\n      handlePWM_PulseFinishedCallback(timerData);\n    }\n    else {\n      handleIC_CaptureCallback(timerData);\n    }\n    *(undefined *)(timerData + 7) = 0;\n  }\n  currentTimer = *timerData;\n  if (((*(uint *)(currentTimer + 0x10) & 8) != 0) && ((*(uint *)(currentTimer + 0xc) & 8) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xfffffff7;\n    *(undefined *)(timerData + 7) = 4;\n    if ((*(uint *)(*timerData + 0x1c) & 3) == 0) {\n      handleOC_DelayElapsedCallback(timerData);\n      handlePWM_PulseFinishedCallback(timerData);\n    }\n    else {\n      handleIC_CaptureCallback(timerData);\n    }\n    *(undefined *)(timerData + 7) = 0;\n  }\n  currentTimer = *timerData;\n  if (((*(uint *)(currentTimer + 0x10) & 0x10) != 0) && ((*(uint *)(currentTimer + 0xc) & 0x10) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xffffffef;\n    *(undefined *)(timerData + 7) = 8;\n    if ((*(uint *)(*timerData + 0x1c) & 0x300) == 0) {\n      handleOC_DelayElapsedCallback(timerData);\n      handlePWM_PulseFinishedCallback(timerData);\n    }\n    else {\n      handleIC_CaptureCallback(timerData);\n    }\n    *(undefined *)(timerData + 7) = 0;\n  }\n  currentTimer = *timerData;\n  if (((*(uint *)(currentTimer + 0x10) & 1) != 0) && ((*(uint *)(currentTimer + 0xc) & 1) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xfffffffe;\n    handlePeriodElapsedCallback(timerData);\n  }\n  currentTimer = *timerData;\n  if (((*(uint *)(currentTimer + 0x10) & 0x80) != 0) && ((*(uint *)(currentTimer + 0xc) & 0x80) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xffffff7f;\n    handleEx_BreakCallback(timerData);\n  }\n  currentTimer = *timerData;\n  if (((*(uint *)(currentTimer + 0x10) & 0x40) != 0) && ((*(uint *)(currentTimer + 0xc) & 0x40) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xffffffbf;\n    handleTriggerCallback(timerData);\n  }\n  currentTimer = *timerData;\n  if (((*(uint *)(currentTimer + 0x10) & 0x20) != 0) && ((*(uint *)(currentTimer + 0xc) & 0x20) != 0)) {\n    *(undefined4 *)(currentTimer + 0x10) = 0xffffffdf;\n    handleEx_CommutationCallback(timerData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005e6e": "process_timers_08005e6e",
                "param_1": "timerData",
                "iVar1": "currentTimer",
                "HAL_TIM_OC_DelayElapsedCallback": "handleOC_DelayElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback": "handlePWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback": "handleIC_CaptureCallback",
                "HAL_TIM_PeriodElapsedCallback": "handlePeriodElapsedCallback",
                "HAL_TIMEx_BreakCallback": "handleEx_BreakCallback",
                "HAL_TIM_TriggerCallback": "handleTriggerCallback",
                "HAL_TIMEx_CommutationCallback": "handleEx_CommutationCallback"
            },
            "calling": [],
            "called": [
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIMEx_BreakCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fe8": {
            "entrypoint": "0x08005fe8",
            "current_name": "set_memory_and_flags_08005fe8",
            "code": "\nvoid setMemoryAndFlags_08005fe8(uint *memory,uint *values)\n\n{\n  uint tempValue;\n  \n  tempValue = *memory;\n  if ((((memory == (uint *)0x40012c00) || (memory == (uint *)0x40000000)) ||\n      (memory == (uint *)0x40000400)) || (memory == (uint *)0x40000800)) {\n    tempValue = tempValue & 0xffffff8f | values[1];\n  }\n  if (((memory == (uint *)0x40012c00) || (memory == (uint *)0x40000000)) ||\n     ((memory == (uint *)0x40000400 || (memory == (uint *)0x40000800)))) {\n    tempValue = tempValue & 0xfffffcff | values[3];\n  }\n  *memory = tempValue & 0xffffff7f | values[5];\n  memory[0xb] = values[2];\n  memory[10] = *values;\n  if (memory == (uint *)0x40012c00) {\n    specialValue = values[4];\n  }\n  memory[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fe8": "set_memory_and_flags_08005fe8",
                "param_1": "memory",
                "param_2": "values",
                "uVar1": "tempValue",
                "uRam40012c30": "specialValue"
            },
            "calling": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_OC_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006060": {
            "entrypoint": "0x08006060",
            "current_name": "initialize_timer_08006060",
            "code": "\nundefined4 initializeTimer_08006060(undefined4 *timerConfig)\n\n{\n  if (timerConfig != (undefined4 *)0x0) {\n    if (*(char *)((int)timerConfig + 0x3d) == '\\0') {\n      *(undefined *)(timerConfig + 0xf) = 0;\n      HAL_TIM_OC_MspInit();\n    }\n    *(undefined *)((int)timerConfig + 0x3d) = 2;\n    TIM_Base_SetConfig(*timerConfig,timerConfig + 1);\n    *(undefined *)((int)timerConfig + 0x3d) = 1;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08006060": "initialize_timer_08006060",
                "param_1": "timerConfig"
            },
            "calling": [
                "TimerPulseInit"
            ],
            "called": [
                "TIM_Base_SetConfig",
                "HAL_TIM_OC_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006092": {
            "entrypoint": "0x08006092",
            "current_name": "initialize_pwm_08006092",
            "code": "\nundefined4 initialize_pwm_08006092(undefined4 *pwm_config)\n\n{\n  if (pwm_config != (undefined4 *)0x0) {\n    if (*(char *)((int)pwm_config + 0x3d) == '\\0') {\n      *(undefined *)(pwm_config + 0xf) = 0;\n      initialize_pwm_08006092_peripherals();\n    }\n    *(undefined *)((int)pwm_config + 0x3d) = 2;\n    configure_pwm(*pwm_config,pwm_config + 1);\n    *(undefined *)((int)pwm_config + 0x3d) = 1;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08006092": "initialize_pwm_08006092",
                "param_1": "pwm_config",
                "HAL_TIM_PWM_MspInit": "initialize_pwm_peripherals",
                "TIM_Base_SetConfig": "configure_pwm"
            },
            "calling": [
                "pwm_start"
            ],
            "called": [
                "TIM_Base_SetConfig",
                "HAL_TIM_PWM_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060c4": {
            "entrypoint": "0x080060c4",
            "current_name": "update_registers_080060c4",
            "code": "\nvoid updateRegisters_080060c4(int registerAddress,int *inputValues)\n\n{\n  uint newUVar1;\n  uint newUVar2;\n  int newVar3;\n  \n  *(uint *)(registerAddress + 0x20) = *(uint *)(registerAddress + 0x20) & 0xffffffef;\n  newUVar2 = *(uint *)(registerAddress + 4);\n  newVar3 = *inputValues;\n  newUVar1 = *(uint *)(registerAddress + 0x20) & 0xffffffdf | inputValues[2] << 4;\n  if (registerAddress == 0x40012c00) {\n    newUVar1 = (newUVar1 & 0xffffff7f | inputValues[3] << 4) & 0xffffffbf;\n    newUVar2 = newUVar2 & 0xfffff3ff | inputValues[5] << 2 | inputValues[6] << 2;\n  }\n  *(uint *)(registerAddress + 4) = newUVar2;\n  *(uint *)(registerAddress + 0x18) = *(uint *)(registerAddress + 0x18) & 0xffff8cff | newVar3 << 8;\n  *(int *)(registerAddress + 0x38) = inputValues[1];\n  *(uint *)(registerAddress + 0x20) = newUVar1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060c4": "update_registers_080060c4",
                "param_1": "registerAddress",
                "param_2": "inputValues",
                "uVar1": "newUVar1",
                "uVar2": "newUVar2",
                "iVar3": "newVar3"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006128": {
            "entrypoint": "0x08006128",
            "current_name": "set_timer_output_compare_config_08006128",
            "code": "\nundefined4 setTimerOutputCompareConfig_08006128(undefined4 *timerConfig,undefined4 param1,undefined4 timerChannel)\n\n{\n  if (*(char *)(timerConfig + 0xf) != '\\x01') {\n    *(undefined *)(timerConfig + 0xf) = 1;\n    *(undefined *)((int)timerConfig + 0x3d) = 2;\n    switch(timerChannel) {\n    case 0:\n      configureChannel1(*timerConfig);\n      break;\n    case 4:\n      configureChannel2(*timerConfig);\n      break;\n    case 8:\n      configureChannel3(*timerConfig);\n      break;\n    case 0xc:\n      configureChannel4(*timerConfig);\n    }\n    *(undefined *)((int)timerConfig + 0x3d) = 1;\n    *(undefined *)(timerConfig + 0xf) = 0;\n    return 0;\n  }\n  return 2;\n}\n\n",
            "renaming": {
                "FUN_08006128": "set_timer_output_compare_config_08006128",
                "param_1": "timerConfig",
                "param_2": "param1",
                "param_3": "timerChannel",
                "TIM_OC1_SetConfig": "configureChannel1",
                "TIM_OC2_SetConfig": "configureChannel2",
                "TIM_OC3_SetConfig": "configureChannel3",
                "TIM_OC4_SetConfig": "configureChannel4"
            },
            "calling": [
                "TimerPulseInit"
            ],
            "called": [
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC3_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006186": {
            "entrypoint": "0x08006186",
            "current_name": "configure_tim_output_compare_08006186",
            "code": "\nundefined4 configure_TIM_output_compare_08006186(int *config,int data,undefined4 channel)\n\n{\n  if (*(char *)(config + 0xf) != '\\x01') {\n    *(undefined *)(config + 0xf) = 1;\n    *(undefined *)((int)config + 0x3d) = 2;\n    switch(channel) {\n    case 0:\n      TIM_OC1_SetConfig(*config);\n      *(uint *)(*config + 0x18) = *(uint *)(*config + 0x18) | 8;\n      *(uint *)(*config + 0x18) = *(uint *)(*config + 0x18) & 0xfffffffb;\n      *(uint *)(*config + 0x18) = *(uint *)(*config + 0x18) | *(uint *)(data + 0x10);\n      break;\n    case 4:\n      TIM_OC2_SetConfig(*config);\n      *(uint *)(*config + 0x18) = *(uint *)(*config + 0x18) | 0x800;\n      *(uint *)(*config + 0x18) = *(uint *)(*config + 0x18) & 0xfffffbff;\n      *(uint *)(*config + 0x18) = *(uint *)(*config + 0x18) | *(int *)(data + 0x10) << 8;\n      break;\n    case 8:\n      TIM_OC3_SetConfig(*config);\n      *(uint *)(*config + 0x1c) = *(uint *)(*config + 0x1c) | 8;\n      *(uint *)(*config + 0x1c) = *(uint *)(*config + 0x1c) & 0xfffffffb;\n      *(uint *)(*config + 0x1c) = *(uint *)(*config + 0x1c) | *(uint *)(data + 0x10);\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(*config);\n      *(uint *)(*config + 0x1c) = *(uint *)(*config + 0x1c) | 0x800;\n      *(uint *)(*config + 0x1c) = *(uint *)(*config + 0x1c) & 0xfffffbff;\n      *(uint *)(*config + 0x1c) = *(uint *)(*config + 0x1c) | *(int *)(data + 0x10) << 8;\n    }\n    *(undefined *)((int)config + 0x3d) = 1;\n    *(undefined *)(config + 0xf) = 0;\n    return 0;\n  }\n  return 2;\n}\n\n",
            "renaming": {
                "FUN_08006186": "configure_tim_output_compare_08006186",
                "param_1": "config",
                "param_2": "data",
                "param_3": "channel"
            },
            "calling": [
                "pwm_start"
            ],
            "called": [
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC3_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006262": {
            "entrypoint": "0x08006262",
            "current_name": "update_bitwise_value_08006262",
            "code": "\nvoid updateBitwiseValue_08006262(int baseAddress,uint bitPosition,int newValue)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & ~(1 << (bitPosition & 0xff));\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) | newValue << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006262": "update_bitwise_value_08006262",
                "param_1": "baseAddress",
                "param_2": "bitPosition",
                "param_3": "newValue"
            },
            "calling": [
                "HAL_TIM_OC_Start_IT",
                "HAL_TIM_PWM_Start",
                "HAL_TIM_PWM_Stop",
                "HAL_TIM_OC_Stop_IT"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006280": {
            "entrypoint": "0x08006280",
            "current_name": "set_tim_channel_flags_08006280",
            "code": "\nundefined4 setTimChannelFlags_08006280(uint **channelPointer,undefined4 flagValue)\n\n{\n  switch(flagValue) {\n  case 0:\n    (*channelPointer)[3] = (*channelPointer)[3] | 2;\n    break;\n  case 4:\n    (*channelPointer)[3] = (*channelPointer)[3] | 4;\n    break;\n  case 8:\n    (*channelPointer)[3] = (*channelPointer)[3] | 8;\n    break;\n  case 0xc:\n    (*channelPointer)[3] = (*channelPointer)[3] | 0x10;\n  }\n  configureTimChannel(*channelPointer,flagValue,1);\n  if (*channelPointer == (uint *)0x40012c00) {\n    timControlRegister = timControlRegister | 0x8000;\n  }\n  **channelPointer = **channelPointer | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006280": "set_tim_channel_flags_08006280",
                "param_1": "channelPointer",
                "param_2": "flagValue",
                "TIM_CCxChannelCmd": "configureTimChannel",
                "uRam40012c44": "timControlRegister"
            },
            "calling": [
                "TimerPulseInit"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080062f4": {
            "entrypoint": "0x080062f4",
            "current_name": "update_and_configure_timers_080062f4",
            "code": "\nundefined4 updateAndConfigureTimers_080062f4(uint **timerData,undefined4 mode)\n\n{\n  uint *tempPtr;\n  \n  switch(mode) {\n  case 0:\n    (*timerData)[3] = (*timerData)[3] & 0xfffffffd;\n    break;\n  case 4:\n    (*timerData)[3] = (*timerData)[3] & 0xfffffffb;\n    break;\n  case 8:\n    (*timerData)[3] = (*timerData)[3] & 0xfffffff7;\n    break;\n  case 0xc:\n    (*timerData)[3] = (*timerData)[3] & 0xffffffef;\n  }\n  TIM_CCxChannelCmd(*timerData,mode,0);\n  if (((*timerData == (uint *)0x40012c00) && ((specialRegister2 & 0x1111) == 0)) &&\n     ((specialRegister2 & 0x444) == 0)) {\n    specialRegister3 = specialRegister3 & 0xffff7fff;\n  }\n  tempPtr = *timerData;\n  if (((tempPtr[8] & 0x1111) == 0) && ((tempPtr[8] & 0x444) == 0)) {\n    *tempPtr = *tempPtr & 0xfffffffe;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080062f4": "update_and_configure_timers_080062f4",
                "param_1": "timerData",
                "param_2": "mode",
                "puVar1": "tempPtr",
                "uRam40012c20": "specialRegister2",
                "uRam40012c44": "specialRegister3"
            },
            "calling": [
                "TimerPulseDeinit"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006390": {
            "entrypoint": "0x08006390",
            "current_name": "configure_timer_channel_08006390",
            "code": "\nundefined4 configureTimerChannel_08006390(uint **timerConfig,undefined4 channelCmd)\n\n{\n  setChannelCommand(*timerConfig,channelCmd,1);\n  if (*timerConfig == (uint *)0x40012c00) {\n    timerRegister = timerRegister | 0x8000;\n  }\n  **timerConfig = **timerConfig | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006390": "configure_timer_channel_08006390",
                "param_1": "timerConfig",
                "param_2": "channelCmd",
                "uRam40012c44": "timerRegister",
                "TIM_CCxChannelCmd": "setChannelCommand"
            },
            "calling": [
                "pwm_start"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080063c0": {
            "entrypoint": "0x080063c0",
            "current_name": "configure_tim_c_cx_channel_080063c0",
            "code": "\nundefined4 configure_TIM_CCxChannel_080063c0(uint **config_ptr,undefined4 channel_value)\n\n{\n  uint *reg_ptr;\n  \n  TIM_CCxChannelCmd(*config_ptr,channel_value,0);\n  if (((*config_ptr == (uint *)0x40012c00) && ((TIM_FLAG_MASK & 0x1111) == 0)) &&\n     ((TIM_FLAG_MASK & 0x444) == 0)) {\n    TIM_FLAG = TIM_FLAG & 0xffff7fff;\n  }\n  reg_ptr = *config_ptr;\n  if (((reg_ptr[8] & 0x1111) == 0) && ((reg_ptr[8] & 0x444) == 0)) {\n    *reg_ptr = *reg_ptr & 0xfffffffe;\n  }\n  *(undefined *)((int)config_ptr + 0x3d) = 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080063c0": "configure_tim_c_cx_channel_080063c0",
                "param_1": "config_ptr",
                "param_2": "channel_value",
                "puVar1": "reg_ptr",
                "uRam40012c20": "TIM_FLAG_MASK",
                "uRam40012c44": "TIM_FLAG"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006420": {
            "entrypoint": "0x08006420",
            "current_name": "update_bitwise_value_08006420",
            "code": "\nvoid updateBitwiseValue_08006420(int ptr,uint bitIndex,int value)\n\n{\n  *(uint *)(ptr + 0x20) = *(uint *)(ptr + 0x20) & ~(4 << (bitIndex & 0xff));\n  *(uint *)(ptr + 0x20) = *(uint *)(ptr + 0x20) | value << (bitIndex & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006420": "update_bitwise_value_08006420",
                "param_1": "ptr",
                "param_2": "bitIndex",
                "param_3": "value"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Start",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800643c": {
            "entrypoint": "0x0800643c",
            "current_name": "enable_channel_with_interrupts_0800643c",
            "code": "\nundefined4 enableChannelWithInterrupts_0800643c(uint **channelArray,undefined4 channelNumber)\n\n{\n  enableChannelCmd(*channelArray,channelNumber,4);\n  (*channelArray)[0x11] = (*channelArray)[0x11] | 0x8000;\n  **channelArray = **channelArray | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800643c": "enable_channel_with_interrupts_0800643c",
                "param_1": "channelArray",
                "param_2": "channelNumber",
                "TIM_CCxNChannelCmd": "enableChannelCmd"
            },
            "calling": [
                "pwm_start"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006460": {
            "entrypoint": "0x08006460",
            "current_name": "initialize_tim_08006460",
            "code": "\nundefined4 initializeTim_08006460(uint **timPointer,undefined4 channelNumber)\n\n{\n  uint *timAddress;\n  \n  TIM_CCxNChannelCmd(*timPointer,channelNumber,0);\n  timAddress = *timPointer;\n  if (((timAddress[8] & 0x1111) == 0) && ((timAddress[8] & 0x444) == 0)) {\n    timAddress[0x11] = timAddress[0x11] & 0xffff7fff;\n  }\n  timAddress = *timPointer;\n  if (((timAddress[8] & 0x1111) == 0) && ((timAddress[8] & 0x444) == 0)) {\n    *timAddress = *timAddress & 0xfffffffe;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006460": "initialize_tim_08006460",
                "param_1": "timPointer",
                "param_2": "channelNumber",
                "puVar1": "timAddress"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080064ac": {
            "entrypoint": "0x080064ac",
            "current_name": "FUNC_080064ac",
            "code": "\nvoid FUNC_080064ac(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080064ac": "FUNC_080064ac"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080064ae": {
            "entrypoint": "0x080064ae",
            "current_name": "FUNC_080064ae",
            "code": "\nvoid FUNC_080064ae(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080064ae": "FUNC_080064ae"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080064b0": {
            "entrypoint": "0x080064b0",
            "current_name": "reset_bits_and_set_space_080064b0",
            "code": "\nvoid resetBitsAndSetSpace_080064b0(int *pData)\n\n{\n  *(uint *)(*pData + 0xc) = *(uint *)(*pData + 0xc) & 0xfffffedf;\n  *(uint *)(*pData + 0x14) = *(uint *)(*pData + 0x14) & 0xfffffffe;\n  *(undefined *)((int)pData + 0x3a) = 0x20;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080064b0": "reset_bits_and_set_space_080064b0",
                "param_1": "pData"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080064cc": {
            "entrypoint": "0x080064cc",
            "current_name": "extract_data_080064cc",
            "code": "\nundefined4 extract_data_080064cc(int *data_ptr)\n\n{\n  short count;\n  byte *byte_ptr;\n  \n  if (*(char *)((int)data_ptr + 0x39) != '!') {\n    return 2;\n  }\n  if (data_ptr[2] == 0x1000) {\n    *(uint *)(*data_ptr + 4) = *(ushort *)data_ptr[8] & 0x1ff;\n    if (data_ptr[4] == 0) {\n      data_ptr[8] = data_ptr[8] + 2;\n    }\n    else {\n      data_ptr[8] = data_ptr[8] + 1;\n    }\n  }\n  else {\n    byte_ptr = (byte *)data_ptr[8];\n    data_ptr[8] = (int)(byte_ptr + 1);\n    *(uint *)(*data_ptr + 4) = (uint)*byte_ptr;\n  }\n  count = *(short *)((int)data_ptr + 0x26) + -1;\n  *(short *)((int)data_ptr + 0x26) = count;\n  if (count == 0) {\n    *(uint *)(*data_ptr + 0xc) = *(uint *)(*data_ptr + 0xc) & 0xffffff7f;\n    *(uint *)(*data_ptr + 0xc) = *(uint *)(*data_ptr + 0xc) | 0x40;\n    return 0;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080064cc": "extract_data_080064cc",
                "param_1": "data_ptr",
                "sVar1": "count",
                "pbVar2": "byte_ptr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006538": {
            "entrypoint": "0x08006538",
            "current_name": "calculate_freq_offset_08006538",
            "code": "\nvoid calculateFreqOffset_08006538(int *inputParams)\n\n{\n  int pclk1Freq1;\n  int pclk1Freq2;\n  int pclk1Freq3;\n  int pclk1Freq4;\n  int pclk1Freq5;\n  int pclk1Freq6;\n  int pclk1Freq7;\n  int pclk1Freq8;\n  int pclk1Freq9;\n  int currentPclk1Freq;\n  \n  *(uint *)(*inputParams + 0x10) = *(uint *)(*inputParams + 0x10) & 0xffffcfff | inputParams[3];\n  *(uint *)(*inputParams + 0xc) =\n       inputParams[2] | inputParams[4] | inputParams[5] | *(uint *)(*inputParams + 0xc) & 0xffffe9f3;\n  *(uint *)(*inputParams + 0x14) = *(uint *)(*inputParams + 0x14) & 0xfffffcff | inputParams[6];\n  currentPclk1Freq = *inputParams;\n  if (currentPclk1Freq != 0x40013800) {\n    pclk1Freq1 = getPCLK1Frequency();\n    pclk1Freq6 = inputParams[1];\n    pclk1Freq2 = getPCLK1Frequency();\n    pclk1Freq7 = inputParams[1];\n    pclk1Freq3 = getPCLK1Frequency();\n    pclk1Freq8 = inputParams[1];\n    pclk1Freq4 = getPCLK1Frequency();\n    pclk1Freq9 = inputParams[1];\n    pclk1Freq5 = getPCLK1Frequency();\n    *(uint *)(currentPclk1Freq + 8) =\n         ((uint)((int)((ulonglong)\n                       (((uint)(pclk1Freq4 * 0x19) / (uint)(pclk1Freq9 << 2) +\n                        (int)(((ulonglong)(uint)(pclk1Freq5 * 0x19) / (ulonglong)(uint)(inputParams[1] << 2))\n                             / 100) * -100) * 0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n         ((((uint)(pclk1Freq2 * 0x19) / (uint)(pclk1Freq7 << 2) +\n           (int)(((ulonglong)(uint)(pclk1Freq3 * 0x19) / (ulonglong)(uint)(pclk1Freq8 << 2)) / 100) * -100) *\n           0x10 + 0x32) / 100 & 0xf0) +\n         (int)(((ulonglong)(uint)(pclk1Freq1 * 0x19) / (ulonglong)(uint)(pclk1Freq6 << 2)) / 100) * 0x10;\n    return;\n  }\n  currentPclk1Freq = getPCLK2Frequency();\n  pclk1Freq5 = inputParams[1];\n  pclk1Freq1 = getPCLK2Frequency();\n  pclk1Freq6 = inputParams[1];\n  pclk1Freq2 = getPCLK2Frequency();\n  pclk1Freq7 = inputParams[1];\n  pclk1Freq3 = getPCLK2Frequency();\n  pclk1Freq8 = inputParams[1];\n  pclk1Freq4 = getPCLK2Frequency();\n  freqOffset = ((uint)((int)((ulonglong)\n                               (((uint)(pclk1Freq3 * 0x19) / (uint)(pclk1Freq8 << 2) +\n                                (int)(((ulonglong)(uint)(pclk1Freq4 * 0x19) /\n                                      (ulonglong)(uint)(inputParams[1] << 2)) / 100) * -100) * 0x10 +\n                               0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((uint)(pclk1Freq1 * 0x19) / (uint)(pclk1Freq6 << 2) +\n                   (int)(((ulonglong)(uint)(pclk1Freq2 * 0x19) / (ulonglong)(uint)(pclk1Freq7 << 2)) / 100) *\n                   -100) * 0x10 + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(uint)(currentPclk1Freq * 0x19) / (ulonglong)(uint)(pclk1Freq5 << 2)) / 100) *\n                 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006538": "calculate_freq_offset_08006538",
                "param_1": "inputParams",
                "iVar1": "pclk1Freq1",
                "iVar2": "pclk1Freq2",
                "iVar3": "pclk1Freq3",
                "iVar4": "pclk1Freq4",
                "iVar5": "pclk1Freq5",
                "iVar6": "pclk1Freq6",
                "iVar7": "pclk1Freq7",
                "iVar8": "pclk1Freq8",
                "iVar9": "pclk1Freq9",
                "iVar10": "currentPclk1Freq",
                "iRam40013808": "freqOffset",
                "HAL_RCC_GetPCLK1Freq": "getPCLK1Frequency",
                "HAL_RCC_GetPCLK2Freq": "getPCLK2Frequency"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080066e8": {
            "entrypoint": "0x080066e8",
            "current_name": "check_parameters_080066e8",
            "code": "\nundefined4 checkParameters_080066e8(uint **ptr_arr,uint value1,uint condition,int start_time,uint timeout)\n\n{\n  int current_time;\n  \n  do {\n    if (((value1 & ~**ptr_arr) == 0) != condition) {\n      return 0;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (current_time = HAL_GetTick(), (uint)(current_time - start_time) <= timeout))));\n  (*ptr_arr)[3] = (*ptr_arr)[3] & 0xfffffe5f;\n  (*ptr_arr)[5] = (*ptr_arr)[5] & 0xfffffffe;\n  *(undefined *)((int)ptr_arr + 0x39) = 0x20;\n  *(undefined *)((int)ptr_arr + 0x3a) = 0x20;\n  *(undefined *)(ptr_arr + 0xe) = 0;\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_080066e8": "check_parameters_080066e8",
                "param_1": "ptr_arr",
                "param_2": "value1",
                "param_3": "condition",
                "param_4": "start_time",
                "param_5": "timeout",
                "iVar1": "current_time"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800674c": {
            "entrypoint": "0x0800674c",
            "current_name": "FUNC_0800674c",
            "code": "\nvoid FUNC_0800674c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800674c": "FUNC_0800674c"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800674e": {
            "entrypoint": "0x0800674e",
            "current_name": "initialize_uart_0800674e",
            "code": "\nundefined4 initialize_uart_0800674e(int *uart_handle)\n\n{\n  if (uart_handle != (int *)0x0) {\n    if (*(char *)((int)uart_handle + 0x39) == '\\0') {\n      *(undefined *)(uart_handle + 0xe) = 0;\n      initialize_uart_0800674e_peripherals;\n    }\n    *(undefined *)((int)uart_handle + 0x39) = 0x24;\n    *(uint *)(*uart_handle + 0xc) = *(uint *)(*uart_handle + 0xc) & 0xffffdfff;\n    configure_uart;\n    *(uint *)(*uart_handle + 0x10) = *(uint *)(*uart_handle + 0x10) & 0xffffb7ff;\n    *(uint *)(*uart_handle + 0x14) = *(uint *)(*uart_handle + 0x14) & 0xffffffd5;\n    *(uint *)(*uart_handle + 0xc) = *(uint *)(*uart_handle + 0xc) | 0x2000;\n    uart_data_flag = 0;\n    *(undefined *)((int)uart_handle + 0x39) = 0x20;\n    *(undefined *)((int)uart_handle + 0x3a) = 0x20;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800674e": "initialize_uart_0800674e",
                "param_1": "uart_handle",
                "HAL_UART_MspInit()": "initialize_uart_peripherals",
                "UART_SetConfig(param_1)": "configure_uart",
                "param_1[0xf]": "uart_data_flag"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080067ac": {
            "entrypoint": "0x080067ac",
            "current_name": "process_data_080067ac",
            "code": "\nundefined4 processData_080067ac(int *dataBuffer,ushort *byteBuffer,int bufferSize,undefined4 timeout)\n\n{\n  int result;\n  undefined4 returnValue;\n  \n  if (*(char *)((int)dataBuffer + 0x39) == ' ') {\n    if (byteBuffer == (ushort *)0x0) {\n      returnValue = 1;\n    }\n    else if (bufferSize == 0) {\n      returnValue = 1;\n    }\n    else if (*(char *)(dataBuffer + 0xe) == '\\x01') {\n      returnValue = 2;\n    }\n    else {\n      *(undefined *)(dataBuffer + 0xe) = 1;\n      dataBuffer[0xf] = 0;\n      *(undefined *)((int)dataBuffer + 0x39) = 0x21;\n      returnValue = HAL_GetTick();\n      *(short *)(dataBuffer + 9) = (short)bufferSize;\n      *(short *)((int)dataBuffer + 0x26) = (short)bufferSize;\n      while (*(short *)((int)dataBuffer + 0x26) != 0) {\n        *(short *)((int)dataBuffer + 0x26) = *(short *)((int)dataBuffer + 0x26) + -1;\n        if (dataBuffer[2] == 0x1000) {\n          result = UART_WaitOnFlagUntilTimeout(dataBuffer,0x80,0,returnValue,timeout);\n          if (result != 0) {\n            return 3;\n          }\n          *(uint *)(*dataBuffer + 4) = *byteBuffer & 0x1ff;\n          if (dataBuffer[4] == 0) {\n            byteBuffer = byteBuffer + 1;\n          }\n          else {\n            byteBuffer = (ushort *)((int)byteBuffer + 1);\n          }\n        }\n        else {\n          result = UART_WaitOnFlagUntilTimeout(dataBuffer,0x80,0,returnValue,timeout);\n          if (result != 0) {\n            return 3;\n          }\n          *(uint *)(*dataBuffer + 4) = (uint)*(byte *)byteBuffer;\n          byteBuffer = (ushort *)((int)byteBuffer + 1);\n        }\n      }\n      result = UART_WaitOnFlagUntilTimeout(dataBuffer,0x40,0,returnValue,timeout);\n      if (result == 0) {\n        *(undefined *)((int)dataBuffer + 0x39) = 0x20;\n        *(undefined *)(dataBuffer + 0xe) = 0;\n        returnValue = 0;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080067ac": "process_data_080067ac",
                "param_1": "dataBuffer",
                "param_2": "byteBuffer",
                "param_3": "bufferSize",
                "param_4": "timeout",
                "iVar1": "result",
                "uVar2": "returnValue"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "UART_WaitOnFlagUntilTimeout",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800688e": {
            "entrypoint": "0x0800688e",
            "current_name": "update_parameters_0800688e",
            "code": "\nundefined4 updateParameters_0800688e(int *ptrParams,int value1,int value2)\n\n{\n  if (*(char *)((int)ptrParams + 0x39) != ' ') {\n    return 2;\n  }\n  if (value1 == 0) {\n    return 1;\n  }\n  if (value2 == 0) {\n    return 1;\n  }\n  if (*(char *)(ptrParams + 0xe) != '\\x01') {\n    ptrParams[8] = value1;\n    *(short *)(ptrParams + 9) = (short)value2;\n    *(short *)((int)ptrParams + 0x26) = (short)value2;\n    ptrParams[15] = 0;\n    *(undefined *)((int)ptrParams + 0x39) = 0x21;\n    *(undefined *)(ptrParams + 0xe) = 0;\n    *(uint *)(*ptrParams + 0xc) = *(uint *)(*ptrParams + 0xc) | 0x80;\n    return 0;\n  }\n  return 2;\n}\n\n",
            "renaming": {
                "FUN_0800688e": "update_parameters_0800688e",
                "param_1": "ptrParams",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[8]": "ptrParams[8]",
                "param_1[0xf]": "ptrParams[15]"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080068d6": {
            "entrypoint": "0x080068d6",
            "current_name": "validate_and_update_data_080068d6",
            "code": "\nundefined4 validate_and_update_data_080068d6(int *data_ptr,int value_1,int value_2)\n\n{\n  if (*(char *)((int)data_ptr + 0x3a) != ' ') {\n    return 2;\n  }\n  if (value_1 == 0) {\n    return 1;\n  }\n  if (value_2 == 0) {\n    return 1;\n  }\n  if (*(char *)(data_ptr + 0xe) != '\\x01') {\n    data_ptr_value_1 = value_1;\n    *(short *)(data_ptr + 0xb) = (short)value_2;\n    *(short *)((int)data_ptr + 0x2e) = (short)value_2;\n    data_ptr_value_4 = 0;\n    *(undefined *)((int)data_ptr + 0x3a) = 0x22;\n    *(undefined *)(data_ptr + 0xe) = 0;\n    *(uint *)(*data_ptr + 0xc) = *(uint *)(*data_ptr + 0xc) | 0x100;\n    *(uint *)(*data_ptr + 0x14) = *(uint *)(*data_ptr + 0x14) | 1;\n    *(uint *)(*data_ptr + 0xc) = *(uint *)(*data_ptr + 0xc) | 0x20;\n    return 0;\n  }\n  return 2;\n}\n\n",
            "renaming": {
                "FUN_080068d6": "validate_and_update_data_080068d6",
                "param_1": "data_ptr",
                "param_2": "value_1",
                "param_3": "value_2",
                "param_1[10]": "data_ptr_value_1",
                "param_1[0xf]": "data_ptr_value_4"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006932": {
            "entrypoint": "0x08006932",
            "current_name": "set_flag_08006932",
            "code": "\nundefined4 setFlag_08006932(int *ptr)\n\n{\n  *(uint *)(*ptr + 0xc) = *(uint *)(*ptr + 0xc) & 0xffffffbf;\n  *(undefined *)((int)ptr + 0x39) = 0x20;\n  uartTransmitCompleteCallback;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006932": "set_flag_08006932",
                "param_1": "ptr",
                "HAL_UART_TxCpltCallback()": "uartTransmitCompleteCallback"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800694c": {
            "entrypoint": "0x0800694c",
            "current_name": "process_data_0800694c",
            "code": "\nundefined4 processData_0800694c(int *dataPointer)\n\n{\n  byte *bytePointer;\n  short counter;\n  undefined *undefinedPointer;\n  \n  if (*(char *)((int)dataPointer + 0x3a) != '\\\"') {\n    return 2;\n  }\n  if (dataPointer[2] == 0x1000) {\n    if (dataPointer[4] == 0) {\n      *(ushort *)dataPointer[10] = (ushort)((uint)(*(int *)(*dataPointer + 4) << 0x17) >> 0x17);\n      dataPointer[10] = dataPointer[10] + 2;\n    }\n    else {\n      *(ushort *)dataPointer[10] = (ushort)*(undefined4 *)(*dataPointer + 4) & 0xff;\n      dataPointer[10] = dataPointer[10] + 1;\n    }\n  }\n  else if (dataPointer[4] == 0) {\n    undefinedPointer = (undefined *)dataPointer[10];\n    dataPointer[10] = (int)(undefinedPointer + 1);\n    *undefinedPointer = (char)*(undefined4 *)(*dataPointer + 4);\n  }\n  else {\n    bytePointer = (byte *)dataPointer[10];\n    dataPointer[10] = (int)(bytePointer + 1);\n    *bytePointer = (byte)*(undefined4 *)(*dataPointer + 4) & 0x7f;\n  }\n  counter = *(short *)((int)dataPointer + 0x2e) + -1;\n  *(short *)((int)dataPointer + 0x2e) = counter;\n  if (counter != 0) {\n    return 0;\n  }\n  *(uint *)(*dataPointer + 0xc) = *(uint *)(*dataPointer + 0xc) & 0xffffffdf;\n  *(uint *)(*dataPointer + 0xc) = *(uint *)(*dataPointer + 0xc) & 0xfffffeff;\n  *(uint *)(*dataPointer + 0x14) = *(uint *)(*dataPointer + 0x14) & 0xfffffffe;\n  *(undefined *)((int)dataPointer + 0x3a) = 0x20;\n  HAL_UART_RxCpltCallback();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800694c": "process_data_0800694c",
                "param_1": "dataPointer",
                "pbVar1": "bytePointer",
                "sVar2": "counter",
                "puVar3": "undefinedPointer"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080069ec": {
            "entrypoint": "0x080069ec",
            "current_name": "handle_uart_operations_080069ec",
            "code": "\nvoid handleUARTOperations_080069ec(uint **param)\n\n{\n  int result;\n  uint variable2;\n  uint *ptrVariable3;\n  uint variable4;\n  uint variable5;\n  \n  ptrVariable3 = *param;\n  variable5 = *ptrVariable3;\n  variable2 = ptrVariable3[3];\n  if ((((variable5 & 0xf) == 0) && ((variable5 & 0x20) != 0)) && ((variable2 & 0x20) != 0)) {\n    UART_Receive_IT(param);\n    return;\n  }\n  if (((variable5 & 0xf) == 0) || ((variable4 = ptrVariable3[5] & 1, variable4 == 0 && ((variable2 & 0x120) == 0)))) {\n    if (((variable5 & 0x80) != 0) && ((variable2 & 0x80) != 0)) {\n      UART_Transmit_IT(param);\n      return;\n    }\n    if (((variable5 & 0x40) != 0) && ((variable2 & 0x40) != 0)) {\n      UART_EndTransmit_IT(param);\n    }\n  }\n  else {\n    if (((variable5 & 1) != 0) && ((variable2 & 0x100) != 0)) {\n      param[0xf] = (uint *)((uint)param[0xf] | 1);\n    }\n    if (((variable5 & 4) != 0) && (variable4 != 0)) {\n      param[0xf] = (uint *)((uint)param[0xf] | 2);\n    }\n    if (((variable5 & 2) != 0) && (variable4 != 0)) {\n      param[0xf] = (uint *)((uint)param[0xf] | 4);\n    }\n    if (((variable5 & 8) != 0) && (variable4 != 0)) {\n      param[0xf] = (uint *)((uint)param[0xf] | 8);\n    }\n    if (param[0xf] != (uint *)0x0) {\n      if (((variable5 & 0x20) != 0) && ((variable2 & 0x20) != 0)) {\n        UART_Receive_IT(param);\n      }\n      if ((((uint)param[0xf] & 8) == 0) && (((*param)[5] & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(param);\n        param[0xf] = (uint *)0x0;\n        return;\n      }\n      UART_EndRxTransfer(param);\n      ptrVariable3 = *param;\n      if ((ptrVariable3[5] & 0x40) == 0) {\n        HAL_UART_ErrorCallback(param);\n        return;\n      }\n      ptrVariable3[5] = ptrVariable3[5] & 0xffffffbf;\n      if (param[0xd] == (uint *)0x0) {\n        HAL_UART_ErrorCallback(param);\n        return;\n      }\n      param[0xd][0xd] = (uint)&LAB_08006b0c_1;\n      result = HAL_DMA_Abort_IT(param[0xd]);\n      if (result != 0) {\n        (*(code *)param[0xd][0xd])();\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080069ec": "handle_uart_operations_080069ec",
                "param_1": "param",
                "iVar1": "result",
                "uVar2": "variable2",
                "uVar4": "variable4",
                "uVar5": "variable5",
                "puVar3": "ptrVariable3"
            },
            "calling": [],
            "called": [
                "UART_EndRxTransfer",
                "UART_EndTransmit_IT",
                "UART_Receive_IT",
                "HAL_UART_ErrorCallback",
                "HAL_DMA_Abort_IT",
                "UART_Transmit_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b1c": {
            "entrypoint": "0x08006b1c",
            "current_name": "combine_bytes_08006b1c",
            "code": "\nbyte combineBytes_08006b1c(int input)\n\n{\n  return *(byte *)(input + 0x3a) | *(byte *)(input + 0x39);\n}\n\n",
            "renaming": {
                "FUN_08006b1c": "combine_bytes_08006b1c",
                "param_1": "input"
            },
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b28": {
            "entrypoint": "0x08006b28",
            "current_name": "get_bit_at_index_08006b28",
            "code": "\nuint getBitAtIndex_08006b28(uint index,int arrayBase)\n\n{\n  return *(uint *)(arrayBase + ((index << 0x18) >> 0x1c) * 4) >> (index & 0xf) & 1;\n}\n\n",
            "renaming": {
                "FUN_08006b28": "get_bit_at_index_08006b28",
                "param_1": "index",
                "param_2": "arrayBase"
            },
            "calling": [
                "analogWrite",
                "digitalWrite",
                "digitalRead",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b3e": {
            "entrypoint": "0x08006b3e",
            "current_name": "set_bit_in_array_08006b3e",
            "code": "\nvoid setBitInArray_08006b3e(uint inputNumber,int arrayAddress)\n\n{\n  uint shiftedIndex;\n  \n  shiftedIndex = (inputNumber << 0x18) >> 0x1c;\n  *(uint *)(arrayAddress + shiftedIndex * 4) = *(uint *)(arrayAddress + shiftedIndex * 4) | 1 << (inputNumber & 0xf);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006b3e": "set_bit_in_array_08006b3e",
                "param_1": "inputNumber",
                "param_2": "arrayAddress",
                "uVar1": "shiftedIndex"
            },
            "calling": [
                "analogWrite",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b5c": {
            "entrypoint": "0x08006b5c",
            "current_name": "modify_bit_in_array_08006b5c",
            "code": "\nvoid modifyBitInArray_08006b5c(uint bitPosition,int arrayAddress)\n\n{\n  uint shiftedBitPosition;\n  \n  shiftedBitPosition = (bitPosition << 0x18) >> 0x1c;\n  *(uint *)(arrayAddress + shiftedBitPosition * 4) = *(uint *)(arrayAddress + shiftedBitPosition * 4) & ~(1 << (bitPosition & 0xf));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006b5c": "modify_bit_in_array_08006b5c",
                "param_1": "bitPosition",
                "param_2": "arrayAddress",
                "uVar1": "shiftedBitPosition"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b7c": {
            "entrypoint": "0x08006b7c",
            "current_name": "get_address_from_param_08006b7c",
            "code": "\nundefined4 getAddressFromParam_08006b7c(undefined4 inputParam)\n\n{\n  switch(inputParam) {\n  case 0:\n    return 0x40010800;\n  case 1:\n    return 0x40010c00;\n  case 2:\n    return 0x40011000;\n  case 3:\n    return 0x40011400;\n  case 4:\n    return 0x40011800;\n  default:\n    return 0;\n  }\n}\n\n",
            "renaming": {
                "FUN_08006b7c": "get_address_from_param_08006b7c",
                "param_1": "inputParam"
            },
            "calling": [
                "digitalWrite",
                "digitalRead"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006bb8": {
            "entrypoint": "0x08006bb8",
            "current_name": "set_flag_and_return_address_08006bb8",
            "code": "\n\n\nundefined4 setFlagAndReturnAddress_08006bb8(undefined4 flag)\n\n{\n  undefined4 returnAddress;\n  \n  switch(flag) {\n  case 0:\n    _DAT_40021018 = _DAT_40021018 | 4;\n    returnAddress = 0x40010800;\n    break;\n  case 1:\n    _DAT_40021018 = _DAT_40021018 | 8;\n    returnAddress = 0x40010c00;\n    break;\n  case 2:\n    _DAT_40021018 = _DAT_40021018 | 0x10;\n    returnAddress = 0x40011000;\n    break;\n  case 3:\n    _DAT_40021018 = _DAT_40021018 | 0x20;\n    returnAddress = 0x40011400;\n    break;\n  case 4:\n    _DAT_40021018 = _DAT_40021018 | 0x40;\n    returnAddress = 0x40011800;\n    break;\n  default:\n    returnAddress = 0;\n  }\n  return returnAddress;\n}\n\n",
            "renaming": {
                "FUN_08006bb8": "set_flag_and_return_address_08006bb8",
                "param_1": "flag",
                "uVar1": "returnAddress"
            },
            "calling": [
                "uart_init",
                "i2c_custom_init",
                "HAL_TIM_PWM_MspInit",
                "HAL_ADC_MspInit",
                "digital_io_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c60": {
            "entrypoint": "0x08006c60",
            "current_name": "map_pin_to_index_08006c60",
            "code": "\nuint map_pin_to_index_08006c60(undefined4 pin_value,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int index;\n  uint mapped_index;\n  \n  index = pinmap_function(pin_value,&DAT_0800a5b8,param_3,param_4,param_4);\n  mapped_index = (uint)(index << 0xc) >> 0x1b;\n  if (0x10 < mapped_index - 1) {\n    mapped_index = 0;\n  }\n  return mapped_index;\n}\n\n",
            "renaming": {
                "FUN_08006c60": "map_pin_to_index_08006c60",
                "param_1": "pin_value",
                "iVar1": "index",
                "uVar2": "mapped_index"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c7c": {
            "entrypoint": "0x08006c7c",
            "current_name": "get_pinmap_08006c7c",
            "code": "\nundefined4 getPinmap_08006c7c(undefined4 param1,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  int result;\n  uint shiftedResult;\n  \n  result = pinmap_function(param1,&DAT_0800a6cc,param3,param4,param4);\n  shiftedResult = (uint)(result << 0xc) >> 0x1b;\n  if (shiftedResult == 3) {\n    return 8;\n  }\n  if (shiftedResult != 4) {\n    if (shiftedResult != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_08006c7c": "get_pinmap_08006c7c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "result",
                "uVar2": "shiftedResult"
            },
            "calling": [
                "pwm_start",
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ca8": {
            "entrypoint": "0x08006ca8",
            "current_name": "initialize_gpio_08006ca8",
            "code": "\n\n\nvoid initializeGPIO_08006ca8(int *gpioConfig,undefined4 portClock)\n\n{\n  undefined4 gpioPort;\n  uint configMask;\n  int gpioMode;\n  uint pinBit;\n  undefined4 pinMode;\n  undefined4 pinConfig;\n  \n  gpioMode = *gpioConfig;\n  if (gpioMode == 0x40012400) {\n    configMask = _DAT_40021018 | 0x200;\n    gpioMode = 0x200;\n    _DAT_40021018 = configMask;\n  }\n  else {\n    configMask = 0x40012800;\n    if (gpioMode == 0x40012800) {\n      configMask = _DAT_40021018 | 0x400;\n      gpioMode = 0x400;\n      _DAT_40021018 = configMask;\n    }\n  }\n  gpioPort = set_GPIO_Port_Clock((uint)((int)(char)DAT_20000014 << 0x18) >> 0x1c,portClock,configMask,gpioMode);\n  pinBit = 1 << (DAT_20000014 & 0xf) & 0xffff;\n  pinMode = 3;\n  pinConfig = 0;\n  HAL_GPIO_Init(gpioPort,&pinBit);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006ca8": "initialize_gpio_08006ca8",
                "param_1": "gpioConfig",
                "param_2": "portClock",
                "uVar1": "gpioPort",
                "uVar2": "configMask",
                "iVar3": "gpioMode",
                "local_18": "pinBit",
                "local_14": "pinMode",
                "local_10": "pinConfig"
            },
            "calling": [
                "HAL_ADC_Init"
            ],
            "called": [
                "set_GPIO_Port_Clock",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d24": {
            "entrypoint": "0x08006d24",
            "current_name": "update_flags_based_on_param_08006d24",
            "code": "\n\n\nvoid updateFlagsBasedOnParam_08006d24(int *param)\n\n{\n  if (*param != 0x40012400) {\n    if (*param == 0x40012800) {\n      _DAT_4002100c = _DAT_4002100c & 0xfffffbff;\n      _DAT_40021018 = _DAT_40021018 & 0xfffffbff;\n    }\n    return;\n  }\n  _DAT_4002100c = _DAT_4002100c & 0xfffffdff;\n  _DAT_40021018 = _DAT_40021018 & 0xfffffdff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006d24": "update_flags_based_on_param_08006d24",
                "param_1": "param"
            },
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d80": {
            "entrypoint": "0x08006d80",
            "current_name": "read_analog_value_08006d80",
            "code": "\nundefined2 read_analog_value_08006d80(undefined4 peripheral_address)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined2 analog_value;\n  uint adc_channel;\n  undefined4 adc_flag_1;\n  undefined4 adc_flag_2;\n  int peripheral_value;\n  undefined4 adc_config_1;\n  undefined4 adc_config_2;\n  undefined4 adc_config_3;\n  undefined4 adc_config_4;\n  undefined4 adc_config_5;\n  undefined4 adc_config_6;\n  undefined4 adc_config_7;\n  undefined4 adc_config_8;\n  \n  memset(&peripheral_value,0,0x30);\n  adc_channel = 0;\n  adc_flag_1 = 0;\n  adc_flag_2 = 0;\n  analog_value = 0;\n  peripheral_value = pinmap_peripheral(peripheral_address,&DAT_0800a5b8);\n  if (peripheral_value == 0) {\n    analog_value = 0;\n  }\n  else {\n    adc_config_1 = 0;\n    adc_config_2 = 0;\n    adc_config_3 = 0;\n    adc_config_5 = 0;\n    adc_config_7 = 0xe0000;\n    adc_config_8 = 0;\n    adc_config_4 = 1;\n    adc_config_6 = 0;\n    DAT_20000014 = (undefined)peripheral_address;\n    iVar1 = HAL_ADC_Init(&peripheral_value);\n    if (iVar1 == 0) {\n      adc_channel = get_adc_channel(peripheral_address);\n      if (adc_channel < 0x12) {\n        adc_flag_1 = 1;\n        adc_flag_2 = 2;\n        iVar1 = HAL_ADC_ConfigChannel(&peripheral_value,&adc_channel);\n        if (iVar1 == 0) {\n          iVar1 = HAL_ADCEx_Calibration_Start(&peripheral_value);\n          if (iVar1 == 0) {\n            iVar1 = HAL_ADC_Start(&peripheral_value);\n            if (iVar1 == 0) {\n              iVar1 = HAL_ADC_PollForConversion(&peripheral_value,10);\n              if (iVar1 == 0) {\n                uVar2 = HAL_ADC_GetState(&peripheral_value);\n                if ((uVar2 & 0x200) != 0) {\n                  analog_value = HAL_ADC_GetValue(&peripheral_value);\n                }\n                iVar1 = HAL_ADC_Stop(&peripheral_value);\n                if (iVar1 == 0) {\n                  iVar1 = HAL_ADC_DeInit(&peripheral_value);\n                  if (iVar1 != 0) {\n                    analog_value = 0;\n                  }\n                }\n                else {\n                  analog_value = 0;\n                }\n              }\n              else {\n                analog_value = 0;\n              }\n            }\n            else {\n              analog_value = 0;\n            }\n          }\n          else {\n            analog_value = 0;\n          }\n        }\n        else {\n          analog_value = 0;\n        }\n      }\n      else {\n        analog_value = 0;\n      }\n    }\n    else {\n      analog_value = 0;\n    }\n  }\n  return analog_value;\n}\n\n",
            "renaming": {
                "FUN_08006d80": "read_analog_value_08006d80",
                "param_1": "peripheral_address",
                "local_46": "analog_value",
                "local_44": "adc_channel",
                "local_40": "adc_flag_1",
                "local_3c": "adc_flag_2",
                "local_38": "peripheral_value",
                "local_34": "adc_config_1",
                "local_30": "adc_config_2",
                "local_2c": "adc_config_3",
                "local_28": "adc_config_4",
                "local_24": "adc_config_5",
                "local_20": "adc_config_6",
                "local_1c": "adc_config_7",
                "local_10": "adc_config_8"
            },
            "calling": [
                "analogRead"
            ],
            "called": [
                "HAL_ADC_ConfigChannel",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_PollForConversion",
                "HAL_ADC_GetValue",
                "HAL_ADC_Init",
                "HAL_ADC_Start",
                "memset",
                "HAL_ADC_Stop",
                "HAL_ADC_DeInit",
                "get_adc_channel",
                "pinmap_peripheral",
                "HAL_ADC_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e68": {
            "entrypoint": "0x08006e68",
            "current_name": "initialize_gpio_08006e68",
            "code": "\n\n\nvoid initializeGPIO_08006e68(undefined4 clockPin)\n\n{\n  int pinmapResult;\n  undefined4 GPIO_Port;\n  uint pinmask;\n  undefined4 mode_1;\n  undefined4 mode_2;\n  undefined4 mode_3;\n  \n  pinmapResult = pinmap_function((int)(char)DAT_20000014,&DAT_0800a6cc);\n  timer_enable_clock(clockPin);\n  GPIO_Port = set_GPIO_Port_Clock((uint)((int)(char)DAT_20000014 << 0x18) >> 0x1c);\n  mode_1 = 2;\n  mode_2 = 0;\n  mode_3 = 3;\n  _DAT_40021018 = _DAT_40021018 | 1;\n  switch((uint)(pinmapResult << 0x11) >> 0x19) {\n  case 1:\n    _DAT_40010004 = _DAT_40010004 | 0x7000001;\n    break;\n  case 2:\n    _DAT_40010004 = _DAT_40010004 & 0xfffffffe | 0x7000000;\n    break;\n  case 3:\n    _DAT_40010004 = _DAT_40010004 | 0x7000002;\n    break;\n  case 4:\n    _DAT_40010004 = _DAT_40010004 & 0xfffffffd | 0x7000000;\n    break;\n  case 5:\n    _DAT_40010004 = _DAT_40010004 | 0x7000004;\n    break;\n  case 6:\n    _DAT_40010004 = _DAT_40010004 & 0xfffffffb | 0x7000000;\n    break;\n  case 7:\n    _DAT_40010004 = _DAT_40010004 | 0x7000008;\n    break;\n  case 8:\n    _DAT_40010004 = _DAT_40010004 & 0xfffffff7 | 0x7000000;\n    break;\n  case 9:\n    _DAT_40010004 = _DAT_40010004 | 0x7000030;\n    break;\n  case 10:\n    _DAT_40010004 = _DAT_40010004 & 0xffffffcf | 0x7000010;\n    break;\n  case 0xb:\n    _DAT_40010004 = _DAT_40010004 & 0xffffffcf | 0x7000000;\n    break;\n  case 0xc:\n    _DAT_40010004 = _DAT_40010004 | 0x70000c0;\n    break;\n  case 0xd:\n    _DAT_40010004 = _DAT_40010004 & 0xffffff3f | 0x7000040;\n    break;\n  case 0xe:\n    _DAT_40010004 = _DAT_40010004 & 0xffffff3f | 0x7000000;\n    break;\n  case 0xf:\n    _DAT_40010004 = _DAT_40010004 | 0x7000300;\n    break;\n  case 0x10:\n    _DAT_40010004 = _DAT_40010004 & 0xfffffcff | 0x7000200;\n    break;\n  case 0x11:\n    _DAT_40010004 = _DAT_40010004 & 0xfffffcff | 0x7000100;\n    break;\n  case 0x12:\n    _DAT_40010004 = _DAT_40010004 & 0xfffffcff | 0x7000000;\n    break;\n  case 0x13:\n    _DAT_40010004 = _DAT_40010004 | 0x7000c00;\n    break;\n  case 0x14:\n    _DAT_40010004 = _DAT_40010004 & 0xfffff3ff | 0x7000800;\n    break;\n  case 0x15:\n    _DAT_40010004 = _DAT_40010004 & 0xfffff3ff | 0x7000000;\n    break;\n  case 0x16:\n    _DAT_40010004 = _DAT_40010004 | 0x7001000;\n    break;\n  case 0x17:\n    _DAT_40010004 = _DAT_40010004 & 0xffffefff | 0x7000000;\n    break;\n  case 0x1b:\n    _DAT_40010004 = _DAT_40010004 | 0x7008000;\n    break;\n  case 0x1c:\n    _DAT_40010004 = _DAT_40010004 & 0xffff7fff | 0x7000000;\n    break;\n  case 0x21:\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff;\n    break;\n  case 0x22:\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x1000000;\n    break;\n  case 0x23:\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x2000000;\n    break;\n  case 0x24:\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n  }\n  pinmask = 1 << (DAT_20000014 & 0xf) & 0xffff;\n  HAL_GPIO_Init(GPIO_Port,&pinmask);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e68": "initialize_gpio_08006e68",
                "param_1": "clockPin",
                "iVar1": "pinmapResult",
                "uVar2": "GPIO_Port",
                "local_20": "pinmask",
                "local_1c": "mode_1",
                "local_18": "mode_2",
                "local_14": "mode_3"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [
                "timer_enable_clock",
                "pinmap_function",
                "set_GPIO_Port_Clock",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007110": {
            "entrypoint": "0x08007110",
            "current_name": "disable_timer_clock_08007110",
            "code": "\nvoid disableTimerClock_08007110(void)\n\n{\n  timer_disable_clock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007110": "disable_timer_clock_08007110"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007118": {
            "entrypoint": "0x08007118",
            "current_name": "initialize_pwm_08007118",
            "code": "\nvoid initializePwm_08007118(undefined4 pinNumber,uint timerFrequency,int channel,undefined4 configParams,char startFlag)\n\n{\n  uint timerClkFreq;\n  int pwmChannel;\n  int configResult;\n  undefined4 pwmConfig1;\n  undefined4 pwmConfig2;\n  undefined4 pwmConfig3;\n  undefined4 pwmConfig4;\n  undefined4 pwmConfig5;\n  undefined4 pwmConfig6;\n  undefined4 pwmConfig7;\n  int pwmPeriph;\n  int prescaler;\n  undefined4 pwmConfig8;\n  int channelCount;\n  undefined4 pwmConfig9;\n  undefined4 pwmConfig10;\n  undefined pwmConfigFlag;\n  \n  memset(&pwmPeriph,0,0x40);\n  pwmConfig1 = 0;\n  pwmConfig2 = 0;\n  pwmConfig3 = 0;\n  pwmConfig4 = 0;\n  pwmConfig5 = 0;\n  pwmConfig6 = 0;\n  pwmConfig7 = 0;\n  pwmPeriph = pinmap_peripheral(pinNumber,&DAT_0800a6cc);\n  if (pwmPeriph != 0) {\n    timerClkFreq = getTimerClkFreq();\n    prescaler = timerClkFreq / timerFrequency - 1;\n    channelCount = channel + -1;\n    pwmConfig9 = 0;\n    pwmConfig8 = 0;\n    pwmConfig10 = 0;\n    pwmConfigFlag = 0;\n    if (startFlag == '\\x01') {\n      DAT_20000014 = (undefined)pinNumber;\n      pwmChannel = HAL_TIM_PWM_Init(&pwmPeriph);\n      if (pwmChannel != 0) {\n        return;\n      }\n    }\n    pwmChannel = get_pwm_channel(pinNumber);\n    if ((((pwmChannel == 0) || (pwmChannel == 4)) || (pwmChannel == 8)) || ((pwmChannel == 0xc || (pwmChannel == 0x18)))) {\n      pwmConfig1 = 0x60;\n      pwmConfig3 = 0;\n      pwmConfig5 = 0;\n      pwmConfig4 = 0;\n      pwmConfig7 = 0;\n      pwmConfig6 = 0;\n      pwmConfig2 = configParams;\n      configResult = HAL_TIM_PWM_ConfigChannel(&pwmPeriph,&pwmConfig1,pwmChannel);\n      if (configResult == 0) {\n        timerClkFreq = pinmap_function(pinNumber,&DAT_0800a6cc);\n        if ((timerClkFreq & 0x100000) == 0) {\n          HAL_TIM_PWM_Start(&pwmPeriph,pwmChannel);\n        }\n        else {\n          HAL_TIMEx_PWMN_Start(&pwmPeriph,pwmChannel);\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007118": "initialize_pwm_08007118",
                "param_1": "pinNumber",
                "param_2": "timerFrequency",
                "param_3": "channel",
                "param_4": "configParams",
                "param_5": "startFlag",
                "uVar1": "timerClkFreq",
                "iVar2": "pwmChannel",
                "iVar3": "configResult",
                "local_74": "pwmConfig1",
                "local_70": "pwmConfig2",
                "local_6c": "pwmConfig3",
                "local_68": "pwmConfig4",
                "local_64": "pwmConfig5",
                "local_60": "pwmConfig6",
                "local_5c": "pwmConfig7",
                "local_58": "pwmPeriph",
                "local_54": "prescaler",
                "local_50": "pwmConfig8",
                "local_4c": "channelCount",
                "local_48": "pwmConfig9",
                "local_44": "pwmConfig10",
                "local_1b": "pwmConfigFlag"
            },
            "calling": [
                "analogWrite"
            ],
            "called": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_PWM_ConfigChannel",
                "pinmap_function",
                "HAL_TIMEx_PWMN_Start",
                "memset",
                "get_pwm_channel",
                "HAL_TIM_PWM_Start",
                "getTimerClkFreq",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080071e4": {
            "entrypoint": "0x080071e4",
            "current_name": "stop_pwm_if_valid_channel_080071e4",
            "code": "\nvoid stopPWMIfValidChannel_080071e4(undefined4 peripheral)\n\n{\n  int pwmChannel;\n  uint pinFunction;\n  int pwmHandle [17];\n  \n  pwmHandle[0] = pinmap_peripheral(peripheral,&DAT_0800a6cc);\n  if ((pwmHandle[0] != 0) &&\n     ((((pwmChannel = get_pwm_channel(peripheral), pwmChannel == 0 || (pwmChannel == 4)) || (pwmChannel == 8)) ||\n      ((pwmChannel == 0xc || (pwmChannel == 0x18)))))) {\n    pinFunction = pinmap_function(peripheral,&DAT_0800a6cc);\n    if ((pinFunction & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(pwmHandle,pwmChannel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(pwmHandle,pwmChannel);\n    }\n    HAL_TIM_PWM_DeInit(pwmHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080071e4": "stop_pwm_if_valid_channel_080071e4",
                "param_1": "peripheral",
                "iVar1": "pwmChannel",
                "uVar2": "pinFunction",
                "local_50": "pwmHandle"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "pinmap_function",
                "HAL_TIM_PWM_DeInit",
                "get_pwm_channel",
                "HAL_TIM_PWM_Stop",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800723c": {
            "entrypoint": "0x0800723c",
            "current_name": "get_system_tick_0800723c",
            "code": "\nvoid get_system_tick_0800723c(void)\n\n{\n  HAL_GetTick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800723c": "get_system_tick_0800723c"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007244": {
            "entrypoint": "0x08007244",
            "current_name": "FUNC_08007244",
            "code": "\nvoid FUNC_08007244(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007244": "FUNC_08007244"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007246": {
            "entrypoint": "0x08007246",
            "current_name": "handle_system_tick_08007246",
            "code": "\nvoid handleSystemTick_08007246(void)\n\n{\n  incrementSystemTick();\n  handleSysTickInterrupt();\n  handleNoOsSysTick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007246": "handle_system_tick_08007246",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterrupt",
                "noOsSystickHandler": "handleNoOsSysTick"
            },
            "calling": [],
            "called": [
                "noOsSystickHandler",
                "HAL_SYSTICK_IRQHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007258": {
            "entrypoint": "0x08007258",
            "current_name": "initialize_gpio_08007258",
            "code": "\n\n\nvoid initializeGPIO_08007258(uint pin,undefined4 mode,undefined4 pull)\n\n{\n  undefined4 port;\n  uint pinMask;\n  undefined4 modeCopy;\n  undefined4 pullCopy;\n  undefined4 constant3;\n  \n  port = set_GPIO_Port_Clock((pin << 0x18) >> 0x1c);\n  pinMask = 1 << (pin & 0xf) & 0xffff;\n  constant3 = 3;\n  _DAT_40021018 = _DAT_40021018 | 1;\n  if ((pin - 0xd & 0xff) < 2) {\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n  }\n  if (((pin == 0xf) || (pin == 0x13)) || (pin == 0x14)) {\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x2000000;\n  }\n  modeCopy = mode;\n  pullCopy = pull;\n  HAL_GPIO_Init(port,&pinMask);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007258": "initialize_gpio_08007258",
                "param_1": "pin",
                "param_2": "mode",
                "param_3": "pull",
                "uVar1": "port",
                "local_20": "pinMask",
                "local_1c": "modeCopy",
                "local_18": "pullCopy",
                "local_14": "constant3"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "set_GPIO_Port_Clock",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072d8": {
            "entrypoint": "0x080072d8",
            "current_name": "set_pin_state_080072d8",
            "code": "\nvoid setPinState_080072d8(undefined4 port,undefined2 pin,int state,undefined4 arg1)\n\n{\n  if (state == 0) {\n    HAL_GPIO_WritePin(port,pin,0,arg1,arg1);\n    return;\n  }\n  HAL_GPIO_WritePin(port,pin,1,arg1,arg1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072d8": "set_pin_state_080072d8",
                "param_1": "port",
                "param_2": "pin",
                "param_3": "state",
                "param_4": "arg1"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072f0": {
            "entrypoint": "0x080072f0",
            "current_name": "read_pin_080072f0",
            "code": "\nvoid read_pin_080072f0(undefined4 gpio_port,undefined2 pin_number,undefined4 gpio_mode,undefined4 pin_state)\n\n{\n  HAL_GPIO_ReadPin(gpio_port,pin_number,gpio_mode,pin_state,pin_state);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072f0": "read_pin_080072f0",
                "param_1": "gpio_port",
                "param_2": "pin_number",
                "param_3": "gpio_mode",
                "param_4": "pin_state"
            },
            "calling": [
                "digitalRead"
            ],
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072fa": {
            "entrypoint": "0x080072fa",
            "current_name": "initialize_system_080072fa",
            "code": "\nvoid initializeSystem_080072fa(void)\n\n{\n  initializeHardware();\n  configureSystemClock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072fa": "initialize_system_080072fa",
                "HAL_Init": "initializeHardware",
                "SystemClock_Config": "configureSystemClock"
            },
            "calling": [
                "FUN_080036a2"
            ],
            "called": [
                "HAL_Init",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007306": {
            "entrypoint": "0x08007306",
            "current_name": "find_value_in_list_08007306",
            "code": "\nundefined4 find_value_in_list_08007306(int value,char *list)\n\n{\n  while( true ) {\n    if (*list == -1) {\n      return 0;\n    }\n    if (*list == value) break;\n    list = list + 0xc;\n  }\n  return *(undefined4 *)(list + 4);\n}\n\n",
            "renaming": {
                "FUN_08007306": "find_value_in_list_08007306",
                "param_1": "value",
                "param_2": "list"
            },
            "calling": [
                "pinmap_peripheral",
                "pinmap_find_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007320": {
            "entrypoint": "0x08007320",
            "current_name": "find_peripheral_08007320",
            "code": "\nundefined4 findPeripheral_08007320(int input)\n\n{\n  undefined4 peripheral;\n  \n  if (input != -1) {\n    peripheral = pinmap_find_peripheral();\n    return peripheral;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08007320": "find_peripheral_08007320",
                "param_1": "input",
                "uVar1": "peripheral"
            },
            "calling": [
                "uart_init",
                "i2c_custom_init",
                "uart_debug_write",
                "pwm_start",
                "adc_read_value",
                "uart_debug_init",
                "pwm_stop"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007332": {
            "entrypoint": "0x08007332",
            "current_name": "find_value_position_08007332",
            "code": "\nint find_value_position_08007332(int value,char *array)\n\n{\n  while( true ) {\n    if (*(int *)(array + 4) == 0) {\n      return -1;\n    }\n    if (*(int *)(array + 4) == value) break;\n    array = array + 0xc;\n  }\n  return (int)*array;\n}\n\n",
            "renaming": {
                "FUN_08007332": "find_value_position_08007332",
                "param_1": "value",
                "param_2": "array"
            },
            "calling": [
                "pinmap_find_pin",
                "pinmap_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800734a": {
            "entrypoint": "0x0800734a",
            "current_name": "find_pin_0800734a",
            "code": "\nundefined4 findPin_0800734a(int pinIndex)\n\n{\n  undefined4 pin;\n  \n  if (pinIndex != 0) {\n    pin = pinmap_find_pin();\n    return pin;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800734a": "find_pin_0800734a",
                "param_1": "pinIndex",
                "uVar1": "pin"
            },
            "calling": [
                "HardwareSerial",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800735a": {
            "entrypoint": "0x0800735a",
            "current_name": "find_value_index_0800735a",
            "code": "\nundefined4 find_value_index_0800735a(int value,char *data)\n\n{\n  while( true ) {\n    if (*data == -1) {\n      return 0xffffffff;\n    }\n    if (*data == value) break;\n    data = data + 0xc;\n  }\n  return *(undefined4 *)(data + 8);\n}\n\n",
            "renaming": {
                "FUN_0800735a": "find_value_index_0800735a",
                "param_1": "value",
                "param_2": "data"
            },
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007376": {
            "entrypoint": "0x08007376",
            "current_name": "find_pinmap_function_08007376",
            "code": "\nundefined4 find_pinmap_function_08007376(int input_value)\n\n{\n  undefined4 result;\n  \n  if (input_value == -1) {\n    return 0xffffffff;\n  }\n  result = pinmap_find_function();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08007376": "find_pinmap_function_08007376",
                "param_1": "input_value",
                "uVar1": "result"
            },
            "calling": [
                "uart_init",
                "i2c_custom_init",
                "pwm_start",
                "HAL_TIM_PWM_MspInit",
                "get_adc_channel",
                "pwm_stop",
                "get_pwm_channel"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800738a": {
            "entrypoint": "0x0800738a",
            "current_name": "check_match_0800738a",
            "code": "\nundefined4 check_match_0800738a(int index,char *data)\n\n{\n  if (index == -1) {\n    return 0;\n  }\n  while( true ) {\n    if (*data == -1) {\n      return 0;\n    }\n    if (index == *data) break;\n    data = data + 0xc;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800738a": "check_match_0800738a",
                "param_1": "index",
                "param_2": "data"
            },
            "calling": [
                "sysexCallback",
                "analogWrite",
                "enableI2CPins",
                "FUN_0800021a",
                "setPinModeCallback",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073ae": {
            "entrypoint": "0x080073ae",
            "current_name": "check_and_get_non_zero_param_080073ae",
            "code": "\nint check_and_get_non_zero_param_080073ae(int first_param,int second_param)\n\n{\n  if (first_param != second_param) {\n    if (first_param == 0) {\n      return second_param;\n    }\n    if (second_param == 0) {\n      return first_param;\n    }\n    first_param = 0;\n  }\n  return first_param;\n}\n\n",
            "renaming": {
                "FUN_080073ae": "check_and_get_non_zero_param_080073ae",
                "param_1": "first_param",
                "param_2": "second_param"
            },
            "calling": [
                "uart_init",
                "i2c_custom_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073c0": {
            "entrypoint": "0x080073c0",
            "current_name": "execute_function_080073c0",
            "code": "\nvoid executeFunction_080073c0(void)\n\n{\n  if (DAT_200005f4 != (code *)0x0) {\n    (*DAT_200005f4)(DAT_2000060c);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080073c0": "execute_function_080073c0"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073e8": {
            "entrypoint": "0x080073e8",
            "current_name": "infinite_loop_080073e8",
            "code": "\nvoid infiniteLoop_080073e8(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080073e8": "infinite_loop_080073e8"
            },
            "calling": [
                "_Error_Handler",
                "SystemClock_Config"
            ],
            "called": [
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073ec": {
            "entrypoint": "0x080073ec",
            "current_name": "initialize_device_080073ec",
            "code": "\n\n\nvoid initializeDevice_080073ec(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080073ec": "initialize_device_080073ec"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007438": {
            "entrypoint": "0x08007438",
            "current_name": "process_param_08007438",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nvoid processParam_08007438(int *parameter)\n\n{\n  if (*parameter == 0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 | 0x800;\n    DAT_20000610 = parameter;\n  }\n  if (*parameter == 0x40000000) {\n    _DAT_4002101c = _DAT_4002101c | 1;\n    DAT_20000614 = parameter;\n  }\n  if (*parameter == 0x40000400) {\n    _DAT_4002101c = _DAT_4002101c | 2;\n    DAT_20000618 = parameter;\n  }\n  if (*parameter == 0x40000800) {\n    _DAT_4002101c = _DAT_4002101c | 4;\n    DAT_2000061c = parameter;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007438": "process_param_08007438",
                "param_1": "parameter"
            },
            "calling": [
                "HAL_TIM_PWM_MspInit",
                "HAL_TIM_OC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080074e0": {
            "entrypoint": "0x080074e0",
            "current_name": "configure_registers_080074e0",
            "code": "\n\n\nvoid configureRegisters_080074e0(int *registerValues)\n\n{\n  if (*registerValues == 0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 & 0xfffff7ff;\n  }\n  if (*registerValues == 0x40000000) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffe;\n  }\n  if (*registerValues == 0x40000400) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffd;\n  }\n  if (*registerValues == 0x40000800) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080074e0": "configure_registers_080074e0",
                "param_1": "registerValues"
            },
            "calling": [
                "HAL_TIM_OC_MspDeInit",
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007544": {
            "entrypoint": "0x08007544",
            "current_name": "get_timer_irq_number_08007544",
            "code": "\nundefined4 getTimerIRQNumber_08007544(uint irqNumber)\n\n{\n  if (irqNumber == 0xffffffff) {\n    return 0;\n  }\n  if (irqNumber == 0x40000400) {\n    return 0x1d;\n  }\n  if (irqNumber < 0x40000401) {\n    if (irqNumber == 0x40000000) {\n      return 0x1c;\n    }\n  }\n  else {\n    if (irqNumber == 0x40000800) {\n      return 0x1e;\n    }\n    if (irqNumber == 0x40012c00) {\n      return 0x19;\n    }\n  }\n  printErrorMessage(\"TIM: Unknown timer IRQn\");\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08007544": "get_timer_irq_number_08007544",
                "param_1": "irqNumber",
                "iprintf": "printErrorMessage"
            },
            "calling": [
                "TimerPulseDeinit",
                "TimerPulseInit"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007594": {
            "entrypoint": "0x08007594",
            "current_name": "check_timer_instance_08007594",
            "code": "\nundefined4 checkTimerInstance_08007594(uint instance)\n\n{\n  if (instance == 0xffffffff) {\n    return 0;\n  }\n  if (instance == 0x40000400) {\n    return 1;\n  }\n  if (instance < 0x40000401) {\n    if (instance == 0x40000000) {\n      return 1;\n    }\n  }\n  else {\n    if (instance == 0x40000800) {\n      return 1;\n    }\n    if (instance == 0x40012c00) {\n      return 2;\n    }\n  }\n  printErrorMessage(\"TIM: Unknown timer instance\");\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08007594": "check_timer_instance_08007594",
                "param_1": "instance",
                "iprintf": "printErrorMessage"
            },
            "calling": [
                "getTimerClkFreq"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080075dc": {
            "entrypoint": "0x080075dc",
            "current_name": "calculate_timer_clk_freq_080075dc",
            "code": "\nint calculateTimerClkFreq_080075dc(undefined4 timerNum)\n\n{\n  uint localVar1;\n  int timerClkSrc;\n  uint localVar2;\n  undefined4 clockConfig1;\n  undefined4 clockConfig2;\n  undefined4 clockConfig3;\n  undefined4 clockConfig4;\n  uint localVar3;\n  uint localVar4;\n  \n  clockConfig2 = 0;\n  clockConfig3 = 0;\n  clockConfig4 = 0;\n  localVar3 = 0;\n  localVar4 = 0;\n  clockConfig1 = 0;\n  HAL_RCC_GetClockConfig(&clockConfig2,&clockConfig1);\n  timerClkSrc = getTimerClkSrc(timerNum);\n  localVar1 = localVar4;\n  localVar2 = localVar3;\n  if (timerClkSrc == 1) {\n    timerClkSrc = HAL_RCC_GetPCLK1Freq();\n  }\n  else if (timerClkSrc == 2) {\n    timerClkSrc = HAL_RCC_GetPCLK2Freq();\n    localVar2 = localVar1;\n  }\n  else {\n    iprintf(\"TIM: Unknown clock source\");\n    timerClkSrc = 0;\n    localVar2 = 0;\n  }\n  if (localVar2 != 0x500) {\n    if (localVar2 < 0x501) {\n      if (localVar2 != 0x400) {\n        return timerClkSrc;\n      }\n    }\n    else if ((localVar2 != 0x600) && (localVar2 != 0x700)) {\n      return timerClkSrc;\n    }\n  }\n  return timerClkSrc << 1;\n}\n\n",
            "renaming": {
                "FUN_080075dc": "calculate_timer_clk_freq_080075dc",
                "param_1": "timerNum",
                "uVar1": "localVar1",
                "iVar2": "timerClkSrc",
                "uVar3": "localVar2",
                "local_20": "clockConfig1",
                "local_1c": "clockConfig2",
                "local_18": "clockConfig3",
                "local_14": "clockConfig4",
                "local_10": "localVar3",
                "local_c": "localVar4"
            },
            "calling": [
                "TimerPulseInit",
                "pwm_start"
            ],
            "called": [
                "HAL_RCC_GetClockConfig",
                "HAL_RCC_GetPCLK2Freq",
                "getTimerClkSrc",
                "HAL_RCC_GetPCLK1Freq",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007648": {
            "entrypoint": "0x08007648",
            "current_name": "initialize_timer_08007648",
            "code": "\nvoid initializeTimer_08007648(undefined4 *timerParameters,undefined4 value2,undefined4 value3,undefined4 value4)\n\n{\n  char timerIRQ;\n  uint timerFrequency;\n  int initResult;\n  undefined4 *paramPointer;\n  undefined4 localVariable1;\n  undefined4 localVariable2;\n  undefined4 localVariable3;\n  undefined4 localVariable4;\n  undefined4 localVariable5;\n  undefined4 localVariable6;\n  undefined4 localVariable7;\n  \n  localVariable1 = 0;\n  localVariable2 = 0;\n  localVariable3 = 0;\n  localVariable4 = 0;\n  localVariable5 = 0;\n  localVariable6 = 0;\n  localVariable7 = 0;\n  paramPointer = timerParameters + 1;\n  *timerParameters = 0x40000000;\n  timerParameters[1] = 0x40000000;\n  timerParameters[4] = value2;\n  timerFrequency = getTimerClkFreq();\n  timerParameters[2] = timerFrequency / 1000000 - 1;\n  timerParameters[5] = 0;\n  timerParameters[3] = 0;\n  timerParameters[6] = 0;\n  timerParameters[0x13] = value4;\n  localVariable1 = 0;\n  localVariable3 = 0;\n  localVariable5 = 0;\n  localVariable4 = 0;\n  localVariable6 = 0;\n  localVariable7 = 0;\n  localVariable2 = value3;\n  timerIRQ = getTimerIrq(*timerParameters);\n  HAL_NVIC_SetPriority((int)timerIRQ,0xe,0);\n  timerIRQ = getTimerIrq(*timerParameters);\n  HAL_NVIC_EnableIRQ((int)timerIRQ);\n  initResult = HAL_TIM_OC_Init(paramPointer);\n  if ((initResult == 0) && (initResult = HAL_TIM_OC_ConfigChannel(paramPointer,&localVariable1,0), initResult == 0)) {\n    HAL_TIM_OC_Start_IT(paramPointer,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007648": "initialize_timer_08007648",
                "param_1": "timerParameters",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "cVar1": "timerIRQ",
                "uVar2": "timerFrequency",
                "iVar3": "initResult",
                "puVar4": "paramPointer",
                "local_34": "localVariable1",
                "local_30": "localVariable2",
                "local_2c": "localVariable3",
                "local_28": "localVariable4",
                "local_24": "localVariable5",
                "local_20": "localVariable6",
                "local_1c": "localVariable7"
            },
            "calling": [
                "initISR"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_TIM_OC_Start_IT",
                "HAL_TIM_OC_ConfigChannel",
                "getTimerIrq",
                "HAL_TIM_OC_Init",
                "getTimerClkFreq",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080076e0": {
            "entrypoint": "0x080076e0",
            "current_name": "disable_and_stop_timer_080076e0",
            "code": "\nvoid disableAndStopTimer_080076e0(undefined4 *timerParams)\n\n{\n  char timerIrq;\n  int deInitResult;\n  \n  timerParams[0x13] = 0;\n  timerIrq = getTimerIrq(*timerParams);\n  HAL_NVIC_DisableIRQ((int)timerIrq);\n  deInitResult = HAL_TIM_OC_DeInit(timerParams + 1);\n  if (deInitResult == 0) {\n    HAL_TIM_OC_Stop_IT(timerParams + 1,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080076e0": "disable_and_stop_timer_080076e0",
                "param_1": "timerParams",
                "cVar1": "timerIrq",
                "iVar2": "deInitResult"
            },
            "calling": [
                "finISR"
            ],
            "called": [
                "HAL_NVIC_DisableIRQ",
                "getTimerIrq",
                "HAL_TIM_OC_DeInit",
                "HAL_TIM_OC_Stop_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007708": {
            "entrypoint": "0x08007708",
            "current_name": "initialize_timer_clock_08007708",
            "code": "\nvoid initializeTimerClock_08007708(void)\n\n{\n  enableTimerClock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007708": "initialize_timer_clock_08007708",
                "timer_enable_clock": "enableTimerClock"
            },
            "calling": [
                "HAL_TIM_OC_Init"
            ],
            "called": [
                "timer_enable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007710": {
            "entrypoint": "0x08007710",
            "current_name": "disable_timer_clock_08007710",
            "code": "\nvoid disable_timer_clock_08007710(void)\n\n{\n  timer_disable_clock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007710": "disable_timer_clock_08007710"
            },
            "calling": [
                "HAL_TIM_OC_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007718": {
            "entrypoint": "0x08007718",
            "current_name": "subtract_four_08007718",
            "code": "\nint subtract_four_08007718(int input_number)\n\n{\n  return input_number + -4;\n}\n\n",
            "renaming": {
                "FUN_08007718": "subtract_four_08007718",
                "param_1": "input_number"
            },
            "calling": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800771c": {
            "entrypoint": "0x0800771c",
            "current_name": "execute_timer_function_0800771c",
            "code": "\nvoid executeTimerFunction_0800771c(int timerIndex)\n\n{\n  int timerObject;\n  \n  timerObject = getTimerObject();\n  if ((*(code **)(timerObject + 0x4c) != (code *)0x0) && (*(char *)(timerIndex + 0x1c) == '\\x01')) {\n    (**(code **)(timerObject + 0x4c))(timerObject,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800771c": "execute_timer_function_0800771c",
                "param_1": "timerIndex",
                "iVar1": "timerObject",
                "get_timer_obj": "getTimerObject"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007736": {
            "entrypoint": "0x08007736",
            "current_name": "execute_timer_function_08007736",
            "code": "\nvoid executeTimerFunction_08007736(void)\n\n{\n  int timerObject;\n  \n  timerObject = getTimerObject();\n  if (*(functionPointer **)(timerObject + 0x48) != (functionPointer *)0x0) {\n    (**(functionPointer **)(timerObject + 0x48))();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007736": "execute_timer_function_08007736",
                "iVar1": "timerObject",
                "get_timer_obj": "getTimerObject",
                "code": "functionPointer"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007744": {
            "entrypoint": "0x08007744",
            "current_name": "get_pointer_value_08007744",
            "code": "\nundefined4 getPointerValue_08007744(int inputParam)\n\n{\n  return *(undefined4 *)(*(int *)(inputParam + 4) + 0x24);\n}\n\n",
            "renaming": {
                "FUN_08007744": "get_pointer_value_08007744",
                "param_1": "inputParam"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800774a": {
            "entrypoint": "0x0800774a",
            "current_name": "update_value_in_struct_0800774a",
            "code": "\nvoid updateValueInStruct_0800774a(int structPointer,undefined4 newValue)\n\n{\n  *(undefined4 *)(*(int *)(structPointer + 4) + 0x24) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800774a": "update_value_in_struct_0800774a",
                "param_1": "structPointer",
                "param_2": "newValue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007750": {
            "entrypoint": "0x08007750",
            "current_name": "update_memory_08007750",
            "code": "\nvoid updateMemory_08007750(int baseAddress,int index,undefined4 value)\n\n{\n  *(undefined4 *)(*(int *)(baseAddress + 4) + 0x34 + index * 4) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007750": "update_memory_08007750",
                "param_1": "baseAddress",
                "param_2": "index",
                "param_3": "value"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080077b0": {
            "entrypoint": "0x080077b0",
            "current_name": "initialize_i2_c_080077b0",
            "code": "\n\n\nvoid initializeI2C_080077b0(int *device,int param2,int param3,int param4,undefined param5)\n\n{\n  int pin1;\n  int pin2;\n  undefined4 gpioPort;\n  uint function1;\n  uint function2;\n  int *i2cPeripheral;\n  uint pinMask1;\n  uint pinMask2;\n  uint pinFunction;\n  undefined4 gpioConfig;\n  \n  if (device != (int *)0x0) {\n    i2cPeripheral = device + 1;\n    pin1 = pinmap_peripheral((int)*(char *)(device + 0x16),&DAT_0800a69c);\n    pin2 = pinmap_peripheral((int)*(char *)((int)device + 0x59),&DAT_0800a66c);\n    if ((pin1 == 0) || (pin2 == 0)) {\n      iprintf(\"ERROR: at least one I2C pin has no peripheral\\n\");\n    }\n    else {\n      pin1 = pinmap_merge_peripheral(pin1,pin2);\n      *device = pin1;\n      if (pin1 == 0) {\n        iprintf(\"ERROR: I2C pins mismatch\\n\");\n      }\n      else {\n        if (pin1 == 0x40005400) {\n          _DAT_4002101c = _DAT_4002101c | 0x200000;\n          _DAT_40021010 = _DAT_40021010 & 0xffdfffff;\n          *(undefined *)((int)device + 0x5a) = 0x1f;\n          *(undefined *)((int)device + 0x5b) = 0x20;\n          DAT_20000668 = i2cPeripheral;\n        }\n        if (*device == 0x40005800) {\n          _DAT_4002101c = _DAT_4002101c | 0x400000;\n          _DAT_40021010 = _DAT_40021010 & 0xffbfffff;\n          *(undefined *)((int)device + 0x5a) = 0x21;\n          *(undefined *)((int)device + 0x5b) = 0x22;\n          DAT_2000066c = i2cPeripheral;\n        }\n        gpioPort = setGpioPortClock((uint)((int)*(char *)((int)device + 0x59) << 0x18) >> 0x1c);\n        pinMask1 = 1 << ((int)*(char *)((int)device + 0x59) & 0xfU) & 0xffff;\n        function1 = pinmap_function((int)*(char *)((int)device + 0x59),&DAT_0800a66c);\n        function2 = pinmap_function((int)*(char *)((int)device + 0x59),&DAT_0800a66c);\n        pinMask2 = (function1 >> 3 & 1) << 4 | function2 & 7;\n        gpioConfig = 3;\n        pin1 = pinmap_function((int)*(char *)((int)device + 0x59),&DAT_0800a66c);\n        pinFunction = (uint)(pin1 << 0x1a) >> 0x1e;\n        pin1 = pinmap_function((int)*(char *)((int)device + 0x59),&DAT_0800a66c);\n        _DAT_40021018 = _DAT_40021018 | 1;\n        function2 = 1;\n        function1 = _DAT_40021018;\n        switch((uint)(pin1 << 0x11) >> 0x19) {\n        case 1:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000001;\n          _DAT_40010004 = function2;\n          break;\n        case 2:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffffe | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 3:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000002;\n          _DAT_40010004 = function2;\n          break;\n        case 4:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffffd | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 5:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000004;\n          _DAT_40010004 = function2;\n          break;\n        case 6:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffffb | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 7:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000008;\n          _DAT_40010004 = function2;\n          break;\n        case 8:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffff7 | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 9:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000030;\n          _DAT_40010004 = function2;\n          break;\n        case 10:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xffffffcf | 0x7000010;\n          _DAT_40010004 = function2;\n          break;\n        case 0xb:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xffffffcf | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0xc:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x70000c0;\n          _DAT_40010004 = function2;\n          break;\n        case 0xd:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xffffff3f | 0x7000040;\n          _DAT_40010004 = function2;\n          break;\n        case 0xe:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xffffff3f | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0xf:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000300;\n          _DAT_40010004 = function2;\n          break;\n        case 0x10:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffcff | 0x7000200;\n          _DAT_40010004 = function2;\n          break;\n        case 0x11:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffcff | 0x7000100;\n          _DAT_40010004 = function2;\n          break;\n        case 0x12:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffcff | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x13:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000c00;\n          _DAT_40010004 = function2;\n          break;\n        case 0x14:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffff3ff | 0x7000800;\n          _DAT_40010004 = function2;\n          break;\n        case 0x15:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffff3ff | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x16:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7001000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x17:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xffffefff | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x1b:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7008000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x1c:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xffff7fff | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x21:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xf8ffffff;\n          _DAT_40010004 = function2;\n          break;\n        case 0x22:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xf8ffffff | 0x1000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x23:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xf8ffffff | 0x2000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x24:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n          _DAT_40010004 = function2;\n        }\n        initializeGpio(gpioPort,&pinMask1,function1,function2);\n        gpioPort = setGpioPortClock((uint)((int)*(char *)(device + 0x16) << 0x18) >> 0x1c);\n        pinMask1 = 1 << ((int)*(char *)(device + 0x16) & 0xfU) & 0xffff;\n        function1 = pinmap_function((int)*(char *)(device + 0x16),&DAT_0800a69c);\n        function2 = pinmap_function((int)*(char *)(device + 0x16),&DAT_0800a69c);\n        pinMask2 = (function1 >> 3 & 1) << 4 | function2 & 7;\n        gpioConfig = 3;\n        pin1 = pinmap_function((int)*(char *)(device + 0x16),&DAT_0800a69c);\n        pinFunction = (uint)(pin1 << 0x1a) >> 0x1e;\n        pin1 = pinmap_function((int)*(char *)(device + 0x16),&DAT_0800a69c);\n        _DAT_40021018 = _DAT_40021018 | 1;\n        function2 = 1;\n        function1 = _DAT_40021018;\n        switch((uint)(pin1 << 0x11) >> 0x19) {\n        case 1:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000001;\n          _DAT_40010004 = function2;\n          break;\n        case 2:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffffe | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 3:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000002;\n          _DAT_40010004 = function2;\n          break;\n        case 4:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffffd | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 5:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000004;\n          _DAT_40010004 = function2;\n          break;\n        case 6:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffffb | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 7:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000008;\n          _DAT_40010004 = function2;\n          break;\n        case 8:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffff7 | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 9:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000030;\n          _DAT_40010004 = function2;\n          break;\n        case 10:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xffffffcf | 0x7000010;\n          _DAT_40010004 = function2;\n          break;\n        case 0xb:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xffffffcf | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0xc:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x70000c0;\n          _DAT_40010004 = function2;\n          break;\n        case 0xd:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xffffff3f | 0x7000040;\n          _DAT_40010004 = function2;\n          break;\n        case 0xe:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xffffff3f | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0xf:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000300;\n          _DAT_40010004 = function2;\n          break;\n        case 0x10:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffcff | 0x7000200;\n          _DAT_40010004 = function2;\n          break;\n        case 0x11:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffcff | 0x7000100;\n          _DAT_40010004 = function2;\n          break;\n        case 0x12:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffffcff | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x13:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7000c00;\n          _DAT_40010004 = function2;\n          break;\n        case 0x14:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffff3ff | 0x7000800;\n          _DAT_40010004 = function2;\n          break;\n        case 0x15:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xfffff3ff | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x16:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7001000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x17:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xffffefff | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x1b:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 | 0x7008000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x1c:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xffff7fff | 0x7000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x21:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xf8ffffff;\n          _DAT_40010004 = function2;\n          break;\n        case 0x22:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xf8ffffff | 0x1000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x23:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xf8ffffff | 0x2000000;\n          _DAT_40010004 = function2;\n          break;\n        case 0x24:\n          function1 = 0x40010000;\n          function2 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n          _DAT_40010004 = function2;\n        }\n        initializeGpio(gpioPort,&pinMask1,function1,function2);\n        device[1] = *device;\n        device[2] = param2;\n        device[3] = 0;\n        device[4] = param4;\n        device[7] = 0xff;\n        device[5] = param3;\n        device[6] = 0;\n        device[8] = 0;\n        device[9] = 0;\n        *(undefined *)((int)device + 0x41) = 0;\n        setPriority((int)*(char *)((int)device + 0x5a),0,1);\n        enableIRQ((int)*(char *)((int)device + 0x5a));\n        setPriority((int)*(char *)((int)device + 0x5b),0,1);\n        enableIRQ((int)*(char *)((int)device + 0x5b));\n        initializeI2C_080077b0Peripheral(i2cPeripheral);\n        *(undefined *)((int)device + 0x5d) = param5;\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080077b0": "initialize_i2_c_080077b0",
                "param_1": "device",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "iVar1": "pin1",
                "iVar2": "pin2",
                "uVar3": "gpioPort",
                "uVar4": "function1",
                "uVar5": "function2",
                "piVar6": "i2cPeripheral",
                "local_38": "pinMask1",
                "local_34": "pinMask2",
                "local_30": "pinFunction",
                "local_2c": "gpioConfig",
                "set_GPIO_Port_Clock": "setGpioPortClock",
                "HAL_GPIO_Init": "initializeGpio",
                "HAL_NVIC_SetPriority": "setPriority",
                "HAL_NVIC_EnableIRQ": "enableIRQ",
                "HAL_I2C_Init": "initializeI2CPeripheral"
            },
            "calling": [
                "FUN_08002968"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "pinmap_function",
                "set_GPIO_Port_Clock",
                "iprintf",
                "pinmap_merge_peripheral",
                "HAL_I2C_Init",
                "HAL_GPIO_Init",
                "HAL_NVIC_SetPriority",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007e74": {
            "entrypoint": "0x08007e74",
            "current_name": "transmit_with_timeout_08007e74",
            "code": "\nint transmitWithTimeout_08007e74(int deviceAddress,undefined4 dataBuffer,undefined4 dataSize,undefined4 timeout)\n\n{\n  int startTime;\n  int transmitStatus;\n  uint elapsedTime;\n  int errorStatus;\n  int i2cHandle;\n  undefined4 errorFlag;\n  \n  errorFlag = timeout;\n  startTime = HAL_GetTick();\n  elapsedTime = 0;\n  errorStatus = 2;\n  do {\n    i2cHandle = deviceAddress + 4;\n    transmitStatus = HAL_I2C_Master_Transmit_IT(i2cHandle,dataBuffer,dataSize,timeout,errorFlag);\n    if (transmitStatus == 0) {\n      errorStatus = 0;\n      while ((transmitStatus = HAL_I2C_GetState(i2cHandle), transmitStatus != 0x20 && (errorStatus == 0))) {\n        transmitStatus = HAL_GetTick();\n        elapsedTime = transmitStatus - startTime;\n        if (elapsedTime < 0x65) {\n          transmitStatus = HAL_I2C_GetError(i2cHandle);\n          if (transmitStatus != 0) {\n            errorStatus = 2;\n          }\n        }\n        else {\n          errorStatus = 1;\n        }\n      }\n    }\n    transmitStatus = HAL_I2C_GetError(i2cHandle);\n  } while ((transmitStatus == 4) && (elapsedTime < 100));\n  return errorStatus;\n}\n\n",
            "renaming": {
                "FUN_08007e74": "transmit_with_timeout_08007e74",
                "param_1": "deviceAddress",
                "param_2": "dataBuffer",
                "param_3": "dataSize",
                "param_4": "timeout",
                "iVar1": "startTime",
                "iVar2": "transmitStatus",
                "uVar3": "elapsedTime",
                "iVar4": "errorStatus",
                "iVar5": "i2cHandle",
                "uVar6": "errorFlag"
            },
            "calling": [
                "FUN_08002a58"
            ],
            "called": [
                "HAL_I2C_Master_Transmit_IT",
                "HAL_I2C_GetState",
                "HAL_I2C_GetError",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007ede": {
            "entrypoint": "0x08007ede",
            "current_name": "copy_data_08007ede",
            "code": "\nundefined4 copyData_08007ede(int dest,int src,uint size)\n\n{\n  uint index;\n  \n  if (0x20 < size) {\n    return 2;\n  }\n  for (index = 0; index < size; index = index + 1 & 0xff) {\n    *(undefined *)(dest + index + 0x68) = *(undefined *)(src + index);\n    *(char *)(dest + 0x88) = *(char *)(dest + 0x88) + '\\x01';\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08007ede": "copy_data_08007ede",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "uVar1": "index"
            },
            "calling": [
                "FUN_080027f0",
                "FUN_0800288c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f0e": {
            "entrypoint": "0x08007f0e",
            "current_name": "receive_data_from_i2_c_08007f0e",
            "code": "\nint receiveDataFromI2C_08007f0e(int deviceAddress,undefined4 dataBuffer,undefined4 dataSize,undefined4 timeout)\n\n{\n  int startTime;\n  int i2cState;\n  uint elapsedTime;\n  int result;\n  int i2cDevice;\n  undefined4 timeoutInit;\n  \n  timeoutInit = timeout;\n  startTime = HAL_GetTick();\n  elapsedTime = 0;\n  result = 2;\n  do {\n    i2cDevice = deviceAddress + 4;\n    i2cState = HAL_I2C_Master_Receive_IT(i2cDevice,dataBuffer,dataSize,timeout,timeoutInit);\n    if (i2cState == 0) {\n      result = 0;\n      while ((i2cState = HAL_I2C_GetState(i2cDevice), i2cState != 0x20 && (result == 0))) {\n        i2cState = HAL_GetTick();\n        elapsedTime = i2cState - startTime;\n        if (elapsedTime < 0x65) {\n          i2cState = HAL_I2C_GetError(i2cDevice);\n          if (i2cState != 0) {\n            result = 2;\n          }\n        }\n        else {\n          result = 1;\n        }\n      }\n    }\n    i2cState = HAL_I2C_GetError(i2cDevice);\n  } while ((i2cState == 4) && (elapsedTime < 100));\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08007f0e": "receive_data_from_i2_c_08007f0e",
                "param_1": "deviceAddress",
                "param_2": "dataBuffer",
                "param_3": "dataSize",
                "param_4": "timeout",
                "iVar1": "startTime",
                "iVar2": "i2cState",
                "uVar3": "elapsedTime",
                "iVar4": "result",
                "iVar5": "i2cDevice",
                "uVar6": "timeoutInit"
            },
            "calling": [
                "FUN_08002b68"
            ],
            "called": [
                "HAL_I2C_GetState",
                "HAL_I2C_Master_Receive_IT",
                "HAL_I2C_GetError",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f78": {
            "entrypoint": "0x08007f78",
            "current_name": "subtract_4_from_param_08007f78",
            "code": "\nint subtract_4_from_param_08007f78(int num)\n\n{\n  return num + -4;\n}\n\n",
            "renaming": {
                "FUN_08007f78": "subtract_4_from_param_08007f78",
                "param_1": "num"
            },
            "calling": [
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f7c": {
            "entrypoint": "0x08007f7c",
            "current_name": "update_i2_c_listener_08007f7c",
            "code": "\nvoid updateI2CListener_08007f7c(int deviceAddress,int listenerEnabledFlag)\n\n{\n  if (deviceAddress != 0) {\n    if (listenerEnabledFlag != 0) {\n      *(int *)(deviceAddress + 0x60) = listenerEnabledFlag;\n      HAL_I2C_EnableListen_IT(deviceAddress + 4);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007f7c": "update_i2_c_listener_08007f7c",
                "param_1": "deviceAddress",
                "param_2": "listenerEnabledFlag"
            },
            "calling": [
                "FUN_08002968"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f8e": {
            "entrypoint": "0x08007f8e",
            "current_name": "set_i2_c_param_and_enable_listen_08007f8e",
            "code": "\nvoid setI2CParamAndEnableListen_08007f8e(int deviceAddress,int paramValue)\n\n{\n  if (deviceAddress != 0) {\n    if (paramValue != 0) {\n      *(int *)(deviceAddress + 100) = paramValue;\n      HAL_I2C_EnableListen_IT(deviceAddress + 4);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007f8e": "set_i2_c_param_and_enable_listen_08007f8e",
                "param_1": "deviceAddress",
                "param_2": "paramValue"
            },
            "calling": [
                "FUN_08002968"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007fa0": {
            "entrypoint": "0x08007fa0",
            "current_name": "i2c_slave_communication_08007fa0",
            "code": "\nvoid i2cSlaveCommunication_08007fa0(int i2cBaseAddress,int receiveFlag,int expectedValue,undefined4 callbackFunction)\n\n{\n  int i2cObj;\n  \n  i2cObj = getI2CObject();\n  if (expectedValue == *(int *)(i2cBaseAddress + 0xc)) {\n    if (receiveFlag == 0) {\n      *(undefined *)(i2cObj + 0x88) = 0;\n      *(undefined *)(i2cObj + 0x5c) = 0;\n      if (*(code **)(i2cObj + 100) != (code *)0x0) {\n        (**(code **)(i2cObj + 100))();\n      }\n      transmitSequentially(i2cBaseAddress,i2cObj + 0x68,*(undefined *)(i2cObj + 0x88),8);\n      return;\n    }\n    *(undefined *)(i2cObj + 0x5c) = 1;\n    receiveSequentially(i2cBaseAddress,i2cObj + 0x68,0x20,8,callbackFunction);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007fa0": "i2c_slave_communication_08007fa0",
                "param_1": "i2cBaseAddress",
                "param_2": "receiveFlag",
                "param_3": "expectedValue",
                "param_4": "callbackFunction",
                "iVar1": "i2cObj",
                "get_i2c_obj": "getI2CObject",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "transmitSequentially",
                "HAL_I2C_Slave_Sequential_Receive_IT": "receiveSequentially"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007ff0": {
            "entrypoint": "0x08007ff0",
            "current_name": "enable_i2c_listen_mode_08007ff0",
            "code": "\nvoid enable_i2c_listen_mode_08007ff0(undefined4 i2c_handle)\n\n{\n  int i2c_obj;\n  \n  i2c_obj = get_i2c_object();\n  if (((*(function_pointer **)(i2c_obj + 0x60) != (function_pointer *)0x0) && (*(char *)(i2c_obj + 0x5c) == '\\x01')) &&\n     (*(char *)(i2c_obj + 0x2c) != ' ')) {\n    (**(function_pointer **)(i2c_obj + 0x60))(i2c_obj + 0x68);\n  }\n  enable_i2c_listen_interrupts(i2c_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007ff0": "enable_i2c_listen_mode_08007ff0",
                "param_1": "i2c_handle",
                "iVar1": "i2c_obj",
                "get_i2c_obj": "get_i2c_object",
                "code": "function_pointer",
                "HAL_I2C_EnableListen_IT": "enable_i2c_listen_interrupts"
            },
            "calling": [
                "I2C_Slave_AF",
                "I2C_ITError",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008020": {
            "entrypoint": "0x08008020",
            "current_name": "enable_i2_c_listen_it_08008020",
            "code": "\nvoid enableI2CListenIT_08008020(undefined4 inputAddress)\n\n{\n  int i2cObject;\n  \n  i2cObject = getI2CObject();\n  if (*(char *)(i2cObject + 0x5d) == '\\0') {\n    enableI2CListen(inputAddress);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008020": "enable_i2_c_listen_it_08008020",
                "param_1": "inputAddress",
                "iVar1": "i2cObject",
                "get_i2c_obj": "getI2CObject",
                "HAL_I2C_EnableListen_IT": "enableI2CListen"
            },
            "calling": [
                "I2C_ITError"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008078": {
            "entrypoint": "0x08008078",
            "current_name": "configure_uart_pins_08008078",
            "code": "\n\n\nvoid configureUARTPins_08008078(int *uartPinArray)\n\n{\n  int peripheral1;\n  int peripheral2;\n  undefined4 gpioPortClock1;\n  uint pinFunction1;\n  uint pin1;\n  uint pinFunctionValue1;\n  uint pinFunctionMode1;\n  undefined4 gpioPortClock2;\n  \n  if (uartPinArray != (int *)0x0) {\n    peripheral1 = pinmap_peripheral((int)*(char *)(uartPinArray + 0x16),&DAT_0800a864);\n    peripheral2 = pinmap_peripheral((int)*(char *)((int)uartPinArray + 0x59),&DAT_0800a81c);\n    if ((peripheral2 == 0) || (peripheral1 == 0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\",peripheral2);\n    }\n    else {\n      peripheral1 = pinmap_merge_peripheral(peripheral1);\n      *uartPinArray = peripheral1;\n      if (peripheral1 == 0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (peripheral1 == 0x40013800) {\n          _DAT_4002100c = _DAT_4002100c & 0xffffbfff;\n          _DAT_40021018 = _DAT_40021018 | 0x4000;\n          *(undefined *)(uartPinArray + 0x11) = 0;\n          *(undefined *)((int)uartPinArray + 0x5a) = 0x25;\n        }\n        else if (peripheral1 == 0x40004400) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffdffff;\n          _DAT_4002101c = _DAT_4002101c | 0x20000;\n          *(undefined *)(uartPinArray + 0x11) = 1;\n          *(undefined *)((int)uartPinArray + 0x5a) = 0x26;\n        }\n        else if (peripheral1 == 0x40004800) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffbffff;\n          _DAT_4002101c = _DAT_4002101c | 0x40000;\n          *(undefined *)(uartPinArray + 0x11) = 2;\n          *(undefined *)((int)uartPinArray + 0x5a) = 0x27;\n        }\n        gpioPortClock1 = set_GPIO_Port_Clock((uint)((int)*(char *)((int)uartPinArray + 0x59) << 0x18) >> 0x1c);\n        pinFunction1 = pinmap_function((int)*(char *)((int)uartPinArray + 0x59),&DAT_0800a81c);\n        pin1 = 1 << (*(byte *)((int)uartPinArray + 0x59) & 0xf) & 0xffff;\n        pinFunctionValue1 = (pinFunction1 >> 3 & 1) << 4 | pinFunction1 & 7;\n        pinFunctionMode1 = (pinFunction1 << 0x1a) >> 0x1e;\n        _DAT_40021018 = _DAT_40021018 | 1;\n        switch((pinFunction1 << 0x11) >> 0x19) {\n        case 1:\n          _DAT_40010004 = _DAT_40010004 | 0x7000001;\n          break;\n        case 2:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          _DAT_40010004 = _DAT_40010004 | 0x7000002;\n          break;\n        case 4:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          _DAT_40010004 = _DAT_40010004 | 0x7000004;\n          break;\n        case 6:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          _DAT_40010004 = _DAT_40010004 | 0x7000008;\n          break;\n        case 8:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          _DAT_40010004 = _DAT_40010004 | 0x7000030;\n          break;\n        case 10:\n          _DAT_40010004 = _DAT_40010004 & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          _DAT_40010004 = _DAT_40010004 & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          _DAT_40010004 = _DAT_40010004 | 0x70000c0;\n          break;\n        case 0xd:\n          _DAT_40010004 = _DAT_40010004 & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          _DAT_40010004 = _DAT_40010004 & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          _DAT_40010004 = _DAT_40010004 | 0x7000300;\n          break;\n        case 0x10:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          _DAT_40010004 = _DAT_40010004 | 0x7000c00;\n          break;\n        case 0x14:\n          _DAT_40010004 = _DAT_40010004 & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          _DAT_40010004 = _DAT_40010004 & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          _DAT_40010004 = _DAT_40010004 | 0x7001000;\n          break;\n        case 0x17:\n          _DAT_40010004 = _DAT_40010004 & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          _DAT_40010004 = _DAT_40010004 | 0x7008000;\n          break;\n        case 0x1c:\n          _DAT_40010004 = _DAT_40010004 & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          _DAT_40010004 = _DAT_40010004 & 0xf8ffffff;\n          break;\n        case 0x22:\n          _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n        }\n        gpioPortClock2 = 3;\n        HAL_GPIO_Init(gpioPortClock1,&pin1);\n        gpioPortClock1 = set_GPIO_Port_Clock((uint)((int)*(char *)(uartPinArray + 0x16) << 0x18) >> 0x1c);\n        pinFunction1 = pinmap_function((int)*(char *)(uartPinArray + 0x16),&DAT_0800a864);\n        pin1 = 1 << (*(byte *)(uartPinArray + 0x16) & 0xf) & 0xffff;\n        pinFunctionValue1 = (pinFunction1 >> 3 & 1) << 4 | pinFunction1 & 7;\n        pinFunctionMode1 = (pinFunction1 << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(gpioPortClock1,&pin1);\n        (&DAT_200006c0)[*(byte *)(uartPinArray + 0x11)] = uartPinArray + 1;\n        uartPinArray[1] = *uartPinArray;\n        uartPinArray[2] = uartPinArray[0x12];\n        uartPinArray[3] = uartPinArray[0x13];\n        uartPinArray[4] = uartPinArray[0x14];\n        uartPinArray[5] = uartPinArray[0x15];\n        uartPinArray[6] = 0xc;\n        uartPinArray[7] = 0;\n        uartPinArray[8] = 0;\n        HAL_UART_Init(uartPinArray + 1);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008078": "configure_uart_pins_08008078",
                "param_1": "uartPinArray",
                "iVar1": "peripheral1",
                "iVar2": "peripheral2",
                "uVar3": "gpioPortClock1",
                "uVar4": "pinFunction1",
                "local_20": "pin1",
                "local_1c": "pinFunctionValue1",
                "local_18": "pinFunctionMode1",
                "local_14": "gpioPortClock2"
            },
            "calling": [
                "uart_debug_init",
                "begin"
            ],
            "called": [
                "pinmap_function",
                "set_GPIO_Port_Clock",
                "HAL_UART_Init",
                "pinmap_merge_peripheral",
                "iprintf",
                "HAL_GPIO_Init",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080084b0": {
            "entrypoint": "0x080084b0",
            "current_name": "initialize_uart_080084b0",
            "code": "\nvoid initialize_uart_080084b0(void)\n\n{\n  int pinmap_result;\n  undefined4 pinmap_result2;\n  \n  pinmap_result = pinmap_peripheral(2,&DAT_0800a864);\n  if (pinmap_result != 0) {\n    pinmap_result2 = pinmap_peripheral(2,&DAT_0800a864);\n    DAT_20000075 = pinmap_pin(pinmap_result2,&DAT_0800a81c);\n    DAT_20000074 = 2;\n    DAT_20000064 = 0x2580;\n    DAT_20000070 = 0;\n    DAT_20000068 = 0;\n    DAT_2000006c = 0;\n    uart_init(&DAT_2000001c);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080084b0": "initialize_uart_080084b0",
                "iVar1": "pinmap_result",
                "uVar2": "pinmap_result2"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "uart_init",
                "pinmap_pin",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008500": {
            "entrypoint": "0x08008500",
            "current_name": "transmit_data_08008500",
            "code": "\nuint transmitData_08008500(undefined4 data,uint length)\n\n{\n  int startTime;\n  int peripheral;\n  uint index;\n  \n  startTime = HAL_GetTick();\n  peripheral = pinmap_peripheral(2,&DAT_0800a864);\n  if (peripheral == 0) {\n    return 0;\n  }\n  for (index = 0;\n      (index < 5 &&\n      (((&DAT_200006c0)[index] == 0 ||\n       (peripheral = pinmap_peripheral(2,&DAT_0800a864), *(int *)(&DAT_200006c0)[index] != peripheral))));\n      index = index + 1 & 0xff) {\n  }\n  if (4 < index) {\n    if ((4 < DAT_20000060) && (uart_debug_init(), 4 < DAT_20000060)) {\n      return 0;\n    }\n    index = (uint)DAT_20000060;\n  }\n  do {\n    peripheral = HAL_UART_Transmit((&DAT_200006c0)[index],data,length & 0xffff,1000);\n    if (peripheral == 0) {\n      return length;\n    }\n    peripheral = HAL_GetTick();\n  } while ((uint)(peripheral - startTime) < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008500": "transmit_data_08008500",
                "param_1": "data",
                "param_2": "length",
                "iVar1": "startTime",
                "iVar2": "peripheral",
                "uVar3": "index"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "uart_debug_init",
                "HAL_UART_Transmit",
                "HAL_GetTick",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080085b8": {
            "entrypoint": "0x080085b8",
            "current_name": "check_uart_state_080085b8",
            "code": "\nbool check_UART_state_080085b8(int index)\n\n{\n  uint UART_state;\n  \n  UART_state = HAL_UART_GetState((&DAT_200006c0)[*(byte *)(index + 0x44)]);\n  return (UART_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_080085b8": "check_uart_state_080085b8",
                "param_1": "index",
                "uVar1": "UART_state"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080085dc": {
            "entrypoint": "0x080085dc",
            "current_name": "is_uart_state_valid_080085dc",
            "code": "\nbool isUARTStateValid_080085dc(int inputValue)\n\n{\n  uint uart_state;\n  \n  uart_state = HAL_UART_GetState((&DAT_200006c0)[*(byte *)(inputValue + 0x44)]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_080085dc": "is_uart_state_valid_080085dc",
                "param_1": "inputValue",
                "uVar1": "uart_state"
            },
            "calling": [],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008600": {
            "entrypoint": "0x08008600",
            "current_name": "extract_serial_byte_08008600",
            "code": "\nundefined4 extract_serial_byte_08008600(int serial_handle,undefined *output_byte,undefined4 param3,undefined4 interrupt_context)\n\n{\n  int is_rx_active;\n  \n  if (serial_handle == 0) {\n    return 0xffffffff;\n  }\n  is_rx_active = serial_rx_active();\n  if (is_rx_active == 0) {\n    *output_byte = *(undefined *)(serial_handle + 0x45);\n    HAL_UART_Receive_IT((&DAT_200006c0)[*(byte *)(serial_handle + 0x44)],serial_handle + 0x45,1,&DAT_200006c0,\n                        interrupt_context);\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08008600": "extract_serial_byte_08008600",
                "param_1": "serial_handle",
                "param_2": "output_byte",
                "param_3": "param3",
                "param_4": "interrupt_context",
                "iVar1": "is_rx_active"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800863c": {
            "entrypoint": "0x0800863c",
            "current_name": "configure_serial_communication_0800863c",
            "code": "\nvoid configureSerialCommunication_0800863c(int port,undefined4 baudRate,undefined4 param3,undefined4 param4)\n\n{\n  int isSerialRxActive;\n  uint portIndex;\n  \n  if (port != 0) {\n    isSerialRxActive = serial_rx_active();\n    if (isSerialRxActive == 0) {\n      portIndex = (uint)*(byte *)(port + 0x44);\n      *(undefined4 *)(&DAT_20000670 + portIndex * 4) = baudRate;\n      *(int *)(&DAT_20000684 + portIndex * 4) = port;\n      HAL_NVIC_SetPriority((int)*(char *)(port + 0x5a),0,1,portIndex,param4);\n      HAL_NVIC_EnableIRQ((int)*(char *)(port + 0x5a));\n      HAL_UART_Receive_IT((&DAT_200006c0)[*(byte *)(port + 0x44)],port + 0x45,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800863c": "configure_serial_communication_0800863c",
                "param_1": "port",
                "param_2": "baudRate",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "isSerialRxActive",
                "uVar2": "portIndex"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_UART_Receive_IT",
                "HAL_NVIC_SetPriority",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008694": {
            "entrypoint": "0x08008694",
            "current_name": "configure_peripheral_08008694",
            "code": "\nvoid configurePeripheral_08008694(int deviceAddress,undefined4 priorityLevel)\n\n{\n  byte configByte;\n  \n  if (deviceAddress != 0) {\n    configByte = *(byte *)(deviceAddress + 0x44);\n    *(undefined4 *)(&DAT_20000698 + (uint)configByte * 4) = priorityLevel;\n    *(int *)(&DAT_200006ac + (uint)configByte * 4) = deviceAddress;\n    HAL_NVIC_SetPriority((int)*(char *)(deviceAddress + 0x5a),0,2);\n    HAL_NVIC_EnableIRQ((int)*(char *)(deviceAddress + 0x5a));\n    HAL_UART_Transmit_IT\n              ((&DAT_200006c0)[*(byte *)(deviceAddress + 0x44)],\n               *(int *)(deviceAddress + 100) + (uint)*(ushort *)(deviceAddress + 0x6a),1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008694": "configure_peripheral_08008694",
                "param_1": "deviceAddress",
                "param_2": "priorityLevel",
                "bVar1": "configByte"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080086e8": {
            "entrypoint": "0x080086e8",
            "current_name": "find_element_index_080086e8",
            "code": "\nuint find_element_index_080086e8(int element)\n\n{\n  uint index;\n  \n  if (element == 0) {\n    index = 5;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (4 < index) {\n        return index;\n      }\n      if (element == (&DAT_200006c0)[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return index;\n}\n\n",
            "renaming": {
                "FUN_080086e8": "find_element_index_080086e8",
                "param_1": "element",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800870c": {
            "entrypoint": "0x0800870c",
            "current_name": "execute_uart_function_0800870c",
            "code": "\nvoid executeUARTFunction_0800870c(void)\n\n{\n  uint uartIndex;\n  \n  uartIndex = uart_index();\n  if (uartIndex < 5) {\n    (**(code **)(&DAT_20000670 + uartIndex * 4))(*(undefined4 *)(&DAT_20000684 + uartIndex * 4));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800870c": "execute_uart_function_0800870c",
                "uVar1": "uartIndex"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008730": {
            "entrypoint": "0x08008730",
            "current_name": "transmit_data_08008730",
            "code": "\nvoid transmitData_08008730(void)\n\n{\n  uint uartIndex;\n  int status;\n  int data;\n  \n  uartIndex = uart_index();\n  data = *(int *)(&DAT_200006ac + uartIndex * 4);\n  if ((uartIndex < 5) && (status = (**(code **)(&DAT_20000698 + uartIndex * 4))(data), status != -1)) {\n    transmitViaUART\n              ((&DAT_200006c0)[*(byte *)(data + 0x44)],\n               *(int *)(data + 100) + (uint)*(ushort *)(data + 0x6a),1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008730": "transmit_data_08008730",
                "uVar1": "uartIndex",
                "iVar2": "status",
                "iVar3": "data",
                "HAL_UART_Transmit_IT": "transmitViaUART"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800877c": {
            "entrypoint": "0x0800877c",
            "current_name": "FUNC_0800877c",
            "code": "\nvoid FUNC_0800877c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800877c": "FUNC_0800877c"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008804": {
            "entrypoint": "0x08008804",
            "current_name": "allocate_memory_08008804",
            "code": "\nundefined * allocateMemory_08008804(int size)\n\n{\n  undefined *allocatedMemory;\n  \n  if (DAT_200006d4 == (undefined *)0x0) {\n    DAT_200006d4 = &DAT_20000a3c;\n  }\n  allocatedMemory = DAT_200006d4;\n  if (DAT_200006d4 + size <= maxMemory) {\n    DAT_200006d4 = DAT_200006d4 + size;\n    return allocatedMemory;\n  }\n  DAT_20000a38 = 0xc;\n  return (undefined *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08008804": "allocate_memory_08008804",
                "param_1": "size",
                "puVar1": "allocatedMemory",
                "&stack0x00000000": "maxMemory"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008840": {
            "entrypoint": "0x08008840",
            "current_name": "get_default_return_value_08008840",
            "code": "\nundefined4 get_default_return_value_08008840(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08008840": "get_default_return_value_08008840"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008846": {
            "entrypoint": "0x08008846",
            "current_name": "set_memory_block_size_08008846",
            "code": "\nundefined4 setMemoryBlockSize_08008846(undefined4 param1,int param2)\n\n{\n  *(undefined4 *)(param2 + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008846": "set_memory_block_size_08008846",
                "param_1": "param1",
                "param_2": "param2"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008850": {
            "entrypoint": "0x08008850",
            "current_name": "initialize_return_value_08008850",
            "code": "\nundefined4 initializeReturnValue_08008850(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08008850": "initialize_return_value_08008850"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008854": {
            "entrypoint": "0x08008854",
            "current_name": "get_zero_08008854",
            "code": "\nundefined4 getZero_08008854(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008854": "get_zero_08008854"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008858": {
            "entrypoint": "0x08008858",
            "current_name": "initialize_08008858",
            "code": "\nundefined4 initialize_08008858(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008858": "initialize_08008858"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800885c": {
            "entrypoint": "0x0800885c",
            "current_name": "write_debug_message_0800885c",
            "code": "\nvoid write_debug_message_0800885c(undefined4 unused_param,undefined4 data_1,undefined4 data_2,undefined4 data_3)\n\n{\n  uart_debug_write(data_1,data_2,data_2,data_3,data_3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800885c": "write_debug_message_0800885c",
                "param_1": "unused_param",
                "param_2": "data_1",
                "param_3": "data_2",
                "param_4": "data_3"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008868": {
            "entrypoint": "0x08008868",
            "current_name": "infinite_loop_08008868",
            "code": "\nvoid infiniteLoop_08008868(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08008868": "infinite_loop_08008868"
            },
            "calling": [
                "abort",
                "_exit"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800886c": {
            "entrypoint": "0x0800886c",
            "current_name": "initialize_data_0800886c",
            "code": "\nundefined4 initializeData_0800886c(void)\n\n{\n  DAT_20000a38 = 0x16;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800886c": "initialize_data_0800886c"
            },
            "calling": [
                "raise"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800887c": {
            "entrypoint": "0x0800887c",
            "current_name": "initialize_program_0800887c",
            "code": "\nundefined4 initialize_program_0800887c(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800887c": "initialize_program_0800887c"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008880": {
            "entrypoint": "0x08008880",
            "current_name": "convert_value_08008880",
            "code": "\nuint convert_value_08008880(uint value)\n\n{\n  bool less_than_3c;\n  char result;\n  uint converted_value;\n  \n  if (value < 0xe) {\n    if (value + 0x2e < 0x3c) {\n      less_than_3c = true;\n    }\n    else {\n      less_than_3c = false;\n    }\n  }\n  else {\n    less_than_3c = value < 0x3c;\n  }\n  if (less_than_3c) {\n    if (value < 0xe) {\n      value = value + 0x2e;\n    }\n    result = (&DAT_0800a908)[value];\n  }\n  else {\n    result = -1;\n  }\n  if (result == -1) {\n    converted_value = 0;\n  }\n  else {\n    converted_value = adc_read_value();\n    if (DAT_20000088 != 0xc) {\n      if (DAT_20000088 < 0xc) {\n        return converted_value >> (0xc - DAT_20000088 & 0xff);\n      }\n      return converted_value << (DAT_20000088 - 0xc & 0xff);\n    }\n  }\n  return converted_value;\n}\n\n",
            "renaming": {
                "FUN_08008880": "convert_value_08008880",
                "param_1": "value",
                "bVar1": "less_than_3c",
                "cVar2": "result",
                "uVar3": "converted_value"
            },
            "calling": [
                "loop",
                "reportAnalogCallback"
            ],
            "called": [
                "adc_read_value"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088e0": {
            "entrypoint": "0x080088e0",
            "current_name": "configure_gpio_080088e0",
            "code": "\nvoid configureGPIO_080088e0(uint pinNumber,uint outputValue)\n\n{\n  int pinInPinMapResult;\n  int pinIndex;\n  \n  if (pinNumber < 0x3c) {\n    pinIndex = (int)(char)(&DAT_0800a908)[pinNumber];\n  }\n  else {\n    pinIndex = -1;\n  }\n  if (pinIndex != -1) {\n    pinInPinMapResult = checkPinInPinMap(pinIndex,&DAT_0800a6cc);\n    if (pinInPinMapResult == 0) {\n      setPinMode(pinNumber,1);\n      if (DAT_2000008c != 8) {\n        if (DAT_2000008c < 9) {\n          outputValue = outputValue << (8 - DAT_2000008c & 0xff);\n        }\n        else {\n          outputValue = outputValue >> (DAT_2000008c - 8 & 0xff);\n        }\n      }\n      if (outputValue < 0x80) {\n        writeGPIO(pinNumber,0);\n      }\n      else {\n        writeGPIO(pinNumber,1);\n      }\n    }\n    else {\n      pinInPinMapResult = checkPinConfigured(pinIndex,&DAT_200006d8);\n      if (pinInPinMapResult == 0) {\n        setPinConfigured(pinIndex,&DAT_200006d8);\n      }\n      if (DAT_2000008c != 8) {\n        if (DAT_2000008c < 9) {\n          outputValue = outputValue << (8 - DAT_2000008c & 0xff);\n        }\n        else {\n          outputValue = outputValue >> (DAT_2000008c - 8 & 0xff);\n        }\n      }\n      startPWM(pinIndex,0x3e418,0xff,outputValue,pinInPinMapResult == 0);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088e0": "configure_gpio_080088e0",
                "param_1": "pinNumber",
                "param_2": "outputValue",
                "iVar1": "pinInPinMapResult",
                "iVar2": "pinIndex",
                "pin_in_pinmap": "checkPinInPinMap",
                "pinMode": "setPinMode",
                "digitalWrite": "writeGPIO",
                "is_pin_configured": "checkPinConfigured",
                "set_pin_configured": "setPinConfigured",
                "pwm_start": "startPWM"
            },
            "calling": [
                "FUN_0800021a",
                "setPinModeCallback"
            ],
            "called": [
                "pin_in_pinmap",
                "set_pin_configured",
                "pwm_start",
                "is_pin_configured",
                "digitalWrite",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008990": {
            "entrypoint": "0x08008990",
            "current_name": "configure_and_initialize_pin_08008990",
            "code": "\nvoid configure_and_initialize_pin_08008990(uint pin_id,undefined4 pin_mode,undefined4 param_3,undefined1 *pin_config)\n\n{\n  int is_configured;\n  undefined1 *pin_config_ptr;\n  int pin_config_index;\n  \n  if (pin_id < 0x3c) {\n    pin_config_index = (int)(char)(&DAT_0800a908)[pin_id];\n    pin_config_ptr = &DAT_0800a908;\n  }\n  else {\n    pin_config_index = -1;\n    pin_config_ptr = pin_config;\n  }\n  if (pin_config_index != -1) {\n    is_configured = is_pin_configured(pin_config_index,&DAT_200006d8,param_3,pin_config_ptr,pin_config);\n    if (is_configured != 0) {\n      is_configured = pin_in_pinmap(pin_config_index,&DAT_0800a6cc);\n      if (is_configured != 0) {\n        pwm_stop(pin_config_index);\n      }\n      reset_pin_configured(pin_config_index,&DAT_200006d8);\n    }\n    switch(pin_mode) {\n    case 0:\n      digital_io_init(pin_config_index,0);\n      break;\n    case 1:\n      digital_io_init(pin_config_index,1,0);\n      break;\n    case 2:\n      digital_io_init(pin_config_index,0,1);\n      break;\n    case 3:\n      digital_io_init(pin_config_index,0,2);\n    }\n    set_pin_configured(pin_config_index,&DAT_200006ec);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008990": "configure_and_initialize_pin_08008990",
                "param_1": "pin_id",
                "param_2": "pin_mode",
                "param_4": "pin_config",
                "iVar1": "is_configured",
                "iVar3": "pin_config_index",
                "puVar2": "pin_config_ptr"
            },
            "calling": [
                "FUN_080025ac",
                "blinkVersion",
                "analogWrite",
                "setPinModeCallback"
            ],
            "called": [
                "pin_in_pinmap",
                "set_pin_configured",
                "is_pin_configured",
                "pwm_stop",
                "reset_pin_configured",
                "digital_io_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a24": {
            "entrypoint": "0x08008a24",
            "current_name": "configure_pin_and_write_08008a24",
            "code": "\nvoid configurePinAndWrite_08008a24(uint pinIndex,undefined4 value,undefined4 configParam1,undefined1 *configParam2)\n\n{\n  int isPinConfigured;\n  undefined4 gpioPort;\n  undefined1 *pinConfigArray;\n  uint pinConfig;\n  \n  if (pinIndex < 0x3c) {\n    pinConfig = (uint)(char)(&DAT_0800a908)[pinIndex];\n    pinConfigArray = &DAT_0800a908;\n  }\n  else {\n    pinConfig = 0xffffffff;\n    pinConfigArray = configParam2;\n  }\n  if ((pinConfig != 0xffffffff) &&\n     (isPinConfigured = is_pin_configured(pinConfig,&DAT_200006ec,configParam1,pinConfigArray,configParam2), isPinConfigured != 0)) {\n    gpioPort = get_GPIO_Port((pinConfig << 0x18) >> 0x1c);\n    digital_io_write(gpioPort,1 << (pinConfig & 0xf) & 0xffff,value);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008a24": "configure_pin_and_write_08008a24",
                "param_1": "pinIndex",
                "param_2": "value",
                "param_3": "configParam1",
                "param_4": "configParam2",
                "iVar1": "isPinConfigured",
                "uVar2": "gpioPort",
                "puVar3": "pinConfigArray",
                "uVar4": "pinConfig"
            },
            "calling": [
                "strobeBlinkPin",
                "analogWrite",
                "setPinModeCallback"
            ],
            "called": [
                "is_pin_configured",
                "get_GPIO_Port",
                "digital_io_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a6c": {
            "entrypoint": "0x08008a6c",
            "current_name": "read_pin_value_08008a6c",
            "code": "\nchar read_pin_value_08008a6c(uint pin_index)\n\n{\n  char pin_value;\n  int is_configured;\n  undefined4 gpio_port;\n  uint pin_config;\n  \n  if (pin_index < 0x3c) {\n    pin_config = (uint)(char)(&DAT_0800a908)[pin_index];\n  }\n  else {\n    pin_config = 0xffffffff;\n  }\n  if (pin_config == 0xffffffff) {\n    pin_value = '\\0';\n  }\n  else {\n    is_configured = check_pin_configuration(pin_config,&DAT_200006ec);\n    if (is_configured == 0) {\n      pin_value = '\\0';\n    }\n    else {\n      gpio_port = get_gpio_port((pin_config << 0x18) >> 0x1c);\n      pin_value = read_digital_io(gpio_port,1 << (pin_config & 0xf) & 0xffff);\n    }\n  }\n  if (pin_value != '\\0') {\n    pin_value = '\\x01';\n  }\n  return pin_value;\n}\n\n",
            "renaming": {
                "FUN_08008a6c": "read_pin_value_08008a6c",
                "param_1": "pin_index",
                "cVar1": "pin_value",
                "iVar2": "is_configured",
                "uVar3": "gpio_port",
                "uVar4": "pin_config",
                "is_pin_configured": "check_pin_configuration",
                "get_GPIO_Port": "get_gpio_port",
                "digital_io_read": "read_digital_io"
            },
            "calling": [
                "checkDigitalInputs"
            ],
            "called": [
                "digital_io_read",
                "is_pin_configured",
                "get_GPIO_Port"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008abc": {
            "entrypoint": "0x08008abc",
            "current_name": "get_current_millisecond_08008abc",
            "code": "\nvoid get_current_millisecond_08008abc(void)\n\n{\n  get_current_millisecond_08008abc();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008abc": "get_current_millisecond_08008abc",
                "GetCurrentMilli": "get_current_millisecond"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ac4": {
            "entrypoint": "0x08008ac4",
            "current_name": "FUNC_08008ac4",
            "code": "\nvoid FUNC_08008ac4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008ac4": "FUNC_08008ac4"
            },
            "calling": [
                "blinkVersion",
                "strobeBlinkPin"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008afa": {
            "entrypoint": "0x08008afa",
            "current_name": "calculate_offset_08008afa",
            "code": "\nushort calculate_offset_08008afa(int base_address)\n\n{\n  return (*(short *)(base_address + 0x134) + 0x40) - *(short *)(base_address + 0x136) & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_08008afa": "calculate_offset_08008afa",
                "param_1": "base_address"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b66": {
            "entrypoint": "0x08008b66",
            "current_name": "process_uart_input_08008b66",
            "code": "\nvoid process_uart_input_08008b66(int uart_handle)\n\n{\n  int input_result;\n  ushort new_index;\n  undefined received_byte;\n  \n  input_result = uart_getc(uart_handle,&received_byte);\n  if ((input_result == 0) &&\n     (new_index = *(short *)(uart_handle + 0x60) + 1U & 0x3f, new_index != *(ushort *)(uart_handle + 0x62))) {\n    *(undefined *)(*(int *)(uart_handle + 0x5c) + (uint)*(ushort *)(uart_handle + 0x60)) = received_byte;\n    *(ushort *)(uart_handle + 0x60) = new_index;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008b66": "process_uart_input_08008b66",
                "param_1": "uart_handle",
                "iVar1": "input_result",
                "uVar2": "new_index",
                "local_9": "received_byte"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008bf4": {
            "entrypoint": "0x08008bf4",
            "current_name": "FUNC_08008bf4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08008bfa) */\n/* WARNING: Removing unreachable block (ram,0x08008c0c) */\n/* WARNING: Removing unreachable block (ram,0x08008c02) */\n/* WARNING: Removing unreachable block (ram,0x08008c14) */\n\nvoid FUNC_08008bf4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008bf4": "FUNC_08008bf4"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008c20": {
            "entrypoint": "0x08008c20",
            "current_name": "initialize_parameters_08008c20",
            "code": "\nvoid initializeParameters_08008c20(int baseAddress)\n\n{\n  *(int *)(baseAddress + 0x130) = baseAddress + 0x11;\n  *(undefined2 *)(baseAddress + 0x134) = 0;\n  *(undefined2 *)(baseAddress + 0x136) = 0;\n  *(int *)(baseAddress + 0x138) = baseAddress + 0x51;\n  *(undefined2 *)(baseAddress + 0x13c) = 0;\n  *(undefined2 *)(baseAddress + 0x13e) = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008c20": "initialize_parameters_08008c20",
                "param_1": "baseAddress"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008c44": {
            "entrypoint": "0x08008c44",
            "current_name": "configure_uart_08008c44",
            "code": "\nvoid configureUART_08008c44(int uartConfig,undefined4 baudRate,byte serialConfig)\n\n{\n  uint databits;\n  byte configBits;\n  int uartMode;\n  code *jumpTable;\n  \n  *(undefined4 *)(uartConfig + 0x11c) = baudRate;\n  *(byte *)(uartConfig + 0x140) = serialConfig;\n  configBits = serialConfig & 7;\n  if (configBits == 4) {\n    uartMode = 7;\n  }\n  else if (configBits == 6) {\n    uartMode = 8;\n  }\n  else if (configBits == 2) {\n    uartMode = 6;\n  }\n  else {\n    uartMode = 0;\n  }\n  if ((serialConfig & 0x30) == 0x30) {\n    *(undefined4 *)(uartConfig + 0x128) = 0x600;\n    uartMode = uartMode + 1;\n  }\n  else if ((serialConfig & 0x20) == 0) {\n    *(undefined4 *)(uartConfig + 0x128) = 0;\n  }\n  else {\n    *(undefined4 *)(uartConfig + 0x128) = 0x400;\n    uartMode = uartMode + 1;\n  }\n  if ((serialConfig & 8) == 0) {\n    *(undefined4 *)(uartConfig + 0x124) = 0;\n  }\n  else {\n    *(undefined4 *)(uartConfig + 0x124) = 0x2000;\n  }\n  if (uartMode == 8) {\n    *(undefined4 *)(uartConfig + 0x120) = 0;\n  }\n  else if (uartMode == 9) {\n    *(undefined4 *)(uartConfig + 0x120) = 0x1000;\n  }\n  else {\n    uartMode = 0;\n  }\n  if (uartMode != 0) {\n    uart_init(uartConfig + 0xd4);\n    uart_attach_rx_callback(uartConfig + 0xd4,0x8008b67);\n    return;\n  }\n  jumpTable = (code *)0x8008cee;\n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n  if (databits < 0x3c) {\n    uRam0000012d = (&DAT_0800a908)[databits];\n  }\n  else {\n    uRam0000012d = 0xff;\n  }\n                    /* WARNING: Could not recover jumptable at 0x08008d0c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(0,databits,&stack0x00000148);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008c44": "configure_uart_08008c44",
                "param_1": "uartConfig",
                "param_2": "baudRate",
                "param_3": "serialConfig",
                "extraout_r1": "databits",
                "bVar1": "configBits",
                "iVar2": "uartMode",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [
                "FUN_08003048"
            ],
            "called": [
                "uart_init",
                "uart_attach_rx_callback",
                "__assert_func"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008d00": {
            "entrypoint": "0x08008d00",
            "current_name": "set_threshold_value_08008d00",
            "code": "\nvoid setThresholdValue_08008d00(int destination,uint inputValue)\n\n{\n  undefined threshold;\n  code *jumpTable;\n  \n  if (inputValue < 0x3c) {\n    threshold = (&DAT_0800a908)[inputValue];\n  }\n  else {\n    threshold = 0xff;\n  }\n  *(undefined *)(destination + 0x12d) = threshold;\n                    /* WARNING: Could not recover jumptable at 0x08008d0c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008d00": "set_threshold_value_08008d00",
                "param_1": "destination",
                "param_2": "inputValue",
                "uVar1": "threshold",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008d18": {
            "entrypoint": "0x08008d18",
            "current_name": "set_byte_value_08008d18",
            "code": "\nvoid setByteValue_08008d18(int baseAddress,uint offset)\n\n{\n  undefined byteValue;\n  \n  if (offset < 0x3c) {\n    byteValue = (&DAT_0800a908)[offset];\n  }\n  else {\n    byteValue = 0xff;\n  }\n  *(undefined *)(baseAddress + 300) = byteValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008d18": "set_byte_value_08008d18",
                "param_1": "baseAddress",
                "param_2": "offset",
                "uVar1": "byteValue"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008d30": {
            "entrypoint": "0x08008d30",
            "current_name": "initialize_device_08008d30",
            "code": "\nundefined4 *\ninitializeDevice_08008d30(undefined4 *device,undefined4 pin,undefined4 rxConfig,undefined4 txConfig)\n\n{\n  undefined pinResult;\n  \n  device[1] = 0;\n  device[2] = 1000;\n  *device = &PTR_LAB_08008ba4_1_0800aab8;\n  if (device == (undefined4 *)&DAT_20000700) {\n    setRx(&DAT_20000700,0,rxConfig,&DAT_20000700,txConfig);\n    setTx(&DAT_20000700,1);\n  }\n  else {\n    pinResult = pinmap_pin(pin,&DAT_0800a81c);\n    *(undefined *)((int)device + 0x12d) = pinResult;\n    pinResult = pinmap_pin(pin,&DAT_0800a864);\n    *(undefined *)(device + 0x4b) = pinResult;\n  }\n  init(device);\n  return device;\n}\n\n",
            "renaming": {
                "FUN_08008d30": "initialize_device_08008d30",
                "param_1": "device",
                "param_2": "pin",
                "param_3": "rxConfig",
                "param_4": "txConfig",
                "uVar1": "pinResult"
            },
            "calling": [
                "FUN_08008d8c"
            ],
            "called": [
                "setRx",
                "init",
                "setTx",
                "pinmap_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008d8c": {
            "entrypoint": "0x08008d8c",
            "current_name": "initialize_serial_communication_08008d8c",
            "code": "\nvoid initializeSerialCommunication_08008d8c(int status,int value,undefined4 config1,undefined4 config2)\n\n{\n  if (status != 1) {\n    return;\n  }\n  if (value == 0xffff) {\n    HardwareSerial(&DAT_20000700,0x40004400,config1,0xffff,config2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008d8c": "initialize_serial_communication_08008d8c",
                "param_1": "status",
                "param_2": "value",
                "param_3": "config1",
                "param_4": "config2"
            },
            "calling": [],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008df8": {
            "entrypoint": "0x08008df8",
            "current_name": "initialize_data_08008df8",
            "code": "\nvoid initializeData_08008df8(undefined4 *output,undefined value1,undefined value2,undefined value3,\n                 undefined value4)\n\n{\n  *output = &DAT_0800ab0c;\n  *(undefined *)(output + 1) = value1;\n  *(undefined *)((int)output + 5) = value2;\n  *(undefined *)((int)output + 6) = value3;\n  *(undefined *)((int)output + 7) = value4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008df8": "initialize_data_08008df8",
                "param_1": "output",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3",
                "param_5": "value4"
            },
            "calling": [
                "FUN_08008e14"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e14": {
            "entrypoint": "0x08008e14",
            "current_name": "initialize_ip_address_08008e14",
            "code": "\nvoid initializeIPAddress_08008e14(int condition1,int condition2)\n\n{\n  if ((condition1 == 1) && (condition2 == 0xffff)) {\n    IPAddress(&DAT_20000844,0,0,0,0);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008e14": "initialize_ip_address_08008e14",
                "param_1": "condition1",
                "param_2": "condition2"
            },
            "calling": [],
            "called": [
                "IPAddress"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ef4": {
            "entrypoint": "0x08008ef4",
            "current_name": "calculate_interpolated_value_08008ef4",
            "code": "\nint calculate_interpolated_value_08008ef4(int start_value,int start_input,int end_input,int start_output,int end_output)\n\n{\n  return (uint)((end_output - start_output) * (start_value - start_input)) / (uint)(end_input - start_input) + start_output;\n}\n\n",
            "renaming": {
                "FUN_08008ef4": "calculate_interpolated_value_08008ef4",
                "param_1": "start_value",
                "param_2": "start_input",
                "param_3": "end_input",
                "param_4": "start_output",
                "param_5": "end_output"
            },
            "calling": [
                "FUN_080026b0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f0c": {
            "entrypoint": "0x08008f0c",
            "current_name": "FUNC_08008f0c",
            "code": "\nvoid FUNC_08008f0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008f0c": "FUNC_08008f0c"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008f0e": {
            "entrypoint": "0x08008f0e",
            "current_name": "initialize_hardware_08008f0e",
            "code": "\nvoid initialize_hardware_08008f0e(void)\n\n{\n  set_priority_grouping(3);\n  configure_hardware();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008f0e": "initialize_hardware_08008f0e",
                "HAL_NVIC_SetPriorityGrouping": "set_priority_grouping",
                "initialize_hardware_configuration_080036a2": "configure_hardware"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "FUN_080036a2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f1c": {
            "entrypoint": "0x08008f1c",
            "current_name": "initialize_and_run_08008f1c",
            "code": "\nvoid initializeAndRun_08008f1c(void)\n\n{\n  initializeVariant();\n  performSetup();\n  do {\n    performLoop();\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08008f1c": "initialize_and_run_08008f1c",
                "initVariant": "initializeVariant",
                "setup": "performSetup",
                "loop": "performLoop",
                "serialEventRun": "runSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "initVariant",
                "loop",
                "serialEventRun",
                "setup"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f3c": {
            "entrypoint": "0x08008f3c",
            "current_name": "count_set_bits_08008f3c",
            "code": "\nchar countSetBits_08008f3c(uint number)\n\n{\n  char bitCount;\n  \n  bitCount = '\\0';\n  for (; number != 1; number = number >> 1) {\n    bitCount = bitCount + '\\x01';\n  }\n  return bitCount;\n}\n\n",
            "renaming": {
                "FUN_08008f3c": "count_set_bits_08008f3c",
                "param_1": "number",
                "cVar1": "bitCount"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008f78": {
            "entrypoint": "0x08008f78",
            "current_name": "initialize_parameters_08008f78",
            "code": "\nvoid initializeParameters_08008f78(int flag,int value,undefined4 param_3,undefined4 param_4)\n\n{\n  if (flag != 1) {\n    return;\n  }\n  if (value == 0xffff) {\n    DAT_2000084c = 6;\n    DAT_20000858 = 0;\n    DAT_20000860 = 7;\n    DAT_2000086c = 0;\n    DAT_20000874 = 8;\n    DAT_20000880 = 0;\n    DAT_20000888 = 9;\n    DAT_20000894 = 0;\n    DAT_2000089c = 10;\n    DAT_200008a8 = 0;\n    DAT_200008b0 = 0x17;\n    DAT_200008bc = 0;\n    DAT_200008c4 = 0x17;\n    DAT_200008d0 = 0;\n    DAT_200008d8 = 0x17;\n    DAT_200008e4 = 0;\n    DAT_200008ec = 0x17;\n    DAT_200008f8 = 0;\n    DAT_20000900 = 0x17;\n    DAT_2000090c = 0;\n    DAT_20000914 = 0x28;\n    DAT_20000920 = 0;\n    DAT_20000928 = 0x28;\n    DAT_20000934 = 0;\n    DAT_2000093c = 0x28;\n    DAT_20000948 = 0;\n    DAT_20000950 = 0x28;\n    DAT_2000095c = 0;\n    DAT_20000964 = 0x28;\n    DAT_20000970 = 0;\n    DAT_20000978 = 0x28;\n    DAT_20000984 = 0;\n    __aeabi_atexit(0,&LAB_08008f50_1,&DAT_20000000,&DAT_2000084c,param_4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008f78": "initialize_parameters_08008f78",
                "param_1": "flag",
                "param_2": "value"
            },
            "calling": [],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009084": {
            "entrypoint": "0x08009084",
            "current_name": "check_and_perform_action_08009084",
            "code": "\nvoid checkAndPerformAction_08009084(int input)\n\n{\n  int pinId;\n  \n  if (*(int *)(input + 8) != 0) {\n    (**(code **)(input + 0xc))();\n    return;\n  }\n  __throw_bad_function_call();\n  pinId = get_pin_id();\n  if ((&DAT_20000858)[pinId * 5] != 0) {\n    checkAndPerformAction_08009084();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009084": "check_and_perform_action_08009084",
                "param_1": "input",
                "iVar1": "pinId"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009094": {
            "entrypoint": "0x08009094",
            "current_name": "check_pin_and_invoke_operator_08009094",
            "code": "\nvoid checkPinAndInvokeOperator_08009094(void)\n\n{\n  int pinId;\n  \n  pinId = getPinId();\n  if ((&DAT_20000858)[pinId * 5] != 0) {\n    invokeOperator();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009094": "check_pin_and_invoke_operator_08009094",
                "iVar1": "pinId",
                "get_pin_id": "getPinId",
                "operator()": "invokeOperator"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c2": {
            "entrypoint": "0x080090c2",
            "current_name": "register_exit_function_080090c2",
            "code": "\nvoid registerExitFunction_080090c2(undefined4 exitFunction,undefined4 userData)\n\n{\n  __cxa_atexit(userData,exitFunction);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090c2": "register_exit_function_080090c2",
                "param_1": "exitFunction",
                "param_2": "userData"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090cc": {
            "entrypoint": "0x080090cc",
            "current_name": "print_assert_failed_message_080090cc",
            "code": "\nvoid printAssertFailedMessage_080090cc(undefined4 fileName,undefined4 lineNumber,char *functionName,undefined4 errorMessage)\n\n{\n  undefined4 filePointer;\n  char *extraInfo;\n  undefined8 abortResult;\n  undefined4 errorDescription;\n  \n  filePointer = *(undefined4 *)(DAT_20000090 + 0xc);\n  errorDescription = errorMessage;\n  if (functionName == (char *)0x0) goto LAB_080090f0;\n  extraInfo = \", function: \";\n  do {\n    fiprintf(filePointer,\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",errorMessage,fileName,lineNumber,\n             extraInfo,functionName,errorDescription);\n    abortResult = abort();\n    lineNumber = (undefined4)((ulonglong)abortResult >> 0x20);\n    filePointer = (undefined4)abortResult;\nLAB_080090f0:\n    functionName = \"\";\n    extraInfo = functionName;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080090cc": "print_assert_failed_message_080090cc",
                "param_1": "fileName",
                "param_2": "lineNumber",
                "param_3": "functionName",
                "param_4": "errorMessage",
                "uVar1": "filePointer",
                "pcVar2": "extraInfo",
                "uVar3": "abortResult",
                "uVar4": "errorDescription"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "abort",
                "fiprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009108": {
            "entrypoint": "0x08009108",
            "current_name": "extend_unsigned_integer_08009108",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009110) */\n\nlonglong extendUnsignedInteger_08009108(undefined4 flags,uint value)\n\n{\n  return (ulonglong)value << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08009108": "extend_unsigned_integer_08009108",
                "param_1": "flags",
                "param_2": "value"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009124": {
            "entrypoint": "0x08009124",
            "current_name": "print_formatted_data_08009124",
            "code": "\nvoid print_formatted_data_08009124(undefined4 format_string,undefined4 param_2,undefined4 data_1,undefined4 data_2)\n\n{\n  undefined4 formatted_data_1;\n  undefined4 formatted_data_2;\n  \n  formatted_data_1 = data_1;\n  formatted_data_2 = data_2;\n  _vfiprintf_r(DAT_20000090,format_string,param_2,&formatted_data_1,format_string,&formatted_data_1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009124": "print_formatted_data_08009124",
                "param_1": "format_string",
                "param_3": "data_1",
                "param_4": "data_2",
                "uStack_8": "formatted_data_1",
                "uStack_4": "formatted_data_2"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009148": {
            "entrypoint": "0x08009148",
            "current_name": "execute_functions_08009148",
            "code": "\nvoid executeFunctions_08009148(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(code *)(&DAT_0800abe4)[index])();\n  }\n  _init();\n  for (index = 0; index != 0xc; index = index + 1) {\n    (*(code *)(&DAT_0800abe4)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009148": "execute_functions_08009148",
                "iVar1": "index"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "premain"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009190": {
            "entrypoint": "0x08009190",
            "current_name": "allocate_memory_08009190",
            "code": "\nvoid allocateMemory_08009190(undefined4 size)\n\n{\n  _malloc_r(DAT_20000090,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009190": "allocate_memory_08009190",
                "param_1": "size"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a0": {
            "entrypoint": "0x080091a0",
            "current_name": "free_memory_080091a0",
            "code": "\nvoid freeMemory_080091a0(undefined4 ptr)\n\n{\n  _free_r(DAT_20000090,ptr);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080091a0": "free_memory_080091a0",
                "param_1": "ptr"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091b0": {
            "entrypoint": "0x080091b0",
            "current_name": "copy_array_080091b0",
            "code": "\nvoid copyArray_080091b0(int arrayStartIndex,undefined *sourceArray,int arrayLength)\n\n{\n  undefined *destArrayEnd;\n  undefined *destArrayIndex;\n  \n  destArrayIndex = (undefined *)(arrayStartIndex + -1);\n  destArrayEnd = sourceArray + arrayLength;\n  for (; sourceArray != destArrayEnd; sourceArray = sourceArray + 1) {\n    destArrayIndex = destArrayIndex + 1;\n    *destArrayIndex = *sourceArray;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080091b0": "copy_array_080091b0",
                "param_1": "arrayStartIndex",
                "param_2": "sourceArray",
                "param_3": "arrayLength",
                "puVar1": "destArrayEnd",
                "puVar2": "destArrayIndex"
            },
            "calling": [
                "realloc",
                "FUN_080027f0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091c6": {
            "entrypoint": "0x080091c6",
            "current_name": "memset_array_080091c6",
            "code": "\nvoid memset_array_080091c6(undefined *array,undefined value,int length)\n\n{\n  undefined *end_ptr;\n  \n  end_ptr = array + length;\n  for (; array != end_ptr; array = array + 1) {\n    *array = value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080091c6": "memset_array_080091c6",
                "param_1": "array",
                "param_2": "value",
                "param_3": "length",
                "puVar1": "end_ptr"
            },
            "calling": [
                "std.isra.0",
                "__sfp",
                "FUN_08002a58",
                "pwm_start",
                "adc_read_value",
                "FUN_08002968",
                "__sfmoreglue"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091d8": {
            "entrypoint": "0x080091d8",
            "current_name": "allocate_memory_080091d8",
            "code": "\nvoid allocateMemory_080091d8(undefined4 *result,int size,undefined4 param3,undefined4 param4)\n\n{\n  int **ppiVar6;\n  int **ppiVar7;\n  int **ppiVar8;\n  int *ptr2;\n  int **ppiVar9;\n  int **ppiVar10;\n  \n  if (size == 0) {\n    return;\n  }\n  ppiVar10 = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    ppiVar10 = (int **)((int)ppiVar10 + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  ppiVar8 = (int **)&DAT_2000098c;\n  if (DAT_2000098c == (int **)0x0) {\n    ppiVar10[1] = (int *)0x0;\n    ppiVar7 = ppiVar6;\n    DAT_2000098c = ppiVar10;\n  }\n  else {\n    ppiVar8 = DAT_2000098c;\n    if (ppiVar10 < DAT_2000098c) {\n      ppiVar7 = (int **)*ppiVar10;\n      ppiVar8 = (int **)((int)ppiVar10 + (int)ppiVar7);\n      if (DAT_2000098c == ppiVar8) {\n        ptr2 = *DAT_2000098c;\n        DAT_2000098c = (int **)DAT_2000098c[1];\n        ppiVar8 = (int **)((int)ptr2 + (int)ppiVar7);\n        *ppiVar10 = (int *)ppiVar8;\n      }\n      ppiVar10[1] = (int *)DAT_2000098c;\n      DAT_2000098c = ppiVar10;\n    }\n    else {\n      do {\n        ppiVar9 = ppiVar8;\n        ppiVar8 = (int **)ppiVar9[1];\n        if (ppiVar8 == (int **)0x0) break;\n      } while (ppiVar8 <= ppiVar10);\n      ppiVar7 = (int **)*ppiVar9;\n      if ((int **)((int)ppiVar9 + (int)ppiVar7) == ppiVar10) {\n        ppiVar7 = (int **)((int)ppiVar7 + (int)*ppiVar10);\n        *ppiVar9 = (int *)ppiVar7;\n        if (ppiVar8 == (int **)((int)ppiVar9 + (int)ppiVar7)) {\n          ptr2 = *ppiVar8;\n          ppiVar8 = (int **)ppiVar8[1];\n          ppiVar7 = (int **)((int)ppiVar7 + (int)ptr2);\n          *ppiVar9 = (int *)ppiVar7;\n          ppiVar9[1] = (int *)ppiVar8;\n        }\n      }\n      else if (ppiVar10 < (int **)((int)ppiVar9 + (int)ppiVar7)) {\n        *result = 0xc;\n      }\n      else {\n        ppiVar7 = (int **)((int)ppiVar10 + (int)*ppiVar10);\n        if (ppiVar8 == ppiVar7) {\n          ptr2 = *ppiVar8;\n          ppiVar8 = (int **)ppiVar8[1];\n          ppiVar7 = (int **)((int)ptr2 + (int)*ppiVar10);\n          *ppiVar10 = (int *)ppiVar7;\n        }\n        ppiVar10[1] = (int *)ppiVar8;\n        ppiVar9[1] = (int *)ppiVar10;\n      }\n    }\n  }\n  __malloc_unlock(result,ppiVar7,ppiVar8,param4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080091d8": "allocate_memory_080091d8",
                "param_1": "result",
                "param_2": "size",
                "param_3": "param3",
                "param_4": "param4",
                "extraout_r1": "ppiVar6",
                "ppiVar1": "ppiVar7",
                "ppiVar2": "ppiVar8",
                "piVar3": "ptr2",
                "ppiVar4": "ppiVar9",
                "ppiVar5": "ppiVar10"
            },
            "calling": [
                "abort",
                "realloc",
                "free",
                "__swsetup_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009270": {
            "entrypoint": "0x08009270",
            "current_name": "allocate_memory_08009270",
            "code": "\nuint allocate_memory_08009270(undefined4 *size,uint alignment)\n\n{\n  uint *current_block;\n  int remaining_space;\n  uint *previous_block;\n  uint difference;\n  uint *split_block;\n  uint allocated_memory;\n  \n  allocated_memory = (alignment + 3 & 0xfffffffc) + 8;\n  if (allocated_memory < 0xc) {\n    allocated_memory = 0xc;\n  }\n  if (((int)allocated_memory < 0) || (allocated_memory < alignment)) {\n    *size = 0xc;\n  }\n  else {\n    __malloc_lock();\n    current_block = DAT_2000098c;\n    split_block = DAT_2000098c;\n    while (previous_block = current_block, previous_block != (uint *)0x0) {\n      difference = *previous_block - allocated_memory;\n      if (-1 < (int)difference) {\n        if (difference < 0xc) {\n          if (split_block == previous_block) {\n            current_block = (uint *)split_block[1];\n            DAT_2000098c = current_block;\n          }\n          else {\n            current_block = (uint *)previous_block[1];\n          }\n          if (split_block != previous_block) {\n            split_block[1] = (uint)current_block;\n            split_block = previous_block;\n          }\n        }\n        else {\n          *previous_block = difference;\n          *(uint *)((int)previous_block + difference) = allocated_memory;\n          split_block = (uint *)((int)previous_block + difference);\n        }\n        goto LAB_080092d4;\n      }\n      split_block = previous_block;\n      current_block = (uint *)previous_block[1];\n    }\n    if (DAT_20000990 == 0) {\n      DAT_20000990 = _sbrk_r(size);\n    }\n    current_block = (uint *)_sbrk_r(size,allocated_memory);\n    if ((current_block != (uint *)0xffffffff) &&\n       ((split_block = (uint *)((int)current_block + 3U & 0xfffffffc), current_block == split_block ||\n        (remaining_space = _sbrk_r(size,(int)split_block - (int)current_block), remaining_space != -1)))) {\n      *split_block = allocated_memory;\nLAB_080092d4:\n      __malloc_unlock(size);\n      allocated_memory = (int)split_block + 0xbU & 0xfffffff8;\n      remaining_space = allocated_memory - (int)(split_block + 1);\n      if (remaining_space != 0) {\n        *(int *)((int)split_block + remaining_space) = -remaining_space;\n        return allocated_memory;\n      }\n      return allocated_memory;\n    }\n    *size = 0xc;\n    __malloc_unlock(size);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08009270": "allocate_memory_08009270",
                "param_1": "size",
                "param_2": "alignment",
                "puVar1": "current_block",
                "iVar2": "remaining_space",
                "puVar3": "previous_block",
                "uVar4": "difference",
                "puVar5": "split_block",
                "uVar6": "allocated_memory"
            },
            "calling": [
                "realloc",
                "__smakebuf_r",
                "malloc",
                "__sfmoreglue"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800932c": {
            "entrypoint": "0x0800932c",
            "current_name": "process_input_0800932c",
            "code": "\nuint process_input_0800932c(int input_data,byte input_byte,byte **input_buffer)\n\n{\n  int index;\n  byte *buffer_end;\n  byte *short_value;\n  uint return_value;\n  \n  buffer_end = input_buffer[2] + -1;\n  input_buffer[2] = buffer_end;\n  if ((-1 < (int)buffer_end) ||\n     (((int)input_buffer[6] <= (int)buffer_end && (buffer_end = (byte *)(uint)input_byte, buffer_end != (byte *)0xa))))\n  {\n    buffer_end = *input_buffer;\n    *input_buffer = buffer_end + 1;\n    *buffer_end = input_byte;\n    return (uint)input_byte;\n  }\n  if ((input_data != 0) && (*(int *)(input_data + 0x18) == 0)) {\n    __sinit();\n  }\n  if (input_buffer == (byte **)&DAT_0800aba4) {\n    input_buffer = *(byte ***)(input_data + 4);\n  }\n  else if (input_buffer == (byte **)&DAT_0800abc4) {\n    input_buffer = *(byte ***)(input_data + 8);\n  }\n  else if (input_buffer == (byte **)&DAT_0800ab84) {\n    input_buffer = *(byte ***)(input_data + 0xc);\n  }\n  input_buffer[2] = input_buffer[6];\n  short_value = (byte *)(uint)*(ushort *)(input_buffer + 3);\n  index = (int)short_value << 0x1c;\n  if (((index < 0) && (short_value = input_buffer[4], short_value != (byte *)0x0)) ||\n     (index = __swsetup_r(input_data,input_buffer,index,short_value,buffer_end), index == 0)) {\n    return_value = (uint)input_byte;\n    index = (int)*input_buffer - (int)input_buffer[4];\n    if ((index < (int)input_buffer[5]) || (index = _fflush_r(input_data,input_buffer), index == 0)) {\n      input_buffer[2] = input_buffer[2] + -1;\n      buffer_end = *input_buffer;\n      *input_buffer = buffer_end + 1;\n      *buffer_end = input_byte;\n      if ((byte *)(index + 1) != input_buffer[5]) {\n        if (-1 < (int)((uint)*(ushort *)(input_buffer + 3) << 0x1f)) {\n          return return_value;\n        }\n        if (return_value != 10) {\n          return return_value;\n        }\n      }\n      index = _fflush_r(input_data,input_buffer);\n      if (index == 0) {\n        return return_value;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800932c": "process_input_0800932c",
                "param_1": "input_data",
                "param_2": "input_byte",
                "param_3": "input_buffer",
                "iVar1": "index",
                "pbVar2": "buffer_end",
                "pbVar3": "short_value",
                "uVar4": "return_value"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__sinit",
                "_fflush_r",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009358": {
            "entrypoint": "0x08009358",
            "current_name": "write_to_stream_08009358",
            "code": "\nint writeToStream_08009358(undefined4 stream,undefined4 buffer_size,undefined *buffer,int length)\n\n{\n  int result;\n  undefined *end_of_buffer;\n  int remaining_length;\n  \n  end_of_buffer = buffer + length;\n  remaining_length = length;\n  do {\n    if (buffer == end_of_buffer) {\n      return 0;\n    }\n    result = __sfputc_r(stream,*buffer,buffer_size,length,remaining_length);\n    length = result + 1;\n    buffer = buffer + 1;\n  } while (length != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009358": "write_to_stream_08009358",
                "param_1": "stream",
                "param_2": "buffer_size",
                "param_3": "buffer",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "end_of_buffer",
                "iVar3": "remaining_length"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800937c": {
            "entrypoint": "0x0800937c",
            "current_name": "format_string_0800937c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009550) */\n\nint formatString_0800937c(int stream,undefined4 *format,byte *string,int *numArgs)\n\n{\n  int writeResult;\n  int *argPtr;\n  bool isNumber;\n  byte *currentChar;\n  byte *startChar;\n  int returnValue;\n  int temp;\n  int *argPtrArray;\n  uint flagBits;\n  int precision;\n  undefined4 width;\n  int argNum;\n  int totalChars;\n  byte formatChar;\n  undefined SPACE;\n  undefined PLUS;\n  undefined leftJustify;\n  undefined4 rightJustify;\n  \n  argPtrArray = numArgs;\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (format == &DAT_0800aba4) {\n    format = *(undefined4 **)(stream + 4);\n  }\n  else if (format == (undefined4 *)&DAT_0800abc4) {\n    format = *(undefined4 **)(stream + 8);\n  }\n  else if (format == (undefined4 *)&DAT_0800ab84) {\n    format = *(undefined4 **)(stream + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(format + 3) << 0x1c)) || (format[4] == 0)) &&\n     (temp = __swsetup_r(stream,format), temp != 0)) {\n    return -1;\n  }\n  totalChars = 0;\n  SPACE = 0x20;\n  PLUS = 0x30;\n  currentChar = string;\nLAB_080093be:\n  startChar = currentChar;\n  if (*startChar != 0) goto LAB_08009474;\n  goto LAB_080093c8;\nLAB_08009474:\n  currentChar = startChar + 1;\n  if (*startChar != 0x25) goto LAB_080093be;\nLAB_080093c8:\n  temp = (int)startChar - (int)string;\n  if (temp != 0) {\n    writeResult = __sfputs_r(stream,format,string,temp);\n    if (writeResult == -1) {\nLAB_08009568:\n      if ((int)((uint)*(ushort *)(format + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalChars;\n    }\n    totalChars = totalChars + temp;\n  }\n  if (*startChar == 0) goto LAB_08009568;\n  flagBits = 0;\n  argNum = 0;\n  precision = -1;\n  width = 0;\n  leftJustify = 0;\n  rightJustify = 0;\n  currentChar = startChar + 1;\n  while( true ) {\n    temp = memchr(\"#-0+ \",*currentChar);\n    string = currentChar + 1;\n    if (temp == 0) break;\n    flagBits = 1 << (temp + 0xf7ff54b0U & 0xff) | flagBits;\n    currentChar = string;\n  }\n  if ((int)(flagBits << 0x1b) < 0) {\n    leftJustify = 0x20;\n  }\n  if ((int)(flagBits << 0x1c) < 0) {\n    leftJustify = 0x2b;\n  }\n  if (*currentChar == 0x2a) {\n    argPtr = argPtrArray + 1;\n    temp = *argPtrArray;\n    argPtrArray = argPtr;\n    if (temp < 0) {\n      argNum = -temp;\n      flagBits = flagBits | 2;\n      goto LAB_080094a6;\n    }\n  }\n  else {\n    isNumber = false;\n    temp = argNum;\n    string = currentChar;\n    while( true ) {\n      if (9 < *string - 0x30) break;\n      temp = temp * 10 + (*string - 0x30);\n      isNumber = true;\n      string = string + 1;\n    }\n    if (!isNumber) goto LAB_080094a6;\n  }\n  argNum = temp;\nLAB_080094a6:\n  if (*string == 0x2e) {\n    if (string[1] == 0x2a) {\n      string = string + 2;\n      argPtr = argPtrArray + 1;\n      precision = *argPtrArray;\n      argPtrArray = argPtr;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      isNumber = false;\n      temp = 0;\n      precision = 0;\n      while( true ) {\n        string = string + 1;\n        if (9 < *string - 0x30) break;\n        temp = temp * 10 + (*string - 0x30);\n        isNumber = true;\n      }\n      if (isNumber) {\n        precision = temp;\n      }\n    }\n  }\n  temp = memchr(&DAT_0800ab56,*string,3);\n  if (temp != 0) {\n    string = string + 1;\n    flagBits = flagBits | 0x40 << (temp + 0xf7ff54aaU & 0xff);\n  }\n  formatChar = *string;\n  string = string + 1;\n  temp = memchr(\"efgEFG\",formatChar,6);\n  if (temp == 0) {\n    returnValue = _printf_i(stream,&flagBits,format,0x8009359,&argPtrArray);\n    if (returnValue == -1) goto LAB_08009568;\n  }\n  else {\n    argPtrArray = (int *)(((int)argPtrArray + 7U & 0xfffffff8) + 8);\n  }\n  totalChars = totalChars + returnValue;\n  currentChar = string;\n  goto LAB_080093be;\n}\n\n",
            "renaming": {
                "FUN_0800937c": "format_string_0800937c",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "string",
                "param_4": "numArgs",
                "iVar1": "writeResult",
                "piVar2": "argPtr",
                "bVar3": "isNumber",
                "pbVar4": "currentChar",
                "pbVar5": "startChar",
                "unaff_r9": "returnValue",
                "iVar6": "temp",
                "local_8c": "argPtrArray",
                "local_88": "flagBits",
                "local_84": "precision",
                "local_80": "width",
                "local_7c": "argNum",
                "local_74": "totalChars",
                "local_70": "formatChar",
                "local_6f": "SPACE",
                "local_6e": "PLUS",
                "local_45": "leftJustify",
                "local_30": "rightJustify"
            },
            "calling": [
                "iprintf",
                "fiprintf"
            ],
            "called": [
                "__sinit",
                "memchr",
                "_printf_i",
                "__sfputs_r",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080095a8": {
            "entrypoint": "0x080095a8",
            "current_name": "extracted_data_080095a8",
            "code": "\nundefined4\nextractedData_080095a8(undefined4 input,uint *data,uint *result,undefined4 extra,code *callback)\n\n{\n  int index;\n  int returnValue;\n  uint maxValue;\n  uint additionalValue;\n  bool checkFlag;\n  \n  maxValue = data[4];\n  if ((int)data[4] < (int)data[2]) {\n    maxValue = data[2];\n  }\n  *result = maxValue;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *result = maxValue + 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *result = *result + 2;\n  }\n  if ((*data & 6) == 0) {\n    for (index = 0; index < (int)(data[3] - *result); index = index + 1) {\n      returnValue = (*callback)(input,extra,(int)data + 0x19,1);\n      if (returnValue == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  maxValue = (uint)*(byte *)((int)data + 0x43);\n  if (maxValue != 0) {\n    maxValue = 1;\n  }\n  additionalValue = maxValue;\n  if ((int)(*data << 0x1a) < 0) {\n    *(undefined *)((int)data + maxValue + 0x43) = 0x30;\n    additionalValue = maxValue + 2;\n    *(undefined *)((int)data + maxValue + 0x44) = *(undefined *)((int)data + 0x45);\n  }\n  index = (*callback)(input,extra,(int)data + 0x43,additionalValue);\n  if (index != -1) {\n    maxValue = data[3];\n    checkFlag = (*data & 6) != 4;\n    if (checkFlag) {\n      maxValue = 0;\n    }\n    additionalValue = 0;\n    if (!checkFlag) {\n      maxValue = maxValue - *result;\n    }\n    if (!checkFlag) {\n      maxValue = maxValue & ~((int)maxValue >> 0x1f);\n    }\n    if ((int)data[4] < (int)data[2]) {\n      maxValue = maxValue + (data[2] - data[4]);\n    }\n    while( true ) {\n      if (maxValue == additionalValue) {\n        return 0;\n      }\n      index = (*callback)(input,extra,(int)data + 0x1a,1);\n      if (index == -1) break;\n      additionalValue = additionalValue + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080095a8": "extracted_data_080095a8",
                "param_1": "input",
                "param_2": "data",
                "param_3": "result",
                "param_4": "extra",
                "param_5": "callback",
                "iVar1": "index",
                "iVar2": "returnValue",
                "uVar3": "maxValue",
                "uVar4": "additionalValue",
                "bVar5": "checkFlag"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009698": {
            "entrypoint": "0x08009698",
            "current_name": "format_and_print_08009698",
            "code": "\nuint formatAndPrint_08009698(undefined4 formatString,uint *specifiers,undefined4 argCount,code *outputFunction,uint **argList)\n\n{\n  byte specifierByte;\n  int i;\n  uint *nextArg;\n  int result;\n  char *digitString;\n  uint base;\n  uint **strPtrPtr;\n  char **strPtrPtrPtr;\n  uint argValue;\n  uint argLength;\n  char *endPtr;\n  char *strPtr;\n  uint local_24 [2];\n  \n  specifierByte = *(byte *)(specifiers + 6);\n  strPtr = (char *)((int)specifiers + 0x43);\n  if (specifierByte != 0x6e) {\n    if (specifierByte < 0x6f) {\n      if (specifierByte != 99) {\n        if (specifierByte < 100) {\n          if (specifierByte == 0) goto LAB_08009852;\n          if (specifierByte != 0x58) goto LAB_080096c8;\n          *(undefined *)((int)specifiers + 0x45) = 0x58;\n          digitString = \"0123456789ABCDEF\";\nLAB_080097e2:\n          base = *specifiers;\n          nextArg = *argList;\n          *argList = nextArg + 1;\n          if (((base & 0x80) == 0) && ((int)(base << 0x19) < 0)) {\n            argValue = (uint)*(ushort *)nextArg;\n          }\n          else {\n            argValue = *nextArg;\n          }\n          if ((int)(base << 0x1f) < 0) {\n            *specifiers = base | 0x20;\n          }\n          if (argValue == 0) {\n            *specifiers = *specifiers & 0xffffffdf;\n          }\n          base = 0x10;\nLAB_08009778:\n          *(undefined *)((int)specifiers + 0x43) = 0;\n        }\n        else {\n          if ((specifierByte != 100) && (specifierByte != 0x69)) goto LAB_080096c8;\n          argValue = *specifiers;\n          nextArg = *argList;\n          if ((argValue & 0x80) == 0) {\n            *argList = nextArg + 1;\n            if ((argValue & 0x40) == 0) goto LAB_080096e8;\n            argValue = (uint)(short)*(ushort *)nextArg;\n          }\n          else {\n            *argList = nextArg + 1;\nLAB_080096e8:\n            argValue = *nextArg;\n          }\n          if ((int)argValue < 0) {\n            argValue = -argValue;\n            *(undefined *)((int)specifiers + 0x43) = 0x2d;\n          }\n          digitString = \"0123456789ABCDEF\";\n          base = 10;\n        }\n        argLength = specifiers[1];\n        specifiers[2] = argLength;\n        endPtr = strPtr;\n        if ((int)argLength < 0) {\n          if (argValue != 0) goto LAB_08009816;\nLAB_080098c4:\n          *(char *)((int)specifiers + 0x42) = *digitString;\n          endPtr = (char *)((int)specifiers + 0x42);\n        }\n        else {\n          *specifiers = *specifiers & 0xfffffffb;\n          if (argValue == 0) {\n            if (argLength != 0) goto LAB_080098c4;\n          }\n          else {\nLAB_08009816:\n            do {\n              argLength = argValue / base;\n              endPtr = endPtr + -1;\n              *endPtr = digitString[argValue - base * argLength];\n              argValue = argLength;\n            } while (argLength != 0);\n          }\n        }\n        if (((base == 8) && ((int)(*specifiers << 0x1f) < 0)) && ((int)specifiers[1] <= (int)specifiers[4]))\n        {\n          endPtr[-1] = '0';\n          endPtr = endPtr + -1;\n        }\n        specifiers[4] = (int)strPtr - (int)endPtr;\n        strPtr = endPtr;\n        goto LAB_080097be;\n      }\n      nextArg = *argList;\n      *argList = nextArg + 1;\n      *(char *)((int)specifiers + 0x42) = (char)*nextArg;\nLAB_08009728:\n      strPtr = (char *)((int)specifiers + 0x42);\n      argValue = 1;\n    }\n    else {\n      if (specifierByte != 0x73) {\n        if (specifierByte < 0x74) {\n          if (specifierByte == 0x6f) {\nLAB_0800974e:\n            argValue = *specifiers;\n            nextArg = *argList;\n            if ((argValue & 0x80) == 0) {\n              *argList = nextArg + 1;\n              if ((argValue & 0x40) == 0) goto LAB_0800975c;\n              argValue = (uint)*(ushort *)nextArg;\n            }\n            else {\n              *argList = nextArg + 1;\nLAB_0800975c:\n              argValue = *nextArg;\n            }\n            if (specifierByte == 0x6f) {\n              base = 8;\n            }\n            else {\n              base = 10;\n            }\n            digitString = \"0123456789ABCDEF\";\n            goto LAB_08009778;\n          }\n          if (specifierByte == 0x70) {\n            *specifiers = *specifiers | 0x20;\nLAB_0800970e:\n            digitString = \"0123456789abcdef\";\n            *(undefined *)((int)specifiers + 0x45) = 0x78;\n            goto LAB_080097e2;\n          }\n        }\n        else {\n          if (specifierByte == 0x75) goto LAB_0800974e;\n          if (specifierByte == 0x78) goto LAB_0800970e;\n        }\nLAB_080096c8:\n        *(byte *)((int)specifiers + 0x42) = specifierByte;\n        goto LAB_08009728;\n      }\n      strPtrPtrPtr = (char **)*argList;\n      *argList = (uint *)(strPtrPtrPtr + 1);\n      strPtr = *strPtrPtrPtr;\n      i = memchr(strPtr,0,specifiers[1]);\n      if (i != 0) {\n        specifiers[1] = i - (int)strPtr;\n      }\n      argValue = specifiers[1];\n    }\n    specifiers[4] = argValue;\n    *(undefined *)((int)specifiers + 0x43) = 0;\n    goto LAB_080097be;\n  }\n  argValue = *specifiers;\n  strPtrPtr = (uint **)*argList;\n  base = specifiers[5];\n  if ((argValue & 0x80) == 0) {\n    *argList = (uint *)(strPtrPtr + 1);\n    nextArg = *strPtrPtr;\n    if ((argValue & 0x40) == 0) goto LAB_0800983e;\n    *(short *)nextArg = (short)base;\n  }\n  else {\n    *argList = (uint *)(strPtrPtr + 1);\n    nextArg = *strPtrPtr;\nLAB_0800983e:\n    *nextArg = base;\n  }\nLAB_08009852:\n  specifiers[4] = 0;\nLAB_080097be:\n  i = _printf_common(formatString,specifiers,local_24,argCount,outputFunction);\n  if ((i == -1) || (i = (*outputFunction)(formatString,argCount,strPtr,specifiers[4]), i == -1)) {\nLAB_080097d2:\n    argValue = 0xffffffff;\n  }\n  else {\n    if ((int)(*specifiers << 0x1e) < 0) {\n      for (i = 0; i < (int)(specifiers[3] - local_24[0]); i = i + 1) {\n        result = (*outputFunction)(formatString,argCount,(int)specifiers + 0x19,1);\n        if (result == -1) goto LAB_080097d2;\n      }\n    }\n    argValue = specifiers[3];\n    if ((int)specifiers[3] < (int)local_24[0]) {\n      argValue = local_24[0];\n    }\n  }\n  return argValue;\n}\n\n",
            "renaming": {
                "FUN_08009698": "format_and_print_08009698",
                "param_1": "formatString",
                "param_2": "specifiers",
                "param_3": "argCount",
                "param_4": "outputFunction",
                "param_5": "argList",
                "bVar1": "specifierByte",
                "iVar2": "i",
                "puVar3": "nextArg",
                "iVar4": "result",
                "pcVar5": "digitString",
                "uVar6": "base",
                "uVar9": "argValue",
                "uVar10": "argLength",
                "pcVar11": "endPtr",
                "pcVar12": "strPtr",
                "ppuVar7": "strPtrPtr",
                "ppcVar8": "strPtrPtrPtr"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "memchr",
                "_printf_common"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098d8": {
            "entrypoint": "0x080098d8",
            "current_name": "print_formatted_text_080098d8",
            "code": "\nvoid printFormattedText_080098d8(undefined4 formatSpecifier,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  int data;\n  undefined4 formatSpecifierCopy;\n  undefined4 arg1Copy;\n  undefined4 arg2Copy;\n  undefined4 arg3Copy;\n  \n  data = DAT_20000090;\n  formatSpecifierCopy = formatSpecifier;\n  arg1Copy = arg1;\n  arg2Copy = arg2;\n  arg3Copy = arg3;\n  if ((DAT_20000090 != 0) && (*(int *)(DAT_20000090 + 0x18) == 0)) {\n    __sinit(DAT_20000090);\n  }\n  _vfiprintf_r(data,*(undefined4 *)(data + 8),formatSpecifier,&arg1Copy,formatSpecifierCopy,&arg1Copy);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080098d8": "print_formatted_text_080098d8",
                "param_1": "formatSpecifier",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "iVar1": "data",
                "uVar2": "formatSpecifierCopy",
                "uStack_c": "arg1Copy",
                "uStack_8": "arg2Copy",
                "uStack_4": "arg3Copy"
            },
            "calling": [
                "uart_init",
                "i2c_custom_init",
                "getTimerClkSrc",
                "getTimerIrq",
                "getTimerClkFreq"
            ],
            "called": [
                "__sinit",
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009908": {
            "entrypoint": "0x08009908",
            "current_name": "copy_and_free_memory_08009908",
            "code": "\nint copyAndFreeMemory_08009908(int source,uint size)\n\n{\n  undefined4 context;\n  int destination;\n  uint usableSize;\n  \n  context = DAT_20000090;\n  if (source != 0) {\n    if (size == 0) {\n      _free_r();\n      destination = 0;\n    }\n    else {\n      usableSize = _malloc_usable_size_r();\n      destination = source;\n      if ((usableSize < size) && (destination = _malloc_r(context,size), destination != 0)) {\n        memcpy(destination,source,size);\n        _free_r(context,source);\n      }\n    }\n    return destination;\n  }\n  destination = _malloc_r(DAT_20000090,size,size,&DAT_20000090);\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08009908": "copy_and_free_memory_08009908",
                "param_1": "source",
                "param_2": "size",
                "uVar1": "context",
                "iVar2": "destination",
                "uVar3": "usableSize"
            },
            "calling": [
                "FUN_080027f0",
                "FUN_0800288c",
                "allocateRxBuffer"
            ],
            "called": [
                "memcpy",
                "_malloc_usable_size_r",
                "_malloc_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009918": {
            "entrypoint": "0x08009918",
            "current_name": "initialize_memory_08009918",
            "code": "\nvoid initializeMemory_08009918(int *memoryPointer,undefined4 size)\n\n{\n  int allocationResult;\n  \n  DAT_20000a38 = 0;\n  allocationResult = _sbrk(size);\n  if ((allocationResult == -1) && (DAT_20000a38 != 0)) {\n    *memoryPointer = DAT_20000a38;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009918": "initialize_memory_08009918",
                "param_1": "memoryPointer",
                "param_2": "size",
                "iVar1": "allocationResult"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009938": {
            "entrypoint": "0x08009938",
            "current_name": "find_character_08009938",
            "code": "\nchar * find_character_08009938(char *string,char character)\n\n{\n  char *current_char;\n  \n  do {\n    current_char = string;\n    if (*current_char == '\\0') {\n      if (character != '\\0') {\n        current_char = (char *)0x0;\n      }\n      return current_char;\n    }\n    string = current_char + 1;\n  } while (character != *current_char);\n  return current_char;\n}\n\n",
            "renaming": {
                "FUN_08009938": "find_character_08009938",
                "param_1": "string",
                "param_2": "character",
                "pcVar1": "current_char"
            },
            "calling": [
                "strrchr"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009954": {
            "entrypoint": "0x08009954",
            "current_name": "copy_string_with_limit_08009954",
            "code": "\nvoid copyStringWithLimit_08009954(char *destination,char *source,int limit)\n\n{\n  char currentChar;\n  int remainingChars;\n  char *destPtr;\n  \n  do {\n    destPtr = destination;\n    remainingChars = limit;\n    if (remainingChars == 0) {\n      return;\n    }\n    currentChar = *source;\n    destination = destPtr + 1;\n    *destPtr = currentChar;\n    source = source + 1;\n    limit = remainingChars + -1;\n  } while (currentChar != '\\0');\n  for (; destination != destPtr + remainingChars; destination = destination + 1) {\n    *destination = '\\0';\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009954": "copy_string_with_limit_08009954",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "limit",
                "cVar1": "currentChar",
                "iVar2": "remainingChars",
                "pcVar3": "destPtr"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800997e": {
            "entrypoint": "0x0800997e",
            "current_name": "find_last_occurrence_0800997e",
            "code": "\nint find_last_occurrence_0800997e(int str,int target,undefined4 param_3,undefined4 param_4)\n\n{\n  int last_occurrence;\n  int prev_occurrence;\n  \n  if (target != 0) {\n    prev_occurrence = 0;\n    while (last_occurrence = strchr(str,target,param_3,str,param_4), last_occurrence != 0) {\n      str = last_occurrence + 1;\n      prev_occurrence = last_occurrence;\n    }\n    return prev_occurrence;\n  }\n  prev_occurrence = strchr();\n  return prev_occurrence;\n}\n\n",
            "renaming": {
                "FUN_0800997e": "find_last_occurrence_0800997e",
                "param_1": "str",
                "param_2": "target",
                "iVar1": "last_occurrence",
                "iVar2": "prev_occurrence"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [
                "strchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080099a4": {
            "entrypoint": "0x080099a4",
            "current_name": "find_common_substring_080099a4",
            "code": "\nchar * find_common_substring_080099a4(char *input_string_1,char *input_string_2)\n\n{\n  char *current_char_1;\n  char *current_char_2;\n  char *current_char_temp;\n  \n  if (*input_string_1 == '\\0') {\n    if (*input_string_2 != '\\0') {\n      input_string_1 = (char *)0x0;\n    }\n    return input_string_1;\n  }\n  do {\n    current_char_1 = input_string_1;\n    if (*current_char_1 == '\\0') {\n      return (char *)0x0;\n    }\n    current_char_temp = input_string_2 + -1;\n    current_char_2 = current_char_1 + -1;\n    do {\n      current_char_temp = current_char_temp + 1;\n      if (*current_char_temp == '\\0') {\n        return current_char_1;\n      }\n      current_char_2 = current_char_2 + 1;\n      input_string_1 = current_char_1 + 1;\n    } while (*current_char_2 == *current_char_temp);\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080099a4": "find_common_substring_080099a4",
                "param_1": "input_string_1",
                "param_2": "input_string_2",
                "pcVar1": "current_char_1",
                "pcVar2": "current_char_2",
                "pcVar3": "current_char_temp"
            },
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a80": {
            "entrypoint": "0x08009a80",
            "current_name": "decode_and_update_status_08009a80",
            "code": "\nuint decode_and_update_status_08009a80(undefined4 *output_buffer,undefined4 *input_buffer)\n\n{\n  int data_buffer_offset;\n  uint decoded_value;\n  ushort input_buffer_status;\n  \n  data_buffer_offset = DAT_20000090;\n  if ((DAT_20000090 != 0) && (*(int *)(DAT_20000090 + 0x18) == 0)) {\n    __sinit(DAT_20000090);\n  }\n  if (input_buffer == &DAT_0800aba4) {\n    input_buffer = *(undefined4 **)(data_buffer_offset + 4);\n  }\n  else if (input_buffer == (undefined4 *)&DAT_0800abc4) {\n    input_buffer = *(undefined4 **)(data_buffer_offset + 8);\n  }\n  else if (input_buffer == (undefined4 *)&DAT_0800ab84) {\n    input_buffer = *(undefined4 **)(data_buffer_offset + 0xc);\n  }\n  input_buffer_status = *(ushort *)(input_buffer + 3);\n  decoded_value = (uint)input_buffer_status;\n  if (-1 < (int)(decoded_value << 0x1c)) {\n    if (-1 < (int)(decoded_value << 0x1b)) {\n      *output_buffer = 9;\n      goto LAB_08009ab0;\n    }\n    if ((int)(decoded_value << 0x1d) < 0) {\n      if ((undefined4 *)input_buffer[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)input_buffer[0xd] != input_buffer + 0x11) {\n          _free_r(output_buffer);\n        }\n        input_buffer[0xd] = 0;\n      }\n      *(ushort *)(input_buffer + 3) = *(ushort *)(input_buffer + 3) & 0xffdb;\n      input_buffer[1] = 0;\n      *input_buffer = input_buffer[4];\n    }\n    *(ushort *)(input_buffer + 3) = *(ushort *)(input_buffer + 3) | 8;\n  }\n  if ((input_buffer[4] == 0) && ((*(ushort *)(input_buffer + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(output_buffer,input_buffer);\n  }\n  input_buffer_status = *(ushort *)(input_buffer + 3);\n  decoded_value = input_buffer_status & 1;\n  if ((input_buffer_status & 1) == 0) {\n    if (-1 < (int)((uint)input_buffer_status << 0x1e)) {\n      decoded_value = input_buffer[5];\n    }\n    input_buffer[2] = decoded_value;\n  }\n  else {\n    input_buffer[2] = 0;\n    input_buffer[6] = -input_buffer[5];\n  }\n  if (input_buffer[4] == 0) {\n    input_buffer_status = *(ushort *)(input_buffer + 3);\n    decoded_value = (int)(short)input_buffer_status & 0x80;\n    if (decoded_value != 0) {\nLAB_08009ab0:\n      *(ushort *)(input_buffer + 3) = input_buffer_status | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    decoded_value = 0;\n  }\n  return decoded_value;\n}\n\n",
            "renaming": {
                "FUN_08009a80": "decode_and_update_status_08009a80",
                "param_1": "output_buffer",
                "param_2": "input_buffer",
                "iVar1": "data_buffer_offset",
                "uVar2": "decoded_value",
                "uVar3": "input_buffer_status"
            },
            "calling": [
                "_vfiprintf_r",
                "__sfputc_r"
            ],
            "called": [
                "__sinit",
                "__smakebuf_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009b5c": {
            "entrypoint": "0x08009b5c",
            "current_name": "execute_cleanup_process_08009b5c",
            "code": "\nvoid executeCleanupProcess_08009b5c(void)\n\n{\n  uint *pointer1;\n  int index;\n  int *pointer2;\n  int *pointer3;\n  uint value;\n  ushort flag;\n  int tempIndex;\n  code *functionPointer;\n  int loopCounter;\n  uint tempValue;\n  code *jumpTable;\n  bool isTrue;\n  undefined8 result;\n  \n  raise(6);\n  jumpTable = (code *)0x8009b6b;\n  result = _exit(1);\n  pointer2 = (int *)((ulonglong)result >> 0x20);\n  pointer1 = (uint *)result;\n  flag = *(ushort *)(pointer2 + 3);\n  value = (uint)flag;\n  if ((int)(value << 0x1c) < 0) {\n    index = pointer2[4];\n    if (index != 0) {\n      tempIndex = value << 0x1e;\n      isTrue = tempIndex != 0;\n      if (isTrue) {\n        tempIndex = 0;\n      }\n      loopCounter = *pointer2;\n      if (!isTrue) {\n        tempIndex = pointer2[5];\n      }\n      *pointer2 = index;\n      pointer2[2] = tempIndex;\n      for (loopCounter = loopCounter - index; 0 < loopCounter; loopCounter = loopCounter - tempIndex) {\n        tempIndex = (*(code *)pointer2[10])(pointer1,pointer2[8],index,loopCounter);\n        if (tempIndex < 1) {\n          flag = *(ushort *)(pointer2 + 3);\n          goto LAB_08009c62;\n        }\n        index = index + tempIndex;\n      }\n    }\n  }\n  else if (((0 < pointer2[1]) || (0 < pointer2[0x10])) &&\n          (functionPointer = (code *)pointer2[0xb], functionPointer != (code *)0x0)) {\n    tempValue = *pointer1;\n    *pointer1 = 0;\n    if ((flag & 0x1000) == 0) {\n      index = (*functionPointer)(pointer1,pointer2[8],value & 0x1000,1);\n      if ((index == -1) && (value = *pointer1, value != 0)) {\n        if ((value != 0x1d) && (value != 0x16)) {\n          *(ushort *)(pointer2 + 3) = *(ushort *)(pointer2 + 3) | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x08009c2c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          (*jumpTable)();\n          return;\n        }\n        *pointer1 = tempValue;\n        goto LAB_08009b86;\n      }\n    }\n    else {\n      index = pointer2[0x15];\n    }\n    if (((int)((uint)*(ushort *)(pointer2 + 3) << 0x1d) < 0) &&\n       (index = index - pointer2[1], pointer2[0xd] != 0)) {\n      index = index - pointer2[0x10];\n    }\n    index = (*(code *)pointer2[0xb])(pointer1,pointer2[8],index,0);\n    flag = *(ushort *)(pointer2 + 3);\n    if ((index == -1) &&\n       ((0x1d < *pointer1 || (-1 < (int)((0x20400001U >> (*pointer1 & 0xff)) << 0x1f))))) {\nLAB_08009c62:\n      *(ushort *)(pointer2 + 3) = flag | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x08009c6c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*jumpTable)(0xffffffff);\n      return;\n    }\n    pointer2[1] = 0;\n    *pointer2 = pointer2[4];\n    if (((int)((uint)flag << 0x13) < 0) && ((index != -1 || (*pointer1 == 0)))) {\n      pointer2[0x15] = index;\n    }\n    pointer3 = (int *)pointer2[0xd];\n    *pointer1 = tempValue;\n    if (pointer3 != (int *)0x0) {\n      if (pointer3 != pointer2 + 0x11) {\n        _free_r(pointer1);\n      }\n      pointer2[0xd] = 0;\n                    /* WARNING: Could not recover jumptable at 0x08009c02. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*jumpTable)();\n      return;\n    }\n  }\nLAB_08009b86:\n                    /* WARNING: Could not recover jumptable at 0x08009b88. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009b5c": "execute_cleanup_process_08009b5c",
                "puVar1": "pointer1",
                "iVar2": "index",
                "piVar3": "pointer2",
                "piVar4": "pointer3",
                "uVar5": "value",
                "uVar6": "flag",
                "iVar7": "tempIndex",
                "pcVar8": "functionPointer",
                "iVar9": "loopCounter",
                "uVar10": "tempValue",
                "UNRECOVERED_JUMPTABLE_00": "jumpTable",
                "bVar11": "isTrue",
                "uVar12": "result"
            },
            "calling": [
                "__assert_func",
                "__throw_bad_function_call"
            ],
            "called": [
                "raise",
                "_exit",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009c7c": {
            "entrypoint": "0x08009c7c",
            "current_name": "process_data_08009c7c",
            "code": "\nundefined4 processData_08009c7c(uint *dataArray,int *paramArray)\n\n{\n  undefined4 result;\n  int index;\n  int *tempArray;\n  uint var1;\n  ushort var2;\n  int var3;\n  undefined4 unaff_r4;\n  undefined4 unaff_r5;\n  code *functionPtr;\n  int var4;\n  uint var5;\n  code *UNRECOVERED_JUMPTABLE_00;\n  bool bVar10;\n  \n  if (paramArray[4] != 0) {\n    if ((dataArray != (uint *)0x0) && (dataArray[6] == 0)) {\n      __sinit();\n    }\n    if (paramArray == &DAT_0800aba4) {\n      paramArray = (int *)dataArray[1];\n    }\n    else if (paramArray == (int *)&DAT_0800abc4) {\n      paramArray = (int *)dataArray[2];\n    }\n    else if (paramArray == (int *)&DAT_0800ab84) {\n      paramArray = (int *)dataArray[3];\n    }\n    if (*(short *)(paramArray + 3) != 0) {\n      var2 = *(ushort *)(paramArray + 3);\n      var1 = (uint)var2;\n      if ((int)(var1 << 0x1c) < 0) {\n        index = paramArray[4];\n        if (index != 0) {\n          var3 = var1 << 0x1e;\n          bVar10 = var3 != 0;\n          if (bVar10) {\n            var3 = 0;\n          }\n          var4 = *paramArray;\n          if (!bVar10) {\n            var3 = paramArray[5];\n          }\n          *paramArray = index;\n          paramArray[2] = var3;\n          for (var4 = var4 - index; 0 < var4; var4 = var4 - var3) {\n            var3 = (*(code *)paramArray[10])(dataArray,paramArray[8],index,var4,unaff_r4,unaff_r5);\n            if (var3 < 1) {\n              var2 = *(ushort *)(paramArray + 3);\n              goto LAB_08009c62;\n            }\n            index = index + var3;\n          }\n        }\n      }\n      else if (((0 < paramArray[1]) || (0 < paramArray[0x10])) &&\n              (functionPtr = (code *)paramArray[0xb], functionPtr != (code *)0x0)) {\n        var5 = *dataArray;\n        *dataArray = 0;\n        if ((var2 & 0x1000) == 0) {\n          index = (*functionPtr)(dataArray,paramArray[8],var1 & 0x1000,1);\n          if ((index == -1) && (var1 = *dataArray, var1 != 0)) {\n            if ((var1 != 0x1d) && (var1 != 0x16)) {\n              *(ushort *)(paramArray + 3) = *(ushort *)(paramArray + 3) | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x08009c2c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n              result = (*UNRECOVERED_JUMPTABLE_00)();\n              return result;\n            }\n            *dataArray = var5;\n            goto LAB_08009b86;\n          }\n        }\n        else {\n          index = paramArray[0x15];\n        }\n        if (((int)((uint)*(ushort *)(paramArray + 3) << 0x1d) < 0) &&\n           (index = index - paramArray[1], paramArray[0xd] != 0)) {\n          index = index - paramArray[0x10];\n        }\n        index = (*(code *)paramArray[0xb])(dataArray,paramArray[8],index,0);\n        var2 = *(ushort *)(paramArray + 3);\n        if ((index == -1) &&\n           ((0x1d < *dataArray || (-1 < (int)((0x20400001U >> (*dataArray & 0xff)) << 0x1f))))) {\nLAB_08009c62:\n          *(ushort *)(paramArray + 3) = var2 | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x08009c6c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          result = (*UNRECOVERED_JUMPTABLE_00)(0xffffffff);\n          return result;\n        }\n        paramArray[1] = 0;\n        *paramArray = paramArray[4];\n        if (((int)((uint)var2 << 0x13) < 0) && ((index != -1 || (*dataArray == 0)))) {\n          paramArray[0x15] = index;\n        }\n        tempArray = (int *)paramArray[0xd];\n        *dataArray = var5;\n        if (tempArray != (int *)0x0) {\n          if (tempArray != paramArray + 0x11) {\n            _free_r(dataArray);\n          }\n          paramArray[0xd] = 0;\n                    /* WARNING: Could not recover jumptable at 0x08009c02. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          result = (*UNRECOVERED_JUMPTABLE_00)();\n          return result;\n        }\n      }\nLAB_08009b86:\n                    /* WARNING: Could not recover jumptable at 0x08009b88. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      result = (*UNRECOVERED_JUMPTABLE_00)(0);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08009c7c": "process_data_08009c7c",
                "param_1": "dataArray",
                "param_2": "paramArray",
                "uVar1": "result",
                "iVar2": "index",
                "piVar3": "tempArray",
                "uVar4": "var1",
                "uVar5": "var2",
                "iVar6": "var3",
                "pcVar7": "functionPtr",
                "iVar8": "var4",
                "uVar9": "var5"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009cdc": {
            "entrypoint": "0x08009cdc",
            "current_name": "initialize_user_08009cdc",
            "code": "\nvoid initializeUser_08009cdc(undefined4 *user,undefined2 value1,undefined2 value2)\n\n{\n  *user = 0;\n  user[1] = 0;\n  user[2] = 0;\n  *(undefined2 *)(user + 3) = value1;\n  user[25] = 0;\n  *(undefined2 *)((int)user + 0xe) = value2;\n  user[4] = 0;\n  user[5] = 0;\n  user[6] = 0;\n  memset(user + 0x17,0,8);\n  user[8] = user;\n  user[9] = 0x800a021;\n  user[10] = 0x800a043;\n  user[11] = 0x800a07b;\n  user[12] = &LAB_0800a09e_1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009cdc": "initialize_user_08009cdc",
                "param_1": "user",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[1]": "user[1]",
                "param_1[2]": "user[2]",
                "param_1[0x19]": "user[25]",
                "param_1[4]": "user[4]",
                "param_1[5]": "user[5]",
                "param_1[6]": "user[6]",
                "param_1[8]": "user[8]",
                "param_1[9]": "user[9]",
                "param_1[10]": "user[10]",
                "param_1[0xb]": "user[11]",
                "param_1[0xc]": "user[12]"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009d24": {
            "entrypoint": "0x08009d24",
            "current_name": "allocate_memory_08009d24",
            "code": "\nundefined4 * allocate_memory_08009d24(undefined4 size,int num_elements)\n\n{\n  undefined4 *ptr;\n  int total_size;\n  \n  total_size = (num_elements + -1) * 0x68;\n  ptr = (undefined4 *)_malloc_r(size,total_size + 0x74);\n  if (ptr != (undefined4 *)0x0) {\n    *ptr = 0;\n    ptr[1] = num_elements;\n    ptr[2] = ptr + 3;\n    memset(ptr + 3,0,total_size + 0x68);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08009d24": "allocate_memory_08009d24",
                "param_1": "size",
                "param_2": "num_elements",
                "puVar1": "ptr",
                "iVar2": "total_size"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "memset",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009d50": {
            "entrypoint": "0x08009d50",
            "current_name": "initialize_data_08009d50",
            "code": "\nvoid initializeData_08009d50(undefined4 *data)\n\n{\n  undefined4 result;\n  undefined4 *tempPtr;\n  \n  if (data[6] == 0) {\n    data[0x12] = 0;\n    data[0x13] = 0;\n    data[0x14] = 0;\n    tempPtr = &DAT_20000094;\n    data[10] = &LAB_08009cd0_1;\n    if (data == &DAT_20000094) {\n      tempPtr = (undefined4 *)0x1;\n    }\n    if (data == &DAT_20000094) {\n      data[6] = tempPtr;\n    }\n    result = __sfp();\n    data[1] = result;\n    result = __sfp(data);\n    data[2] = result;\n    result = __sfp(data);\n    data[3] = result;\n    std_isra_0(data[1],4,0);\n    std_isra_0(data[2],9,1);\n    std_isra_0(data[3],0x12,2);\n    data[6] = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009d50": "initialize_data_08009d50",
                "param_1": "data",
                "uVar1": "result",
                "puVar2": "tempPtr"
            },
            "calling": [
                "_fflush_r",
                "_vfiprintf_r",
                "__sfp",
                "iprintf",
                "__sfputc_r",
                "__swsetup_r"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009db0": {
            "entrypoint": "0x08009db0",
            "current_name": "initialize_data_structure_08009db0",
            "code": "\nint * initializeDataStructure_08009db0(undefined4 *paramPointer,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  int *iterator;\n  int *dataPointer;\n  int **dataStructurePointer;\n  \n  if (DAT_200000ac == 0) {\n    __sinit(&DAT_20000094);\n  }\n  dataStructurePointer = (int **)&DAT_200000dc;\n  do {\n    dataPointer = dataStructurePointer[2];\n    iterator = dataStructurePointer[1];\n    while (iterator = (int *)((int)iterator + -1), -1 < (int)iterator) {\n      if (*(short *)(dataPointer + 3) == 0) {\n        *(undefined2 *)((int)dataPointer + 0xe) = 0xffff;\n        dataPointer[0x19] = 0;\n        *(undefined2 *)(dataPointer + 3) = 1;\n        *dataPointer = 0;\n        dataPointer[2] = 0;\n        dataPointer[1] = 0;\n        dataPointer[4] = 0;\n        dataPointer[5] = 0;\n        dataPointer[6] = 0;\n        memset(dataPointer + 0x17,0,8,1,param4);\n        dataPointer[0xd] = 0;\n        dataPointer[0xe] = 0;\n        dataPointer[0x12] = 0;\n        dataPointer[0x13] = 0;\n        return dataPointer;\n      }\n      dataPointer = dataPointer + 0x1a;\n    }\n    if (*dataStructurePointer == (int *)0x0) {\n      iterator = (int *)__sfmoreglue(paramPointer,4);\n      *dataStructurePointer = iterator;\n      if (iterator == (int *)0x0) {\n        *paramPointer = 0xc;\n        return (int *)0x0;\n      }\n    }\n    dataStructurePointer = (int **)*dataStructurePointer;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08009db0": "initialize_data_structure_08009db0",
                "param_1": "paramPointer",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "piVar1": "iterator",
                "piVar2": "dataPointer",
                "ppiVar3": "dataStructurePointer"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__sinit",
                "memset",
                "__sfmoreglue"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e64": {
            "entrypoint": "0x08009e64",
            "current_name": "check_file_attributes_08009e64",
            "code": "\nundefined4 checkFileAttributes_08009e64(undefined4 param_1,int fileInfo,undefined4 *filePermissions,uint *fileType)\n\n{\n  int result;\n  undefined4 permissionFlag;\n  undefined stackBuffer [4];\n  uint fileMode;\n  \n  if ((*(short *)(fileInfo + 0xe) < 0) ||\n     (result = _fstat_r(param_1,(int)*(short *)(fileInfo + 0xe),stackBuffer), result < 0)) {\n    *fileType = 0;\n    if ((int)((uint)*(ushort *)(fileInfo + 0xc) << 0x18) < 0) {\n      permissionFlag = 0x40;\n      goto LAB_08009ea4;\n    }\n  }\n  else {\n    *fileType = (uint)((fileMode & 0xf000) == 0x2000);\n  }\n  permissionFlag = 0x400;\nLAB_08009ea4:\n  *filePermissions = permissionFlag;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08009e64": "check_file_attributes_08009e64",
                "param_2": "fileInfo",
                "param_3": "filePermissions",
                "param_4": "fileType",
                "iVar1": "result",
                "uVar2": "permissionFlag",
                "auStack_4c": "stackBuffer",
                "local_48": "fileMode"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009eac": {
            "entrypoint": "0x08009eac",
            "current_name": "process_input_data_08009eac",
            "code": "\nvoid processInputData_08009eac(int inputBufferSize,int *inputData)\n\n{\n  ushort outputStatus;\n  int outputBuffer;\n  int tempInputSize;\n  int *tempInputData;\n  \n  if (-1 < (int)((uint)*(ushort *)(inputData + 3) << 0x1e)) {\n    tempInputSize = inputBufferSize;\n    tempInputData = inputData;\n    outputStatus = __swhatbuf_r(inputBufferSize,inputData,&tempInputSize,&tempInputData);\n    outputBuffer = _malloc_r(inputBufferSize,tempInputSize);\n    if (outputBuffer != 0) {\n      *(undefined **)(inputBufferSize + 0x28) = &LAB_08009cd0_1;\n      *inputData = outputBuffer;\n      *(ushort *)(inputData + 3) = *(ushort *)(inputData + 3) | 0x80;\n      inputData[4] = outputBuffer;\n      inputData[5] = tempInputSize;\n      if ((tempInputData != (int *)0x0) &&\n         (outputBuffer = _isatty_r(inputBufferSize,(int)*(short *)((int)inputData + 0xe)), outputBuffer != 0)) {\n        *(ushort *)(inputData + 3) = *(ushort *)(inputData + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(inputData + 3) = outputStatus | *(ushort *)(inputData + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(inputData + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(inputData + 3) = *(ushort *)(inputData + 3) & 0xfffc | 2;\n  }\n  *inputData = (int)inputData + 0x47;\n  inputData[4] = (int)inputData + 0x47;\n  inputData[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009eac": "process_input_data_08009eac",
                "param_1": "inputBufferSize",
                "param_2": "inputData",
                "uVar1": "outputStatus",
                "iVar2": "outputBuffer",
                "local_18": "tempInputSize",
                "local_14": "tempInputData"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "__swhatbuf_r",
                "_malloc_r",
                "_isatty_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009f2c": {
            "entrypoint": "0x08009f2c",
            "current_name": "find_first_occurrence_08009f2c",
            "code": "\nchar * findFirstOccurrence_08009f2c(char *string,char character,int length)\n\n{\n  char *currentPointer;\n  char *nextPointer;\n  \n  currentPointer = string;\n  do {\n    nextPointer = currentPointer;\n    if (nextPointer == string + length) {\n      return (char *)0x0;\n    }\n    currentPointer = nextPointer + 1;\n  } while (*nextPointer != character);\n  return nextPointer;\n}\n\n",
            "renaming": {
                "FUN_08009f2c": "find_first_occurrence_08009f2c",
                "param_1": "string",
                "param_2": "character",
                "param_3": "length",
                "pcVar1": "currentPointer",
                "pcVar2": "nextPointer"
            },
            "calling": [
                "_printf_i",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009f48": {
            "entrypoint": "0x08009f48",
            "current_name": "FUNC_08009f48",
            "code": "\nvoid FUNC_08009f48(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009f48": "FUNC_08009f48"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009f4a": {
            "entrypoint": "0x08009f4a",
            "current_name": "FUNC_08009f4a",
            "code": "\nvoid FUNC_08009f4a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009f4a": "FUNC_08009f4a"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009fe8": {
            "entrypoint": "0x08009fe8",
            "current_name": "reverse_kill_process_08009fe8",
            "code": "\nint reverseKillProcess_08009fe8(uint signal)\n\n{\n  int *ptrSignalCount;\n  undefined4 pid;\n  int currentSignal;\n  code *signalHandler;\n  undefined4 unusedVar1;\n  undefined4 unusedVar2;\n  undefined4 unusedVar3;\n  undefined4 *ptrSignalTable;\n  \n  ptrSignalCount = DAT_20000090;\n  ptrSignalTable = &DAT_20000090;\n  if (0x1f < signal) {\n    *DAT_20000090 = 0x16;\n    return -1;\n  }\n  currentSignal = DAT_20000090[0x11];\n  if ((currentSignal != 0) && (signalHandler = *(code **)(currentSignal + signal * 4), signalHandler != (code *)0x0)) {\n    if (signalHandler != (code *)0x1) {\n      if (signalHandler == (code *)0xffffffff) {\n        *DAT_20000090 = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(currentSignal + signal * 4) = 0;\n      (*signalHandler)(signal);\n    }\n    return 0;\n  }\n  pid = _getpid_r(DAT_20000090);\n  DAT_20000a38 = 0;\n  currentSignal = _kill(pid,signal,signal,0,ptrSignalTable,unusedVar1,unusedVar2,unusedVar3);\n  if ((currentSignal == -1) && (DAT_20000a38 != 0)) {\n    *ptrSignalCount = DAT_20000a38;\n  }\n  return currentSignal;\n}\n\n",
            "renaming": {
                "FUN_08009fe8": "reverse_kill_process_08009fe8",
                "param_1": "signal",
                "piVar1": "ptrSignalCount",
                "uVar2": "pid",
                "iVar3": "currentSignal",
                "pcVar4": "signalHandler",
                "unaff_r4": "unusedVar1",
                "unaff_r5": "unusedVar2",
                "in_lr": "unusedVar3",
                "puVar5": "ptrSignalTable"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_getpid_r",
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a01c": {
            "entrypoint": "0x0800a01c",
            "current_name": "FUN_0800a01c",
            "code": "\nundefined4 _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "raise"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a020": {
            "entrypoint": "0x0800a020",
            "current_name": "update_value_0800a020",
            "code": "\nvoid updateValue_0800a020(undefined4 fileDescriptor,int dataOffset)\n\n{\n  int readResult;\n  uint updatedValue;\n  bool isSuccess;\n  \n  readResult = _read_r(fileDescriptor,(int)*(short *)(dataOffset + 0xe));\n  isSuccess = -1 < readResult;\n  if (isSuccess) {\n    updatedValue = *(int *)(dataOffset + 0x54) + readResult;\n  }\n  else {\n    updatedValue = *(ushort *)(dataOffset + 0xc) & 0xffffefff;\n  }\n  if (isSuccess) {\n    *(uint *)(dataOffset + 0x54) = updatedValue;\n  }\n  if (!isSuccess) {\n    *(short *)(dataOffset + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a020": "update_value_0800a020",
                "param_1": "fileDescriptor",
                "param_2": "dataOffset",
                "iVar1": "readResult",
                "uVar2": "updatedValue",
                "bVar3": "isSuccess"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a042": {
            "entrypoint": "0x0800a042",
            "current_name": "write_to_position_0800a042",
            "code": "\nvoid writeToPosition_0800a042(int *fileDescriptor,int headerOffset,undefined4 buffer,undefined4 size)\n\n{\n  int writeResult;\n  undefined4 unusedVar1;\n  undefined4 unusedVar2;\n  undefined4 unusedVar3;\n  \n  if ((int)((uint)*(ushort *)(headerOffset + 0xc) << 0x17) < 0) {\n    _lseek_r(fileDescriptor,(int)*(short *)(headerOffset + 0xe),0,2);\n  }\n  *(ushort *)(headerOffset + 0xc) = *(ushort *)(headerOffset + 0xc) & 0xefff;\n  DAT_20000a38 = 0;\n  writeResult = _write((int)*(short *)(headerOffset + 0xe),buffer,size,size,size,unusedVar1,unusedVar2,\n                 unusedVar3);\n  if ((writeResult == -1) && (DAT_20000a38 != 0)) {\n    *fileDescriptor = DAT_20000a38;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a042": "write_to_position_0800a042",
                "param_1": "fileDescriptor",
                "param_2": "headerOffset",
                "param_3": "buffer",
                "param_4": "size",
                "iVar1": "writeResult",
                "unaff_r4": "unusedVar1",
                "unaff_r5": "unusedVar2",
                "in_lr": "unusedVar3"
            },
            "calling": [],
            "called": [
                "_lseek_r",
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a07a": {
            "entrypoint": "0x0800a07a",
            "current_name": "update_file_pointer_0800a07a",
            "code": "\nvoid updateFilePointer_0800a07a(undefined4 fileDescriptor,int bufferAddress)\n\n{\n  int seekResult;\n  ushort updatedFlags;\n  bool seekFailed;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe));\n  seekFailed = seekResult == -1;\n  if (seekFailed) {\n    updatedFlags = *(ushort *)(bufferAddress + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(bufferAddress + 0x54) = seekResult;\n    updatedFlags = *(ushort *)(bufferAddress + 0xc) | 0x1000;\n  }\n  if (seekFailed) {\n    *(ushort *)(bufferAddress + 0xc) = updatedFlags;\n  }\n  if (!seekFailed) {\n    *(ushort *)(bufferAddress + 0xc) = updatedFlags;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a07a": "update_file_pointer_0800a07a",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress",
                "iVar1": "seekResult",
                "uVar2": "updatedFlags",
                "bVar3": "seekFailed"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a0ec": {
            "entrypoint": "0x0800a0ec",
            "current_name": "check_file_status_0800a0ec",
            "code": "\nvoid check_file_status_0800a0ec(int *result,undefined4 file_descriptor,undefined4 file_status,undefined4 buffer)\n\n{\n  int file_status_result;\n  \n  DAT_20000a38 = 0;\n  file_status_result = _fstat(file_descriptor,file_status,file_status,0,buffer);\n  if ((file_status_result == -1) && (DAT_20000a38 != 0)) {\n    *result = DAT_20000a38;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a0ec": "check_file_status_0800a0ec",
                "param_1": "result",
                "param_2": "file_descriptor",
                "param_3": "file_status",
                "param_4": "buffer",
                "iVar1": "file_status_result"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a110": {
            "entrypoint": "0x0800a110",
            "current_name": "check_and_assign_if_console_0800a110",
            "code": "\nvoid checkAndAssignIfConsole_0800a110(int *outputValuePointer,undefined4 fileDescriptor)\n\n{\n  int isTTYResult;\n  \n  DAT_20000a38 = 0;\n  isTTYResult = _isatty(fileDescriptor);\n  if ((isTTYResult == -1) && (DAT_20000a38 != 0)) {\n    *outputValuePointer = DAT_20000a38;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a110": "check_and_assign_if_console_0800a110",
                "param_1": "outputValuePointer",
                "param_2": "fileDescriptor",
                "iVar1": "isTTYResult"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a130": {
            "entrypoint": "0x0800a130",
            "current_name": "set_file_pointer_0800a130",
            "code": "\nvoid setFilePointer_0800a130(int *fileHandle,undefined4 fileDescriptor,undefined4 offset,undefined4 origin)\n\n{\n  int result;\n  \n  DAT_20000a38 = 0;\n  result = _lseek(fileDescriptor,offset,origin,origin,origin);\n  if ((result == -1) && (DAT_20000a38 != 0)) {\n    *fileHandle = DAT_20000a38;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a130": "set_file_pointer_0800a130",
                "param_1": "fileHandle",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "origin",
                "iVar1": "result"
            },
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a154": {
            "entrypoint": "0x0800a154",
            "current_name": "add_offset_and_check_0800a154",
            "code": "\nint addOffsetAndCheck_0800a154(undefined4 offset,int address)\n\n{\n  int result;\n  \n  result = *(int *)(address + -4) + -4;\n  if (*(int *)(address + -4) < 0) {\n    result = result + *(int *)(address + result);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800a154": "add_offset_and_check_0800a154",
                "param_1": "offset",
                "param_2": "address",
                "iVar1": "result"
            },
            "calling": [
                "realloc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a168": {
            "entrypoint": "0x0800a168",
            "current_name": "read_and_update_param1_0800a168",
            "code": "\nvoid readAndUpdateParam1_0800a168(int *resultPtr,undefined4 fileDescriptor,undefined4 buffer,undefined4 count)\n\n{\n  int readResult;\n  \n  DAT_20000a38 = 0;\n  readResult = _read(fileDescriptor,buffer,count,count,count);\n  if ((readResult == -1) && (DAT_20000a38 != 0)) {\n    *resultPtr = DAT_20000a38;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a168": "read_and_update_param1_0800a168",
                "param_1": "resultPtr",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "readResult"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a18c": {
            "entrypoint": "0x0800a18c",
            "current_name": "abort_and_update_data_0800a18c",
            "code": "\nvoid abort_and_update_data_0800a18c(void)\n\n{\n  code *jump_table;\n  \n  jump_table = abort_and_update_data_0800a18c;\n  abort();\n  if (-1 < DAT_200009c0 << 0x1f) {\n    DAT_200009c0 = 1;\n  }\n  if (-1 < DAT_200009bc << 0x1f) {\n    DAT_200009bc = 1;\n  }\n  if (-1 < DAT_200009b8 << 0x1f) {\n    DAT_200009b8 = 1;\n  }\n  if (-1 < DAT_200009b4 << 0x1f) {\n    DAT_200009b4 = 1;\n  }\n  if (-1 < DAT_200009b0 << 0x1f) {\n    DAT_200009b0 = 1;\n  }\n  if (-1 < DAT_200009ac << 0x1f) {\n    DAT_200009ac = 1;\n  }\n  if (-1 < DAT_200009a8 << 0x1f) {\n    DAT_200009a8 = 1;\n  }\n  if (-1 < DAT_200009a4 << 0x1f) {\n    DAT_200009a4 = 1;\n  }\n  if (-1 < DAT_200009a0 << 0x1f) {\n    DAT_200009a0 = 1;\n  }\n  if (-1 < DAT_2000099c << 0x1f) {\n    DAT_2000099c = 1;\n  }\n  if (-1 < DAT_20000998 << 0x1f) {\n    DAT_20000998 = 1;\n  }\n  if (-1 < DAT_20000994 << 0x1f) {\n    DAT_20000994 = 1;\n  }\n                    /* WARNING: Could not recover jumptable at 0x0800a224. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jump_table)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a18c": "abort_and_update_data_0800a18c",
                "UNRECOVERED_JUMPTABLE": "jump_table"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a424": {
            "entrypoint": "0x0800a424",
            "current_name": "FUNC_0800a424",
            "code": "\nvoid FUNC_0800a424(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a424": "FUNC_0800a424"
            },
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800a430": {
            "entrypoint": "0x0800a430",
            "current_name": "FUNC_0800a430",
            "code": "\nvoid FUNC_0800a430(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800a430": "FUNC_0800a430"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 222142,
    "layers": [
        [
            "FUN_0800010c",
            "FUN_08000178",
            "FUN_08000188",
            "FUN_0800018c",
            "FUN_080004d4",
            "FUN_08000588",
            "FUN_080005e0",
            "FUN_08000aec",
            "FUN_08000ef8",
            "FUN_08002400",
            "FUN_0800242c",
            "FUN_08002578",
            "FUN_08002580",
            "FUN_080025ac",
            "FUN_08002644",
            "FUN_0800267c",
            "FUN_080026b0",
            "FUN_080026f8",
            "FUN_0800270c",
            "FUN_08002720",
            "FUN_080027f0",
            "FUN_0800288c",
            "FUN_0800291c",
            "FUN_08002948",
            "FUN_08002968",
            "FUN_08002a30",
            "FUN_08002a58",
            "FUN_08002acc",
            "FUN_08002c2c",
            "FUN_08002dbc",
            "FUN_08002ddc",
            "FUN_08002df6",
            "FUN_08002e44",
            "FUN_08002ec4",
            "FUN_08002ed2",
            "FUN_08002ef2",
            "FUN_08002efe",
            "FUN_08002f0a",
            "FUN_08002f14",
            "FUN_08002f1e",
            "FUN_08002f2c",
            "FUN_08002f84",
            "FUN_08002f94",
            "FUN_08002fa0",
            "FUN_08002fa8",
            "FUN_08002fba",
            "FUN_08002fc2",
            "FUN_08002fca",
            "FUN_08003002",
            "FUN_0800307a",
            "FUN_08003106",
            "FUN_0800314e",
            "FUN_08003154",
            "FUN_08003158",
            "FUN_0800319e",
            "FUN_080031ce",
            "FUN_0800322c",
            "FUN_0800325a",
            "FUN_080032a2",
            "FUN_080032bc",
            "FUN_08003306",
            "FUN_08003346",
            "FUN_08003350",
            "FUN_08003366",
            "FUN_08003370",
            "FUN_08003376",
            "FUN_080033a8",
            "FUN_080033cc",
            "FUN_0800344a",
            "FUN_08003474",
            "FUN_080035b8",
            "FUN_08003658",
            "FUN_080036a2",
            "FUN_080036ac",
            "FUN_080036d8",
            "FUN_08003724",
            "FUN_08003748",
            "FUN_08003760",
            "FUN_0800376c",
            "FUN_080038dc",
            "FUN_080038e4",
            "FUN_08003a1c",
            "FUN_08003a20",
            "FUN_08003aa0",
            "FUN_08003b8c",
            "FUN_08003bd8",
            "FUN_08003ce8",
            "FUN_08003de4",
            "FUN_08003e20",
            "FUN_08003f0c",
            "FUN_08003f30",
            "FUN_08003f94",
            "FUN_08003fb0",
            "FUN_08003fd8",
            "FUN_08004004",
            "FUN_08004024",
            "FUN_08004046",
            "FUN_08004050",
            "FUN_080040e8",
            "FUN_080042d4",
            "FUN_080042e2",
            "FUN_080042f0",
            "FUN_0800430c",
            "FUN_08004396",
            "FUN_080043a2",
            "FUN_0800457c",
            "FUN_0800459c",
            "FUN_080045c0",
            "FUN_08004728",
            "FUN_080047f4",
            "FUN_080048c8",
            "FUN_08004954",
            "FUN_080049e0",
            "FUN_08004a24",
            "FUN_08004a76",
            "FUN_08004ac2",
            "FUN_08004aec",
            "FUN_08004b82",
            "FUN_08004ccc",
            "FUN_08004d6c",
            "FUN_08004e3c",
            "FUN_08004f3c",
            "FUN_08005084",
            "FUN_08005188",
            "FUN_080052f0",
            "FUN_0800542a",
            "FUN_08005430",
            "FUN_08005434",
            "FUN_08005460",
            "FUN_08005840",
            "FUN_080058ac",
            "FUN_080058d2",
            "FUN_08005a1c",
            "FUN_08005a28",
            "FUN_08005a48",
            "FUN_08005a68",
            "FUN_08005aa4",
            "FUN_08005bb8",
            "FUN_08005cb4",
            "FUN_08005cec",
            "FUN_08005d48",
            "FUN_08005dac",
            "FUN_08005df4",
            "FUN_08005e2e",
            "FUN_08005e6e",
            "FUN_08005fe8",
            "FUN_08006060",
            "FUN_08006092",
            "FUN_080060c4",
            "FUN_08006128",
            "FUN_08006186",
            "FUN_08006262",
            "FUN_08006280",
            "FUN_080062f4",
            "FUN_08006390",
            "FUN_080063c0",
            "FUN_08006420",
            "FUN_0800643c",
            "FUN_08006460",
            "FUN_080064b0",
            "FUN_080064cc",
            "FUN_08006538",
            "FUN_080066e8",
            "FUN_0800674e",
            "FUN_080067ac",
            "FUN_0800688e",
            "FUN_080068d6",
            "FUN_08006932",
            "FUN_0800694c",
            "FUN_080069ec",
            "FUN_08006b1c",
            "FUN_08006b28",
            "FUN_08006b3e",
            "FUN_08006b5c",
            "FUN_08006b7c",
            "FUN_08006bb8",
            "FUN_08006c60",
            "FUN_08006c7c",
            "FUN_08006ca8",
            "FUN_08006d24",
            "FUN_08006d80",
            "FUN_08006e68",
            "FUN_08007110",
            "FUN_08007118",
            "FUN_080071e4",
            "FUN_0800723c",
            "FUN_08007246",
            "FUN_08007258",
            "FUN_080072d8",
            "FUN_080072f0",
            "FUN_080072fa",
            "FUN_08007306",
            "FUN_08007320",
            "FUN_08007332",
            "FUN_0800734a",
            "FUN_0800735a",
            "FUN_08007376",
            "FUN_0800738a",
            "FUN_080073ae",
            "FUN_080073c0",
            "FUN_080073e8",
            "FUN_080073ec",
            "FUN_08007438",
            "FUN_080074e0",
            "FUN_08007544",
            "FUN_08007594",
            "FUN_080075dc",
            "FUN_08007648",
            "FUN_080076e0",
            "FUN_08007708",
            "FUN_08007710",
            "FUN_08007718",
            "FUN_0800771c",
            "FUN_08007736",
            "FUN_08007744",
            "FUN_0800774a",
            "FUN_08007750",
            "FUN_080077b0",
            "FUN_08007e74",
            "FUN_08007ede",
            "FUN_08007f0e",
            "FUN_08007f78",
            "FUN_08007f7c",
            "FUN_08007f8e",
            "FUN_08007fa0",
            "FUN_08007ff0",
            "FUN_08008020",
            "FUN_08008078",
            "FUN_080084b0",
            "FUN_08008500",
            "FUN_080085b8",
            "FUN_080085dc",
            "FUN_08008600",
            "FUN_0800863c",
            "FUN_08008694",
            "FUN_080086e8",
            "FUN_0800870c",
            "FUN_08008730",
            "FUN_08008804",
            "FUN_08008840",
            "FUN_08008846",
            "FUN_08008850",
            "FUN_08008854",
            "FUN_08008858",
            "FUN_0800885c",
            "FUN_08008868",
            "FUN_0800886c",
            "FUN_0800887c",
            "FUN_08008880",
            "FUN_080088e0",
            "FUN_08008990",
            "FUN_08008a24",
            "FUN_08008a6c",
            "FUN_08008abc",
            "FUN_08008afa",
            "FUN_08008b66",
            "FUN_08008c20",
            "FUN_08008c44",
            "FUN_08008d00",
            "FUN_08008d18",
            "FUN_08008d30",
            "FUN_08008d8c",
            "FUN_08008df8",
            "FUN_08008e14",
            "FUN_08008ef4",
            "FUN_08008f1c",
            "FUN_08008f3c",
            "FUN_08008f78",
            "FUN_08009094",
            "FUN_080090c2",
            "FUN_080090cc",
            "FUN_08009108",
            "FUN_08009124",
            "FUN_08009148",
            "FUN_08009190",
            "FUN_080091a0",
            "FUN_080091b0",
            "FUN_080091c6",
            "FUN_080091d8",
            "FUN_08009270",
            "FUN_0800932c",
            "FUN_08009358",
            "FUN_0800937c",
            "FUN_080095a8",
            "FUN_08009698",
            "FUN_080098d8",
            "FUN_08009908",
            "FUN_08009918",
            "FUN_08009938",
            "FUN_08009954",
            "FUN_0800997e",
            "FUN_080099a4",
            "FUN_08009a80",
            "FUN_08009b5c",
            "FUN_08009c7c",
            "FUN_08009cdc",
            "FUN_08009d24",
            "FUN_08009d50",
            "FUN_08009db0",
            "FUN_08009e64",
            "FUN_08009eac",
            "FUN_08009f2c",
            "FUN_08009fe8",
            "FUN_0800a020",
            "FUN_0800a042",
            "FUN_0800a07a",
            "FUN_0800a0ec",
            "FUN_0800a110",
            "FUN_0800a130",
            "FUN_0800a154",
            "FUN_0800a168"
        ],
        [
            "FUN_08000214",
            "FUN_0800021a",
            "FUN_08000488",
            "FUN_080005f8",
            "FUN_08000be8",
            "FUN_08001bf8",
            "FUN_08001c08",
            "FUN_08001c18",
            "FUN_08001cd0",
            "FUN_080022f8",
            "FUN_08002634",
            "FUN_08002a1c",
            "FUN_08002ac0",
            "FUN_08002b68",
            "FUN_08002c1e",
            "FUN_08002ce0",
            "FUN_08002e26",
            "FUN_08008f0e"
        ],
        [
            "FUN_08000500",
            "FUN_08002a26",
            "FUN_08002c00",
            "FUN_08003048"
        ],
        [
            "FUN_08000a64",
            "FUN_08001b48",
            "FUN_08002c14"
        ],
        [
            "FUN_08009084",
            "FUN_0800a18c"
        ]
    ],
    "locked_functions": []
}