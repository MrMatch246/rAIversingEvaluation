{
    "functions": {
        "FUN_080001ac": {
            "entrypoint": "0x080001ac",
            "current_name": "initialize_flag_080001ac",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001b8) */\n\nundefined4 initializeFlag_080001ac(undefined4 input)\n\n{\n  if ((char)DAT_20000104 == '\\0') {\n    DAT_20000104._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_080001ac": "initialize_flag_080001ac",
                "param_1": "input"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000230": {
            "entrypoint": "0x08000230",
            "current_name": "find_byte_sequence_08000230",
            "code": "\nbyte * find_byte_sequence_08000230(uint *data,uint byte_to_find,uint data_size)\n\n{\n  byte current_byte;\n  char is_zero_0;\n  char is_zero_1;\n  char is_zero_2;\n  char is_zero_3;\n  byte *result;\n  uint *current_ptr;\n  byte *next_byte;\n  uint ptr_alignment;\n  uint data_size_aligned;\n  uint xor_result_0;\n  uint xor_result_1;\n  bool is_non_zero_0;\n  bool is_non_zero_1;\n  bool is_non_zero_2;\n  bool is_non_zero_3;\n  \n  byte_to_find = byte_to_find & 0xff;\n  if ((int)data_size < 0x10) {\njoined_r0x08000290:\n    do {\n      if (data_size == 0) {\n        return (byte *)0x0;\n      }\n      current_ptr = (uint *)((int)data + 1);\n      current_byte = *(byte *)data;\n      data_size = data_size - 1;\n      data = current_ptr;\n    } while (current_byte != byte_to_find);\n  }\n  else {\n    ptr_alignment = (uint)data & 7;\n    while( true ) {\n      if (ptr_alignment == 0) {\n        ptr_alignment = byte_to_find | byte_to_find << 8;\n        ptr_alignment = ptr_alignment | ptr_alignment << 0x10;\n        data_size_aligned = data_size & 0xfffffff8;\n        do {\n          current_ptr = data + 2;\n          data_size_aligned = data_size_aligned - 8;\n          xor_result_0 = *data ^ ptr_alignment;\n          xor_result_1 = data[1] ^ ptr_alignment;\n          is_zero_0 = -((char)xor_result_0 == '\\0');\n          is_zero_1 = -((char)(xor_result_0 >> 8) == '\\0');\n          is_zero_2 = -((char)(xor_result_0 >> 0x10) == '\\0');\n          is_zero_3 = -((char)(xor_result_0 >> 0x18) == '\\0');\n          xor_result_0 = CONCAT13(is_zero_3,CONCAT12(is_zero_2,CONCAT11(is_zero_1,is_zero_0)));\n          is_non_zero_0 = (char)xor_result_1 != '\\0';\n          is_non_zero_1 = (char)(xor_result_1 >> 8) != '\\0';\n          is_non_zero_2 = (char)(xor_result_1 >> 0x10) != '\\0';\n          is_non_zero_3 = (char)(xor_result_1 >> 0x18) != '\\0';\n          xor_result_1 = CONCAT13(is_non_zero_3 * is_zero_3 - !is_non_zero_3,\n                            CONCAT12(is_non_zero_2 * is_zero_2 - !is_non_zero_2,\n                                     CONCAT11(is_non_zero_1 * is_zero_1 - !is_non_zero_1,is_non_zero_0 * is_zero_0 - !is_non_zero_0)));\n          if (xor_result_1 != 0) {\n            if (xor_result_0 == 0) {\n              next_byte = (byte *)((int)data + 5);\n              xor_result_0 = xor_result_1;\n            }\n            else {\n              next_byte = (byte *)((int)data + 1);\n            }\n            if ((xor_result_0 & 1) == 0) {\n              is_non_zero_0 = (xor_result_0 & 0x100) == 0;\n              result = next_byte + 1;\n              if (is_non_zero_0) {\n                is_non_zero_0 = (xor_result_0 & 0x18000) == 0;\n                result = next_byte + 2;\n              }\n              next_byte = result;\n              if (is_non_zero_0) {\n                next_byte = next_byte + 1;\n              }\n            }\n            return next_byte + -1;\n          }\n          data = current_ptr;\n        } while (data_size_aligned != 0);\n        data_size = data_size & 7;\n        goto joined_r0x08000290;\n      }\n      current_ptr = (uint *)((int)data + 1);\n      data_size = data_size - 1;\n      if (*(byte *)data == byte_to_find) break;\n      ptr_alignment = (uint)current_ptr & 7;\n      data = current_ptr;\n      if (data_size == 0) {\n        return (byte *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)current_ptr + -1);\n}\n\n",
            "renaming": {
                "FUN_08000230": "find_byte_sequence_08000230",
                "param_1": "data",
                "param_2": "byte_to_find",
                "param_3": "data_size",
                "bVar1": "current_byte",
                "cVar2": "is_zero_0",
                "cVar3": "is_zero_1",
                "cVar4": "is_zero_2",
                "cVar5": "is_zero_3",
                "pbVar6": "result",
                "puVar7": "current_ptr",
                "pbVar8": "next_byte",
                "uVar9": "ptr_alignment",
                "uVar10": "data_size_aligned",
                "uVar11": "xor_result_0",
                "uVar12": "xor_result_1",
                "bVar13": "is_non_zero_0",
                "bVar14": "is_non_zero_1",
                "bVar15": "is_non_zero_2",
                "bVar16": "is_non_zero_3"
            },
            "calling": [
                "_printf_i",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002d0": {
            "entrypoint": "0x080002d0",
            "current_name": "calculate_division_or_concatenation_080002d0",
            "code": "\nundefined8 calculateDivisionOrConcatenation_080002d0(int input1,int input2,int check1,int check2)\n\n{\n  undefined8 result;\n  \n  if ((check2 == 0) && (check1 == 0)) {\n    if (input2 != 0 || input1 != 0) {\n      input2 = -1;\n      input1 = -1;\n    }\n    return CONCAT44(input2,input1);\n  }\n  result = __udivmoddi4();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080002d0": "calculate_division_or_concatenation_080002d0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "check1",
                "param_4": "check2",
                "uVar1": "result"
            },
            "calling": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "called": [
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000300": {
            "entrypoint": "0x08000300",
            "current_name": "divide_with_remainder_08000300",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080005aa) */\n\nulonglong divide_with_remainder_08000300(uint dividend,uint dividend_low,uint divisor,uint divisor_low,uint *remainder)\n\n{\n  ulonglong result_low;\n  uint temp;\n  uint result_high;\n  uint quotient;\n  uint temp1;\n  uint quotient_low;\n  uint temp2;\n  uint tmp;\n  uint quotient_high;\n  int shift;\n  bool carry;\n  \n  if (divisor_low == 0) {\n    if (dividend_low < divisor) {\n      shift = LZCOUNT(divisor);\n      if (shift != 0) {\n        divisor = divisor << shift;\n        dividend_low = dividend >> (0x20U - shift & 0xff) | dividend_low << shift;\n        dividend = dividend << shift;\n      }\n      tmp = divisor >> 0x10;\n      quotient_low = dividend_low / tmp;\n      temp1 = dividend >> 0x10 | (dividend_low - tmp * quotient_low) * 0x10000;\n      quotient = quotient_low * (divisor & 0xffff);\n      result_high = quotient_low;\n      if (temp1 <= quotient && quotient - temp1 != 0) {\n        carry = CARRY4(temp1,divisor);\n        temp1 = temp1 + divisor;\n        result_high = quotient_low - 1;\n        if ((carry == false) && (temp1 <= quotient && quotient - temp1 != 0)) {\n          result_high = quotient_low - 2;\n          temp1 = temp1 + divisor;\n        }\n      }\n      quotient_low = (temp1 - quotient) / tmp;\n      temp1 = dividend & 0xffff | ((temp1 - quotient) - tmp * quotient_low) * 0x10000;\n      tmp = quotient_low * (divisor & 0xffff);\n      quotient = quotient_low;\n      if (temp1 <= tmp && tmp - temp1 != 0) {\n        carry = CARRY4(temp1,divisor);\n        temp1 = temp1 + divisor;\n        quotient = quotient_low - 1;\n        if ((carry == false) && (temp1 <= tmp && tmp - temp1 != 0)) {\n          quotient = quotient_low - 2;\n          temp1 = temp1 + divisor;\n        }\n      }\n      temp1 = temp1 - tmp;\n      quotient = quotient | result_high << 0x10;\n      result_high = 0;\n    }\n    else {\n      if (divisor == 0) {\n        divisor = 1 / 0;\n      }\n      shift = LZCOUNT(divisor);\n      if (shift == 0) {\n        dividend_low = dividend_low - divisor;\n        temp1 = divisor >> 0x10;\n        quotient_high = divisor & 0xffff;\n        result_high = 1;\n      }\n      else {\n        divisor = divisor << shift;\n        temp1 = divisor >> 0x10;\n        quotient = dividend_low >> (0x20U - shift & 0xff);\n        temp2 = dividend >> (0x20U - shift & 0xff) | dividend_low << shift;\n        result_high = quotient / temp1;\n        quotient_high = divisor & 0xffff;\n        tmp = temp2 >> 0x10 | (quotient - temp1 * result_high) * 0x10000;\n        quotient_low = result_high * quotient_high;\n        dividend = dividend << shift;\n        quotient = result_high;\n        if (tmp <= quotient_low && quotient_low - tmp != 0) {\n          carry = CARRY4(tmp,divisor);\n          tmp = tmp + divisor;\n          quotient = result_high - 1;\n          if ((carry == false) && (tmp <= quotient_low && quotient_low - tmp != 0)) {\n            quotient = result_high - 2;\n            tmp = tmp + divisor;\n          }\n        }\n        temp = (tmp - quotient_low) / temp1;\n        dividend_low = temp2 & 0xffff | ((tmp - quotient_low) - temp1 * temp) * 0x10000;\n        quotient_low = temp * quotient_high;\n        result_high = temp;\n        if (dividend_low <= quotient_low && quotient_low - dividend_low != 0) {\n          carry = CARRY4(dividend_low,divisor);\n          dividend_low = dividend_low + divisor;\n          result_high = temp - 1;\n          if ((carry == false) && (dividend_low <= quotient_low && quotient_low - dividend_low != 0)) {\n            result_high = temp - 2;\n            dividend_low = dividend_low + divisor;\n          }\n        }\n        dividend_low = dividend_low - quotient_low;\n        result_high = result_high | quotient << 0x10;\n      }\n      temp2 = dividend_low / temp1;\n      tmp = dividend >> 0x10 | (dividend_low - temp1 * temp2) * 0x10000;\n      quotient = quotient_high * temp2;\n      quotient_low = temp2;\n      if (tmp <= quotient && quotient - tmp != 0) {\n        carry = CARRY4(tmp,divisor);\n        tmp = tmp + divisor;\n        quotient_low = temp2 - 1;\n        if ((carry == false) && (tmp <= quotient && quotient - tmp != 0)) {\n          quotient_low = temp2 - 2;\n          tmp = tmp + divisor;\n        }\n      }\n      temp2 = (tmp - quotient) / temp1;\n      temp1 = dividend & 0xffff | ((tmp - quotient) - temp1 * temp2) * 0x10000;\n      quotient_high = quotient_high * temp2;\n      quotient = temp2;\n      if (temp1 <= quotient_high && quotient_high - temp1 != 0) {\n        carry = CARRY4(temp1,divisor);\n        temp1 = temp1 + divisor;\n        quotient = temp2 - 1;\n        if ((carry == false) && (temp1 <= quotient_high && quotient_high - temp1 != 0)) {\n          quotient = temp2 - 2;\n          temp1 = temp1 + divisor;\n        }\n      }\n      temp1 = temp1 - quotient_high;\n      quotient = quotient | quotient_low << 0x10;\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = temp1 >> shift;\n      remainder[1] = 0;\n      return CONCAT44(result_high,quotient);\n    }\n  }\n  else if (dividend_low < divisor_low) {\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = dividend_low;\n      return 0;\n    }\n    quotient = 0;\n    result_high = 0;\n  }\n  else {\n    shift = LZCOUNT(divisor_low);\n    if (shift != 0) {\n      tmp = 0x20 - shift;\n      result_high = divisor >> (tmp & 0xff) | divisor_low << shift;\n      quotient_high = result_high >> 0x10;\n      quotient = dividend_low >> (tmp & 0xff);\n      temp = dividend >> (tmp & 0xff) | dividend_low << shift;\n      temp2 = quotient / quotient_high;\n      quotient_low = temp >> 0x10 | (quotient - quotient_high * temp2) * 0x10000;\n      temp1 = temp2 * (result_high & 0xffff);\n      dividend = dividend << shift;\n      quotient = temp2;\n      if (quotient_low <= temp1 && temp1 - quotient_low != 0) {\n        carry = CARRY4(quotient_low,result_high);\n        quotient_low = quotient_low + result_high;\n        quotient = temp2 - 1;\n        if ((carry == false) && (quotient_low <= temp1 && temp1 - quotient_low != 0)) {\n          quotient = temp2 - 2;\n          quotient_low = quotient_low + result_high;\n        }\n      }\n      temp2 = (quotient_low - temp1) / quotient_high;\n      quotient_low = temp & 0xffff | ((quotient_low - temp1) - quotient_high * temp2) * 0x10000;\n      quotient_high = temp2 * (result_high & 0xffff);\n      temp1 = temp2;\n      if (quotient_low <= quotient_high && quotient_high - quotient_low != 0) {\n        carry = CARRY4(quotient_low,result_high);\n        quotient_low = quotient_low + result_high;\n        temp1 = temp2 - 1;\n        if ((carry == false) && (quotient_low <= quotient_high && quotient_high - quotient_low != 0)) {\n          temp1 = temp2 - 2;\n          quotient_low = quotient_low + result_high;\n        }\n      }\n      temp1 = temp1 | quotient << 0x10;\n      result_low = (ulonglong)temp1 * (ulonglong)(divisor << shift);\n      if (CONCAT44(quotient_low - quotient_high,dividend) < result_low) {\n        result_low = result_low - CONCAT44(result_high,divisor << shift);\n        temp1 = temp1 - 1;\n      }\n      if (remainder != (uint *)0x0) {\n        quotient = ((quotient_low - quotient_high) - (int)(result_low >> 0x20)) - (uint)(dividend < (uint)result_low);\n        *remainder = quotient << (tmp & 0xff) | dividend - (uint)result_low >> shift;\n        remainder[1] = quotient >> shift;\n      }\n      return (ulonglong)temp1;\n    }\n    if ((divisor_low < dividend_low) || (divisor <= dividend)) {\n      carry = dividend < divisor;\n      dividend = dividend - divisor;\n      dividend_low = (dividend_low - divisor_low) - (uint)carry;\n      quotient = 1;\n    }\n    else {\n      quotient = 0;\n    }\n    result_high = 0;\n    if (remainder != (uint *)0x0) {\n      *remainder = dividend;\n      remainder[1] = dividend_low;\n      return (ulonglong)quotient;\n    }\n  }\n  return CONCAT44(result_high,quotient);\n}\n\n",
            "renaming": {
                "FUN_08000300": "divide_with_remainder_08000300",
                "param_1": "dividend",
                "param_2": "dividend_low",
                "param_3": "divisor",
                "param_4": "divisor_low",
                "param_5": "remainder",
                "uVar1": "result_low",
                "uVar2": "temp",
                "uVar3": "result_high",
                "uVar4": "quotient",
                "uVar5": "temp1",
                "uVar6": "quotient_low",
                "uVar7": "temp2",
                "uVar8": "tmp",
                "uVar9": "quotient_high",
                "iVar10": "shift",
                "bVar11": "carry"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005e0": {
            "entrypoint": "0x080005e0",
            "current_name": "send_software_interrupt_080005e0",
            "code": "\nvoid sendSoftwareInterrupt_080005e0(void)\n\n{\n  software_interrupt(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080005e0": "send_software_interrupt_080005e0"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005e4": {
            "entrypoint": "0x080005e4",
            "current_name": "execute_afl_call_080005e4",
            "code": "\nundefined4 executeAflCall_080005e4(undefined4 inputValue,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  undefined4 result;\n  \n  if (DAT_20000120 != 0) {\n    return 0;\n  }\n  result = aflCall(1,inputValue,0,0,param4);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080005e4": "execute_afl_call_080005e4",
                "param_1": "inputValue",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "result"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000600": {
            "entrypoint": "0x08000600",
            "current_name": "initialize_device_08000600",
            "code": "\nvoid initializeDevice_08000600(int **devicePtr,undefined4 param2)\n\n{\n  char status;\n  int retVal;\n  \n  status = *(char *)((int)devicePtr + 5);\n  if (status == '\\x02') {\n    *devicePtr = &DAT_20000338;\n  }\n  else if (status == '\\x03') {\n    *devicePtr = &DAT_20000338;\n  }\n  else if (status == '\\x01') {\n    *devicePtr = &DAT_20000338;\n  }\n  else {\n    *devicePtr = &DAT_20000338;\n  }\n  begin(*devicePtr,param2,6);\n  if (1 < *(byte *)((int)devicePtr + 6)) {\n    pinMode(*(byte *)((int)devicePtr + 6),1);\n    digitalWrite(*(undefined *)((int)devicePtr + 6),0);\n  }\n  do {\n    retVal = (**(code **)(**devicePtr + 0xc))();\n  } while (-1 < retVal);\n  *(undefined *)((int)devicePtr + 0x49) = 0;\n  *(undefined *)((int)devicePtr + 0x4a) = 0;\n  *(undefined2 *)(devicePtr + 0x15) = 0;\n  *(undefined2 *)((int)devicePtr + 0x52) = 0;\n  *(undefined2 *)(devicePtr + 0x14) = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000600": "initialize_device_08000600",
                "param_1": "devicePtr",
                "param_2": "param2",
                "cVar1": "status",
                "iVar2": "retVal"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "digitalWrite",
                "pinMode",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800066c": {
            "entrypoint": "0x0800066c",
            "current_name": "initialize_data_0800066c",
            "code": "\nvoid initializeData_0800066c(int dataPointer,undefined newValue,int limit,undefined extraData)\n\n{\n  *(undefined *)(dataPointer + 4) = newValue;\n  if (3 < limit) {\n    limit = 0;\n  }\n  *(char *)(dataPointer + 5) = (char)limit;\n  *(undefined *)(dataPointer + 6) = extraData;\n  *(undefined2 *)(dataPointer + 0x56) = 1000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800066c": "initialize_data_0800066c",
                "param_1": "dataPointer",
                "param_2": "newValue",
                "param_3": "limit",
                "param_4": "extraData"
            },
            "calling": [
                "Modbus"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000682": {
            "entrypoint": "0x08000682",
            "current_name": "initialize_and_return_08000682",
            "code": "\nundefined4 initialize_and_return_08000682(undefined4 input_param)\n\n{\n  initialize_data();\n  return input_param;\n}\n\n",
            "renaming": {
                "FUN_08000682": "initialize_and_return_08000682",
                "param_1": "input_param",
                "initialize_data_0800066c": "initialize_data"
            },
            "calling": [
                "FUN_08000690"
            ],
            "called": [
                "FUN_0800066c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000690": {
            "entrypoint": "0x08000690",
            "current_name": "check_and_execute_modbus_08000690",
            "code": "\nvoid check_and_execute_modbus_08000690(int input_value,int special_value,undefined4 reserved_1,undefined4 reserved_2)\n\n{\n  if (input_value != 1) {\n    return;\n  }\n  if (special_value == 0xffff) {\n    Modbus(&DAT_20000124,1,0,0,reserved_2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000690": "check_and_execute_modbus_08000690",
                "param_1": "input_value",
                "param_2": "special_value",
                "param_3": "reserved_1",
                "param_4": "reserved_2"
            },
            "calling": [],
            "called": [
                "Modbus"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006b4": {
            "entrypoint": "0x080006b4",
            "current_name": "process_data_080006b4",
            "code": "\nint processData_080006b4(int **data)\n\n{\n  bool isFull;\n  undefined result;\n  int returnValue;\n  byte index;\n  \n  if (1 < *(byte *)((int)data + 6)) {\n    turnOffPin(*(byte *)((int)data + 6),0);\n  }\n  *(undefined *)((int)data + 0x49) = 0;\n  if (*(byte *)((int)data + 5) < 4) {\n    isFull = false;\n    while (returnValue = (**(code **)(**data + 8))(), returnValue != 0) {\n      index = *(byte *)((int)data + 0x49);\n      result = (**(code **)(**data + 0xc))();\n      *(undefined *)((int)data + index + 9) = result;\n      index = *(char *)((int)data + 0x49) + 1;\n      *(byte *)((int)data + 0x49) = index;\n      if (0x3f < index) {\n        isFull = true;\n      }\n    }\n  }\n  else {\n    isFull = false;\n  }\n  *(short *)(data + 0x14) = *(short *)(data + 0x14) + 1;\n  if (isFull) {\n    *(short *)(data + 0x15) = *(short *)(data + 0x15) + 1;\n    return -3;\n  }\n  return (int)*(char *)((int)data + 0x49);\n}\n\n",
            "renaming": {
                "FUN_080006b4": "process_data_080006b4",
                "param_1": "data",
                "bVar1": "isFull",
                "uVar2": "result",
                "iVar3": "returnValue",
                "bVar4": "index",
                "digitalWrite": "turnOffPin"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000728": {
            "entrypoint": "0x08000728",
            "current_name": "calculate_checksum_08000728",
            "code": "\nuint calculateChecksum_08000728(int dataAddress,int dataLength)\n\n{\n  byte bitIndex;\n  uint checksum;\n  uint bit;\n  uint byteIndex;\n  \n  checksum = 0xffff;\n  for (byteIndex = 0; (int)byteIndex < dataLength; byteIndex = byteIndex + 1 & 0xff) {\n    checksum = checksum ^ *(byte *)(dataAddress + byteIndex + 9);\n    for (bitIndex = 1; bitIndex < 9; bitIndex = bitIndex + 1) {\n      bit = checksum & 1;\n      checksum = checksum >> 1;\n      if (bit != 0) {\n        checksum = checksum ^ 0xa001;\n      }\n    }\n  }\n  return (checksum & 0xff) << 8 | checksum >> 8;\n}\n\n",
            "renaming": {
                "FUN_08000728": "calculate_checksum_08000728",
                "param_1": "dataAddress",
                "param_2": "dataLength",
                "bVar1": "bitIndex",
                "uVar2": "checksum",
                "uVar3": "bit",
                "uVar4": "byteIndex"
            },
            "calling": [
                "sendTxBuffer"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800076c": {
            "entrypoint": "0x0800076c",
            "current_name": "update_crc_and_time_0800076c",
            "code": "\nvoid updateCRCAndTime_0800076c(int **data,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  undefined2 calculatedCRC;\n  int result;\n  uint num;\n  \n  num = (uint)*(byte *)((int)data + 0x49);\n  calculatedCRC = calculateCRC(data,num,param3,param4,param4);\n  *(char *)((int)data + num + 9) = (char)((ushort)calculatedCRC >> 8);\n  num = num + 1 & 0xff;\n  *(char *)((int)data + num + 9) = (char)calculatedCRC;\n  *(char *)((int)data + 0x49) = (char)num + '\\x01';\n  if (1 < *(byte *)((int)data + 6)) {\n    digitalWrite(*(byte *)((int)data + 6),1);\n  }\n  if (*(byte *)((int)data + 5) < 4) {\n    (**(code **)(**data + 4))(*data,(int)data + 9,*(undefined *)((int)data + 0x49));\n  }\n  if (1 < *(byte *)((int)data + 6)) {\n    digitalWrite(*(byte *)((int)data + 6),0);\n  }\n  if (*(byte *)((int)data + 5) < 4) {\n    do {\n      result = (**(code **)(**data + 0xc))();\n    } while (-1 < result);\n  }\n  *(undefined *)((int)data + 0x49) = 0;\n  result = millis();\n  data[0x17] = (int *)(result + (uint)*(ushort *)((int)data + 0x56));\n  *(short *)((int)data + 0x52) = *(short *)((int)data + 0x52) + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800076c": "update_crc_and_time_0800076c",
                "param_1": "data",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "calculatedCRC",
                "iVar2": "result",
                "uVar3": "num",
                "calcCRC": "calculateCRC"
            },
            "calling": [
                "process_FC3",
                "poll",
                "process_FC15",
                "process_FC6",
                "process_FC5",
                "process_FC16",
                "process_FC1"
            ],
            "called": [
                "digitalWrite",
                "calcCRC",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080007f0": {
            "entrypoint": "0x080007f0",
            "current_name": "check_condition_and_update_counter_080007f0",
            "code": "\nundefined4 check_condition_and_update_counter_080007f0(int data_address,undefined4 second_parameter,uint value_1,undefined4 value_2)\n\n{\n  bool is_match;\n  byte result_byte;\n  char result_1;\n  char result_2;\n  int result_3;\n  uint loop_counter;\n  int result_4;\n  \n  loop_counter = 0;\n  do {\n    if (7 < loop_counter) {\n      is_match = false;\nLAB_0800080a:\n      if (!is_match) {\n        *(short *)(data_address + 0x54) = *(short *)(data_address + 0x54) + 1;\n        return 1;\n      }\n      result_4 = *(byte *)(data_address + 10) - 1;\n      switch(*(byte *)(data_address + 10)) {\n      case 1:\n      case 2:\n      case 0xf:\n        goto switchD_08000816_caseD_1;\n      case 3:\n      case 4:\n      case 0x10:\n        result_1 = makeWord(*(undefined *)(data_address + 0xb),*(undefined *)(data_address + 0xc),value_1,result_4,\n                         value_2);\n        result_2 = makeWord(*(undefined *)(data_address + 0xd),*(undefined *)(data_address + 0xe));\n        if (*(byte *)(data_address + 0x60) < (byte)(result_2 + result_1)) {\n          return 2;\n        }\n        return 0;\n      case 5:\n        result_4 = makeWord(*(undefined *)(data_address + 0xb),*(undefined *)(data_address + 0xc),value_1,result_4,\n                         value_2);\n        if ((uint)*(byte *)(data_address + 0x60) < (uint)(result_4 << 0x14) >> 0x18) {\n          return 2;\n        }\n        return 0;\n      case 6:\n        result_byte = makeWord(*(undefined *)(data_address + 0xb),*(undefined *)(data_address + 0xc),value_1,result_4,\n                         value_2);\n        if (*(byte *)(data_address + 0x60) < result_byte) {\n          return 2;\n        }\n        return 0;\n      default:\n        return 0;\n      }\n    }\n    value_1 = (uint)*(byte *)(data_address + 10);\n    if ((byte)(&DAT_08005a10)[loop_counter] == value_1) {\n      is_match = true;\n      goto LAB_0800080a;\n    }\n    loop_counter = loop_counter + 1 & 0xff;\n  } while( true );\nswitchD_08000816_caseD_1:\n  result_4 = makeWord(*(undefined *)(data_address + 0xb),*(undefined *)(data_address + 0xc),value_1,result_4,value_2\n                  );\n  result_3 = makeWord(*(undefined *)(data_address + 0xd),*(undefined *)(data_address + 0xe));\n  if ((uint)*(byte *)(data_address + 0x60) <\n      (((uint)(result_4 << 0xc) >> 0x10) + ((uint)(result_3 << 0xc) >> 0x10) & 0xff)) {\n    return 2;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080007f0": "check_condition_and_update_counter_080007f0",
                "param_1": "data_address",
                "param_2": "second_parameter",
                "param_3": "value_1",
                "param_4": "value_2",
                "bVar1": "is_match",
                "bVar2": "result_byte",
                "cVar3": "result_1",
                "cVar4": "result_2",
                "iVar5": "result_3",
                "uVar6": "loop_counter",
                "iVar7": "result_4"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008cc": {
            "entrypoint": "0x080008cc",
            "current_name": "copy_data_080008cc",
            "code": "\nvoid copyData_080008cc(int dataPtr,undefined newValue)\n\n{\n  *(undefined *)(dataPtr + 9) = *(undefined *)(dataPtr + 4);\n  *(byte *)(dataPtr + 10) = *(byte *)(dataPtr + 10) ^ 0x80;\n  *(undefined *)(dataPtr + 0xb) = newValue;\n  *(undefined *)(dataPtr + 0x49) = 3;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080008cc": "copy_data_080008cc",
                "param_1": "dataPtr",
                "param_2": "newValue"
            },
            "calling": [
                "poll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008e2": {
            "entrypoint": "0x080008e2",
            "current_name": "update_tx_buffer_080008e2",
            "code": "\nint updateTxBuffer_080008e2(int buffer,int data,undefined4 param3,undefined4 param4)\n\n{\n  int wordValue;\n  uint length;\n  uint i;\n  uint bitIndex;\n  char shiftedValue;\n  int baseAddress;\n  \n  wordValue = makeWord(*(undefined *)(buffer + 0xb),*(undefined *)(buffer + 0xc),param3,param4,\n                   param4);\n  length = makeWord(*(undefined *)(buffer + 0xd),*(undefined *)(buffer + 0xe));\n  shiftedValue = (char)((length << 0x15) >> 0x18);\n  if ((length & 7) != 0) {\n    shiftedValue = shiftedValue + '\\x01';\n  }\n  *(char *)(buffer + 0xb) = shiftedValue;\n  *(undefined *)(buffer + 0x49) = 3;\n  bitIndex = 0;\n  for (i = 0; (int)i < (int)length; i = i + 1 & 0xffff) {\n    if (((int)(uint)*(ushort *)(data + ((i + wordValue) * 0x100000 >> 0x18) * 2) >>\n         (i + wordValue & 0xf) & 1U) == 0) {\n      baseAddress = (uint)*(byte *)(buffer + 0x49) + buffer;\n      *(byte *)(baseAddress + 9) = *(byte *)(baseAddress + 9) & ~(byte)(1 << bitIndex);\n    }\n    else {\n      baseAddress = (uint)*(byte *)(buffer + 0x49) + buffer;\n      *(byte *)(baseAddress + 9) = *(byte *)(baseAddress + 9) | (byte)(1 << bitIndex);\n    }\n    bitIndex = bitIndex + 1 & 0xff;\n    if (7 < bitIndex) {\n      *(char *)(buffer + 0x49) = *(char *)(buffer + 0x49) + '\\x01';\n      bitIndex = 0;\n    }\n  }\n  if ((length & 7) != 0) {\n    *(char *)(buffer + 0x49) = *(char *)(buffer + 0x49) + '\\x01';\n  }\n  shiftedValue = *(char *)(buffer + 0x49);\n  sendTxBuffer(buffer);\n  return (int)(char)(shiftedValue + '\\x02');\n}\n\n",
            "renaming": {
                "FUN_080008e2": "update_tx_buffer_080008e2",
                "param_1": "buffer",
                "param_2": "data",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "wordValue",
                "uVar2": "length",
                "uVar3": "i",
                "uVar4": "bitIndex",
                "cVar5": "shiftedValue",
                "iVar6": "baseAddress"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "process_data_08000998",
            "code": "\nint processData_08000998(int data,int buffer,undefined4 param_3,undefined4 param_4)\n\n{\n  byte tempByte;\n  char tempChar;\n  byte word1;\n  byte word2;\n  uint i;\n  uint j;\n  \n  word1 = makeWord(*(undefined *)(data + 0xb),*(undefined *)(data + 0xc),param_3,param_4,\n                   param_4);\n  word2 = makeWord(*(undefined *)(data + 0xd),*(undefined *)(data + 0xe));\n  *(byte *)(data + 0xb) = word2 << 1;\n  *(undefined *)(data + 0x49) = 3;\n  for (i = (uint)word1; i < (uint)word1 + (uint)word2; i = i + 1 & 0xff) {\n    tempByte = *(byte *)(data + 0x49);\n    *(char *)(data + (uint)tempByte + 9) = (char)((ushort)*(undefined2 *)(buffer + i * 2) >> 8)\n    ;\n    j = tempByte + 1 & 0xff;\n    tempChar = (char)j;\n    *(char *)(data + 0x49) = tempChar;\n    *(undefined *)(data + j + 9) = *(undefined *)(buffer + i * 2);\n    *(char *)(data + 0x49) = tempChar + '\\x01';\n  }\n  tempChar = *(char *)(data + 0x49);\n  sendTxBuffer(data);\n  return (int)(char)(tempChar + '\\x02');\n}\n\n",
            "renaming": {
                "FUN_08000998": "process_data_08000998",
                "param_1": "data",
                "param_2": "buffer",
                "bVar1": "tempByte",
                "cVar2": "tempChar",
                "bVar3": "word1",
                "bVar4": "word2",
                "uVar5": "i",
                "uVar6": "j"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a00": {
            "entrypoint": "0x08000a00",
            "current_name": "update_data_and_send_08000a00",
            "code": "\nundefined4 updateDataAndSend_08000a00(int dataAddress,int bufferAddress,undefined4 param3,undefined4 param4)\n\n{\n  uint wordValue;\n  uint shiftedValue;\n  \n  wordValue = makeWord(*(undefined *)(dataAddress + 0xb),*(undefined *)(dataAddress + 0xc),param3,param4,\n                   param4);\n  shiftedValue = (wordValue << 0x14) >> 0x18;\n  if (*(char *)(dataAddress + 0xd) == -1) {\n    *(ushort *)(bufferAddress + shiftedValue * 2) =\n         (ushort)(1 << (wordValue & 0xf)) | *(ushort *)(bufferAddress + shiftedValue * 2);\n  }\n  else {\n    *(ushort *)(bufferAddress + shiftedValue * 2) =\n         *(ushort *)(bufferAddress + shiftedValue * 2) & ~(ushort)(1 << (wordValue & 0xf));\n  }\n  *(undefined *)(dataAddress + 0x49) = 6;\n  sendBuffer(dataAddress);\n  return 8;\n}\n\n",
            "renaming": {
                "FUN_08000a00": "update_data_and_send_08000a00",
                "param_1": "dataAddress",
                "param_2": "bufferAddress",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "wordValue",
                "uVar2": "shiftedValue",
                "sendTxBuffer": "sendBuffer"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a4e": {
            "entrypoint": "0x08000a4e",
            "current_name": "update_buffer_and_send_08000a4e",
            "code": "\nundefined4 updateBufferAndSend_08000a4e(int inputBufferAddress,int outputBufferAddress)\n\n{\n  byte firstWord;\n  undefined2 secondWord;\n  \n  firstWord = makeWord(*(undefined *)(inputBufferAddress + 0xb),*(undefined *)(inputBufferAddress + 0xc));\n  secondWord = makeWord(*(undefined *)(inputBufferAddress + 0xd),*(undefined *)(inputBufferAddress + 0xe));\n  *(undefined2 *)(outputBufferAddress + (uint)firstWord * 2) = secondWord;\n  *(undefined *)(inputBufferAddress + 0x49) = 6;\n  sendTxBuffer(inputBufferAddress);\n  return 8;\n}\n\n",
            "renaming": {
                "FUN_08000a4e": "update_buffer_and_send_08000a4e",
                "param_1": "inputBufferAddress",
                "param_2": "outputBufferAddress",
                "bVar1": "firstWord",
                "uVar2": "secondWord"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a7a": {
            "entrypoint": "0x08000a7a",
            "current_name": "update_buffer_08000a7a",
            "code": "\nundefined4 updateBuffer_08000a7a(int buffer1,int buffer2,undefined4 param3,undefined4 param4)\n\n{\n  int word1;\n  int word2;\n  uint counter1;\n  uint counter2;\n  uint bitPosition;\n  uint bufferOffset;\n  uint byteOffset;\n  \n  word1 = makeWord(*(undefined *)(buffer1 + 0xb),*(undefined *)(buffer1 + 0xc),param3,param4,\n                   param4);\n  word2 = makeWord(*(undefined *)(buffer1 + 0xd),*(undefined *)(buffer1 + 0xe));\n  counter2 = 0;\n  byteOffset = 7;\n  for (counter1 = 0; (int)counter1 < word2; counter1 = counter1 + 1 & 0xffff) {\n    bufferOffset = (counter1 + word1) * 0x100000 >> 0x18;\n    bitPosition = counter1 + word1 & 0xf;\n    if (((int)(uint)*(byte *)(buffer1 + byteOffset + 9) >> counter2 & 1U) == 0) {\n      *(ushort *)(buffer2 + bufferOffset * 2) = *(ushort *)(buffer2 + bufferOffset * 2) & ~(ushort)(1 << bitPosition);\n    }\n    else {\n      *(ushort *)(buffer2 + bufferOffset * 2) = (ushort)(1 << bitPosition) | *(ushort *)(buffer2 + bufferOffset * 2);\n    }\n    counter2 = counter2 + 1 & 0xff;\n    if (7 < counter2) {\n      byteOffset = byteOffset + 1 & 0xff;\n      counter2 = 0;\n    }\n  }\n  *(undefined *)(buffer1 + 0x49) = 6;\n  sendTxBuffer(buffer1);\n  return 8;\n}\n\n",
            "renaming": {
                "FUN_08000a7a": "update_buffer_08000a7a",
                "param_1": "buffer1",
                "param_2": "buffer2",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "word1",
                "iVar2": "word2",
                "uVar3": "counter1",
                "uVar4": "counter2",
                "uVar5": "bitPosition",
                "uVar6": "bufferOffset",
                "uVar7": "byteOffset"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b04": {
            "entrypoint": "0x08000b04",
            "current_name": "process_data_08000b04",
            "code": "\nint processData_08000b04(int bufferAddress,int outputAddress)\n\n{\n  byte byte1;\n  byte byte2;\n  char char1;\n  undefined2 word;\n  uint index;\n  \n  byte1 = *(byte *)(bufferAddress + 0xc);\n  byte2 = *(byte *)(bufferAddress + 0xe);\n  *(undefined *)(bufferAddress + 0xd) = 0;\n  *(byte *)(bufferAddress + 0xe) = byte2;\n  *(undefined *)(bufferAddress + 0x49) = 6;\n  for (index = 0; index < byte2; index = index + 1 & 0xff) {\n    word = makeWord(*(undefined *)(index * 2 + bufferAddress + 0x10),\n                     *(undefined *)(bufferAddress + (index + 4) * 2 + 9));\n    *(undefined2 *)(outputAddress + (byte1 + index) * 2) = word;\n  }\n  char1 = *(char *)(bufferAddress + 0x49);\n  sendTxBuffer(bufferAddress);\n  return (int)(char)(char1 + '\\x02');\n}\n\n",
            "renaming": {
                "FUN_08000b04": "process_data_08000b04",
                "param_1": "bufferAddress",
                "param_2": "outputAddress",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "cVar3": "char1",
                "uVar4": "word",
                "uVar5": "index"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b54": {
            "entrypoint": "0x08000b54",
            "current_name": "process_request_08000b54",
            "code": "\nint processRequest_08000b54(int **requestParams,int *response,undefined4 statusCode)\n\n{\n  byte result;\n  int validationResult;\n  uint bufferSize;\n  int returnValue;\n  \n  requestParams[0x13] = response;\n  *(char *)(requestParams + 0x18) = (char)statusCode;\n  if (*(byte *)((int)requestParams + 5) < 4) {\n    result = (**(code **)(**requestParams + 8))();\n    bufferSize = (uint)result;\n  }\n  if (bufferSize == 0) {\n    returnValue = 0;\n  }\n  else if ((int)bufferSize < 8) {\n    returnValue = 0;\n  }\n  else {\n    returnValue = getRxBuffer(requestParams);\n    *(char *)(requestParams + 2) = (char)returnValue;\n    if (*(char *)((int)requestParams + 9) == *(char *)(requestParams + 1)) {\n      validationResult = validateRequest(requestParams);\n      if (validationResult < 1) {\n        validationResult = millis();\n        requestParams[0x17] = (int *)((uint)*(ushort *)((int)requestParams + 0x56) + validationResult);\n        *(undefined *)(requestParams + 2) = 0;\n        switch(*(undefined *)((int)requestParams + 10)) {\n        case 1:\n        case 2:\n          returnValue = process_FC1(requestParams,response,statusCode);\n          break;\n        case 3:\n        case 4:\n          returnValue = process_FC3(requestParams,response,statusCode);\n          break;\n        case 5:\n          returnValue = process_FC5(requestParams,response,statusCode);\n          break;\n        case 6:\n          returnValue = process_FC6(requestParams,response,statusCode);\n          break;\n        case 0xf:\n          returnValue = process_FC15(requestParams,response,statusCode);\n          break;\n        case 0x10:\n          returnValue = process_FC16(requestParams,response,statusCode);\n        }\n      }\n      else {\n        if (validationResult != 0xff) {\n          buildException(requestParams,validationResult);\n          sendTxBuffer(requestParams);\n        }\n        *(char *)(requestParams + 2) = (char)validationResult;\n        returnValue = (int)(char)validationResult;\n      }\n    }\n    else {\n      returnValue = 0;\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08000b54": "process_request_08000b54",
                "param_1": "requestParams",
                "param_2": "response",
                "param_3": "statusCode",
                "bVar1": "result",
                "iVar2": "validationResult",
                "unaff_r5": "bufferSize",
                "iVar3": "returnValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "buildException",
                "process_FC3",
                "process_FC15",
                "getRxBuffer",
                "process_FC6",
                "validateRequest",
                "process_FC5",
                "process_FC16",
                "millis",
                "process_FC1",
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c4c": {
            "entrypoint": "0x08000c4c",
            "current_name": "initialize_device_08000c4c",
            "code": "\nvoid initialize_device_08000c4c(void)\n\n{\n  start_fork_server(0);\n  initialize_device_08000c4c_data(&DAT_20000124,0x4b00);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c4c": "initialize_device_08000c4c",
                "startForkserver": "start_fork_server",
                "initialize_device_08000600": "initialize_device_data"
            },
            "calling": [
                "main"
            ],
            "called": [
                "startForkserver",
                "FUN_08000600"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c64": {
            "entrypoint": "0x08000c64",
            "current_name": "poll_and_handle_events_08000c64",
            "code": "\nvoid poll_and_handle_events_08000c64(void)\n\n{\n  undefined4 event_handler_address;\n  \n  poll(&DAT_20000124,&DAT_20000004,0x10,event_handler_address,event_handler_address);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c64": "poll_and_handle_events_08000c64",
                "in_r3": "event_handler_address"
            },
            "calling": [
                "main"
            ],
            "called": [
                "poll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c8c": {
            "entrypoint": "0x08000c8c",
            "current_name": "initialize_system_08000c8c",
            "code": "\n\n\nvoid initializeSystem_08000c8c(void)\n\n{\n  uint hclkFrequency;\n  undefined4 oscillatorConfig;\n  undefined4 oscillatorFrequency;\n  undefined4 powerMode;\n  undefined4 clockSource;\n  undefined4 clockDivider;\n  undefined4 systemClock;\n  undefined4 systickDivider;\n  undefined4 systickClockSource;\n  undefined4 flashLatency;\n  undefined4 ahbPrescaler;\n  undefined4 apb1Prescaler;\n  undefined4 apb2Prescaler;\n  undefined4 timerPrescaler;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0xc000;\n  oscillatorConfig = 1;\n  oscillatorFrequency = 0x50000;\n  powerMode = 2;\n  clockSource = 0x400000;\n  clockDivider = 8;\n  systemClock = 0x150;\n  systickDivider = 2;\n  systickClockSource = 7;\n  HAL_RCC_OscConfig(&oscillatorConfig);\n  HAL_PWREx_EnableOverDrive();\n  flashLatency = 0xf;\n  ahbPrescaler = 2;\n  apb1Prescaler = 0;\n  apb2Prescaler = 0x1400;\n  timerPrescaler = 0x1000;\n  HAL_RCC_ClockConfig(&flashLatency,5);\n  hclkFrequency = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFrequency / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(0xffffffff,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c8c": "initialize_system_08000c8c",
                "local_54": "oscillatorConfig",
                "local_50": "oscillatorFrequency",
                "local_3c": "powerMode",
                "local_38": "clockSource",
                "local_34": "clockDivider",
                "local_30": "systemClock",
                "local_2c": "systickDivider",
                "local_28": "systickClockSource",
                "local_24": "flashLatency",
                "local_20": "ahbPrescaler",
                "local_1c": "apb1Prescaler",
                "local_18": "apb2Prescaler",
                "local_14": "timerPrescaler",
                "uVar1": "hclkFrequency"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig",
                "HAL_PWREx_EnableOverDrive",
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d3c": {
            "entrypoint": "0x08000d3c",
            "current_name": "initialize_system_08000d3c",
            "code": "\n/* WARNING: This function may have set the stack pointer */\n\nvoid initializeSystem_08000d3c(void)\n\n{\n  int i;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (i = 0; (undefined4 *)(i + 0x20000000) < &DAT_20000104; i = i + 4) {\n    *(undefined4 *)(i + 0x20000000) = *(undefined4 *)(i + 0x8006034);\n  }\n  for (ptr = &DAT_20000104; ptr < &DAT_20000678; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x8000d72;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08000d72. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d3c": "initialize_system_08000d3c",
                "iVar1": "i",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "main",
                "__libc_init_array",
                "SystemInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d8e": {
            "entrypoint": "0x08000d8e",
            "current_name": "initialize_hardware_configuration_08000d8e",
            "code": "\nvoid initializeHardwareConfiguration_08000d8e(void)\n\n{\n  initializeHardware();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d8e": "initialize_hardware_configuration_08000d8e",
                "hw_config_init": "initializeHardware"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d96": {
            "entrypoint": "0x08000d96",
            "current_name": "FUNC_08000d96",
            "code": "\nvoid FUNC_08000d96(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d96": "FUNC_08000d96"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000d98": {
            "entrypoint": "0x08000d98",
            "current_name": "initialize_system_tick_08000d98",
            "code": "\nundefined4 initializeSystemTick_08000d98(uint priority)\n\n{\n  int configResult;\n  \n  configResult = configureSystemTick(DAT_2000002c / (1000 / DAT_20000024));\n  if (configResult != 0) {\n    return 1;\n  }\n  if (0xf < priority) {\n    return 1;\n  }\n  setInterruptPriority(0xffffffff,priority,0);\n  DAT_20000028 = priority;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000d98": "initialize_system_tick_08000d98",
                "param_1": "priority",
                "iVar1": "configResult",
                "HAL_SYSTICK_Config": "configureSystemTick",
                "HAL_NVIC_SetPriority": "setInterruptPriority"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000de4": {
            "entrypoint": "0x08000de4",
            "current_name": "initialize_hardware_08000de4",
            "code": "\n\n\nundefined4 initializeHardware_08000de4(void)\n\n{\n  _DAT_40023c00 = _DAT_40023c00 | 0x700;\n  setInterruptPriorityGroup(3);\n  initializeTick(0xf);\n  initializeHardware_08000de4Specific();\n  status 0;\n}\n\n",
            "renaming": {
                "FUN_08000de4": "initialize_hardware_08000de4",
                "HAL_NVIC_SetPriorityGrouping": "setInterruptPriorityGroup",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializeHardwareSpecific",
                "return": "status"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_InitTick",
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e18": {
            "entrypoint": "0x08000e18",
            "current_name": "increment_and_add_08000e18",
            "code": "\nvoid incrementAndAdd_08000e18(void)\n\n{\n  DAT_20000670 = (uint)DAT_20000024 + DAT_20000670;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e18": "increment_and_add_08000e18"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e30": {
            "entrypoint": "0x08000e30",
            "current_name": "get_data_value_08000e30",
            "code": "\nundefined4 get_data_value_08000e30(void)\n\n{\n  return DAT_20000670;\n}\n\n",
            "renaming": {
                "FUN_08000e30": "get_data_value_08000e30"
            },
            "calling": [
                "UART_WaitOnFlagUntilTimeout",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig",
                "uart_debug_write",
                "HAL_UART_Transmit",
                "HAL_PWREx_EnableOverDrive",
                "GetCurrentMilli"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e3c": {
            "entrypoint": "0x08000e3c",
            "current_name": "update_register_value_08000e3c",
            "code": "\n\n\nvoid updateRegisterValue_08000e3c(uint inputValue)\n\n{\n  _DAT_e000ed0c = (inputValue & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e3c": "update_register_value_08000e3c",
                "param_1": "inputValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e60": {
            "entrypoint": "0x08000e60",
            "current_name": "update_data_08000e60",
            "code": "\n\n\nvoid updateData_08000e60(uint targetAddress,uint data1,uint data2)\n\n{\n  uint shiftAmount;\n  uint limit;\n  \n  shiftAmount = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  limit = 7 - shiftAmount;\n  if (3 < limit) {\n    limit = 4;\n  }\n  if (shiftAmount + 4 < 7) {\n    shiftAmount = 0;\n  }\n  else {\n    shiftAmount = shiftAmount - 3;\n  }\n  shiftAmount = (data1 & (1 << (limit & 0xff)) - 1U) << (shiftAmount & 0xff) |\n          (1 << (shiftAmount & 0xff)) - 1U & data2;\n  if ((int)targetAddress < 0) {\n    *(char *)((targetAddress & 0xf) + 0xe000ed14) = (char)(shiftAmount << 4);\n  }\n  else {\n    *(char *)(targetAddress + 0xe000e400) = (char)(shiftAmount << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e60": "update_data_08000e60",
                "param_1": "targetAddress",
                "param_2": "data1",
                "param_3": "data2",
                "uVar1": "shiftAmount",
                "uVar2": "limit"
            },
            "calling": [
                "uart_attach_rx_callback",
                "HAL_InitTick",
                "uart_attach_tx_callback",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ec4": {
            "entrypoint": "0x08000ec4",
            "current_name": "set_bit_at_position_08000ec4",
            "code": "\nvoid setBitAtPosition_08000ec4(uint bitPosition)\n\n{\n  if (-1 < (int)bitPosition) {\n    *(int *)((bitPosition >> 5) * 4 + -0x1fff1f00) = 1 << (bitPosition & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ec4": "set_bit_at_position_08000ec4",
                "param_1": "bitPosition"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ee0": {
            "entrypoint": "0x08000ee0",
            "current_name": "validate_parameter_08000ee0",
            "code": "\n\n\nundefined4 validate_parameter_08000ee0(int input_value)\n\n{\n  if (input_value - 1U < 0x1000000) {\n    _DAT_e000e014 = input_value - 1U;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000ee0": "validate_parameter_08000ee0",
                "param_1": "input_value"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f0c": {
            "entrypoint": "0x08000f0c",
            "current_name": "set_bit_08000f0c",
            "code": "\nvoid setBit_08000f0c(uint value)\n\n{\n  if (-1 < (int)value) {\n    *(int *)(((value >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (value & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f0c": "set_bit_08000f0c",
                "param_1": "value"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f2c": {
            "entrypoint": "0x08000f2c",
            "current_name": "update_flag_08000f2c",
            "code": "\n\n\nvoid updateFlag_08000f2c(int flagValue)\n\n{\n  if (flagValue != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f2c": "update_flag_08000f2c",
                "param_1": "flagValue"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4c": {
            "entrypoint": "0x08000f4c",
            "current_name": "FUNC_08000f4c",
            "code": "\nvoid FUNC_08000f4c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4c": "FUNC_08000f4c"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4e": {
            "entrypoint": "0x08000f4e",
            "current_name": "handle_sys_tick_callback_08000f4e",
            "code": "\nvoid handleSysTickCallback_08000f4e(void)\n\n{\n  systickCallback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4e": "handle_sys_tick_callback_08000f4e",
                "HAL_SYSTICK_Callback": "systickCallback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f56": {
            "entrypoint": "0x08000f56",
            "current_name": "initialize_device_08000f56",
            "code": "\nundefined4 initializeDevice_08000f56(int devicePtr)\n\n{\n  if (devicePtr != 0) {\n    *(undefined *)(devicePtr + 4) = 2;\n    disableDAC;\n    *(undefined4 *)(devicePtr + 0x10) = 0;\n    *(undefined *)(devicePtr + 4) = 0;\n    *(undefined *)(devicePtr + 5) = 0;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000f56": "initialize_device_08000f56",
                "param_1": "devicePtr",
                "HAL_DAC_MspDeInit()": "disableDAC"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "HAL_DAC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f72": {
            "entrypoint": "0x08000f72",
            "current_name": "clear_bit_and_set_flag_08000f72",
            "code": "\nundefined4 clearBitAndSetFlag_08000f72(uint **ptrToUintPtr,uint bitPosition)\n\n{\n  **ptrToUintPtr = **ptrToUintPtr & ~(1 << (bitPosition & 0xff));\n  *(undefined *)(ptrToUintPtr + 1) = 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000f72": "clear_bit_and_set_flag_08000f72",
                "param_1": "ptrToUintPtr",
                "param_2": "bitPosition"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f8c": {
            "entrypoint": "0x08000f8c",
            "current_name": "update_param_08000f8c",
            "code": "\nundefined4 updateParam_08000f8c(uint **paramArray)\n\n{\n  if (*(char *)((int)paramArray + 0x35) != '\\x02') {\n    paramValue = (uint *)0x80;\n    return 1;\n  }\n  *(undefined *)((int)paramArray + 0x35) = 5;\n  **paramArray = **paramArray & 0xfffffffe;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000f8c": "update_param_08000f8c",
                "param_1": "paramArray",
                "param_1[0x15]": "paramValue"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fb4": {
            "entrypoint": "0x08000fb4",
            "current_name": "update_registers_08000fb4",
            "code": "\n\n\nvoid updateRegisters_08000fb4(uint *registers,uint *values)\n\n{\n  uint temp1;\n  uint temp2;\n  uint index;\n  uint bitMask;\n  uint value;\n  int regIndex1;\n  uint shift;\n  int regIndex2;\n  \n  for (index = 0; index < 0x10; index = index + 1) {\n    temp2 = 1 << (index & 0xff);\n    bitMask = temp2 & *values;\n    temp1 = _DAT_40013c0c;\n    if (temp2 == bitMask) {\n      if ((values[1] == 2) || (values[1] == 0x12)) {\n        regIndex1 = (index >> 3) + 8;\n        regIndex2 = (index & 7) << 2;\n        registers[regIndex1] = registers[regIndex1] & ~(0xf << regIndex2) | values[4] << regIndex2;\n      }\n      shift = index << 1;\n      temp1 = ~(3 << (shift & 0xff));\n      *registers = *registers & temp1 | (values[1] & 3) << (shift & 0xff);\n      value = values[1];\n      if (((value - 1 < 2) || (value == 0x11)) || (value == 0x12)) {\n        registers[2] = registers[2] & temp1 | values[3] << (shift & 0xff);\n        registers[1] = registers[1] & ~temp2 | ((values[1] << 0x1b) >> 0x1f) << (index & 0xff);\n      }\n      registers[3] = temp1 & registers[3] | values[2] << (shift & 0xff);\n      temp1 = _DAT_40013c0c;\n      if ((values[1] & 0x10000000) != 0) {\n        _DAT_40023844 = _DAT_40023844 | 0x4000;\n        regIndex2 = (index & 3) << 2;\n        if (registers == (uint *)0x40020000) {\n          regIndex1 = 0;\n        }\n        else if (registers == (uint *)0x40020400) {\n          regIndex1 = 1;\n        }\n        else if (registers == (uint *)0x40020800) {\n          regIndex1 = 2;\n        }\n        else if (registers == (uint *)0x40020c00) {\n          regIndex1 = 3;\n        }\n        else if (registers == (uint *)0x40021000) {\n          regIndex1 = 4;\n        }\n        else if (registers == (uint *)0x40021400) {\n          regIndex1 = 5;\n        }\n        else if (registers == (uint *)0x40021800) {\n          regIndex1 = 6;\n        }\n        else if (registers == (uint *)0x40021c00) {\n          regIndex1 = 7;\n        }\n        else if (registers == (uint *)0x40022000) {\n          regIndex1 = 8;\n        }\n        else if (registers == (uint *)0x40022400) {\n          regIndex1 = 9;\n        }\n        else {\n          regIndex1 = 10;\n        }\n        *(uint *)(((index >> 2) + 2) * 4 + 0x40013800) =\n             *(uint *)(((index >> 2) + 2) * 4 + 0x40013800) & ~(0xf << regIndex2) | regIndex1 << regIndex2;\n        temp1 = ~bitMask;\n        temp2 = _DAT_40013c00 & temp1;\n        if ((values[1] & 0x10000) != 0) {\n          temp2 = bitMask | _DAT_40013c00;\n        }\n        value = temp1 & _DAT_40013c04;\n        if ((values[1] & 0x20000) != 0) {\n          value = bitMask | _DAT_40013c04;\n        }\n        shift = temp1 & _DAT_40013c08;\n        if ((values[1] & 0x100000) != 0) {\n          shift = bitMask | _DAT_40013c08;\n        }\n        _DAT_40013c00 = temp2;\n        _DAT_40013c04 = value;\n        _DAT_40013c08 = shift;\n        temp1 = temp1 & _DAT_40013c0c;\n        if ((values[1] & 0x200000) != 0) {\n          temp1 = bitMask | _DAT_40013c0c;\n        }\n      }\n    }\n    _DAT_40013c0c = temp1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fb4": "update_registers_08000fb4",
                "param_1": "registers",
                "param_2": "values",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "index",
                "uVar4": "bitMask",
                "uVar5": "value",
                "iVar6": "regIndex1",
                "uVar7": "shift",
                "iVar8": "regIndex2"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001198": {
            "entrypoint": "0x08001198",
            "current_name": "update_parameter_08001198",
            "code": "\nvoid updateParameter_08001198(int address,int value,int shift)\n\n{\n  if (shift == 0) {\n    *(int *)(address + 0x18) = value << 0x10;\n    return;\n  }\n  *(int *)(address + 0x18) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001198": "update_parameter_08001198",
                "param_1": "address",
                "param_2": "value",
                "param_3": "shift"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011a4": {
            "entrypoint": "0x080011a4",
            "current_name": "update_gpio_when_interrupt_occurs_080011a4",
            "code": "\n\n\nvoid update_GPIO_when_interrupt_occurs_080011a4(uint interrupt_flag)\n\n{\n  if ((_DAT_40013c14 & interrupt_flag) != 0) {\n    _DAT_40013c14 = interrupt_flag;\n    handle_GPIO_interrupt();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011a4": "update_gpio_when_interrupt_occurs_080011a4",
                "param_1": "interrupt_flag",
                "HAL_GPIO_EXTI_Callback": "handle_GPIO_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011c0": {
            "entrypoint": "0x080011c0",
            "current_name": "set_permission_flag_080011c0",
            "code": "\nundefined4 setPermissionFlag_080011c0(int *paramArray)\n\n{\n  if (*(char *)((int)paramArray + 0x3e) == '@') {\n    if (arrayValue1 == 0) {\n      *(uint *)(*paramArray + 0x10) = arrayValue2 & 0xfe;\n    }\n    else {\n      *(uint *)(*paramArray + 0x10) = arrayValue2 & 0xffU | 1;\n    }\n  }\n  else if (arrayValue3 == 0x4000) {\n    if (*(char *)((int)paramArray + 0x3d) == '!') {\n      *(uint *)(*paramArray + 0x10) = arrayValue2 & 0xfe;\n    }\n    else {\n      *(uint *)(*paramArray + 0x10) = arrayValue2 & 0xffU | 1;\n    }\n  }\n  else if (arrayValue1 == 0) {\n    *(uint *)(*paramArray + 0x10) = (uint)(arrayValue2 << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (arrayValue1 == 1) {\n    *(uint *)(*paramArray + 0x10) = (uint)(arrayValue2 << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080011c0": "set_permission_flag_080011c0",
                "param_1": "paramArray",
                "param_1[0x14]": "arrayValue1",
                "param_1[0x11]": "arrayValue2",
                "param_1[4]": "arrayValue3"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800124a": {
            "entrypoint": "0x0800124a",
            "current_name": "set_lower_byte_0800124a",
            "code": "\nundefined4 set_lower_byte_0800124a(int *input_array)\n\n{\n  *(uint *)(*input_array + 0x10) = input_array[0x11] & 0xff;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800124a": "set_lower_byte_0800124a",
                "param_1": "input_array"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001256": {
            "entrypoint": "0x08001256",
            "current_name": "process_flags_08001256",
            "code": "\nundefined4 processFlags_08001256(uint **paramList)\n\n{\n  uint *nextParam;\n  \n  nextParam = paramList[11];\n  if ((*(char *)((int)paramList + 0x3d) == '\\\"') &&\n     ((paramList[20] != (uint *)0x0 || (*(char *)((int)paramList + 0x3e) != '@')))) {\n    if ((paramList[20] == (uint *)0x0) && (paramList[4] == (uint *)0xc000)) {\n      **paramList = **paramList | 0x100;\n      paramList[20] = (uint *)((int)paramList[20] + 1);\n    }\n    else {\n      if (*(short *)((int)paramList + 0x2a) == 0) {\n        **paramList = **paramList | 0x200;\n      }\n      else if (*(short *)((int)paramList + 0x2a) == 1) {\n        if (nextParam == (uint *)0xffff0000) {\n          **paramList = **paramList & 0xfffffbff;\n          nextParam = *paramList;\n          if ((nextParam[1] & 0x800) == 0) {\n            *nextParam = *nextParam | 0x200;\n          }\n          else {\n            *nextParam = *nextParam & 0xfffffbff;\n          }\n        }\n        else if (((nextParam == (uint *)0x4) || (nextParam == (uint *)0x8)) ||\n                (paramList[12] == (uint *)0x12)) {\n          **paramList = **paramList & 0xfffffbff;\n          **paramList = **paramList | 0x200;\n        }\n        else if (paramList[11] == (uint *)0x2) {\n          **paramList = **paramList | 0x400;\n        }\n        else {\n          **paramList = **paramList & 0xfffffbff;\n        }\n      }\n      else if (*(short *)((int)paramList + 0x2a) == 2) {\n        if (paramList[11] == (uint *)0x2) {\n          **paramList = **paramList | 0x400;\n        }\n        else {\n          **paramList = **paramList & 0xfffffbff;\n          **paramList = **paramList | 0x800;\n        }\n        nextParam = *paramList;\n        if ((nextParam[1] & 0x800) != 0) {\n          nextParam[1] = nextParam[1] | 0x1000;\n        }\n      }\n      else {\n        **paramList = **paramList | 0x400;\n        nextParam = *paramList;\n        if ((nextParam[1] & 0x800) != 0) {\n          nextParam[1] = nextParam[1] | 0x1000;\n        }\n      }\n      paramList[20] = (uint *)0x0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001256": "process_flags_08001256",
                "param_1": "paramList",
                "puVar1": "nextParam",
                "param_1[0xb]": "paramList[11]",
                "param_1[0x14]": "paramList[20]",
                "param_1[4]": "paramList[4]",
                "param_1[0xc]": "paramList[12]"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001420": {
            "entrypoint": "0x08001420",
            "current_name": "update_data_08001420",
            "code": "\nundefined4 updateData_08001420(int *dataPointer)\n\n{\n  byte *bytePointer;\n  \n  if (*(short *)((int)dataPointer + 0x2a) != 0) {\n    bytePointer = (byte *)data;\n    data = (int)(bytePointer + 1);\n    *(uint *)(*dataPointer + 0x10) = (uint)*bytePointer;\n    *(short *)((int)dataPointer + 0x2a) = *(short *)((int)dataPointer + 0x2a) + -1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001420": "update_data_08001420",
                "param_1": "dataPointer",
                "pbVar1": "bytePointer",
                "param_1[9]": "data"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001440": {
            "entrypoint": "0x08001440",
            "current_name": "update_data_08001440",
            "code": "\nundefined4 updateData_08001440(int *dataPtr)\n\n{\n  undefined *nextPtr;\n  \n  if (*(short *)((int)dataPtr + 0x2a) != 0) {\n    nextPtr = (undefined *)ptrToData;\n    ptrToData = (int)(nextPtr + 1);\n    *nextPtr = (char)*(undefined4 *)(*dataPtr + 0x10);\n    *(short *)((int)dataPtr + 0x2a) = *(short *)((int)dataPtr + 0x2a) + -1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001440": "update_data_08001440",
                "param_1": "dataPtr",
                "puVar1": "nextPtr",
                "param_1[9]": "ptrToData"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001460": {
            "entrypoint": "0x08001460",
            "current_name": "initialize_data_08001460",
            "code": "\nundefined4 initializeData_08001460(uint **dataPointer,uint *inputData,int inputSize,uint *outputData)\n\n{\n  undefined4 result;\n  uint *dataPtr;\n  \n  if (*(char *)((int)dataPointer + 0x3d) == '(') {\n    if (inputData == (uint *)0x0) {\n      result = 1;\n    }\n    else if (inputSize == 0) {\n      result = 1;\n    }\n    else if (*(char *)(dataPointer + 0xf) == '\\x01') {\n      result = 2;\n    }\n    else {\n      *(undefined *)(dataPointer + 0xf) = 1;\n      dataPtr = *dataPointer;\n      if ((*dataPtr & 1) == 0) {\n        *dataPtr = *dataPtr | 1;\n      }\n      **dataPointer = **dataPointer & 0xfffff7ff;\n      *(undefined *)((int)dataPointer + 0x3d) = 0x29;\n      *(undefined *)((int)dataPointer + 0x3e) = 0x20;\n      result = 0;\n      dataPointer[0x10] = (uint *)0x0;\n      dataPointer[9] = inputData;\n      *(short *)((int)dataPointer + 0x2a) = (short)inputSize;\n      dataPointer[0xb] = outputData;\n      *(undefined2 *)(dataPointer + 10) = *(undefined2 *)((int)dataPointer + 0x2a);\n      *(undefined *)(dataPointer + 0xf) = 0;\n      (*dataPointer)[1] = (*dataPointer)[1] | 0x700;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001460": "initialize_data_08001460",
                "param_1": "dataPointer",
                "param_2": "inputData",
                "param_3": "inputSize",
                "param_4": "outputData",
                "uVar1": "result",
                "puVar2": "dataPtr"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ec": {
            "entrypoint": "0x080014ec",
            "current_name": "validate_parameters_080014ec",
            "code": "\nundefined4 validate_parameters_080014ec(uint **parameter1,uint *parameter2,int parameter3,uint *parameter4)\n\n{\n  undefined4 result;\n  uint *pointerVar;\n  \n  if (*(char *)((int)parameter1 + 0x3d) == '(') {\n    if (parameter2 == (uint *)0x0) {\n      result = 1;\n    }\n    else if (parameter3 == 0) {\n      result = 1;\n    }\n    else if (*(char *)(parameter1 + 0xf) == '\\x01') {\n      result = 2;\n    }\n    else {\n      *(undefined *)(parameter1 + 0xf) = 1;\n      pointerVar = *parameter1;\n      if ((*pointerVar & 1) == 0) {\n        *pointerVar = *pointerVar | 1;\n      }\n      **parameter1 = **parameter1 & 0xfffff7ff;\n      *(undefined *)((int)parameter1 + 0x3d) = 0x2a;\n      *(undefined *)((int)parameter1 + 0x3e) = 0x20;\n      result = 0;\n      parameter1[0x10] = (uint *)0x0;\n      parameter1[9] = parameter2;\n      *(short *)((int)parameter1 + 0x2a) = (short)parameter3;\n      parameter1[0xb] = parameter4;\n      *(undefined2 *)(parameter1 + 10) = *(undefined2 *)((int)parameter1 + 0x2a);\n      *(undefined *)(parameter1 + 0xf) = 0;\n      (*parameter1)[1] = (*parameter1)[1] | 0x700;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080014ec": "validate_parameters_080014ec",
                "param_1": "parameter1",
                "param_2": "parameter2",
                "param_3": "parameter3",
                "param_4": "parameter4",
                "uVar1": "result",
                "puVar2": "pointerVar"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001578": {
            "entrypoint": "0x08001578",
            "current_name": "initialize_param_08001578",
            "code": "\nundefined4 initializeParam_08001578(uint **param)\n\n{\n  uint *ptr;\n  \n  if (*(char *)((int)param + 0x3d) != ' ') {\n    return 2;\n  }\n  *(undefined *)((int)param + 0x3d) = 0x28;\n  ptr = *param;\n  if ((*ptr & 1) == 0) {\n    *ptr = *ptr | 1;\n  }\n  **param = **param | 0x400;\n  (*param)[1] = (*param)[1] | 0x300;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001578": "initialize_param_08001578",
                "param_1": "param",
                "puVar1": "ptr"
            },
            "calling": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b6": {
            "entrypoint": "0x080015b6",
            "current_name": "FUNC_080015b6",
            "code": "\nvoid FUNC_080015b6(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b6": "FUNC_080015b6"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015b8": {
            "entrypoint": "0x080015b8",
            "current_name": "FUNC_080015b8",
            "code": "\nvoid FUNC_080015b8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b8": "FUNC_080015b8"
            },
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015ba": {
            "entrypoint": "0x080015ba",
            "current_name": "FUNC_080015ba",
            "code": "\nvoid FUNC_080015ba(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015ba": "FUNC_080015ba"
            },
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015bc": {
            "entrypoint": "0x080015bc",
            "current_name": "process_data_080015bc",
            "code": "\nundefined4 processData_080015bc(int *data)\n\n{\n  char charVal;\n  byte *bytePtr;\n  \n  charVal = *(char *)((int)data + 0x3d);\n  if (*(short *)((int)data + 0x2a) != 0) {\n    bytePtr = (byte *)data[9];\n    data[9] = (int)(bytePtr + 1);\n    *(uint *)(*data + 0x10) = (uint)*bytePtr;\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    if ((*(short *)((int)data + 0x2a) == 0) && (charVal == ')')) {\n      *(uint *)(*data + 4) = *(uint *)(*data + 4) & 0xfffffbff;\n      data[0xc] = 0x21;\n      *(undefined *)((int)data + 0x3d) = 0x28;\n      HAL_I2C_SlaveTxCpltCallback();\n    }\n    return 0;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080015bc": "process_data_080015bc",
                "param_1": "data",
                "cVar1": "charVal",
                "pbVar2": "bytePtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800160c": {
            "entrypoint": "0x0800160c",
            "current_name": "FUNC_0800160c",
            "code": "\nvoid FUNC_0800160c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800160c": "FUNC_0800160c"
            },
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800160e": {
            "entrypoint": "0x0800160e",
            "current_name": "update_data_0800160e",
            "code": "\nundefined4 updateData_0800160e(int *data)\n\n{\n  char charValue;\n  undefined *ptr;\n  \n  charValue = *(char *)((int)data + 0x3d);\n  if (*(short *)((int)data + 0x2a) != 0) {\n    ptr = (undefined *)ptrArray[9];\n    ptrArray[9] = (int)(ptr + 1);\n    *ptr = (char)*(undefined4 *)(*data + 0x10);\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    if ((*(short *)((int)data + 0x2a) == 0) && (charValue == '*')) {\n      *(uint *)(*data + 4) = *(uint *)(*data + 4) & 0xfffffbff;\n      ptrArray[0xc] = 0x22;\n      *(undefined *)((int)data + 0x3d) = 0x28;\n      HAL_I2C_SlaveRxCpltCallback();\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800160e": "update_data_0800160e",
                "param_1": "data",
                "cVar1": "charValue",
                "puVar2": "ptr",
                "param_1[9]": "ptrArray[9]",
                "param_1[0xc]": "ptrArray[0xc]"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800165a": {
            "entrypoint": "0x0800165a",
            "current_name": "handle_i2_c_addr_callback_0800165a",
            "code": "\nundefined4 handleI2CAddrCallback_0800165a(int *i2cParams,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  undefined2 callbackValue;\n  uint configValue;\n  \n  configValue = *(uint *)(*i2cParams + 0x18);\n  if ((configValue & 0x80) == 0) {\n    callbackValue = *(undefined2 *)(i2cParams + 3);\n  }\n  else {\n    callbackValue = *(undefined2 *)(i2cParams + 6);\n  }\n  HAL_I2C_AddrCallback(i2cParams,(*(uint *)(*i2cParams + 0x18) & 4) == 0,callbackValue,configValue,param4);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800165a": "handle_i2_c_addr_callback_0800165a",
                "param_1": "i2cParams",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "callbackValue",
                "uVar2": "configValue"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001684": {
            "entrypoint": "0x08001684",
            "current_name": "handle_i2_c_interrupt_08001684",
            "code": "\nundefined4 handleI2CInterrupt_08001684(uint **interruptData)\n\n{\n  if (((pointerAtOffset11 == (uint *)0x4) || (pointerAtOffset11 == (uint *)0x8)) &&\n     (*(char *)((int)interruptData + 0x3d) == '(')) {\n    pointerAtOffset11 = (uint *)0xffff0000;\n    (*interruptData)[1] = (*interruptData)[1] & 0xfffff8ff;\n    (*interruptData)[5] = 0xfffffbff;\n    **interruptData = **interruptData & 0xfffffbff;\n    pointerAtOffset12 = (uint *)0x0;\n    *(undefined *)((int)interruptData + 0x3d) = 0x20;\n    *(undefined *)((int)interruptData + 0x3e) = 0;\n    HAL_I2C_ListenCpltCallback();\n  }\n  else if (*(char *)((int)interruptData + 0x3d) == '!') {\n    pointerAtOffset11 = (uint *)0xffff0000;\n    pointerAtOffset12 = (uint *)0x21;\n    *(undefined *)((int)interruptData + 0x3d) = 0x20;\n    *(undefined *)((int)interruptData + 0x3e) = 0;\n    (*interruptData)[1] = (*interruptData)[1] & 0xfffff8ff;\n    (*interruptData)[5] = 0xfffffbff;\n    **interruptData = **interruptData & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback();\n  }\n  else {\n    (*interruptData)[5] = 0xfffffbff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001684": "handle_i2_c_interrupt_08001684",
                "param_1": "interruptData",
                "param_1[0xb]": "pointerAtOffset11",
                "param_1[0xc]": "pointerAtOffset12"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001718": {
            "entrypoint": "0x08001718",
            "current_name": "FUNC_08001718",
            "code": "\nvoid FUNC_08001718(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001718": "FUNC_08001718"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800171a": {
            "entrypoint": "0x0800171a",
            "current_name": "process_data_0800171a",
            "code": "\nundefined4 processData_0800171a(uint **data)\n\n{\n  char character;\n  uint *pointer;\n  \n  character = *(char *)((int)data + 0x3d);\n  pointer = data[11];\n  if ((*(short *)(data + 10) == 0) && (character == '!')) {\n    if ((pointer == (uint *)0x4) || ((pointer == (uint *)0x8 || (pointer == (uint *)0xffff0000)))) {\n      (*data)[1] = (*data)[1] & 0xfffff8ff;\n      **data = **data | 0x200;\n      data[12] = (uint *)0x0;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      if (*(char *)((int)data + 0x3e) == '@') {\n        *(undefined *)((int)data + 0x3e) = 0;\n        HAL_I2C_MemTxCpltCallback();\n      }\n      else {\n        *(undefined *)((int)data + 0x3e) = 0;\n        HAL_I2C_MasterTxCpltCallback();\n      }\n    }\n    else {\n      (*data)[1] = (*data)[1] & 0xfffff8ff;\n      data[12] = (uint *)0x11;\n      *(undefined *)((int)data + 0x3e) = 0;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      HAL_I2C_MasterTxCpltCallback();\n    }\n  }\n  else if ((character == '!') || ((*(char *)((int)data + 0x3e) == '@' && (character == '\\\"')))) {\n    if (*(short *)((int)data + 0x2a) == 0) {\n      (*data)[1] = (*data)[1] & 0xfffffbff;\n    }\n    else if (*(char *)((int)data + 0x3e) == '@') {\n      if (data[0x14] == (uint *)0x0) {\n        if (data[0x13] == (uint *)0x1) {\n          (*data)[4] = (uint)data[18] & 0xff;\n          data[0x14] = (uint *)((int)data[20] + 2);\n        }\n        else {\n          (*data)[4] = (uint)((int)data[0x12] << 0x10) >> 0x18;\n          data[0x14] = (uint *)((int)data[20] + 1);\n        }\n      }\n      else if (data[0x14] == (uint *)0x1) {\n        (*data)[4] = (uint)data[18] & 0xff;\n        data[0x14] = (uint *)((int)data[20] + 1);\n      }\n      else if (data[0x14] == (uint *)0x2) {\n        if (*(char *)((int)data + 0x3d) == '\\\"') {\n          **data = **data | 0x100;\n        }\n        else if (*(char *)((int)data + 0x3d) == '!') {\n          pointer = data[9];\n          data[9] = (uint *)((int)pointer + 1);\n          (*data)[4] = (uint)*(byte *)pointer;\n          *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n        }\n      }\n    }\n    else {\n      pointer = data[9];\n      data[9] = (uint *)((int)pointer + 1);\n      (*data)[4] = (uint)*(byte *)pointer;\n      *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800171a": "process_data_0800171a",
                "param_1": "data",
                "cVar1": "character",
                "puVar2": "pointer",
                "param_1[0xb]": "data[11]",
                "param_1[0xc]": "data[12]",
                "(uint)param_1[0x12]": "(uint)data[18]",
                "(int)param_1[0x14]": "(int)data[20]"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001864": {
            "entrypoint": "0x08001864",
            "current_name": "process_data_08001864",
            "code": "\nundefined4 processData_08001864(uint **data)\n\n{\n  uint *ptr;\n  \n  ptr = data[0xb];\n  if (*(char *)((int)data + 0x3d) == '!') {\n    if (*(short *)((int)data + 0x2a) == 0) {\n      if (((ptr == (uint *)0x4) || (ptr == (uint *)0x8)) || (ptr == (uint *)0xffff0000)) {\n        (*data)[1] = (*data)[1] & 0xfffff8ff;\n        **data = **data | 0x200;\n        data[12] = (uint *)0x0;\n        *(undefined *)((int)data + 0x3d) = 0x20;\n        if (*(char *)((int)data + 0x3e) == '@') {\n          *(undefined *)((int)data + 0x3e) = 0;\n          HAL_I2C_MemTxCpltCallback();\n        }\n        else {\n          *(undefined *)((int)data + 0x3e) = 0;\n          HAL_I2C_MasterTxCpltCallback();\n        }\n      }\n      else {\n        (*data)[1] = (*data)[1] & 0xfffff8ff;\n        data[12] = (uint *)0x11;\n        *(undefined *)((int)data + 0x3e) = 0;\n        *(undefined *)((int)data + 0x3d) = 0x20;\n        HAL_I2C_MasterTxCpltCallback();\n      }\n    }\n    else {\n      ptr = data[9];\n      data[9] = (uint *)((int)ptr + 1);\n      (*data)[4] = (uint)*(byte *)ptr;\n      *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001864": "process_data_08001864",
                "param_1": "data",
                "puVar1": "ptr",
                "param_1[0xc]": "data[12]"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001902": {
            "entrypoint": "0x08001902",
            "current_name": "FUNC_08001902",
            "code": "\nvoid FUNC_08001902(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001902": "FUNC_08001902"
            },
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001904": {
            "entrypoint": "0x08001904",
            "current_name": "process_data_08001904",
            "code": "\nundefined4 processData_08001904(uint **data)\n\n{\n  uint *tempPtr;\n  \n  if (*(char *)((int)data + 0x3d) == '\\\"') {\n    if (*(ushort *)((int)data + 0x2a) < 4) {\n      if (*(ushort *)((int)data + 0x2a) < 2) {\n        **data = **data & 0xfffffbff;\n        (*data)[1] = (*data)[1] & 0xfffff8ff;\n        tempPtr = ptrArray;\n        ptrArray = (uint *)((int)tempPtr + 1);\n        *(char *)tempPtr = (char)(*data)[4];\n        *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n        *(undefined *)((int)data + 0x3d) = 0x20;\n        data[0xc] = (uint *)0x0;\n        if (*(char *)((int)data + 0x3e) == '@') {\n          *(undefined *)((int)data + 0x3e) = 0;\n          HAL_I2C_MemRxCpltCallback();\n        }\n        else {\n          *(undefined *)((int)data + 0x3e) = 0;\n          HAL_I2C_MasterRxCpltCallback();\n        }\n      }\n    }\n    else {\n      tempPtr = ptrArray;\n      ptrArray = (uint *)((int)tempPtr + 1);\n      *(char *)tempPtr = (char)(*data)[4];\n      *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n      if (*(short *)((int)data + 0x2a) == 3) {\n        (*data)[1] = (*data)[1] & 0xfffffbff;\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001904": "process_data_08001904",
                "param_1": "data",
                "puVar1": "tempPtr",
                "param_1[9]": "ptrArray"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080019a0": {
            "entrypoint": "0x080019a0",
            "current_name": "process_data_080019a0",
            "code": "\nundefined4 processData_080019a0(uint **data)\n\n{\n  uint *tempPtr;\n  \n  if (*(short *)((int)data + 0x2a) == 4) {\n    (*data)[1] = (*data)[1] & 0xfffffbff;\n    tempPtr = data[9];\n    data[9] = (uint *)((int)tempPtr + 1);\n    *(char *)tempPtr = (char)(*data)[4];\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n  }\n  else if (*(short *)((int)data + 0x2a) == 3) {\n    (*data)[1] = (*data)[1] & 0xfffffbff;\n    **data = **data & 0xfffffbff;\n    tempPtr = data[9];\n    data[9] = (uint *)((int)tempPtr + 1);\n    *(char *)tempPtr = (char)(*data)[4];\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n  }\n  else if (*(short *)((int)data + 0x2a) == 2) {\n    if ((int)data[0xb] - 1U < 2) {\n      **data = **data & 0xfffffbff;\n      **data = **data | 0x100;\n    }\n    else {\n      **data = **data | 0x200;\n    }\n    tempPtr = data[9];\n    data[9] = (uint *)((int)tempPtr + 1);\n    *(char *)tempPtr = (char)(*data)[4];\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    tempPtr = data[9];\n    data[9] = (uint *)((int)tempPtr + 1);\n    *(char *)tempPtr = (char)(*data)[4];\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    (*data)[1] = (*data)[1] & 0xfffffcff;\n    *(undefined *)((int)data + 0x3d) = 0x20;\n    data[0xc] = (uint *)0x0;\n    if (*(char *)((int)data + 0x3e) == '@') {\n      *(undefined *)((int)data + 0x3e) = 0;\n      HAL_I2C_MemRxCpltCallback();\n    }\n    else {\n      *(undefined *)((int)data + 0x3e) = 0;\n      HAL_I2C_MasterRxCpltCallback();\n    }\n  }\n  else {\n    tempPtr = data[9];\n    data[9] = (uint *)((int)tempPtr + 1);\n    *(char *)tempPtr = (char)(*data)[4];\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080019a0": "process_data_080019a0",
                "param_1": "data",
                "puVar1": "tempPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001aac": {
            "entrypoint": "0x08001aac",
            "current_name": "FUNC_08001aac",
            "code": "\nvoid FUNC_08001aac(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001aac": "FUNC_08001aac"
            },
            "calling": [
                "I2C_ITError"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "handle_i2_c_event_08001ab0",
            "code": "\nvoid handleI2CEvent_08001ab0(uint **eventData)\n\n{\n  int status;\n  uint *charPtr;\n  uint *eventPtr;\n  \n  if (*(byte *)((int)eventData + 0x3d) - 0x29 < 2) {\n    eventData[0xc] = (uint *)0x0;\n    *(undefined *)((int)eventData + 0x3d) = 0x28;\n  }\n  else {\n    if ((*(char *)((int)eventData + 0x3d) != '`') && (((*eventData)[1] & 0x800) == 0)) {\n      *(undefined *)((int)eventData + 0x3d) = 0x20;\n    }\n    eventData[0xc] = (uint *)0x0;\n    *(undefined *)((int)eventData + 0x3e) = 0;\n  }\n  **eventData = **eventData & 0xfffff7ff;\n  eventPtr = *eventData;\n  if ((eventPtr[1] & 0x800) == 0) {\n    if (*(char *)((int)eventData + 0x3d) == '`') {\n      *(undefined *)((int)eventData + 0x3d) = 0x20;\n      eventData[0x10] = (uint *)0x0;\n      if ((eventPtr[5] & 0x40) != 0) {\n        charPtr = eventData[9];\n        eventData[9] = (uint *)((int)charPtr + 1);\n        *(char *)charPtr = (char)eventPtr[4];\n      }\n      **eventData = **eventData & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(eventData);\n    }\n    else {\n      if ((eventPtr[5] & 0x40) != 0) {\n        charPtr = eventData[9];\n        eventData[9] = (uint *)((int)charPtr + 1);\n        *(char *)charPtr = (char)eventPtr[4];\n      }\n      HAL_I2C_ErrorCallback(eventData);\n    }\n  }\n  else {\n    eventPtr[1] = eventPtr[1] & 0xfffff7ff;\n    if (*(char *)((int)eventData[0xd] + 0x35) == '\\x01') {\n      eventData[0xe][0x14] = (uint)&LAB_08001f3c_1;\n      status = HAL_DMA_Abort_IT(eventData[0xe]);\n      if (status != 0) {\n        if (((*eventData)[5] & 0x40) != 0) {\n          eventPtr = eventData[9];\n          eventData[9] = (uint *)((int)eventPtr + 1);\n          *(char *)eventPtr = (char)(*eventData)[4];\n        }\n        **eventData = **eventData & 0xfffffffe;\n        *(undefined *)((int)eventData + 0x3d) = 0x20;\n        (*(code *)eventData[0xe][0x14])();\n      }\n    }\n    else {\n      eventData[0xd][0x14] = (uint)&LAB_08001f3c_1;\n      status = HAL_DMA_Abort_IT(eventData[0xd]);\n      if (status != 0) {\n        **eventData = **eventData & 0xfffffffe;\n        *(undefined *)((int)eventData + 0x3d) = 0x20;\n        (*(code *)eventData[0xd][0x14])();\n      }\n    }\n  }\n  if ((*(char *)((int)eventData + 0x3d) == '(') && (((uint)eventData[0x10] & 4) != 0)) {\n    eventData[0xb] = (uint *)0xffff0000;\n    eventData[0xc] = (uint *)0x0;\n    *(undefined *)((int)eventData + 0x3d) = 0x20;\n    *(undefined *)((int)eventData + 0x3e) = 0;\n    HAL_I2C_ListenCpltCallback(eventData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "handle_i2_c_event_08001ab0",
                "param_1": "eventData",
                "iVar1": "status",
                "puVar2": "charPtr",
                "puVar3": "eventPtr"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_I2C_ErrorCallback",
                "HAL_DMA_Abort_IT",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001bfc": {
            "entrypoint": "0x08001bfc",
            "current_name": "process_i2_c_data_08001bfc",
            "code": "\nundefined4 processI2CData_08001bfc(uint **i2cData)\n\n{\n  char firstChar;\n  uint *ptr1;\n  uint *ptr2;\n  \n  firstChar = *(char *)((int)i2cData + 0x3d);\n  (*i2cData)[1] = (*i2cData)[1] & 0xfffff8ff;\n  **i2cData = **i2cData | 1;\n  **i2cData = **i2cData & 0xfffffbff;\n  ptr1 = *i2cData;\n  if ((ptr1[1] & 0x800) != 0) {\n    if ((*(char *)((int)i2cData + 0x3d) == '\\\"') || (*(char *)((int)i2cData + 0x3d) == '*')) {\n      *(short *)((int)i2cData + 0x2a) = (short)*(undefined4 *)(*i2cData[0xe] + 4);\n    }\n    else {\n      *(short *)((int)i2cData + 0x2a) = (short)*(undefined4 *)(*i2cData[0xd] + 4);\n    }\n  }\n  if (*(short *)((int)i2cData + 0x2a) != 0) {\n    if ((ptr1[5] & 4) != 0) {\n      ptr2 = i2cData[9];\n      i2cData[9] = (uint *)((int)ptr2 + 1);\n      *(char *)ptr2 = (char)ptr1[4];\n      *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n    }\n    if (((*i2cData)[5] & 0x40) != 0) {\n      ptr1 = i2cData[9];\n      i2cData[9] = (uint *)((int)ptr1 + 1);\n      *(char *)ptr1 = (char)(*i2cData)[4];\n      *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n    }\n    i2cData[0x10] = (uint *)((uint)i2cData[0x10] | 4);\n  }\n  if (i2cData[0x10] == (uint *)0x0) {\n    if (((firstChar == '(') || (firstChar == '*')) || (firstChar == ')')) {\n      i2cData[0xb] = (uint *)0xffff0000;\n      i2cData[0xc] = (uint *)0x0;\n      *(undefined *)((int)i2cData + 0x3d) = 0x20;\n      *(undefined *)((int)i2cData + 0x3e) = 0;\n      HAL_I2C_ListenCpltCallback();\n    }\n    else if ((i2cData[0xc] == (uint *)0x22) || (firstChar == '\\\"')) {\n      i2cData[0xc] = (uint *)0x0;\n      *(undefined *)((int)i2cData + 0x3d) = 0x20;\n      *(undefined *)((int)i2cData + 0x3e) = 0;\n      HAL_I2C_SlaveRxCpltCallback();\n    }\n  }\n  else {\n    I2C_ITError();\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001bfc": "process_i2_c_data_08001bfc",
                "param_1": "i2cData",
                "cVar1": "firstChar",
                "puVar2": "ptr1",
                "puVar3": "ptr2"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "HAL_I2C_SlaveRxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001d00": {
            "entrypoint": "0x08001d00",
            "current_name": "handle_i2_c_operation_08001d00",
            "code": "\nvoid handleI2COperation_08001d00(int *inputData)\n\n{\n  int dataPointer;\n  uint statusFlag1;\n  uint statusFlag2;\n  uint statusFlag3;\n  \n  dataPointer = *inputData;\n  statusFlag3 = *(uint *)(dataPointer + 0x18);\n  statusFlag1 = *(uint *)(dataPointer + 0x14);\n  statusFlag2 = *(uint *)(dataPointer + 4);\n  if ((*(char *)((int)inputData + 0x3e) == '\\x10') || (*(char *)((int)inputData + 0x3e) == '@')) {\n    if (((statusFlag1 & 0x10001) == 0) || ((statusFlag2 & 0x200) == 0)) {\n      if (((statusFlag1 & 0x10008) == 0) || ((statusFlag2 & 0x200) == 0)) {\n        if (((statusFlag1 & 0x10002) != 0) && ((statusFlag2 & 0x200) != 0)) {\n          I2C_Master_ADDR(inputData);\n        }\n      }\n      else {\n        I2C_Master_ADD10(inputData);\n      }\n    }\n    else {\n      I2C_Master_SB(inputData);\n    }\n    if ((statusFlag3 & 0x100004) == 0) {\n      if ((((statusFlag1 & 0x10040) != 0) && ((statusFlag2 & 0x400) != 0)) && ((statusFlag1 & 0x10004) == 0)) {\n        I2C_MasterReceive_RXNE(inputData);\n        return;\n      }\n      if (((statusFlag1 & 0x10004) != 0) && ((statusFlag2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(inputData);\n        return;\n      }\n    }\n    else {\n      if ((((statusFlag1 & 0x10080) != 0) && ((statusFlag2 & 0x400) != 0)) && ((statusFlag1 & 0x10004) == 0)) {\n        I2C_MasterTransmit_TXE(inputData);\n        return;\n      }\n      if (((statusFlag1 & 0x10004) != 0) && ((statusFlag2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(inputData);\n        return;\n      }\n    }\n  }\n  else {\n    if (((statusFlag1 & 0x10002) != 0) && ((statusFlag2 & 0x200) != 0)) {\n      I2C_Slave_ADDR();\n      return;\n    }\n    if (((statusFlag1 & 0x10010) != 0) && ((statusFlag2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(inputData);\n      return;\n    }\n    if ((statusFlag3 & 0x100004) == 0) {\n      if ((((statusFlag1 & 0x10040) != 0) && ((statusFlag2 & 0x400) != 0)) && ((statusFlag1 & 0x10004) == 0)) {\n        I2C_SlaveReceive_RXNE(inputData);\n        return;\n      }\n      if (((statusFlag1 & 0x10004) != 0) && ((statusFlag2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(inputData);\n      }\n    }\n    else {\n      if ((((statusFlag1 & 0x10080) != 0) && ((statusFlag2 & 0x400) != 0)) && ((statusFlag1 & 0x10004) == 0)) {\n        I2C_SlaveTransmit_TXE(inputData);\n        return;\n      }\n      if (((statusFlag1 & 0x10004) != 0) && ((statusFlag2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(inputData);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001d00": "handle_i2_c_operation_08001d00",
                "param_1": "inputData",
                "iVar1": "dataPointer",
                "uVar2": "statusFlag1",
                "uVar3": "statusFlag2",
                "uVar4": "statusFlag3"
            },
            "calling": [],
            "called": [
                "I2C_MasterReceive_RXNE",
                "I2C_SlaveReceive_BTF",
                "I2C_Master_SB",
                "I2C_SlaveReceive_RXNE",
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_ADDR",
                "I2C_MasterTransmit_TXE",
                "I2C_MasterTransmit_BTF",
                "I2C_Master_ADD10",
                "I2C_Slave_STOPF",
                "I2C_Master_ADDR",
                "I2C_SlaveTransmit_BTF",
                "I2C_MasterReceive_BTF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e68": {
            "entrypoint": "0x08001e68",
            "current_name": "update_i2_c_status_08001e68",
            "code": "\nvoid updateI2CStatus_08001e68(uint **data)\n\n{\n  char character;\n  uint *ptr;\n  uint status1;\n  uint status2;\n  \n  ptr = *data;\n  status1 = ptr[5];\n  status2 = ptr[1];\n  if (((status1 & 0x10100) != 0) && ((status2 & 0x100) != 0)) {\n    data[0x10] = (uint *)((uint)data[0x10] | 1);\n    ptr[5] = 0xfffffeff;\n  }\n  if (((status1 & 0x10200) != 0) && ((status2 & 0x100) != 0)) {\n    data[0x10] = (uint *)((uint)data[0x10] | 2);\n    (*data)[5] = 0xfffffdff;\n  }\n  if (((status1 & 0x10400) != 0) && ((status2 & 0x100) != 0)) {\n    character = *(char *)((int)data + 0x3d);\n    if (((*(char *)((int)data + 0x3e) == ' ') && (*(short *)((int)data + 0x2a) == 0)) &&\n       (((character == '!' || (character == ')')) || ((character == '(' && (data[0xc] == (uint *)0x21)))))) {\n      I2C_Slave_AF(data);\n    }\n    else {\n      data[0x10] = (uint *)((uint)data[0x10] | 4);\n      if (*(char *)((int)data + 0x3e) == '\\x10') {\n        **data = **data | 0x200;\n      }\n      (*data)[5] = 0xfffffbff;\n    }\n  }\n  if (((status1 & 0x10800) != 0) && ((status2 & 0x100) != 0)) {\n    data[0x10] = (uint *)((uint)data[0x10] | 8);\n    (*data)[5] = 0xfffff7ff;\n  }\n  if (data[0x10] != (uint *)0x0) {\n    I2C_ITError(data);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001e68": "update_i2_c_status_08001e68",
                "param_1": "data",
                "cVar1": "character",
                "puVar2": "ptr",
                "uVar3": "status1",
                "uVar4": "status2"
            },
            "calling": [],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f9c": {
            "entrypoint": "0x08001f9c",
            "current_name": "check_and_wait_for_interrupt_08001f9c",
            "code": "\n\n\nundefined4 check_and_wait_for_interrupt_08001f9c(void)\n\n{\n  int start_ticks;\n  int current_ticks;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_420e0040 = 1;\n  start_ticks = HAL_GetTick();\n  do {\n    if ((_DAT_40007004 & 0x10000) != 0) {\n      _DAT_420e0044 = 1;\n      start_ticks = HAL_GetTick();\n      do {\n        if ((_DAT_40007004 & 0x20000) != 0) {\n          return 0;\n        }\n        current_ticks = HAL_GetTick();\n      } while ((uint)(current_ticks - start_ticks) < 0x3e9);\n      return 3;\n    }\n    current_ticks = HAL_GetTick();\n  } while ((uint)(current_ticks - start_ticks) < 0x3e9);\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_08001f9c": "check_and_wait_for_interrupt_08001f9c",
                "iVar1": "start_ticks",
                "iVar2": "current_ticks"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800201c": {
            "entrypoint": "0x0800201c",
            "current_name": "execute_command_0800201c",
            "code": "\n\n\nundefined4 executeCommand_0800201c(uint *commandParams)\n\n{\n  int startTime;\n  int currentTime;\n  undefined4 result;\n  bool flag;\n  \n  if (commandParams == (uint *)0x0) {\n    return 1;\n  }\n  if ((*commandParams & 1) != 0) {\n    if (((_DAT_40023808 & 0xc) == 4) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) != 0)))) {\n      if (((_DAT_40023800 & 0x20000) != 0) && (commandParams[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      if (commandParams[1] == 0x10000) {\n        _DAT_40023800 = _DAT_40023800 | 0x10000;\n      }\n      else if (commandParams[1] == 0x50000) {\n        _DAT_40023800 = _DAT_40023800 | 0x50000;\n      }\n      else {\n        _DAT_40023800 = _DAT_40023800 & 0xfffaffff;\n      }\n      if (commandParams[1] == 0) {\n        startTime = getTick();\n        while ((_DAT_40023800 & 0x20000) != 0) {\n          currentTime = getTick();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        startTime = getTick();\n        while ((_DAT_40023800 & 0x20000) == 0) {\n          currentTime = getTick();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*commandParams & 2) != 0) {\n    if (((_DAT_40023808 & 0xc) == 0) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) == 0)))) {\n      if (((_DAT_40023800 & 2) != 0) && (commandParams[3] != 1)) {\n        return 1;\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | commandParams[4] << 3;\n    }\n    else if (commandParams[3] == 0) {\n      _DAT_42470000 = 0;\n      startTime = getTick();\n      while ((_DAT_40023800 & 2) != 0) {\n        currentTime = getTick();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42470000 = 1;\n      startTime = getTick();\n      while ((_DAT_40023800 & 2) == 0) {\n        currentTime = getTick();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | commandParams[4] << 3;\n    }\n  }\n  if ((*commandParams & 8) != 0) {\n    if (commandParams[5] == 0) {\n      _DAT_42470e80 = 0;\n      startTime = getTick();\n      while ((_DAT_40023874 & 2) != 0) {\n        currentTime = getTick();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42470e80 = 1;\n      startTime = getTick();\n      while ((_DAT_40023874 & 2) == 0) {\n        currentTime = getTick();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n  }\n  if ((*commandParams & 4) != 0) {\n    flag = (_DAT_40023840 & 0x10000000) == 0;\n    if (flag) {\n      _DAT_40023840 = _DAT_40023840 | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = getTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = getTick();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (commandParams[2] == 1) {\n      _DAT_40023870 = _DAT_40023870 | 1;\n    }\n    else if (commandParams[2] == 5) {\n      _DAT_40023870 = _DAT_40023870 | 5;\n    }\n    else {\n      _DAT_40023870 = _DAT_40023870 & 0xfffffffa;\n    }\n    if (commandParams[2] == 0) {\n      startTime = getTick();\n      while ((_DAT_40023870 & 2) != 0) {\n        currentTime = getTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      startTime = getTick();\n      while ((_DAT_40023870 & 2) == 0) {\n        currentTime = getTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (flag) {\n      _DAT_40023840 = _DAT_40023840 & 0xefffffff;\n    }\n  }\n  if (commandParams[6] == 0) {\n    result = 0;\n  }\n  else if ((_DAT_40023808 & 0xc) == 8) {\n    result = 1;\n  }\n  else if (commandParams[6] == 2) {\n    _DAT_42470060 = 0;\n    startTime = getTick();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        _DAT_40023804 =\n             commandParams[7] | commandParams[8] | commandParams[9] << 6 | ((commandParams[10] >> 1) - 1) * 0x10000 |\n             commandParams[0xb] << 0x18;\n        _DAT_42470060 = 1;\n        startTime = getTick();\n        do {\n          if ((_DAT_40023800 & 0x2000000) != 0) {\n            return 0;\n          }\n          currentTime = getTick();\n        } while ((uint)(currentTime - startTime) < 3);\n        return 3;\n      }\n      currentTime = getTick();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  else {\n    _DAT_42470060 = 0;\n    startTime = getTick();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return 0;\n      }\n      currentTime = getTick();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800201c": "execute_command_0800201c",
                "param_1": "commandParams",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "result",
                "bVar4": "flag",
                "HAL_GetTick": "getTick"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080023b4": {
            "entrypoint": "0x080023b4",
            "current_name": "calculate_clock_frequency_080023b4",
            "code": "\n\n\nuint calculateClockFrequency_080023b4(void)\n\n{\n  undefined4 unusedParameter;\n  uint clockFrequency;\n  \n  if ((_DAT_40023808 & 0xc) == 4) {\n    return 8000000;\n  }\n  if ((_DAT_40023808 & 0xc) != 8) {\n    return 16000000;\n  }\n  if ((_DAT_40023804 & 0x400000) == 0) {\n    clockFrequency = (_DAT_40023804 << 0x11) >> 0x17;\n    clockFrequency = __aeabi_uldivmod(clockFrequency * 16000000,\n                             (((uint)(clockFrequency * 0x20 < clockFrequency) * -0x3f -\n                              (uint)(clockFrequency * 0x7c0 < clockFrequency * 0x1f)) * 8 +\n                             (uint)CARRY4(clockFrequency * 0x3d08,clockFrequency)) * 0x400 | clockFrequency * 0x3d09 >> 0x16,\n                             _DAT_40023804 & 0x3f,0,unusedParameter);\n  }\n  else {\n    clockFrequency = (_DAT_40023804 << 0x11) >> 0x17;\n    clockFrequency = __aeabi_uldivmod(clockFrequency * 8000000,\n                             (((uint)(clockFrequency * 0x20 < clockFrequency) * -0x3f -\n                              (uint)(clockFrequency * 0x7c0 < clockFrequency * 0x1f)) * 8 +\n                             (uint)CARRY4(clockFrequency * 0x3d08,clockFrequency)) * 0x200,_DAT_40023804 & 0x3f,0,\n                             unusedParameter);\n  }\n  return clockFrequency / ((((_DAT_40023804 << 0xe) >> 0x1e) + 1) * 2);\n}\n\n",
            "renaming": {
                "FUN_080023b4": "calculate_clock_frequency_080023b4",
                "in_r3": "unusedParameter",
                "uVar1": "clockFrequency"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "__aeabi_uldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002488": {
            "entrypoint": "0x08002488",
            "current_name": "initialize_device_08002488",
            "code": "\n\n\nundefined4 initialize_device_08002488(uint *device_configuration,uint num_configurations)\n\n{\n  int start_time;\n  int current_time;\n  uint sys_clock_freq;\n  \n  if (device_configuration == (uint *)0x0) {\n    return 1;\n  }\n  if ((_DAT_40023c00 & 0xf) < num_configurations) {\n    _DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)num_configurations);\n    if (num_configurations != (num_configurations & 0xf)) {\n      return 1;\n    }\n  }\n  if ((*device_configuration & 2) != 0) {\n    if ((*device_configuration & 4) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0x1c00;\n    }\n    if ((*device_configuration & 8) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0xe000;\n    }\n    _DAT_40023808 = _DAT_40023808 & 0xffffff0f | device_configuration[2];\n  }\n  if ((*device_configuration & 1) != 0) {\n    sys_clock_freq = device_configuration[1];\n    if (sys_clock_freq == 1) {\n      if ((_DAT_40023800 & 0x20000) == 0) {\n        return 1;\n      }\n    }\n    else if (sys_clock_freq - 2 < 2) {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return 1;\n      }\n    }\n    else if ((_DAT_40023800 & 2) == 0) {\n      return 1;\n    }\n    _DAT_40023808 = sys_clock_freq | _DAT_40023808 & 0xfffffffc;\n    start_time = HAL_GetTick();\n    while( true ) {\n      if ((_DAT_40023808 & 0xc) == device_configuration[1] * 4) break;\n      current_time = HAL_GetTick();\n      if (5000 < (uint)(current_time - start_time)) {\n        return 3;\n      }\n    }\n  }\n  if (num_configurations < (_DAT_40023c00 & 0xf)) {\n    _DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)num_configurations);\n    if (num_configurations != (num_configurations & 0xf)) {\n      return 1;\n    }\n  }\n  if ((*device_configuration & 4) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffffe3ff | device_configuration[3];\n  }\n  if ((*device_configuration & 8) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffff1fff | device_configuration[4] << 3;\n  }\n  sys_clock_freq = HAL_RCC_GetSysClockFreq();\n  DAT_2000002c = sys_clock_freq >> (&DAT_08005dfc)[(_DAT_40023808 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002488": "initialize_device_08002488",
                "param_1": "device_configuration",
                "param_2": "num_configurations",
                "iVar1": "start_time",
                "iVar2": "current_time",
                "uVar3": "sys_clock_freq"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_InitTick",
                "HAL_RCC_GetSysClockFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e0": {
            "entrypoint": "0x080025e0",
            "current_name": "get_global_data_080025e0",
            "code": "\nundefined4 getGlobalData_080025e0(void)\n\n{\n  return DAT_2000002c;\n}\n\n",
            "renaming": {
                "FUN_080025e0": "get_global_data_080025e0"
            },
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "SystemClock_Config",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025ec": {
            "entrypoint": "0x080025ec",
            "current_name": "get_hclk_divisor_080025ec",
            "code": "\n\n\nuint getHCLKDivisor_080025ec(void)\n\n{\n  uint hclkFreq;\n  \n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  return hclkFreq >> (&DAT_08005e0c)[(uint)(_DAT_40023808 << 0x13) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_080025ec": "get_hclk_divisor_080025ec",
                "uVar1": "hclkFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800260c": {
            "entrypoint": "0x0800260c",
            "current_name": "get_adjusted_hclk_freq_0800260c",
            "code": "\n\n\nuint getAdjustedHCLKFreq_0800260c(void)\n\n{\n  uint HCLKFreq;\n  \n  HCLKFreq = getHCLKFreq();\n  return HCLKFreq >> (&DAT_08005e0c)[(uint)(_DAT_40023808 << 0x10) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_0800260c": "get_adjusted_hclk_freq_0800260c",
                "uVar1": "HCLKFreq",
                "HAL_RCC_GetHCLKFreq": "getHCLKFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800262c": {
            "entrypoint": "0x0800262c",
            "current_name": "handle_alarm_events_0800262c",
            "code": "\n\n\nvoid handleAlarmEvents_0800262c(int *alarmParams)\n\n{\n  if (((*(uint *)(*alarmParams + 0xc) & 0x100) != 0) && ((*(uint *)(*alarmParams + 8) & 0x1000) != 0)) {\n    HAL_RTC_AlarmAEventCallback();\n    *(uint *)(*alarmParams + 0xc) = *(uint *)(*alarmParams + 0xc) & 0xff | 0xfffffe7f;\n  }\n  if (((*(uint *)(*alarmParams + 0xc) & 0x200) != 0) && ((*(uint *)(*alarmParams + 8) & 0x2000) != 0)) {\n    HAL_RTCEx_AlarmBEventCallback(alarmParams);\n    *(uint *)(*alarmParams + 0xc) = *(uint *)(*alarmParams + 0xc) & 0xff | 0xfffffd7f;\n  }\n  _DAT_40013c14 = 0x20000;\n  *(undefined *)((int)alarmParams + 0x1d) = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800262c": "handle_alarm_events_0800262c",
                "param_1": "alarmParams"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmAEventCallback",
                "HAL_RTCEx_AlarmBEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800268c": {
            "entrypoint": "0x0800268c",
            "current_name": "FUNC_0800268c",
            "code": "\nvoid FUNC_0800268c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800268c": "FUNC_0800268c"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800268e": {
            "entrypoint": "0x0800268e",
            "current_name": "deinitialize_pwm_timers_0800268e",
            "code": "\nvoid deinitializePwmTimers_0800268e(uint **pointerToParams)\n\n{\n  uint *pointerToData;\n  \n  *(undefined *)((int)pointerToParams + 0x39) = 2;\n  pointerToData = *pointerToParams;\n  if ((pointerToData[8] & 0x1111) == 0) {\n    if ((pointerToData[8] & 0x444) == 0) {\n      *pointerToData = *pointerToData & 0xfffffffe;\n    }\n  }\n  deinitializeTimer(pointerToParams);\n  *(undefined *)((int)pointerToParams + 0x39) = 0;\n  *(undefined *)(pointerToParams + 0xe) = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800268e": "deinitialize_pwm_timers_0800268e",
                "param_1": "pointerToParams",
                "puVar1": "pointerToData",
                "HAL_TIM_PWM_MspDeInit": "deinitializeTimer"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080026c8": {
            "entrypoint": "0x080026c8",
            "current_name": "FUNC_080026c8",
            "code": "\nvoid FUNC_080026c8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026c8": "FUNC_080026c8"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ca": {
            "entrypoint": "0x080026ca",
            "current_name": "FUNC_080026ca",
            "code": "\nvoid FUNC_080026ca(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ca": "FUNC_080026ca"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026cc": {
            "entrypoint": "0x080026cc",
            "current_name": "FUNC_080026cc",
            "code": "\nvoid FUNC_080026cc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026cc": "FUNC_080026cc"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ce": {
            "entrypoint": "0x080026ce",
            "current_name": "process_timers_080026ce",
            "code": "\nvoid processTimers_080026ce(int *timerData)\n\n{\n  int timer;\n  \n  timer = *timerData;\n  if (((*(uint *)(timer + 0x10) & 2) != 0) && ((*(uint *)(timer + 0xc) & 2) != 0)) {\n    *(undefined4 *)(timer + 0x10) = 0xfffffffd;\n    *(undefined *)(timerData + 6) = 1;\n    if ((*(uint *)(*timerData + 0x18) & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback();\n      HAL_TIM_PWM_PulseFinishedCallback(timerData);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback();\n    }\n    *(undefined *)(timerData + 6) = 0;\n  }\n  timer = *timerData;\n  if (((*(uint *)(timer + 0x10) & 4) != 0) && ((*(uint *)(timer + 0xc) & 4) != 0)) {\n    *(undefined4 *)(timer + 0x10) = 0xfffffffb;\n    *(undefined *)(timerData + 6) = 2;\n    if ((*(uint *)(*timerData + 0x18) & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerData);\n      HAL_TIM_PWM_PulseFinishedCallback(timerData);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerData);\n    }\n    *(undefined *)(timerData + 6) = 0;\n  }\n  timer = *timerData;\n  if (((*(uint *)(timer + 0x10) & 8) != 0) && ((*(uint *)(timer + 0xc) & 8) != 0)) {\n    *(undefined4 *)(timer + 0x10) = 0xfffffff7;\n    *(undefined *)(timerData + 6) = 4;\n    if ((*(uint *)(*timerData + 0x1c) & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerData);\n      HAL_TIM_PWM_PulseFinishedCallback(timerData);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerData);\n    }\n    *(undefined *)(timerData + 6) = 0;\n  }\n  timer = *timerData;\n  if (((*(uint *)(timer + 0x10) & 0x10) != 0) && ((*(uint *)(timer + 0xc) & 0x10) != 0)) {\n    *(undefined4 *)(timer + 0x10) = 0xffffffef;\n    *(undefined *)(timerData + 6) = 8;\n    if ((*(uint *)(*timerData + 0x1c) & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerData);\n      HAL_TIM_PWM_PulseFinishedCallback(timerData);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerData);\n    }\n    *(undefined *)(timerData + 6) = 0;\n  }\n  timer = *timerData;\n  if (((*(uint *)(timer + 0x10) & 1) != 0) && ((*(uint *)(timer + 0xc) & 1) != 0)) {\n    *(undefined4 *)(timer + 0x10) = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(timerData);\n  }\n  timer = *timerData;\n  if (((*(uint *)(timer + 0x10) & 0x80) != 0) && ((*(uint *)(timer + 0xc) & 0x80) != 0)) {\n    *(undefined4 *)(timer + 0x10) = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(timerData);\n  }\n  timer = *timerData;\n  if (((*(uint *)(timer + 0x10) & 0x40) != 0) && ((*(uint *)(timer + 0xc) & 0x40) != 0)) {\n    *(undefined4 *)(timer + 0x10) = 0xffffffbf;\n    HAL_TIM_TriggerCallback(timerData);\n  }\n  timer = *timerData;\n  if (((*(uint *)(timer + 0x10) & 0x20) != 0) && ((*(uint *)(timer + 0xc) & 0x20) != 0)) {\n    *(undefined4 *)(timer + 0x10) = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(timerData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ce": "process_timers_080026ce",
                "param_1": "timerData",
                "iVar1": "timer"
            },
            "calling": [
                "TIM1_UP_TIM10_IRQHandler"
            ],
            "called": [
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIMEx_BreakCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002848": {
            "entrypoint": "0x08002848",
            "current_name": "update_bit_value_08002848",
            "code": "\nvoid updateBitValue_08002848(int ptr,uint bitPosition,int value)\n\n{\n  *(uint *)(ptr + 0x20) = *(uint *)(ptr + 0x20) & ~(1 << (bitPosition & 0xff));\n  *(uint *)(ptr + 0x20) = *(uint *)(ptr + 0x20) | value << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002848": "update_bit_value_08002848",
                "param_1": "ptr",
                "param_2": "bitPosition",
                "param_3": "value"
            },
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002864": {
            "entrypoint": "0x08002864",
            "current_name": "disable_timer_capture_channel_08002864",
            "code": "\nundefined4 disableTimerCaptureChannel_08002864(uint **timerConfig,undefined4 channel)\n\n{\n  bool isTimerValid;\n  uint *timerPtr;\n  \n  TIM_CCxChannelCmd(*timerConfig,channel,0);\n  timerPtr = *timerConfig;\n  if (timerPtr == (uint *)0x40010000) {\n    isTimerValid = true;\n  }\n  else if (timerPtr == (uint *)0x40010400) {\n    isTimerValid = true;\n  }\n  else {\n    isTimerValid = false;\n  }\n  if (((isTimerValid) && ((timerPtr[8] & 0x1111) == 0)) && ((timerPtr[8] & 0x444) == 0)) {\n    timerPtr[0x11] = timerPtr[0x11] & 0xffff7fff;\n  }\n  timerPtr = *timerConfig;\n  if (((timerPtr[8] & 0x1111) == 0) && ((timerPtr[8] & 0x444) == 0)) {\n    *timerPtr = *timerPtr & 0xfffffffe;\n  }\n  *(undefined *)((int)timerConfig + 0x39) = 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002864": "disable_timer_capture_channel_08002864",
                "param_1": "timerConfig",
                "param_2": "channel",
                "bVar1": "isTimerValid",
                "puVar2": "timerPtr"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028d4": {
            "entrypoint": "0x080028d4",
            "current_name": "update_bitwise_value_080028d4",
            "code": "\nvoid updateBitwiseValue_080028d4(int p1,uint p2,int p3)\n\n{\n  *(uint *)(p1 + 0x20) = *(uint *)(p1 + 0x20) & ~(4 << (p2 & 0xff));\n  *(uint *)(p1 + 0x20) = *(uint *)(p1 + 0x20) | p3 << (p2 & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080028d4": "update_bitwise_value_080028d4",
                "param_1": "p1",
                "param_2": "p2",
                "param_3": "p3"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028f0": {
            "entrypoint": "0x080028f0",
            "current_name": "disable_tim_ccn_channel_080028f0",
            "code": "\nundefined4 disableTimCcnChannel_080028f0(uint **timCcnChannel,undefined4 channelCmd)\n\n{\n  uint *timCcnChannelPtr;\n  \n  TIM_CCxNChannelCmd(*timCcnChannel,channelCmd,0);\n  timCcnChannelPtr = *timCcnChannel;\n  if (((timCcnChannelPtr[8] & 0x1111) == 0) && ((timCcnChannelPtr[8] & 0x444) == 0)) {\n    timCcnChannelPtr[0x11] = timCcnChannelPtr[0x11] & 0xffff7fff;\n  }\n  timCcnChannelPtr = *timCcnChannel;\n  if (((timCcnChannelPtr[8] & 0x1111) == 0) && ((timCcnChannelPtr[8] & 0x444) == 0)) {\n    *timCcnChannelPtr = *timCcnChannelPtr & 0xfffffffe;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080028f0": "disable_tim_ccn_channel_080028f0",
                "param_1": "timCcnChannel",
                "param_2": "channelCmd",
                "puVar1": "timCcnChannelPtr"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800293c": {
            "entrypoint": "0x0800293c",
            "current_name": "FUNC_0800293c",
            "code": "\nvoid FUNC_0800293c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293c": "FUNC_0800293c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800293e": {
            "entrypoint": "0x0800293e",
            "current_name": "FUNC_0800293e",
            "code": "\nvoid FUNC_0800293e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293e": "FUNC_0800293e"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002940": {
            "entrypoint": "0x08002940",
            "current_name": "clear_flags_08002940",
            "code": "\nvoid clearFlags_08002940(int *flagsPtr)\n\n{\n  *(uint *)(*flagsPtr + 0xc) = *(uint *)(*flagsPtr + 0xc) & 0xfffffedf;\n  *(uint *)(*flagsPtr + 0x14) = *(uint *)(*flagsPtr + 0x14) & 0xfffffffe;\n  *(undefined *)((int)flagsPtr + 0x3a) = 0x20;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002940": "clear_flags_08002940",
                "param_1": "flagsPtr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800295c": {
            "entrypoint": "0x0800295c",
            "current_name": "process_data_0800295c",
            "code": "\nundefined4 processData_0800295c(int *data)\n\n{\n  short count;\n  byte *currentByte;\n  \n  if (*(char *)((int)data + 0x39) != '!') {\n    return 2;\n  }\n  if (data[2] == 0x1000) {\n    *(uint *)(*data + 4) = *(ushort *)data[8] & 0x1ff;\n    if (data[4] == 0) {\n      data[8] = data[8] + 2;\n    }\n    else {\n      data[8] = data[8] + 1;\n    }\n  }\n  else {\n    currentByte = (byte *)data[8];\n    data[8] = (int)(currentByte + 1);\n    *(uint *)(*data + 4) = (uint)*currentByte;\n  }\n  count = *(short *)((int)data + 0x26) + -1;\n  *(short *)((int)data + 0x26) = count;\n  if (count == 0) {\n    *(uint *)(*data + 0xc) = *(uint *)(*data + 0xc) & 0xffffff7f;\n    *(uint *)(*data + 0xc) = *(uint *)(*data + 0xc) | 0x40;\n    return 0;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800295c": "process_data_0800295c",
                "param_1": "data",
                "sVar1": "count",
                "pbVar2": "currentByte"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080029c8": {
            "entrypoint": "0x080029c8",
            "current_name": "calculate_pclk_value_080029c8",
            "code": "\nvoid calculatePCLKValue_080029c8(int *config)\n\n{\n  int pclk1Freq1;\n  int pclk1Freq2;\n  int pclk1Freq3;\n  int pclk1Freq4;\n  int pclk1Freq5;\n  int pclk2Freq1;\n  int pclk2Freq2;\n  int pclk2Freq3;\n  int pclk2Freq4;\n  int baseAddress;\n  \n  *(uint *)(*config + 0x10) = *(uint *)(*config + 0x10) & 0xffffcfff | config[3];\n  *(uint *)(*config + 0xc) =\n       *(uint *)(*config + 0xc) & 0xffff69f3 | config[2] | config[4] | config[5] | config[7];\n  *(uint *)(*config + 0x14) = *(uint *)(*config + 0x14) & 0xfffffcff | config[6];\n  if (config[7] == 0x8000) {\n    baseAddress = *config;\n    if ((baseAddress != 0x40011000) && (baseAddress != 0x40011400)) {\n      pclk1Freq1 = HAL_RCC_GetPCLK1Freq();\n      pclk2Freq1 = config[1];\n      pclk1Freq2 = HAL_RCC_GetPCLK1Freq();\n      pclk2Freq2 = config[1];\n      pclk1Freq3 = HAL_RCC_GetPCLK1Freq();\n      pclk2Freq3 = config[1];\n      pclk1Freq4 = HAL_RCC_GetPCLK1Freq();\n      pclk2Freq4 = config[1];\n      pclk1Freq5 = HAL_RCC_GetPCLK1Freq();\n      *(uint *)(baseAddress + 8) =\n           ((uint)((int)((ulonglong)\n                         (((uint)(pclk1Freq4 * 0x19) / (uint)(pclk2Freq4 << 1) +\n                          (int)(((ulonglong)(uint)(pclk1Freq5 * 0x19) /\n                                (ulonglong)(uint)(config[1] << 1)) / 100) * -100) * 8 + 0x32) *\n                         0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n           ((((uint)(pclk1Freq2 * 0x19) / (uint)(pclk2Freq2 << 1) +\n             (int)(((ulonglong)(uint)(pclk1Freq3 * 0x19) / (ulonglong)(uint)(pclk2Freq3 << 1)) / 100) * -100)\n             * 8 + 0x32) / 100 & 0xf8) * 2 +\n           (int)(((ulonglong)(uint)(pclk1Freq1 * 0x19) / (ulonglong)(uint)(pclk2Freq1 << 1)) / 100) * 0x10;\n      return;\n    }\n    pclk1Freq1 = HAL_RCC_GetPCLK2Freq();\n    pclk2Freq1 = config[1];\n    pclk1Freq2 = HAL_RCC_GetPCLK2Freq();\n    pclk2Freq2 = config[1];\n    pclk1Freq3 = HAL_RCC_GetPCLK2Freq();\n    pclk2Freq3 = config[1];\n    pclk1Freq4 = HAL_RCC_GetPCLK2Freq();\n    pclk2Freq4 = config[1];\n    pclk1Freq5 = HAL_RCC_GetPCLK2Freq();\n    *(uint *)(baseAddress + 8) =\n         ((uint)((int)((ulonglong)\n                       (((uint)(pclk1Freq4 * 0x19) / (uint)(pclk2Freq4 << 1) +\n                        (int)(((ulonglong)(uint)(pclk1Freq5 * 0x19) / (ulonglong)(uint)(config[1] << 1))\n                             / 100) * -100) * 8 + 0x32) * 0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n         ((((uint)(pclk1Freq2 * 0x19) / (uint)(pclk2Freq2 << 1) +\n           (int)(((ulonglong)(uint)(pclk1Freq3 * 0x19) / (ulonglong)(uint)(pclk2Freq3 << 1)) / 100) * -100) *\n           8 + 0x32) / 100 & 0xf8) * 2 +\n         (int)(((ulonglong)(uint)(pclk1Freq1 * 0x19) / (ulonglong)(uint)(pclk2Freq1 << 1)) / 100) * 0x10;\n    return;\n  }\n  baseAddress = *config;\n  if ((baseAddress != 0x40011000) && (baseAddress != 0x40011400)) {\n    pclk1Freq1 = HAL_RCC_GetPCLK1Freq();\n    pclk2Freq1 = config[1];\n    pclk1Freq2 = HAL_RCC_GetPCLK1Freq();\n    pclk2Freq2 = config[1];\n    pclk1Freq3 = HAL_RCC_GetPCLK1Freq();\n    pclk2Freq3 = config[1];\n    pclk1Freq4 = HAL_RCC_GetPCLK1Freq();\n    pclk2Freq4 = config[1];\n    pclk1Freq5 = HAL_RCC_GetPCLK1Freq();\n    *(uint *)(baseAddress + 8) =\n         ((uint)((int)((ulonglong)\n                       (((uint)(pclk1Freq4 * 0x19) / (uint)(pclk2Freq4 << 2) +\n                        (int)(((ulonglong)(uint)(pclk1Freq5 * 0x19) / (ulonglong)(uint)(config[1] << 2))\n                             / 100) * -100) * 0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n         ((((uint)(pclk1Freq2 * 0x19) / (uint)(pclk2Freq2 << 2) +\n           (int)(((ulonglong)(uint)(pclk1Freq3 * 0x19) / (ulonglong)(uint)(pclk2Freq3 << 2)) / 100) * -100) *\n           0x10 + 0x32) / 100 & 0xf0) +\n         (int)(((ulonglong)(uint)(pclk1Freq1 * 0x19) / (ulonglong)(uint)(pclk2Freq1 << 2)) / 100) * 0x10;\n    return;\n  }\n  pclk1Freq1 = HAL_RCC_GetPCLK2Freq();\n  pclk2Freq1 = config[1];\n  pclk1Freq2 = HAL_RCC_GetPCLK2Freq();\n  pclk2Freq2 = config[1];\n  pclk1Freq3 = HAL_RCC_GetPCLK2Freq();\n  pclk2Freq3 = config[1];\n  pclk1Freq4 = HAL_RCC_GetPCLK2Freq();\n  pclk2Freq4 = config[1];\n  pclk1Freq5 = HAL_RCC_GetPCLK2Freq();\n  *(uint *)(baseAddress + 8) =\n       ((uint)((int)((ulonglong)\n                     (((uint)(pclk1Freq4 * 0x19) / (uint)(pclk2Freq4 << 2) +\n                      (int)(((ulonglong)(uint)(pclk1Freq5 * 0x19) / (ulonglong)(uint)(config[1] << 2)) /\n                           100) * -100) * 0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n       ((((uint)(pclk1Freq2 * 0x19) / (uint)(pclk2Freq2 << 2) +\n         (int)(((ulonglong)(uint)(pclk1Freq3 * 0x19) / (ulonglong)(uint)(pclk2Freq3 << 2)) / 100) * -100) *\n         0x10 + 0x32) / 100 & 0xf0) +\n       (int)(((ulonglong)(uint)(pclk1Freq1 * 0x19) / (ulonglong)(uint)(pclk2Freq1 << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080029c8": "calculate_pclk_value_080029c8",
                "param_1": "config",
                "iVar1": "pclk1Freq1",
                "iVar2": "pclk1Freq2",
                "iVar3": "pclk1Freq3",
                "iVar4": "pclk1Freq4",
                "iVar5": "pclk1Freq5",
                "iVar6": "pclk2Freq1",
                "iVar7": "pclk2Freq2",
                "iVar8": "pclk2Freq3",
                "iVar9": "pclk2Freq4",
                "iVar10": "baseAddress"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d0c": {
            "entrypoint": "0x08002d0c",
            "current_name": "check_compatibility_08002d0c",
            "code": "\nundefined4 checkCompatibility_08002d0c(uint **data,uint flag,uint expectedResult,int startTime,uint timeout)\n\n{\n  int currentTime;\n  \n  do {\n    if (((flag & ~**data) == 0) != expectedResult) {\n      return 0;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTime = HAL_GetTick(), (uint)(currentTime - startTime) <= timeout))));\n  (*data)[3] = (*data)[3] & 0xfffffe5f;\n  (*data)[5] = (*data)[5] & 0xfffffffe;\n  *(undefined *)((int)data + 0x39) = 0x20;\n  *(undefined *)((int)data + 0x3a) = 0x20;\n  *(undefined *)(data + 0xe) = 0;\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_08002d0c": "check_compatibility_08002d0c",
                "param_1": "data",
                "param_2": "flag",
                "param_3": "expectedResult",
                "param_4": "startTime",
                "param_5": "timeout",
                "iVar1": "currentTime"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d70": {
            "entrypoint": "0x08002d70",
            "current_name": "FUNC_08002d70",
            "code": "\nvoid FUNC_08002d70(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d70": "FUNC_08002d70"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d72": {
            "entrypoint": "0x08002d72",
            "current_name": "initialize_uart_08002d72",
            "code": "\nundefined4 initializeUART_08002d72(int *uartInstance)\n\n{\n  if (uartInstance != (int *)0x0) {\n    if (*(char *)((int)uartInstance + 0x39) == '\\0') {\n      *(undefined *)(uartInstance + 0xe) = 0;\n      initializeUART_08002d72Peripherals();\n    }\n    *(undefined *)((int)uartInstance + 0x39) = 0x24;\n    *(uint *)(*uartInstance + 0xc) = *(uint *)(*uartInstance + 0xc) & 0xffffdfff;\n    configureUART(uartInstance);\n    *(uint *)(*uartInstance + 0x10) = *(uint *)(*uartInstance + 0x10) & 0xffffb7ff;\n    *(uint *)(*uartInstance + 0x14) = *(uint *)(*uartInstance + 0x14) & 0xffffffd5;\n    *(uint *)(*uartInstance + 0xc) = *(uint *)(*uartInstance + 0xc) | 0x2000;\n    uartStatusFlag = 0;\n    *(undefined *)((int)uartInstance + 0x39) = 0x20;\n    *(undefined *)((int)uartInstance + 0x3a) = 0x20;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002d72": "initialize_uart_08002d72",
                "param_1": "uartInstance",
                "HAL_UART_MspInit": "initializeUARTPeripherals",
                "UART_SetConfig": "configureUART",
                "param_1[0xf]": "uartStatusFlag"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002dd0": {
            "entrypoint": "0x08002dd0",
            "current_name": "process_data_08002dd0",
            "code": "\nundefined4 processData_08002dd0(int *dataBuffer,ushort *inputBuffer,int inputLength,undefined4 timeout)\n\n{\n  int errorFlag;\n  undefined4 returnValue;\n  \n  if (*(char *)((int)dataBuffer + 0x39) == ' ') {\n    if (inputBuffer == (ushort *)0x0) {\n      returnValue = 1;\n    }\n    else if (inputLength == 0) {\n      returnValue = 1;\n    }\n    else if (*(char *)(dataBuffer + 0xe) == '\\x01') {\n      returnValue = 2;\n    }\n    else {\n      *(undefined *)(dataBuffer + 0xe) = 1;\n      dataBuffer[0xf] = 0;\n      *(undefined *)((int)dataBuffer + 0x39) = 0x21;\n      returnValue = HAL_GetTick();\n      *(short *)(dataBuffer + 9) = (short)inputLength;\n      *(short *)((int)dataBuffer + 0x26) = (short)inputLength;\n      while (*(short *)((int)dataBuffer + 0x26) != 0) {\n        *(short *)((int)dataBuffer + 0x26) = *(short *)((int)dataBuffer + 0x26) + -1;\n        if (dataBuffer[2] == 0x1000) {\n          errorFlag = UART_WaitOnFlagUntilTimeout(dataBuffer,0x80,0,returnValue,timeout);\n          if (errorFlag != 0) {\n            return 3;\n          }\n          *(uint *)(*dataBuffer + 4) = *inputBuffer & 0x1ff;\n          if (dataBuffer[4] == 0) {\n            inputBuffer = inputBuffer + 1;\n          }\n          else {\n            inputBuffer = (ushort *)((int)inputBuffer + 1);\n          }\n        }\n        else {\n          errorFlag = UART_WaitOnFlagUntilTimeout(dataBuffer,0x80,0,returnValue,timeout);\n          if (errorFlag != 0) {\n            return 3;\n          }\n          *(uint *)(*dataBuffer + 4) = (uint)*(byte *)inputBuffer;\n          inputBuffer = (ushort *)((int)inputBuffer + 1);\n        }\n      }\n      errorFlag = UART_WaitOnFlagUntilTimeout(dataBuffer,0x40,0,returnValue,timeout);\n      if (errorFlag == 0) {\n        *(undefined *)((int)dataBuffer + 0x39) = 0x20;\n        *(undefined *)(dataBuffer + 0xe) = 0;\n        returnValue = 0;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08002dd0": "process_data_08002dd0",
                "param_1": "dataBuffer",
                "param_2": "inputBuffer",
                "param_3": "inputLength",
                "param_4": "timeout",
                "iVar1": "errorFlag",
                "uVar2": "returnValue"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002eb2": {
            "entrypoint": "0x08002eb2",
            "current_name": "validate_input_08002eb2",
            "code": "\nundefined4 validate_input_08002eb2(int *array,int value1,int value2)\n\n{\n  if (*(char *)((int)array + 0x39) != ' ') {\n    return 2;\n  }\n  if (value1 == 0) {\n    return 1;\n  }\n  if (value2 == 0) {\n    return 1;\n  }\n  if (*(char *)(array + 0xe) != '\\x01') {\n    array_element8 = value1;\n    *(short *)(array + 9) = (short)value2;\n    *(short *)((int)array + 0x26) = (short)value2;\n    array_element0xf = 0;\n    *(undefined *)((int)array + 0x39) = 0x21;\n    *(undefined *)(array + 0xe) = 0;\n    *(uint *)(*array + 0xc) = *(uint *)(*array + 0xc) | 0x80;\n    return 0;\n  }\n  return 2;\n}\n\n",
            "renaming": {
                "FUN_08002eb2": "validate_input_08002eb2",
                "param_1": "array",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[8]": "array_element8",
                "param_1[0xf]": "array_element0xf"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efa": {
            "entrypoint": "0x08002efa",
            "current_name": "update_data_08002efa",
            "code": "\nundefined4 updateData_08002efa(int *data,int value1,int value2)\n\n{\n  if (*(char *)((int)data + 0x3a) != ' ') {\n    return 2;\n  }\n  if (value1 == 0) {\n    return 1;\n  }\n  if (value2 == 0) {\n    return 1;\n  }\n  if (*(char *)(data + 0xe) != '\\x01') {\n    dataElement10 = value1;\n    *(short *)(data + 0xb) = (short)value2;\n    *(short *)((int)data + 0x2e) = (short)value2;\n    dataElement15 = 0;\n    *(undefined *)((int)data + 0x3a) = 0x22;\n    *(undefined *)(data + 0xe) = 0;\n    *(uint *)(*data + 0x14) = *(uint *)(*data + 0x14) | 1;\n    *(uint *)(*data + 0xc) = *(uint *)(*data + 0xc) | 0x120;\n    return 0;\n  }\n  return 2;\n}\n\n",
            "renaming": {
                "FUN_08002efa": "update_data_08002efa",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[10]": "dataElement10",
                "param_1[0xf]": "dataElement15"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f4c": {
            "entrypoint": "0x08002f4c",
            "current_name": "set_uart_configuration_08002f4c",
            "code": "\nundefined4 setUartConfiguration_08002f4c(int *uartConfig)\n\n{\n  *(uint *)(*uartConfig + 0xc) = *(uint *)(*uartConfig + 0xc) & 0xffffffbf;\n  *(undefined *)((int)uartConfig + 0x39) = 0x20;\n  handleTransmitComplete();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002f4c": "set_uart_configuration_08002f4c",
                "param_1": "uartConfig",
                "HAL_UART_TxCpltCallback": "handleTransmitComplete"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f66": {
            "entrypoint": "0x08002f66",
            "current_name": "process_input_08002f66",
            "code": "\nundefined4 processInput_08002f66(int *inputData)\n\n{\n  byte *bytePointer;\n  short previousCount;\n  undefined *undefinedPointer;\n  \n  if (*(char *)((int)inputData + 0x3a) != '\\\"') {\n    return 2;\n  }\n  if (inputData[2] == 0x1000) {\n    if (inputData[4] == 0) {\n      *(ushort *)inputData[10] = (ushort)((uint)(*(int *)(*inputData + 4) << 0x17) >> 0x17);\n      inputData[10] = inputData[10] + 2;\n    }\n    else {\n      *(ushort *)inputData[10] = (ushort)*(undefined4 *)(*inputData + 4) & 0xff;\n      inputData[10] = inputData[10] + 1;\n    }\n  }\n  else if (inputData[4] == 0) {\n    undefinedPointer = (undefined *)inputData[10];\n    inputData[10] = (int)(undefinedPointer + 1);\n    *undefinedPointer = (char)*(undefined4 *)(*inputData + 4);\n  }\n  else {\n    bytePointer = (byte *)inputData[10];\n    inputData[10] = (int)(bytePointer + 1);\n    *bytePointer = (byte)*(undefined4 *)(*inputData + 4) & 0x7f;\n  }\n  previousCount = *(short *)((int)inputData + 0x2e) + -1;\n  *(short *)((int)inputData + 0x2e) = previousCount;\n  if (previousCount != 0) {\n    return 0;\n  }\n  *(uint *)(*inputData + 0xc) = *(uint *)(*inputData + 0xc) & 0xfffffedf;\n  *(uint *)(*inputData + 0x14) = *(uint *)(*inputData + 0x14) & 0xfffffffe;\n  *(undefined *)((int)inputData + 0x3a) = 0x20;\n  HAL_UART_RxCpltCallback();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002f66": "process_input_08002f66",
                "param_1": "inputData",
                "pbVar1": "bytePointer",
                "sVar2": "previousCount",
                "puVar3": "undefinedPointer"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ffc": {
            "entrypoint": "0x08002ffc",
            "current_name": "handle_uart_operations_08002ffc",
            "code": "\nvoid handleUARTOperations_08002ffc(uint **paramList)\n\n{\n  int returnValue;\n  uint secondValue;\n  uint *pointerVar;\n  uint fourthValue;\n  uint firstValue;\n  \n  pointerVar = *paramList;\n  firstValue = *pointerVar;\n  secondValue = pointerVar[3];\n  if ((((firstValue & 0xf) == 0) && ((firstValue & 0x20) != 0)) && ((secondValue & 0x20) != 0)) {\n    UART_Receive_IT(paramList);\n    return;\n  }\n  if (((firstValue & 0xf) == 0) || ((fourthValue = pointerVar[5] & 1, fourthValue == 0 && ((secondValue & 0x120) == 0)))) {\n    if (((firstValue & 0x80) != 0) && ((secondValue & 0x80) != 0)) {\n      UART_Transmit_IT(paramList);\n      return;\n    }\n    if (((firstValue & 0x40) != 0) && ((secondValue & 0x40) != 0)) {\n      UART_EndTransmit_IT(paramList);\n    }\n  }\n  else {\n    if (((firstValue & 1) != 0) && ((secondValue & 0x100) != 0)) {\n      paramList[0xf] = (uint *)((uint)paramList[0xf] | 1);\n    }\n    if (((firstValue & 4) != 0) && (fourthValue != 0)) {\n      paramList[0xf] = (uint *)((uint)paramList[0xf] | 2);\n    }\n    if (((firstValue & 2) != 0) && (fourthValue != 0)) {\n      paramList[0xf] = (uint *)((uint)paramList[0xf] | 4);\n    }\n    if (((firstValue & 8) != 0) && (fourthValue != 0)) {\n      paramList[0xf] = (uint *)((uint)paramList[0xf] | 8);\n    }\n    if (paramList[0xf] != (uint *)0x0) {\n      if (((firstValue & 0x20) != 0) && ((secondValue & 0x20) != 0)) {\n        UART_Receive_IT(paramList);\n      }\n      if ((((uint)paramList[0xf] & 8) == 0) && (((*paramList)[5] & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(paramList);\n        paramList[0xf] = (uint *)0x0;\n        return;\n      }\n      UART_EndRxTransfer(paramList);\n      pointerVar = *paramList;\n      if ((pointerVar[5] & 0x40) == 0) {\n        HAL_UART_ErrorCallback(paramList);\n        return;\n      }\n      pointerVar[5] = pointerVar[5] & 0xffffffbf;\n      if (paramList[0xd] == (uint *)0x0) {\n        HAL_UART_ErrorCallback(paramList);\n        return;\n      }\n      paramList[0xd][0x14] = (uint)&LAB_0800311c_1;\n      returnValue = HAL_DMA_Abort_IT(paramList[0xd]);\n      if (returnValue != 0) {\n        (*(code *)paramList[0xd][0x14])();\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ffc": "handle_uart_operations_08002ffc",
                "param_1": "paramList",
                "iVar1": "returnValue",
                "uVar2": "secondValue",
                "puVar3": "pointerVar",
                "uVar4": "fourthValue",
                "uVar5": "firstValue"
            },
            "calling": [],
            "called": [
                "UART_Transmit_IT",
                "HAL_DMA_Abort_IT",
                "HAL_UART_ErrorCallback",
                "UART_Receive_IT",
                "UART_EndTransmit_IT",
                "UART_EndRxTransfer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800312c": {
            "entrypoint": "0x0800312c",
            "current_name": "combine_bytes_0800312c",
            "code": "\nbyte combineBytes_0800312c(int input)\n\n{\n  return *(byte *)(input + 0x3a) | *(byte *)(input + 0x39);\n}\n\n",
            "renaming": {
                "FUN_0800312c": "combine_bytes_0800312c",
                "param_1": "input"
            },
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003138": {
            "entrypoint": "0x08003138",
            "current_name": "extract_bit_from_four_bytes_08003138",
            "code": "\nuint extractBitFromFourBytes_08003138(uint inputValue,int baseAddress)\n\n{\n  return *(uint *)(baseAddress + ((inputValue << 0x18) >> 0x1c) * 4) >> (inputValue & 0xf) & 1;\n}\n\n",
            "renaming": {
                "FUN_08003138": "extract_bit_from_four_bytes_08003138",
                "param_1": "inputValue",
                "param_2": "baseAddress"
            },
            "calling": [
                "pinMode",
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800314e": {
            "entrypoint": "0x0800314e",
            "current_name": "set_bit_0800314e",
            "code": "\nvoid setBit_0800314e(uint inputValue,int arrayAddress)\n\n{\n  uint shiftedBits;\n  \n  shiftedBits = (inputValue << 0x18) >> 0x1c;\n  *(uint *)(arrayAddress + shiftedBits * 4) = *(uint *)(arrayAddress + shiftedBits * 4) | 1 << (inputValue & 0xf);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800314e": "set_bit_0800314e",
                "param_1": "inputValue",
                "param_2": "arrayAddress",
                "uVar1": "shiftedBits"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800316c": {
            "entrypoint": "0x0800316c",
            "current_name": "update_array_at_index_0800316c",
            "code": "\nvoid updateArrayAtIndex_0800316c(uint index,int array)\n\n{\n  uint shiftedIndex;\n  \n  shiftedIndex = (index << 0x18) >> 0x1c;\n  *(uint *)(array + shiftedIndex * 4) = *(uint *)(array + shiftedIndex * 4) & ~(1 << (index & 0xf));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316c": "update_array_at_index_0800316c",
                "param_1": "index",
                "param_2": "array",
                "uVar1": "shiftedIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800318c": {
            "entrypoint": "0x0800318c",
            "current_name": "map_param_to_value_0800318c",
            "code": "\nundefined4 mapParamToValue_0800318c(undefined4 parameter)\n\n{\n  switch(parameter) {\n  case 0:\n    return 0x40020000;\n  case 1:\n    return 0x40020400;\n  case 2:\n    return 0x40020800;\n  case 3:\n    return 0x40020c00;\n  case 4:\n    return 0x40021000;\n  case 5:\n    return 0x40021400;\n  case 6:\n    return 0x40021800;\n  case 7:\n    return 0x40021c00;\n  case 8:\n    return 0x40022000;\n  case 9:\n    return 0x40022400;\n  case 10:\n    return 0x40022800;\n  default:\n    return 0;\n  }\n}\n\n",
            "renaming": {
                "FUN_0800318c": "map_param_to_value_0800318c",
                "param_1": "parameter"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080031fc": {
            "entrypoint": "0x080031fc",
            "current_name": "set_flag_and_return_address_080031fc",
            "code": "\n\n\nundefined4 setFlagAndReturnAddress_080031fc(undefined4 flagIndex)\n\n{\n  undefined4 address;\n  \n  switch(flagIndex) {\n  case 0:\n    _DAT_40023830 = _DAT_40023830 | 1;\n    address = 0x40020000;\n    break;\n  case 1:\n    _DAT_40023830 = _DAT_40023830 | 2;\n    address = 0x40020400;\n    break;\n  case 2:\n    _DAT_40023830 = _DAT_40023830 | 4;\n    address = 0x40020800;\n    break;\n  case 3:\n    _DAT_40023830 = _DAT_40023830 | 8;\n    address = 0x40020c00;\n    break;\n  case 4:\n    _DAT_40023830 = _DAT_40023830 | 0x10;\n    address = 0x40021000;\n    break;\n  case 5:\n    _DAT_40023830 = _DAT_40023830 | 0x20;\n    address = 0x40021400;\n    break;\n  case 6:\n    _DAT_40023830 = _DAT_40023830 | 0x40;\n    address = 0x40021800;\n    break;\n  case 7:\n    _DAT_40023830 = _DAT_40023830 | 0x80;\n    address = 0x40021c00;\n    break;\n  case 8:\n    _DAT_40023830 = _DAT_40023830 | 0x100;\n    address = 0x40022000;\n    break;\n  case 9:\n    _DAT_40023830 = _DAT_40023830 | 0x200;\n    address = 0x40022400;\n    break;\n  case 10:\n    _DAT_40023830 = _DAT_40023830 | 0x400;\n    address = 0x40022800;\n    break;\n  default:\n    address = 0;\n  }\n  return address;\n}\n\n",
            "renaming": {
                "FUN_080031fc": "set_flag_and_return_address_080031fc",
                "param_1": "flagIndex",
                "uVar1": "address"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003380": {
            "entrypoint": "0x08003380",
            "current_name": "check_pinmap_08003380",
            "code": "\nundefined4 check_pinmap_08003380(undefined4 input_value,undefined4 ptr_data,undefined4 param3,undefined4 param4)\n\n{\n  int result;\n  \n  result = pinmap_function(input_value,&DAT_08005a18,param3,param4,param4);\n  if ((uint)(result << 0xc) >> 0x1b != 2) {\n    return 0;\n  }\n  return 0x10;\n}\n\n",
            "renaming": {
                "FUN_08003380": "check_pinmap_08003380",
                "param_1": "input_value",
                "param_2": "ptr_data",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "result"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800339c": {
            "entrypoint": "0x0800339c",
            "current_name": "calculate_pinmap_0800339c",
            "code": "\nundefined4 calculate_pinmap_0800339c(undefined4 pinmap_value,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int result;\n  uint shifted_result;\n  \n  result = pinmap_function(pinmap_value,&DAT_08005a3c,param_3,param_4,param_4);\n  shifted_result = (uint)(result << 0xc) >> 0x1b;\n  if (shifted_result == 3) {\n    return 8;\n  }\n  if (shifted_result != 4) {\n    if (shifted_result != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_0800339c": "calculate_pinmap_0800339c",
                "param_1": "pinmap_value",
                "iVar1": "result",
                "uVar2": "shifted_result"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033c8": {
            "entrypoint": "0x080033c8",
            "current_name": "clear_flag_080033c8",
            "code": "\n\n\nvoid clearFlag_080033c8(void)\n\n{\n  _DAT_40023840 = _DAT_40023840 & 0xdfffffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033c8": "clear_flag_080033c8"
            },
            "calling": [
                "HAL_DAC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033d8": {
            "entrypoint": "0x080033d8",
            "current_name": "stop_and_de_init_dac_080033d8",
            "code": "\nvoid stopAndDeInitDAC_080033d8(undefined4 peripheral)\n\n{\n  int dacChannel;\n  int peripheralArray [5];\n  \n  peripheralArray[0] = pinmap_peripheral(peripheral,&DAT_08005a18);\n  if ((peripheralArray[0] != 0) && ((dacChannel = get_dac_channel(peripheral), dacChannel == 0 || (dacChannel == 0x10)))) {\n    HAL_DAC_Stop(peripheralArray,dacChannel);\n    HAL_DAC_DeInit(peripheralArray);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033d8": "stop_and_de_init_dac_080033d8",
                "param_1": "peripheral",
                "iVar1": "dacChannel",
                "local_1c": "peripheralArray"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_DAC_DeInit",
                "pinmap_peripheral",
                "HAL_DAC_Stop",
                "get_dac_channel"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800340c": {
            "entrypoint": "0x0800340c",
            "current_name": "disable_timer_clock_0800340c",
            "code": "\nvoid disable_timer_clock_0800340c(void)\n\n{\n  timer_disable_clock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800340c": "disable_timer_clock_0800340c"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003414": {
            "entrypoint": "0x08003414",
            "current_name": "stop_pwm_on_peripheral_08003414",
            "code": "\nvoid stopPwmOnPeripheral_08003414(undefined4 peripheral)\n\n{\n  int pwmChannel;\n  uint functionPinMap;\n  int pwmChannels [16];\n  \n  pwmChannels[0] = pinmap_peripheral(peripheral,&DAT_08005a3c);\n  if ((pwmChannels[0] != 0) &&\n     ((((pwmChannel = get_pwm_channel(peripheral), pwmChannel == 0 || (pwmChannel == 4)) || (pwmChannel == 8)) ||\n      ((pwmChannel == 0xc || (pwmChannel == 0x18)))))) {\n    functionPinMap = pinmap_function(peripheral,&DAT_08005a3c);\n    if ((functionPinMap & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(pwmChannels,pwmChannel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(pwmChannels,pwmChannel);\n    }\n    HAL_TIM_PWM_DeInit(pwmChannels);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003414": "stop_pwm_on_peripheral_08003414",
                "param_1": "peripheral",
                "local_4c": "pwmChannels",
                "iVar1": "pwmChannel",
                "uVar2": "functionPinMap"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "pinmap_peripheral",
                "pinmap_function",
                "HAL_TIMEx_PWMN_Stop",
                "HAL_TIM_PWM_DeInit",
                "get_pwm_channel",
                "HAL_TIM_PWM_Stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800346c": {
            "entrypoint": "0x0800346c",
            "current_name": "get_current_tick_0800346c",
            "code": "\nvoid get_current_tick_0800346c(void)\n\n{\n  current_tick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800346c": "get_current_tick_0800346c",
                "HAL_GetTick": "current_tick"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003474": {
            "entrypoint": "0x08003474",
            "current_name": "FUNC_08003474",
            "code": "\nvoid FUNC_08003474(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003474": "FUNC_08003474"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003476": {
            "entrypoint": "0x08003476",
            "current_name": "handle_system_tick_08003476",
            "code": "\nvoid handleSystemTick_08003476(void)\n\n{\n  incrementSystemTick();\n  handleSystemTick_08003476Interrupt();\n  handleNoOsSystick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003476": "handle_system_tick_08003476",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSystemTickInterrupt",
                "noOsSystickHandler": "handleNoOsSystick"
            },
            "calling": [],
            "called": [
                "noOsSystickHandler",
                "HAL_SYSTICK_IRQHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003486": {
            "entrypoint": "0x08003486",
            "current_name": "initialize_gpio_08003486",
            "code": "\nvoid initializeGPIO_08003486(uint pinNumber,undefined4 param2,undefined4 param3)\n\n{\n  undefined4 GPIOClock;\n  uint pinMask;\n  undefined4 localParam2;\n  undefined4 localParam3;\n  undefined4 localVariable;\n  \n  GPIOClock = set_GPIO_Port_Clock((pinNumber << 0x18) >> 0x1c);\n  pinMask = 1 << (pinNumber & 0xf) & 0xffff;\n  localVariable = 2;\n  localParam2 = param2;\n  localParam3 = param3;\n  HAL_GPIO_Init(GPIOClock,&pinMask);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003486": "initialize_gpio_08003486",
                "param_1": "pinNumber",
                "param_2": "param2",
                "param_3": "param3",
                "uVar1": "GPIOClock",
                "local_24": "pinMask",
                "local_20": "localParam2",
                "local_1c": "localParam3",
                "local_18": "localVariable"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034b6": {
            "entrypoint": "0x080034b6",
            "current_name": "gpio_pin_write_080034b6",
            "code": "\nvoid gpioPinWrite_080034b6(undefined4 port,undefined2 pinNum,int state,undefined4 resetVal)\n\n{\n  if (state == 0) {\n    HAL_GPIO_WritePin(port,pinNum,0,resetVal,resetVal);\n    return;\n  }\n  HAL_GPIO_WritePin(port,pinNum,1,resetVal,resetVal);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034b6": "gpio_pin_write_080034b6",
                "param_1": "port",
                "param_2": "pinNum",
                "param_3": "state",
                "param_4": "resetVal"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034ce": {
            "entrypoint": "0x080034ce",
            "current_name": "initialize_hardware_080034ce",
            "code": "\nvoid initializeHardware_080034ce(void)\n\n{\n  initializeHAL();\n  configureSystemClock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034ce": "initialize_hardware_080034ce",
                "HAL_Init": "initializeHAL",
                "SystemClock_Config": "configureSystemClock"
            },
            "calling": [
                "FUN_08000d8e"
            ],
            "called": [
                "SystemClock_Config",
                "HAL_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034da": {
            "entrypoint": "0x080034da",
            "current_name": "find_value_index_080034da",
            "code": "\nundefined4 find_value_index_080034da(int value,short *array)\n\n{\n  while( true ) {\n    if (*array == -1) {\n      return 0;\n    }\n    if (*array == value) break;\n    array = array + 6;\n  }\n  return *(undefined4 *)(array + 2);\n}\n\n",
            "renaming": {
                "FUN_080034da": "find_value_index_080034da",
                "param_1": "value",
                "param_2": "array"
            },
            "calling": [
                "pinmap_peripheral",
                "pinmap_find_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034f4": {
            "entrypoint": "0x080034f4",
            "current_name": "find_peripheral_080034f4",
            "code": "\nundefined4 findPeripheral_080034f4(int inputValue)\n\n{\n  undefined4 peripheral;\n  \n  if (inputValue != -1) {\n    peripheral = pinmap_find_peripheral();\n    return peripheral;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080034f4": "find_peripheral_080034f4",
                "param_1": "inputValue",
                "uVar1": "peripheral"
            },
            "calling": [
                "dac_stop",
                "pwm_stop",
                "uart_debug_write",
                "uart_debug_init",
                "uart_init"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003506": {
            "entrypoint": "0x08003506",
            "current_name": "find_index_by_value_08003506",
            "code": "\nint find_index_by_value_08003506(int value,short *array)\n\n{\n  while( true ) {\n    if (*(int *)(array + 2) == 0) {\n      return -1;\n    }\n    if (*(int *)(array + 2) == value) break;\n    array = array + 6;\n  }\n  return (int)*array;\n}\n\n",
            "renaming": {
                "FUN_08003506": "find_index_by_value_08003506",
                "param_1": "value",
                "param_2": "array"
            },
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800351e": {
            "entrypoint": "0x0800351e",
            "current_name": "find_valid_pin_0800351e",
            "code": "\nundefined4 find_valid_pin_0800351e(int pin_count)\n\n{\n  undefined4 found_pin;\n  \n  if (pin_count != 0) {\n    found_pin = pinmap_find_pin();\n    return found_pin;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800351e": "find_valid_pin_0800351e",
                "param_1": "pin_count",
                "uVar1": "found_pin"
            },
            "calling": [
                "HardwareSerial",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800352e": {
            "entrypoint": "0x0800352e",
            "current_name": "find_value_index_0800352e",
            "code": "\nundefined4 find_value_index_0800352e(int target_value,short *values_array)\n\n{\n  while( true ) {\n    if (*values_array == -1) {\n      return 0xffffffff;\n    }\n    if (*values_array == target_value) break;\n    values_array = values_array + 6;\n  }\n  return *(undefined4 *)(values_array + 4);\n}\n\n",
            "renaming": {
                "FUN_0800352e": "find_value_index_0800352e",
                "param_1": "target_value",
                "param_2": "values_array"
            },
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800354a": {
            "entrypoint": "0x0800354a",
            "current_name": "find_pinmap_function_0800354a",
            "code": "\nundefined4 find_pinmap_function_0800354a(int input_value)\n\n{\n  undefined4 function_result;\n  \n  if (input_value == -1) {\n    return 0xffffffff;\n  }\n  function_result = pinmap_find_function();\n  return function_result;\n}\n\n",
            "renaming": {
                "FUN_0800354a": "find_pinmap_function_0800354a",
                "param_1": "input_value",
                "uVar1": "function_result"
            },
            "calling": [
                "pwm_stop",
                "get_dac_channel",
                "get_pwm_channel",
                "uart_init"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800355e": {
            "entrypoint": "0x0800355e",
            "current_name": "find_matching_value_0800355e",
            "code": "\nundefined4 find_matching_value_0800355e(int target_value,short *data_array)\n\n{\n  if (target_value == -1) {\n    return 0;\n  }\n  while( true ) {\n    if (*data_array == -1) {\n      return 0;\n    }\n    if (target_value == *data_array) break;\n    data_array = data_array + 6;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800355e": "find_matching_value_0800355e",
                "param_1": "target_value",
                "param_2": "data_array"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003582": {
            "entrypoint": "0x08003582",
            "current_name": "compare_and_return_nonzero_param_08003582",
            "code": "\nint compare_and_return_nonzero_param_08003582(int value_1,int value_2)\n\n{\n  if (value_1 != value_2) {\n    if (value_1 == 0) {\n      return value_2;\n    }\n    if (value_2 == 0) {\n      return value_1;\n    }\n    value_1 = 0;\n  }\n  return value_1;\n}\n\n",
            "renaming": {
                "FUN_08003582": "compare_and_return_nonzero_param_08003582",
                "param_1": "value_1",
                "param_2": "value_2"
            },
            "calling": [
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003594": {
            "entrypoint": "0x08003594",
            "current_name": "execute_callback_08003594",
            "code": "\nvoid executeCallback_08003594(void)\n\n{\n  if (DAT_20000188 != (code *)0x0) {\n    (*DAT_20000188)(DAT_200001ac);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003594": "execute_callback_08003594"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035bc": {
            "entrypoint": "0x080035bc",
            "current_name": "initialize_data_080035bc",
            "code": "\n\n\nvoid initializeData_080035bc(void)\n\n{\n  _DAT_40023808 = 0;\n  _DAT_40023804 = 0x24003010;\n  _DAT_40023800 = _DAT_40023800 & 0xfef2ffff | 1;\n  _DAT_4002380c = 0;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035bc": "initialize_data_080035bc"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fc": {
            "entrypoint": "0x080035fc",
            "current_name": "remove_access_permissions_080035fc",
            "code": "\n\n\nvoid removeAccessPermissions_080035fc(int *memoryAddress)\n\n{\n  if (*memoryAddress == 0x40010000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffe;\n  }\n  if (*memoryAddress == 0x40000000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffe;\n  }\n  if (*memoryAddress == 0x40000400) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffd;\n  }\n  if (*memoryAddress == 0x40000800) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffb;\n  }\n  if (*memoryAddress == 0x40000c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffff7;\n  }\n  if (*memoryAddress == 0x40001000) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffef;\n  }\n  if (*memoryAddress == 0x40001400) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffdf;\n  }\n  if (*memoryAddress == 0x40010400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffd;\n  }\n  if (*memoryAddress == 0x40014000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffeffff;\n  }\n  if (*memoryAddress == 0x40014400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffdffff;\n  }\n  if (*memoryAddress == 0x40014800) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffbffff;\n  }\n  if (*memoryAddress == 0x40001800) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffbf;\n  }\n  if (*memoryAddress == 0x40001c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffff7f;\n  }\n  if (*memoryAddress == 0x40002000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffeff;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fc": "remove_access_permissions_080035fc",
                "param_1": "memoryAddress"
            },
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003750": {
            "entrypoint": "0x08003750",
            "current_name": "subtract_four_08003750",
            "code": "\nint subtractFour_08003750(int inputValue)\n\n{\n  return inputValue + -4;\n}\n\n",
            "renaming": {
                "FUN_08003750": "subtract_four_08003750",
                "param_1": "inputValue"
            },
            "calling": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003754": {
            "entrypoint": "0x08003754",
            "current_name": "execute_if_timer_active_08003754",
            "code": "\nvoid executeIfTimerActive_08003754(int timerIndex)\n\n{\n  int timerObject;\n  \n  timerObject = getTimerObject();\n  if ((*(functionPointer **)(timerObject + 0x48) != (functionPointer *)0x0) && (*(char *)(timerIndex + 0x18) == '\\x01')) {\n    (**(functionPointer **)(timerObject + 0x48))(timerObject,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003754": "execute_if_timer_active_08003754",
                "param_1": "timerIndex",
                "iVar1": "timerObject",
                "get_timer_obj": "getTimerObject",
                "code": "functionPointer"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800376e": {
            "entrypoint": "0x0800376e",
            "current_name": "execute_timer_function_0800376e",
            "code": "\nvoid executeTimerFunction_0800376e(void)\n\n{\n  int timerObject;\n  \n  timerObject = getTimerObject();\n  if (*(code **)(timerObject + 0x44) != (code *)0x0) {\n    (**(code **)(timerObject + 0x44))();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800376e": "execute_timer_function_0800376e",
                "iVar1": "timerObject",
                "get_timer_obj": "getTimerObject"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800377c": {
            "entrypoint": "0x0800377c",
            "current_name": "handle_tim_interrupts_0800377c",
            "code": "\nvoid handle_TIM_interrupts_0800377c(void)\n\n{\n  if (DAT_200001b0 != 0) {\n    HAL_TIM_IRQHandler();\n  }\n  if (DAT_200001d4 != 0) {\n    HAL_TIM_IRQHandler();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800377c": "handle_tim_interrupts_0800377c"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800387c": {
            "entrypoint": "0x0800387c",
            "current_name": "subtract_four_0800387c",
            "code": "\nint subtractFour_0800387c(int inputNumber)\n\n{\n  return inputNumber + -4;\n}\n\n",
            "renaming": {
                "FUN_0800387c": "subtract_four_0800387c",
                "param_1": "inputNumber"
            },
            "calling": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003880": {
            "entrypoint": "0x08003880",
            "current_name": "transmit_data_or_receive_08003880",
            "code": "\nvoid transmitDataOrReceive_08003880(int dataBuffer,int isTransmit,int size,undefined4 callback)\n\n{\n  int i2cObj;\n  \n  i2cObj = getI2cObject();\n  if (size == *(int *)(dataBuffer + 0xc)) {\n    if (isTransmit == 0) {\n      *(undefined *)(i2cObj + 0x88) = 0;\n      *(undefined *)(i2cObj + 0x5e) = 0;\n      if (*(code **)(i2cObj + 100) != (code *)0x0) {\n        (**(code **)(i2cObj + 100))();\n      }\n      transmitDataSequentially(dataBuffer,i2cObj + 0x68,*(undefined *)(i2cObj + 0x88),8);\n      return;\n    }\n    *(undefined *)(i2cObj + 0x5e) = 1;\n    receiveDataSequentially(dataBuffer,i2cObj + 0x68,0x20,8,callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003880": "transmit_data_or_receive_08003880",
                "param_1": "dataBuffer",
                "param_2": "isTransmit",
                "param_3": "size",
                "param_4": "callback",
                "iVar1": "i2cObj",
                "get_i2c_obj": "getI2cObject",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "transmitDataSequentially",
                "HAL_I2C_Slave_Sequential_Receive_IT": "receiveDataSequentially"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080038d0": {
            "entrypoint": "0x080038d0",
            "current_name": "enable_i2_c_listen_080038d0",
            "code": "\nvoid enableI2CListen_080038d0(undefined4 param)\n\n{\n  int i2cObj;\n  \n  i2cObj = getI2CObject();\n  if (((*(functionPointer **)(i2cObj + 0x60) != (functionPointer *)0x0) && (*(char *)(i2cObj + 0x5e) == '\\x01')) &&\n     (*(char *)(i2cObj + 0x2c) != ' ')) {\n    (**(functionPointer **)(i2cObj + 0x60))(i2cObj + 0x68);\n  }\n  enableI2CListen_080038d0Interrupt(param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080038d0": "enable_i2_c_listen_080038d0",
                "param_1": "param",
                "iVar1": "i2cObj",
                "get_i2c_obj": "getI2CObject",
                "code": "functionPointer",
                "HAL_I2C_EnableListen_IT": "enableI2CListenInterrupt"
            },
            "calling": [
                "I2C_ITError",
                "I2C_Slave_STOPF",
                "I2C_Slave_AF"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003900": {
            "entrypoint": "0x08003900",
            "current_name": "enable_i2_c_listening_08003900",
            "code": "\nvoid enableI2CListening_08003900(undefined4 param)\n\n{\n  int i2cObj;\n  \n  i2cObj = getI2CObject();\n  if (*(char *)(i2cObj + 0x5f) == '\\0') {\n    enableI2CListenInterrupt(param);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003900": "enable_i2_c_listening_08003900",
                "param_1": "param",
                "iVar1": "i2cObj",
                "get_i2c_obj": "getI2CObject",
                "HAL_I2C_EnableListen_IT": "enableI2CListenInterrupt"
            },
            "calling": [
                "I2C_ITError"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003978": {
            "entrypoint": "0x08003978",
            "current_name": "initialize_uart_pins_08003978",
            "code": "\n\n\nvoid initializeUARTPins_08003978(int *uartPins)\n\n{\n  int peripheral1;\n  int peripheral2;\n  undefined4 gpioClock1;\n  uint gpioFunction1;\n  uint gpioPinMask1;\n  uint gpioAF1;\n  uint gpioSpeed1;\n  undefined4 gpioPull1;\n  uint gpioMode1;\n  \n  if (uartPins != (int *)0x0) {\n    peripheral1 = pinmap_peripheral((int)*(short *)(uartPins + 0x16),&DAT_08005ca0);\n    peripheral2 = pinmap_peripheral((int)*(short *)((int)uartPins + 0x5a),&DAT_08005c10);\n    if ((peripheral2 == 0) || (peripheral1 == 0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\",peripheral2);\n    }\n    else {\n      peripheral1 = pinmap_merge_peripheral(peripheral1);\n      *uartPins = peripheral1;\n      if (peripheral1 == 0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (peripheral1 == 0x40011000) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffef;\n          _DAT_40023844 = _DAT_40023844 | 0x10;\n          *(undefined *)(uartPins + 0x11) = 0;\n          *(undefined *)(uartPins + 0x17) = 0x25;\n        }\n        else if (peripheral1 == 0x40004400) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffdffff;\n          _DAT_40023840 = _DAT_40023840 | 0x20000;\n          *(undefined *)(uartPins + 0x11) = 1;\n          *(undefined *)(uartPins + 0x17) = 0x26;\n        }\n        else if (peripheral1 == 0x40004800) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffbffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000;\n          *(undefined *)(uartPins + 0x11) = 2;\n          *(undefined *)(uartPins + 0x17) = 0x27;\n        }\n        else if (peripheral1 == 0x40004c00) {\n          _DAT_40023820 = _DAT_40023820 & 0xfff7ffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000;\n          *(undefined *)(uartPins + 0x11) = 3;\n          *(undefined *)(uartPins + 0x17) = 0x34;\n        }\n        else if (peripheral1 == 0x40005000) {\n          _DAT_40023820 = _DAT_40023820 & 0xffefffff;\n          _DAT_40023840 = _DAT_40023840 | 0x100000;\n          *(undefined *)(uartPins + 0x11) = 4;\n          *(undefined *)(uartPins + 0x17) = 0x35;\n        }\n        else if (peripheral1 == 0x40011400) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffdf;\n          _DAT_40023844 = _DAT_40023844 | 0x20;\n          *(undefined *)(uartPins + 0x11) = 5;\n          *(undefined *)(uartPins + 0x17) = 0x47;\n        }\n        else if (peripheral1 == 0x40007800) {\n          _DAT_40023820 = _DAT_40023820 & 0xbfffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000000;\n          *(undefined *)(uartPins + 0x11) = 6;\n          *(undefined *)(uartPins + 0x17) = 0x52;\n        }\n        else if (peripheral1 == 0x40007c00) {\n          _DAT_40023820 = _DAT_40023820 & 0x7fffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000000;\n          *(undefined *)(uartPins + 0x11) = 7;\n          *(undefined *)(uartPins + 0x17) = 0x53;\n        }\n        gpioClock1 = set_GPIO_Port_Clock((uint)((int)*(short *)((int)uartPins + 0x5a) << 0x18) >> 0x1c);\n        gpioFunction1 = pinmap_function((int)*(short *)((int)uartPins + 0x5a),&DAT_08005c10);\n        gpioPinMask1 = 1 << (*(ushort *)((int)uartPins + 0x5a) & 0xf) & 0xffff;\n        gpioAF1 = (gpioFunction1 >> 3 & 1) << 4 | gpioFunction1 & 7;\n        gpioSpeed1 = (gpioFunction1 << 0x1a) >> 0x1e;\n        gpioMode1 = (gpioFunction1 << 0x11) >> 0x19;\n        gpioPull1 = 3;\n        HAL_GPIO_Init(gpioClock1,&gpioPinMask1);\n        gpioClock1 = set_GPIO_Port_Clock((uint)((int)*(short *)(uartPins + 0x16) << 0x18) >> 0x1c);\n        gpioFunction1 = pinmap_function((int)*(short *)(uartPins + 0x16),&DAT_08005ca0);\n        gpioPinMask1 = 1 << (*(ushort *)(uartPins + 0x16) & 0xf) & 0xffff;\n        gpioAF1 = (gpioFunction1 >> 3 & 1) << 4 | gpioFunction1 & 7;\n        gpioSpeed1 = (gpioFunction1 << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(gpioClock1,&gpioPinMask1);\n        (&DAT_200002b4)[*(byte *)(uartPins + 0x11)] = uartPins + 1;\n        uartPins[1] = *uartPins;\n        uartPins[2] = uartPins[0x12];\n        uartPins[3] = uartPins[0x13];\n        uartPins[4] = uartPins[0x14];\n        uartPins[5] = uartPins[0x15];\n        uartPins[6] = 0xc;\n        uartPins[7] = 0;\n        uartPins[8] = 0;\n        HAL_UART_Init(uartPins + 1);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003978": "initialize_uart_pins_08003978",
                "param_1": "uartPins",
                "iVar1": "peripheral1",
                "iVar2": "peripheral2",
                "uVar3": "gpioClock1",
                "uVar4": "gpioFunction1",
                "local_2c": "gpioPinMask1",
                "local_28": "gpioAF1",
                "local_24": "gpioSpeed1",
                "local_20": "gpioPull1",
                "local_1c": "gpioMode1"
            },
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_peripheral",
                "pinmap_function",
                "HAL_UART_Init",
                "HAL_GPIO_Init",
                "pinmap_merge_peripheral",
                "iprintf",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003cc8": {
            "entrypoint": "0x08003cc8",
            "current_name": "initialize_peripherals_08003cc8",
            "code": "\nvoid initialize_peripherals_08003cc8(void)\n\n{\n  int pinmap_result;\n  undefined4 pinmap_peripheral_result;\n  \n  pinmap_result = pinmap_peripheral(0x38,&DAT_08005ca0);\n  if (pinmap_result != 0) {\n    pinmap_peripheral_result = pinmap_peripheral(0x38,&DAT_08005ca0);\n    DAT_2000008a = pinmap_pin(pinmap_peripheral_result,&DAT_08005c10);\n    DAT_20000088 = 0x38;\n    DAT_20000078 = 0x2580;\n    DAT_20000084 = 0;\n    DAT_2000007c = 0;\n    DAT_20000080 = 0;\n    uart_init(&DAT_20000030);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003cc8": "initialize_peripherals_08003cc8",
                "iVar1": "pinmap_result",
                "uVar2": "pinmap_peripheral_result"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "pinmap_peripheral",
                "pinmap_pin",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d18": {
            "entrypoint": "0x08003d18",
            "current_name": "transmit_data_08003d18",
            "code": "\nuint transmitData_08003d18(undefined4 data,uint dataLength)\n\n{\n  int startTime;\n  int peripheralID;\n  uint index;\n  \n  startTime = HAL_GetTick();\n  peripheralID = pinmap_peripheral(0x38,&DAT_08005ca0);\n  if (peripheralID == 0) {\n    return 0;\n  }\n  for (index = 0;\n      (index < 10 &&\n      (((&DAT_200002b4)[index] == 0 ||\n       (peripheralID = pinmap_peripheral(0x38,&DAT_08005ca0), *(int *)(&DAT_200002b4)[index] != peripheralID))));\n      index = index + 1 & 0xff) {\n  }\n  if (9 < index) {\n    if ((9 < DAT_20000074) && (uart_debug_init(), 9 < DAT_20000074)) {\n      return 0;\n    }\n    index = (uint)DAT_20000074;\n  }\n  do {\n    peripheralID = HAL_UART_Transmit((&DAT_200002b4)[index],data,dataLength & 0xffff,1000);\n    if (peripheralID == 0) {\n      return dataLength;\n    }\n    peripheralID = HAL_GetTick();\n  } while ((uint)(peripheralID - startTime) < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003d18": "transmit_data_08003d18",
                "param_1": "data",
                "param_2": "dataLength",
                "iVar1": "startTime",
                "iVar2": "peripheralID",
                "uVar3": "index"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "pinmap_peripheral",
                "HAL_GetTick",
                "HAL_UART_Transmit",
                "uart_debug_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003dd0": {
            "entrypoint": "0x08003dd0",
            "current_name": "check_uart_status_08003dd0",
            "code": "\nbool checkUartStatus_08003dd0(int index)\n\n{\n  uint uartState;\n  \n  uartState = HAL_UART_GetState((&DAT_200002b4)[*(byte *)(index + 0x44)]);\n  return (uartState & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_08003dd0": "check_uart_status_08003dd0",
                "param_1": "index",
                "uVar1": "uartState"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003df4": {
            "entrypoint": "0x08003df4",
            "current_name": "is_uart_state_invalid_08003df4",
            "code": "\nbool is_UartStateInvalid_08003df4(int index)\n\n{\n  uint uartState;\n  \n  uartState = HAL_UART_GetState((&DAT_200002b4)[*(byte *)(index + 0x44)]);\n  return (uartState & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_08003df4": "is_uart_state_invalid_08003df4",
                "param_1": "index",
                "uVar1": "uartState"
            },
            "calling": [
                "FUN_080042e8"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e18": {
            "entrypoint": "0x08003e18",
            "current_name": "receive_and_store_byte_08003e18",
            "code": "\nundefined4 receive_and_store_byte_08003e18(int serial_port,undefined *received_byte,undefined4 param_3,undefined4 callback_function)\n\n{\n  int is_rx_active;\n  \n  if (serial_port == 0) {\n    return 0xffffffff;\n  }\n  is_rx_active = serial_rx_active();\n  if (is_rx_active == 0) {\n    *received_byte = *(undefined *)(serial_port + 0x45);\n    HAL_UART_Receive_IT((&DAT_200002b4)[*(byte *)(serial_port + 0x44)],serial_port + 0x45,1,&DAT_200002b4,\n                        callback_function);\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08003e18": "receive_and_store_byte_08003e18",
                "param_1": "serial_port",
                "param_2": "received_byte",
                "param_4": "callback_function",
                "iVar1": "is_rx_active"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e54": {
            "entrypoint": "0x08003e54",
            "current_name": "initialize_serial_port_08003e54",
            "code": "\nvoid initializeSerialPort_08003e54(int port,undefined4 priority,undefined4 unused1,undefined4 unused2)\n\n{\n  int isRxActive;\n  uint portIndex;\n  \n  if (port != 0) {\n    isRxActive = serial_rx_active();\n    if (isRxActive == 0) {\n      portIndex = (uint)*(byte *)(port + 0x44);\n      *(undefined4 *)(&DAT_20000214 + portIndex * 4) = priority;\n      *(int *)(&DAT_2000023c + portIndex * 4) = port;\n      HAL_NVIC_SetPriority((int)*(char *)(port + 0x5c),0,1,portIndex,unused2);\n      HAL_NVIC_EnableIRQ((int)*(char *)(port + 0x5c));\n      HAL_UART_Receive_IT((&DAT_200002b4)[*(byte *)(port + 0x44)],port + 0x45,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e54": "initialize_serial_port_08003e54",
                "param_1": "port",
                "param_2": "priority",
                "param_3": "unused1",
                "param_4": "unused2",
                "iVar1": "isRxActive",
                "uVar2": "portIndex"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eac": {
            "entrypoint": "0x08003eac",
            "current_name": "initialize_device_08003eac",
            "code": "\nvoid initializeDevice_08003eac(int deviceAddress,undefined4 parameterValue)\n\n{\n  byte byteValue;\n  \n  if (deviceAddress != 0) {\n    byteValue = *(byte *)(deviceAddress + 0x44);\n    *(undefined4 *)(&DAT_20000264 + (uint)byteValue * 4) = parameterValue;\n    *(int *)(&DAT_2000028c + (uint)byteValue * 4) = deviceAddress;\n    HAL_NVIC_SetPriority((int)*(char *)(deviceAddress + 0x5c),0,2);\n    HAL_NVIC_EnableIRQ((int)*(char *)(deviceAddress + 0x5c));\n    HAL_UART_Transmit_IT\n              ((&DAT_200002b4)[*(byte *)(deviceAddress + 0x44)],\n               *(int *)(deviceAddress + 0x68) + (uint)*(ushort *)(deviceAddress + 0x6e),1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003eac": "initialize_device_08003eac",
                "param_1": "deviceAddress",
                "param_2": "parameterValue",
                "bVar1": "byteValue"
            },
            "calling": [
                "FUN_080042e8"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f00": {
            "entrypoint": "0x08003f00",
            "current_name": "find_value_index_08003f00",
            "code": "\nuint find_value_index_08003f00(int value)\n\n{\n  uint index;\n  \n  if (value == 0) {\n    index = 10;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (9 < index) {\n        return index;\n      }\n      if (value == (&DAT_200002b4)[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return index;\n}\n\n",
            "renaming": {
                "FUN_08003f00": "find_value_index_08003f00",
                "param_1": "value",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f24": {
            "entrypoint": "0x08003f24",
            "current_name": "execute_uart_function_08003f24",
            "code": "\nvoid executeUARTFunction_08003f24(void)\n\n{\n  uint uartIndex;\n  \n  uartIndex = uart_index();\n  if (uartIndex < 10) {\n    (**(code **)(&DAT_20000214 + uartIndex * 4))(*(undefined4 *)(&DAT_2000023c + uartIndex * 4));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f24": "execute_uart_function_08003f24",
                "uVar1": "uartIndex"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f48": {
            "entrypoint": "0x08003f48",
            "current_name": "transmit_data_over_uart_08003f48",
            "code": "\nvoid transmitDataOverUART_08003f48(void)\n\n{\n  uint uartIndex;\n  int returnValue;\n  int uartConfig;\n  \n  uartIndex = uart_index();\n  uartConfig = *(int *)(&DAT_2000028c + uartIndex * 4);\n  if ((uartIndex < 10) && (returnValue = (**(code **)(&DAT_20000264 + uartIndex * 4))(uartConfig), returnValue != -1)) {\n    transmitDataAsynchronously\n              ((&DAT_200002b4)[*(byte *)(uartConfig + 0x44)],\n               *(int *)(uartConfig + 0x68) + (uint)*(ushort *)(uartConfig + 0x6e),1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f48": "transmit_data_over_uart_08003f48",
                "uVar1": "uartIndex",
                "iVar2": "returnValue",
                "iVar3": "uartConfig",
                "HAL_UART_Transmit_IT": "transmitDataAsynchronously"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f94": {
            "entrypoint": "0x08003f94",
            "current_name": "FUNC_08003f94",
            "code": "\nvoid FUNC_08003f94(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f94": "FUNC_08003f94"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004094": {
            "entrypoint": "0x08004094",
            "current_name": "reserve_memory_08004094",
            "code": "\nundefined * reserveMemory_08004094(int size)\n\n{\n  undefined *reservedMemory;\n  \n  if (DAT_200002dc == (undefined *)0x0) {\n    DAT_200002dc = &DAT_20000678;\n  }\n  reservedMemory = DAT_200002dc;\n  if (DAT_200002dc + size <= &endPointer) {\n    DAT_200002dc = DAT_200002dc + size;\n    return reservedMemory;\n  }\n  DAT_20000674 = 0xc;\n  return (undefined *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004094": "reserve_memory_08004094",
                "param_1": "size",
                "puVar1": "reservedMemory",
                "stack0x00000000": "endPointer"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d0": {
            "entrypoint": "0x080040d0",
            "current_name": "get_default_value_080040d0",
            "code": "\nuint32_t get_default_value_080040d0(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080040d0": "get_default_value_080040d0",
                "undefined4": "uint32_t"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d6": {
            "entrypoint": "0x080040d6",
            "current_name": "initialize_memory_080040d6",
            "code": "\nundefined4 initializeMemory_080040d6(undefined4 baseAddress,int offset)\n\n{\n  *(undefined4 *)(offset + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040d6": "initialize_memory_080040d6",
                "param_1": "baseAddress",
                "param_2": "offset"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e0": {
            "entrypoint": "0x080040e0",
            "current_name": "initialize_program_080040e0",
            "code": "\nstatus initializeProgram_080040e0(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080040e0": "initialize_program_080040e0",
                "undefined4": "status"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e4": {
            "entrypoint": "0x080040e4",
            "current_name": "initialize_080040e4",
            "code": "\nvoid initialize_080040e4(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e4": "initialize_080040e4",
                "undefined4": "void"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "initialize_application_080040e8",
            "code": "\nvoid initializeApplication_080040e8(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e8": "initialize_application_080040e8",
                "undefined4": "void"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040ec": {
            "entrypoint": "0x080040ec",
            "current_name": "write_debug_message_080040ec",
            "code": "\nvoid write_debug_message_080040ec(undefined4 param_1,undefined4 buffer,undefined4 size,undefined4 param_4)\n\n{\n  uart_debug_write(buffer,size,size,param_4,param_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040ec": "write_debug_message_080040ec",
                "param_2": "buffer",
                "param_3": "size"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040f8": {
            "entrypoint": "0x080040f8",
            "current_name": "keep_running_080040f8",
            "code": "\nvoid keep_running_080040f8(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080040f8": "keep_running_080040f8"
            },
            "calling": [
                "_exit",
                "abort"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040fc": {
            "entrypoint": "0x080040fc",
            "current_name": "initialize_data_080040fc",
            "code": "\nundefined4 initializeData_080040fc(void)\n\n{\n  DAT_20000674 = 0x16;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080040fc": "initialize_data_080040fc"
            },
            "calling": [
                "raise"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800410c": {
            "entrypoint": "0x0800410c",
            "current_name": "FUNC_0800410c",
            "code": "\nundefined4 FUNC_0800410c(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800410c": "FUNC_0800410c"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004110": {
            "entrypoint": "0x08004110",
            "current_name": "initialize_pin_config_08004110",
            "code": "\nvoid initializePinConfig_08004110(uint pinIndex,undefined4 pinMode,undefined4 pinConfig,undefined *pinMap)\n\n{\n  int configStatus;\n  undefined *pinData;\n  int pinValue;\n  \n  if (pinIndex < 0x60) {\n    pinValue = (int)*(short *)(&DAT_08005d3c + pinIndex * 2);\n    pinData = &DAT_08005d3c;\n  }\n  else {\n    pinValue = -1;\n    pinData = pinMap;\n  }\n  if (pinValue != -1) {\n    configStatus = is_pin_configured(pinValue,&DAT_200002e0,pinConfig,pinData,pinMap);\n    if (configStatus != 0) {\n      configStatus = pin_in_pinmap(pinValue,&DAT_08005a18);\n      if (configStatus == 0) {\n        configStatus = pin_in_pinmap(pinValue,&DAT_08005a3c);\n        if (configStatus != 0) {\n          pwm_stop(pinValue);\n        }\n      }\n      else {\n        dac_stop(pinValue);\n      }\n      reset_pin_configured(pinValue,&DAT_200002e0);\n    }\n    switch(pinMode) {\n    case 0:\n      digital_io_init(pinValue,0);\n      break;\n    case 1:\n      digital_io_init(pinValue,1,0);\n      break;\n    case 2:\n      digital_io_init(pinValue,0,1);\n      break;\n    case 3:\n      digital_io_init(pinValue,0,2);\n    }\n    set_pin_configured(pinValue,&DAT_2000030c);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004110": "initialize_pin_config_08004110",
                "param_1": "pinIndex",
                "param_2": "pinMode",
                "param_3": "pinConfig",
                "param_4": "pinMap",
                "iVar1": "configStatus",
                "puVar2": "pinData",
                "iVar3": "pinValue"
            },
            "calling": [
                "FUN_08000600"
            ],
            "called": [
                "dac_stop",
                "reset_pin_configured",
                "pwm_stop",
                "digital_io_init",
                "set_pin_configured",
                "is_pin_configured",
                "pin_in_pinmap"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041bc": {
            "entrypoint": "0x080041bc",
            "current_name": "configure_gpio_080041bc",
            "code": "\nvoid configureGPIO_080041bc(uint pinIndex,undefined4 configData,undefined4 configSize,undefined *data)\n\n{\n  int pinConfigured;\n  undefined4 gpioPort;\n  undefined *pinData;\n  uint pinValue;\n  \n  if (pinIndex < 0x60) {\n    pinValue = (uint)*(short *)(&DAT_08005d3c + pinIndex * 2);\n    pinData = &DAT_08005d3c;\n  }\n  else {\n    pinValue = 0xffffffff;\n    pinData = data;\n  }\n  if ((pinValue != 0xffffffff) &&\n     (pinConfigured = is_pin_configured(pinValue,&DAT_2000030c,configSize,pinData,data), pinConfigured != 0)) {\n    gpioPort = get_GPIO_Port((pinValue << 0x18) >> 0x1c);\n    digital_io_write(gpioPort,1 << (pinValue & 0xf) & 0xffff,configData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041bc": "configure_gpio_080041bc",
                "param_1": "pinIndex",
                "param_2": "configData",
                "param_3": "configSize",
                "param_4": "data",
                "iVar1": "pinConfigured",
                "uVar2": "gpioPort",
                "puVar3": "pinData",
                "uVar4": "pinValue"
            },
            "calling": [
                "FUN_08000600",
                "getRxBuffer",
                "sendTxBuffer"
            ],
            "called": [
                "digital_io_write",
                "is_pin_configured",
                "get_GPIO_Port"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004204": {
            "entrypoint": "0x08004204",
            "current_name": "get_current_time_08004204",
            "code": "\nvoid getCurrentTime_08004204(void)\n\n{\n  getMillisecond();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004204": "get_current_time_08004204",
                "GetCurrentMilli": "getMillisecond"
            },
            "calling": [
                "poll",
                "sendTxBuffer"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004240": {
            "entrypoint": "0x08004240",
            "current_name": "calculate_difference_08004240",
            "code": "\nushort calculate_difference_08004240(int input_value)\n\n{\n  return (*(short *)(input_value + 0x138) + 0x40) - *(short *)(input_value + 0x13a) & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_08004240": "calculate_difference_08004240",
                "param_1": "input_value"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042ac": {
            "entrypoint": "0x080042ac",
            "current_name": "process_input_080042ac",
            "code": "\nvoid processInput_080042ac(int device)\n\n{\n  int inputResult;\n  ushort newIndex;\n  undefined receivedByte;\n  \n  inputResult = uart_getc(device,&receivedByte);\n  if ((inputResult == 0) &&\n     (newIndex = *(short *)(device + 100) + 1U & 0x3f, newIndex != *(ushort *)(device + 0x66))) {\n    *(undefined *)(*(int *)(device + 0x60) + (uint)*(ushort *)(device + 100)) = receivedByte;\n    *(ushort *)(device + 100) = newIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080042ac": "process_input_080042ac",
                "param_1": "device",
                "iVar1": "inputResult",
                "uVar2": "newIndex",
                "local_9": "receivedByte"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042e8": {
            "entrypoint": "0x080042e8",
            "current_name": "initialize_variable_080042e8",
            "code": "\nundefined4 initializeVariable_080042e8(int param,undefined data)\n\n{\n  byte lowerByte;\n  byte maskedByte;\n  int incrementedValue;\n  \n  *(undefined *)(param + 0x10) = 1;\n  incrementedValue = *(ushort *)(param + 0x140) + 1;\n  lowerByte = (byte)incrementedValue;\n  maskedByte = lowerByte & 0x7f;\n  if (incrementedValue == 0) {\n    maskedByte = -(-lowerByte & 0x7f);\n  }\n  do {\n  } while (*(ushort *)(param + 0x142) == (ushort)maskedByte);\n  *(undefined *)(*(int *)(param + 0x13c) + (uint)*(ushort *)(param + 0x140)) = data;\n  *(ushort *)(param + 0x140) = (ushort)maskedByte;\n  incrementedValue = serial_tx_active(param + 0xd4);\n  if (incrementedValue == 0) {\n    uart_attach_tx_callback(param + 0xd4,&LAB_0800420c_1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080042e8": "initialize_variable_080042e8",
                "param_1": "param",
                "param_2": "data",
                "bVar1": "lowerByte",
                "bVar2": "maskedByte",
                "iVar3": "incrementedValue"
            },
            "calling": [],
            "called": [
                "serial_tx_active",
                "uart_attach_tx_callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004338": {
            "entrypoint": "0x08004338",
            "current_name": "FUNC_08004338",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800433e) */\n/* WARNING: Removing unreachable block (ram,0x08004350) */\n/* WARNING: Removing unreachable block (ram,0x08004346) */\n/* WARNING: Removing unreachable block (ram,0x08004358) */\n\nvoid FUNC_08004338(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004338": "FUNC_08004338"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004364": {
            "entrypoint": "0x08004364",
            "current_name": "initialize_data_08004364",
            "code": "\nvoid initializeData_08004364(int data)\n\n{\n  *(int *)(data + 0x134) = data + 0x11;\n  *(undefined2 *)(data + 0x138) = 0;\n  *(undefined2 *)(data + 0x13a) = 0;\n  *(int *)(data + 0x13c) = data + 0x51;\n  *(undefined2 *)(data + 0x140) = 0;\n  *(undefined2 *)(data + 0x142) = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004364": "initialize_data_08004364",
                "param_1": "data"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004388": {
            "entrypoint": "0x08004388",
            "current_name": "initialize_serial_communication_08004388",
            "code": "\nvoid initializeSerialCommunication_08004388(int serialPort,undefined4 baudRate,byte serialConfig)\n\n{\n  uint condition;\n  byte configFlag;\n  int configValue;\n  code *jumptableFunc;\n  \n  *(undefined4 *)(serialPort + 0x11c) = baudRate;\n  *(byte *)(serialPort + 0x144) = serialConfig;\n  configFlag = serialConfig & 7;\n  if (configFlag == 4) {\n    configValue = 7;\n  }\n  else if (configFlag == 6) {\n    configValue = 8;\n  }\n  else if (configFlag == 2) {\n    configValue = 6;\n  }\n  else {\n    configValue = 0;\n  }\n  if ((serialConfig & 0x30) == 0x30) {\n    *(undefined4 *)(serialPort + 0x128) = 0x600;\n    configValue = configValue + 1;\n  }\n  else if ((serialConfig & 0x20) == 0) {\n    *(undefined4 *)(serialPort + 0x128) = 0;\n  }\n  else {\n    *(undefined4 *)(serialPort + 0x128) = 0x400;\n    configValue = configValue + 1;\n  }\n  if ((serialConfig & 8) == 0) {\n    *(undefined4 *)(serialPort + 0x124) = 0;\n  }\n  else {\n    *(undefined4 *)(serialPort + 0x124) = 0x2000;\n  }\n  if (configValue == 8) {\n    *(undefined4 *)(serialPort + 0x120) = 0;\n  }\n  else if (configValue == 9) {\n    *(undefined4 *)(serialPort + 0x120) = 0x1000;\n  }\n  else {\n    configValue = 0;\n  }\n  if (configValue != 0) {\n    uart_init(serialPort + 0xd4);\n    uart_attach_rx_callback(serialPort + 0xd4,0x80042ad);\n    return;\n  }\n  jumptableFunc = (code *)0x8004432;\n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\");\n  if (condition < 0x60) {\n    uRam0000012e = *(undefined2 *)(&DAT_08005d3c + condition * 2);\n  }\n  else {\n    uRam0000012e = 0xffff;\n  }\n                    /* WARNING: Could not recover jumptable at 0x08004452. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptableFunc)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004388": "initialize_serial_communication_08004388",
                "param_1": "serialPort",
                "param_2": "baudRate",
                "param_3": "serialConfig",
                "extraout_r1": "condition",
                "bVar1": "configFlag",
                "iVar2": "configValue",
                "UNRECOVERED_JUMPTABLE": "jumptableFunc"
            },
            "calling": [
                "FUN_08000600"
            ],
            "called": [
                "uart_attach_rx_callback",
                "uart_init",
                "__assert_func"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004444": {
            "entrypoint": "0x08004444",
            "current_name": "update_parameter_08004444",
            "code": "\nvoid updateParameter_08004444(int baseAddress,uint offset)\n\n{\n  undefined2 newValue;\n  code *jumpTable;\n  \n  if (offset < 0x60) {\n    newValue = *(undefined2 *)(&DAT_08005d3c + offset * 2);\n  }\n  else {\n    newValue = 0xffff;\n  }\n  *(undefined2 *)(baseAddress + 0x12e) = newValue;\n                    /* WARNING: Could not recover jumptable at 0x08004452. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004444": "update_parameter_08004444",
                "param_1": "baseAddress",
                "param_2": "offset",
                "uVar1": "newValue",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004460": {
            "entrypoint": "0x08004460",
            "current_name": "set_return_value_based_on_param_08004460",
            "code": "\nvoid setReturnValueBasedOnParam_08004460(int outputAddress,uint inputValue)\n\n{\n  undefined2 returnValue;\n  \n  if (inputValue < 0x60) {\n    returnValue = *(undefined2 *)(&DAT_08005d3c + inputValue * 2);\n  }\n  else {\n    returnValue = 0xffff;\n  }\n  *(undefined2 *)(outputAddress + 300) = returnValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004460": "set_return_value_based_on_param_08004460",
                "param_1": "outputAddress",
                "param_2": "inputValue",
                "uVar1": "returnValue"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800447c": {
            "entrypoint": "0x0800447c",
            "current_name": "initialize_communication_0800447c",
            "code": "\nundefined4 *\ninitializeCommunication_0800447c(undefined4 *communicationParams,undefined4 pinNumber,undefined4 param3,undefined4 param4)\n\n{\n  undefined2 pinResult;\n  \n  communicationParams[1] = 0;\n  communicationParams[2] = 1000;\n  *communicationParams = &PTR_FUN_080042e8_1_08005ed4;\n  if (communicationParams == &DAT_20000338) {\n    setRx(&DAT_20000338,0x4c,param3,&DAT_20000338,param4);\n    setTx(&DAT_20000338,0x4d);\n  }\n  else {\n    pinResult = pinmap_pin(pinNumber,&DAT_08005c10);\n    *(undefined2 *)((int)communicationParams + 0x12e) = pinResult;\n    pinResult = pinmap_pin(pinNumber,&DAT_08005ca0);\n    *(undefined2 *)(communicationParams + 0x4b) = pinResult;\n  }\n  init(communicationParams);\n  return communicationParams;\n}\n\n",
            "renaming": {
                "FUN_0800447c": "initialize_communication_0800447c",
                "param_1": "communicationParams",
                "param_2": "pinNumber",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "pinResult"
            },
            "calling": [
                "FUN_080044d8"
            ],
            "called": [
                "setRx",
                "init",
                "pinmap_pin",
                "setTx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044d8": {
            "entrypoint": "0x080044d8",
            "current_name": "initialize_hardware_serial_080044d8",
            "code": "\nvoid initializeHardwareSerial_080044d8(int condition,int flag,undefined4 parameter1,undefined4 parameter2)\n\n{\n  if (condition != 1) {\n    return;\n  }\n  if (flag == 0xffff) {\n    initializeSerialCommunication(&DAT_20000338,0x40004800,parameter1,0xffff,parameter2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044d8": "initialize_hardware_serial_080044d8",
                "param_1": "condition",
                "param_2": "flag",
                "param_3": "parameter1",
                "param_4": "parameter2",
                "HardwareSerial": "initializeSerialCommunication"
            },
            "calling": [],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004544": {
            "entrypoint": "0x08004544",
            "current_name": "initialize_data_block_08004544",
            "code": "\nvoid initializeDataBlock_08004544(undefined4 *dataBlock,undefined value1,undefined value2,undefined value3,\n                 undefined value4)\n\n{\n  *dataBlock = &DAT_08005f28;\n  *(undefined *)(dataBlock + 1) = value1;\n  *(undefined *)((int)dataBlock + 5) = value2;\n  *(undefined *)((int)dataBlock + 6) = value3;\n  *(undefined *)((int)dataBlock + 7) = value4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004544": "initialize_data_block_08004544",
                "param_1": "dataBlock",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3",
                "param_5": "value4"
            },
            "calling": [
                "FUN_08004560"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004560": {
            "entrypoint": "0x08004560",
            "current_name": "initialize_ip_address_08004560",
            "code": "\nvoid initializeIPAddress_08004560(int optionValue,int flagValue)\n\n{\n  if ((optionValue == 1) && (flagValue == 0xffff)) {\n    IPAddress(&DAT_20000480,0,0,0,0);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004560": "initialize_ip_address_08004560",
                "param_1": "optionValue",
                "param_2": "flagValue"
            },
            "calling": [],
            "called": [
                "IPAddress"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004640": {
            "entrypoint": "0x08004640",
            "current_name": "merge_parameters_08004640",
            "code": "\nuint merge_parameters_08004640(int input_value,uint bitwise_value)\n\n{\n  return bitwise_value | input_value << 8;\n}\n\n",
            "renaming": {
                "FUN_08004640": "merge_parameters_08004640",
                "param_1": "input_value",
                "param_2": "bitwise_value"
            },
            "calling": [
                "process_FC3",
                "process_FC15",
                "validateRequest",
                "process_FC6",
                "process_FC5",
                "process_FC16",
                "process_FC1"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004646": {
            "entrypoint": "0x08004646",
            "current_name": "FUNC_08004646",
            "code": "\nvoid FUNC_08004646(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004646": "FUNC_08004646"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004648": {
            "entrypoint": "0x08004648",
            "current_name": "initialize_nvic_and_hardware_08004648",
            "code": "\nvoid initialize_NVIC_and_hardware_08004648(void)\n\n{\n  HAL_NVIC_SetPriorityGrouping(3);\n  initialize_hardware_configuration();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004648": "initialize_nvic_and_hardware_08004648",
                "initialize_hardware_configuration_08000d8e": "initialize_hardware_configuration"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "FUN_08000d8e",
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004658": {
            "entrypoint": "0x08004658",
            "current_name": "initialize_and_run_08004658",
            "code": "\nvoid initializeAndRun_08004658(void)\n\n{\n  initializeVariant();\n  setupConfiguration();\n  do {\n    executeLoop();\n    runSerialEvents();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004658": "initialize_and_run_08004658",
                "initVariant": "initializeVariant",
                "setup": "setupConfiguration",
                "loop": "executeLoop",
                "serialEventRun": "runSerialEvents"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "setup",
                "serialEventRun",
                "initVariant",
                "loop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004678": {
            "entrypoint": "0x08004678",
            "current_name": "count_set_bits_08004678",
            "code": "\nchar countSetBits_08004678(uint num)\n\n{\n  char bitCount;\n  \n  bitCount = '\\0';\n  for (; num != 1; num = num >> 1) {\n    bitCount = bitCount + '\\x01';\n  }\n  return bitCount;\n}\n\n",
            "renaming": {
                "FUN_08004678": "count_set_bits_08004678",
                "param_1": "num",
                "cVar1": "bitCount"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046b4": {
            "entrypoint": "0x080046b4",
            "current_name": "initialize_params_080046b4",
            "code": "\nvoid initializeParams_080046b4(int flag,int value,undefined4 param3,undefined4 param4)\n\n{\n  if (flag != 1) {\n    return;\n  }\n  if (value == 0xffff) {\n    DAT_20000488 = 6;\n    DAT_20000494 = 0;\n    DAT_2000049c = 7;\n    DAT_200004a8 = 0;\n    DAT_200004b0 = 8;\n    DAT_200004bc = 0;\n    DAT_200004c4 = 9;\n    DAT_200004d0 = 0;\n    DAT_200004d8 = 10;\n    DAT_200004e4 = 0;\n    DAT_200004ec = 0x17;\n    DAT_200004f8 = 0;\n    DAT_20000500 = 0x17;\n    DAT_2000050c = 0;\n    DAT_20000514 = 0x17;\n    DAT_20000520 = 0;\n    DAT_20000528 = 0x17;\n    DAT_20000534 = 0;\n    DAT_2000053c = 0x17;\n    DAT_20000548 = 0;\n    DAT_20000550 = 0x28;\n    DAT_2000055c = 0;\n    DAT_20000564 = 0x28;\n    DAT_20000570 = 0;\n    DAT_20000578 = 0x28;\n    DAT_20000584 = 0;\n    DAT_2000058c = 0x28;\n    DAT_20000598 = 0;\n    DAT_200005a0 = 0x28;\n    DAT_200005ac = 0;\n    DAT_200005b4 = 0x28;\n    DAT_200005c0 = 0;\n    cleanupOnExit(0,&exitLabel,&DAT_20000000,&DAT_20000488,param4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046b4": "initialize_params_080046b4",
                "param_1": "flag",
                "param_2": "value",
                "param_3": "param3",
                "param_4": "param4",
                "__aeabi_atexit": "cleanupOnExit",
                "LAB_0800468c_1": "exitLabel",
                "&LAB_0800468c_1": "&exitLabel"
            },
            "calling": [],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047c0": {
            "entrypoint": "0x080047c0",
            "current_name": "check_and_execute_function_080047c0",
            "code": "\nvoid checkAndExecuteFunction_080047c0(int functionData)\n\n{\n  int pinId;\n  \n  if (*(int *)(functionData + 8) != 0) {\n    (**(code **)(functionData + 0xc))();\n    return;\n  }\n  handleBadFunctionCall;\n  pinId = getPinId;\n  if ((&DAT_20000494)[pinId * 5] != 0) {\n    checkAndExecuteFunction_080047c0();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047c0": "check_and_execute_function_080047c0",
                "param_1": "functionData",
                "iVar1": "pinId",
                "__throw_bad_function_call()": "handleBadFunctionCall",
                "get_pin_id()": "getPinId"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047d0": {
            "entrypoint": "0x080047d0",
            "current_name": "check_and_execute_operator_function_080047d0",
            "code": "\nvoid checkAndExecuteOperatorFunction_080047d0(void)\n\n{\n  int pinId;\n  \n  pinId = getPinId();\n  if ((&DAT_20000494)[pinId * 5] != 0) {\n    executeOperatorFunction();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047d0": "check_and_execute_operator_function_080047d0",
                "iVar1": "pinId",
                "get_pin_id": "getPinId",
                "operator()": "executeOperatorFunction"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047fe": {
            "entrypoint": "0x080047fe",
            "current_name": "register_cleanup_function_080047fe",
            "code": "\nvoid registerCleanupFunction_080047fe(undefined4 cleanupFunction,undefined4 dataPointer)\n\n{\n  __cxa_atexit(dataPointer,cleanupFunction);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047fe": "register_cleanup_function_080047fe",
                "param_1": "cleanupFunction",
                "param_2": "dataPointer"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004808": {
            "entrypoint": "0x08004808",
            "current_name": "print_assertion_failed_message_08004808",
            "code": "\nvoid print_assertion_failed_message_08004808(undefined4 file_name,undefined4 line_number,char *assertion_string,undefined4 function_name)\n\n{\n  undefined4 file;\n  char *extra_info;\n  undefined8 result;\n  undefined4 function_name_copy;\n  \n  file = *(undefined4 *)(DAT_200000a0 + 0xc);\n  function_name_copy = function_name;\n  if (assertion_string == (char *)0x0) goto LAB_0800482c;\n  extra_info = \", function: \";\n  do {\n    fiprintf(file,\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",function_name,file_name,line_number,\n             extra_info,assertion_string,function_name_copy);\n    result = abort();\n    line_number = (undefined4)((ulonglong)result >> 0x20);\n    file = (undefined4)result;\nLAB_0800482c:\n    assertion_string = \"\";\n    extra_info = assertion_string;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004808": "print_assertion_failed_message_08004808",
                "param_1": "file_name",
                "param_2": "line_number",
                "param_3": "assertion_string",
                "param_4": "function_name",
                "uVar1": "file",
                "pcVar2": "extra_info",
                "uVar3": "result",
                "uVar4": "function_name_copy"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "fiprintf",
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004844": {
            "entrypoint": "0x08004844",
            "current_name": "left_shift_64bit_08004844",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800484c) */\n\nlonglong left_shift_64bit_08004844(undefined4 param,uint value)\n\n{\n  return (ulonglong)value << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08004844": "left_shift_64bit_08004844",
                "param_1": "param",
                "param_2": "value"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004860": {
            "entrypoint": "0x08004860",
            "current_name": "print_stack_values_08004860",
            "code": "\nvoid print_stack_values_08004860(undefined4 format_string,undefined4 argument_1,undefined4 argument_2,undefined4 argument_3)\n\n{\n  undefined4 value_1;\n  undefined4 value_2;\n  \n  value_1 = argument_2;\n  value_2 = argument_3;\n  _vfiprintf_r(DAT_200000a0,format_string,argument_1,&value_1,format_string,&value_1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004860": "print_stack_values_08004860",
                "param_1": "format_string",
                "param_2": "argument_1",
                "param_3": "argument_2",
                "param_4": "argument_3",
                "uStack_8": "value_1",
                "uStack_4": "value_2"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004884": {
            "entrypoint": "0x08004884",
            "current_name": "execute_functions_08004884",
            "code": "\nvoid execute_functions_08004884(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(code *)(&DAT_08006008)[index])();\n  }\n  _init();\n  for (index = 0; index != 10; index = index + 1) {\n    (*(code *)(&DAT_08006008)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004884": "execute_functions_08004884",
                "iVar1": "index"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "premain",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048cc": {
            "entrypoint": "0x080048cc",
            "current_name": "fill_memory_080048cc",
            "code": "\nvoid fillMemory_080048cc(undefined *destination,undefined value,int size)\n\n{\n  undefined *endAddress;\n  \n  endAddress = destination + size;\n  for (; destination != endAddress; destination = destination + 1) {\n    *destination = value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080048cc": "fill_memory_080048cc",
                "param_1": "destination",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "endAddress"
            },
            "calling": [
                "__sfp",
                "__sfmoreglue",
                "std.isra.0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048dc": {
            "entrypoint": "0x080048dc",
            "current_name": "extract_pointers_080048dc",
            "code": "\nvoid extractPointers_080048dc(undefined4 *result,int numPointers,undefined4 param_3,undefined4 param_4)\n\n{\n  int *currentPointer;\n  int **nextPointer;\n  int **prevPointer;\n  int **currentPtr;\n  int **nextPtr;\n  int **newPtr;\n  bool isNewPtr;\n  \n  if (numPointers == 0) {\n    return;\n  }\n  newPtr = (int **)(numPointers + -4);\n  if (*(int *)(numPointers + -4) < 0) {\n    newPtr = (int **)((int)newPtr + *(int *)(numPointers + -4));\n  }\n  lockMalloc();\n  currentPtr = (int **)&DAT_200005c8;\n  if (DAT_200005c8 == (int **)0x0) {\n    newPtr[1] = (int *)0x0;\n    prevPointer = nextPointer;\n    DAT_200005c8 = newPtr;\n  }\n  else {\n    currentPtr = DAT_200005c8;\n    if (newPtr < DAT_200005c8) {\n      prevPointer = (int **)*newPtr;\n      currentPtr = (int **)((int)newPtr + (int)prevPointer);\n      isNewPtr = DAT_200005c8 == currentPtr;\n      if (isNewPtr) {\n        currentPtr = (int **)*DAT_200005c8;\n        DAT_200005c8 = (int **)DAT_200005c8[1];\n      }\n      newPtr[1] = (int *)DAT_200005c8;\n      DAT_200005c8 = newPtr;\n      if (isNewPtr) {\n        currentPtr = (int **)((int)currentPtr + (int)prevPointer);\n        *newPtr = (int *)currentPtr;\n      }\n    }\n    else {\n      do {\n        nextPtr = currentPtr;\n        currentPtr = (int **)nextPtr[1];\n        if (currentPtr == (int **)0x0) break;\n      } while (currentPtr <= newPtr);\n      prevPointer = (int **)*nextPtr;\n      if ((int **)((int)nextPtr + (int)prevPointer) == newPtr) {\n        prevPointer = (int **)((int)prevPointer + (int)*newPtr);\n        *nextPtr = (int *)prevPointer;\n        if (currentPtr == (int **)((int)nextPtr + (int)prevPointer)) {\n          currentPointer = *currentPtr;\n          currentPtr = (int **)currentPtr[1];\n          nextPtr[1] = (int *)currentPtr;\n          prevPointer = (int **)((int)prevPointer + (int)currentPointer);\n          *nextPtr = (int *)prevPointer;\n        }\n      }\n      else if (newPtr < (int **)((int)nextPtr + (int)prevPointer)) {\n        *result = 0xc;\n      }\n      else {\n        prevPointer = (int **)((int)newPtr + (int)*newPtr);\n        isNewPtr = currentPtr == prevPointer;\n        if (isNewPtr) {\n          prevPointer = (int **)*currentPtr;\n          currentPtr = (int **)currentPtr[1];\n        }\n        newPtr[1] = (int *)currentPtr;\n        if (isNewPtr) {\n          prevPointer = (int **)((int)prevPointer + (int)*newPtr);\n          *newPtr = (int *)prevPointer;\n        }\n        nextPtr[1] = (int *)newPtr;\n      }\n    }\n  }\n  unlockMalloc(result,prevPointer,currentPtr,param_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080048dc": "extract_pointers_080048dc",
                "param_1": "result",
                "param_2": "numPointers",
                "piVar1": "currentPointer",
                "extraout_r1": "nextPointer",
                "ppiVar2": "prevPointer",
                "ppiVar3": "currentPtr",
                "ppiVar4": "nextPtr",
                "ppiVar5": "newPtr",
                "bVar6": "isNewPtr",
                "__malloc_lock": "lockMalloc",
                "__malloc_unlock": "unlockMalloc"
            },
            "calling": [
                "__swsetup_r",
                "abort"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004978": {
            "entrypoint": "0x08004978",
            "current_name": "allocate_memory_08004978",
            "code": "\nuint allocate_memory_08004978(undefined4 *ptr_size,uint requested_size)\n\n{\n  uint *current_chunk;\n  int remaining_bytes;\n  uint *next_chunk;\n  uint difference;\n  uint *previous_chunk;\n  uint allocated_size;\n  \n  allocated_size = (requested_size + 3 & 0xfffffffc) + 8;\n  if (allocated_size < 0xc) {\n    allocated_size = 0xc;\n  }\n  if (((int)allocated_size < 0) || (allocated_size < requested_size)) {\n    *ptr_size = 0xc;\n  }\n  else {\n    __malloc_lock();\n    current_chunk = DAT_200005c8;\n    previous_chunk = DAT_200005c8;\n    while (next_chunk = current_chunk, next_chunk != (uint *)0x0) {\n      difference = *next_chunk - allocated_size;\n      if (-1 < (int)difference) {\n        if (difference < 0xc) {\n          if (previous_chunk == next_chunk) {\n            current_chunk = (uint *)previous_chunk[1];\n          }\n          else {\n            current_chunk = (uint *)next_chunk[1];\n          }\n          if (previous_chunk != next_chunk) {\n            previous_chunk[1] = (uint)current_chunk;\n            previous_chunk = next_chunk;\n            current_chunk = DAT_200005c8;\n          }\n        }\n        else {\n          *next_chunk = difference;\n          *(uint *)((int)next_chunk + difference) = allocated_size;\n          previous_chunk = (uint *)((int)next_chunk + difference);\n          current_chunk = DAT_200005c8;\n        }\n        goto LAB_080049dc;\n      }\n      previous_chunk = next_chunk;\n      current_chunk = (uint *)next_chunk[1];\n    }\n    if (DAT_200005cc == 0) {\n      DAT_200005cc = _sbrk_r(ptr_size);\n    }\n    current_chunk = (uint *)_sbrk_r(ptr_size,allocated_size);\n    if ((current_chunk != (uint *)0xffffffff) &&\n       ((previous_chunk = (uint *)((int)current_chunk + 3U & 0xfffffffc), current_chunk == previous_chunk ||\n        (remaining_bytes = _sbrk_r(ptr_size,(int)previous_chunk - (int)current_chunk), remaining_bytes != -1)))) {\n      *previous_chunk = allocated_size;\n      current_chunk = DAT_200005c8;\nLAB_080049dc:\n      DAT_200005c8 = current_chunk;\n      __malloc_unlock(ptr_size);\n      allocated_size = (int)previous_chunk + 0xbU & 0xfffffff8;\n      remaining_bytes = allocated_size - (int)(previous_chunk + 1);\n      if (remaining_bytes != 0) {\n        *(int *)((int)previous_chunk + remaining_bytes) = -remaining_bytes;\n        return allocated_size;\n      }\n      return allocated_size;\n    }\n    *ptr_size = 0xc;\n    __malloc_unlock(ptr_size);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004978": "allocate_memory_08004978",
                "param_1": "ptr_size",
                "param_2": "requested_size",
                "puVar1": "current_chunk",
                "iVar2": "remaining_bytes",
                "puVar3": "next_chunk",
                "uVar4": "difference",
                "puVar5": "previous_chunk",
                "uVar6": "allocated_size"
            },
            "calling": [
                "__smakebuf_r",
                "__sfmoreglue"
            ],
            "called": [
                "__malloc_lock",
                "_sbrk_r",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a34": {
            "entrypoint": "0x08004a34",
            "current_name": "append_to_buffer_08004a34",
            "code": "\nuint appendToBuffer_08004a34(int buffer,byte data,byte **bufferPtr)\n\n{\n  int result;\n  byte *bufferEndPtr;\n  byte *swappedPtr;\n  uint dataValue;\n  \n  bufferEndPtr = bufferPtr[2] + -1;\n  bufferPtr[2] = bufferEndPtr;\n  if ((-1 < (int)bufferEndPtr) ||\n     (((int)bufferPtr[6] <= (int)bufferEndPtr && (bufferEndPtr = (byte *)(uint)data, bufferEndPtr != (byte *)0xa))))\n  {\n    bufferEndPtr = *bufferPtr;\n    *bufferPtr = bufferEndPtr + 1;\n    *bufferEndPtr = data;\n    return (uint)data;\n  }\n  if ((buffer != 0) && (*(int *)(buffer + 0x18) == 0)) {\n    __sinit();\n  }\n  if (bufferPtr == (byte **)&DAT_08005fc0) {\n    bufferPtr = *(byte ***)(buffer + 4);\n  }\n  else if (bufferPtr == (byte **)&DAT_08005fe0) {\n    bufferPtr = *(byte ***)(buffer + 8);\n  }\n  else if (bufferPtr == (byte **)&DAT_08005fa0) {\n    bufferPtr = *(byte ***)(buffer + 0xc);\n  }\n  bufferPtr[2] = bufferPtr[6];\n  swappedPtr = (byte *)(uint)*(ushort *)(bufferPtr + 3);\n  result = (int)swappedPtr << 0x1c;\n  if (((result < 0) && (swappedPtr = bufferPtr[4], swappedPtr != (byte *)0x0)) ||\n     (result = __swsetup_r(buffer,bufferPtr,result,swappedPtr,bufferEndPtr), result == 0)) {\n    result = (int)*bufferPtr - (int)bufferPtr[4];\n    dataValue = (uint)data;\n    if ((result < (int)bufferPtr[5]) || (result = _fflush_r(buffer,bufferPtr), result == 0)) {\n      bufferPtr[2] = bufferPtr[2] + -1;\n      bufferEndPtr = *bufferPtr;\n      *bufferPtr = bufferEndPtr + 1;\n      *bufferEndPtr = data;\n      if ((byte *)(result + 1) != bufferPtr[5]) {\n        if (-1 < (int)((uint)*(ushort *)(bufferPtr + 3) << 0x1f)) {\n          return dataValue;\n        }\n        if (dataValue != 10) {\n          return dataValue;\n        }\n      }\n      result = _fflush_r(buffer,bufferPtr);\n      if (result == 0) {\n        return dataValue;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004a34": "append_to_buffer_08004a34",
                "param_1": "buffer",
                "param_2": "data",
                "param_3": "bufferPtr",
                "iVar1": "result",
                "pbVar2": "bufferEndPtr",
                "pbVar3": "swappedPtr",
                "uVar4": "dataValue"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swsetup_r",
                "_fflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a60": {
            "entrypoint": "0x08004a60",
            "current_name": "copy_string_to_file_08004a60",
            "code": "\nint copyStringToFile_08004a60(undefined4 file,undefined4 buffer,undefined *inputString,int stringLength)\n\n{\n  int result;\n  undefined *endOfString;\n  int lengthCounter;\n  \n  endOfString = inputString + stringLength;\n  lengthCounter = stringLength;\n  do {\n    if (inputString == endOfString) {\n      return 0;\n    }\n    result = __sfputc_r(file,*inputString,buffer,stringLength,lengthCounter);\n    stringLength = result + 1;\n    inputString = inputString + 1;\n  } while (stringLength != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004a60": "copy_string_to_file_08004a60",
                "param_1": "file",
                "param_2": "buffer",
                "param_3": "inputString",
                "param_4": "stringLength",
                "iVar1": "result",
                "puVar2": "endOfString",
                "iVar3": "lengthCounter"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a84": {
            "entrypoint": "0x08004a84",
            "current_name": "handle_printf_format_08004a84",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08004c58) */\n\nint handlePrintfFormat_08004a84(int arg1,undefined4 *arg2,byte *formatString,int *arg4)\n\n{\n  int result;\n  int *ptrVar;\n  bool isDigit;\n  byte *currentChar;\n  byte *startChar;\n  int tempVar;\n  int tempVar2;\n  int *bufferPosition;\n  uint formatFlags;\n  int precision;\n  undefined4 localeInfo;\n  int fieldWidth;\n  int totalLength;\n  byte conversionSpecifier;\n  undefined spaceFlag;\n  undefined zeroFlag;\n  undefined signFlag;\n  undefined4 reservedField;\n  \n  bufferPosition = arg4;\n  if ((arg1 != 0) && (*(int *)(arg1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (arg2 == &DAT_08005fc0) {\n    arg2 = *(undefined4 **)(arg1 + 4);\n  }\n  else if (arg2 == (undefined4 *)&DAT_08005fe0) {\n    arg2 = *(undefined4 **)(arg1 + 8);\n  }\n  else if (arg2 == (undefined4 *)&DAT_08005fa0) {\n    arg2 = *(undefined4 **)(arg1 + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(arg2 + 3) << 0x1c)) || (arg2[4] == 0)) &&\n     (tempVar2 = __swsetup_r(arg1,arg2), tempVar2 != 0)) {\n    return -1;\n  }\n  totalLength = 0;\n  spaceFlag = 0x20;\n  zeroFlag = 0x30;\n  currentChar = formatString;\nLAB_08004ac6:\n  startChar = currentChar;\n  if (*startChar != 0) goto LAB_08004b7c;\n  goto LAB_08004ad0;\nLAB_08004b7c:\n  currentChar = startChar + 1;\n  if (*startChar != 0x25) goto LAB_08004ac6;\nLAB_08004ad0:\n  tempVar2 = (int)startChar - (int)formatString;\n  if (tempVar2 != 0) {\n    result = __sfputs_r(arg1,arg2,formatString,tempVar2);\n    if (result == -1) {\nLAB_08004c70:\n      if ((int)((uint)*(ushort *)(arg2 + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalLength;\n    }\n    totalLength = totalLength + tempVar2;\n  }\n  if (*startChar == 0) goto LAB_08004c70;\n  formatFlags = 0;\n  fieldWidth = 0;\n  precision = -1;\n  localeInfo = 0;\n  signFlag = 0;\n  reservedField = 0;\n  currentChar = startChar + 1;\n  while( true ) {\n    tempVar2 = memchr(\"#-0+ \",*currentChar);\n    formatString = currentChar + 1;\n    if (tempVar2 == 0) break;\n    formatFlags = 1 << (tempVar2 + 0xf7ffa094U & 0xff) | formatFlags;\n    currentChar = formatString;\n  }\n  if ((int)(formatFlags << 0x1b) < 0) {\n    signFlag = 0x20;\n  }\n  if ((int)(formatFlags << 0x1c) < 0) {\n    signFlag = 0x2b;\n  }\n  if (*currentChar == 0x2a) {\n    ptrVar = bufferPosition + 1;\n    tempVar2 = *bufferPosition;\n    bufferPosition = ptrVar;\n    if (tempVar2 < 0) {\n      fieldWidth = -tempVar2;\n      formatFlags = formatFlags | 2;\n      goto LAB_08004bae;\n    }\n  }\n  else {\n    isDigit = false;\n    tempVar2 = fieldWidth;\n    formatString = currentChar;\n    while( true ) {\n      if (9 < *formatString - 0x30) break;\n      tempVar2 = tempVar2 * 10 + (*formatString - 0x30);\n      isDigit = true;\n      formatString = formatString + 1;\n    }\n    if (!isDigit) goto LAB_08004bae;\n  }\n  fieldWidth = tempVar2;\nLAB_08004bae:\n  if (*formatString == 0x2e) {\n    if (formatString[1] == 0x2a) {\n      precision = *bufferPosition;\n      if (precision < 0) {\n        precision = -1;\n      }\n      formatString = formatString + 2;\n      bufferPosition = bufferPosition + 1;\n    }\n    else {\n      isDigit = false;\n      precision = 0;\n      tempVar2 = 0;\n      while( true ) {\n        formatString = formatString + 1;\n        if (9 < *formatString - 0x30) break;\n        tempVar2 = tempVar2 * 10 + (*formatString - 0x30);\n        isDigit = true;\n      }\n      if (isDigit) {\n        precision = tempVar2;\n      }\n    }\n  }\n  tempVar2 = memchr(&DAT_08005f72,*formatString,3);\n  if (tempVar2 != 0) {\n    formatFlags = formatFlags | 0x40 << (tempVar2 + 0xf7ffa08eU & 0xff);\n    formatString = formatString + 1;\n  }\n  conversionSpecifier = *formatString;\n  formatString = formatString + 1;\n  tempVar2 = memchr(\"efgEFG\",conversionSpecifier,6);\n  if (tempVar2 == 0) {\n    tempVar = _printf_i(arg1,&formatFlags,arg2,0x8004a61,&bufferPosition);\n    if (tempVar == -1) goto LAB_08004c70;\n  }\n  else {\n    bufferPosition = (int *)(((int)bufferPosition + 7U & 0xfffffff8) + 8);\n  }\n  totalLength = totalLength + tempVar;\n  currentChar = formatString;\n  goto LAB_08004ac6;\n}\n\n",
            "renaming": {
                "FUN_08004a84": "handle_printf_format_08004a84",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "formatString",
                "param_4": "arg4",
                "iVar1": "result",
                "piVar2": "ptrVar",
                "bVar3": "isDigit",
                "pbVar4": "currentChar",
                "pbVar5": "startChar",
                "unaff_r9": "tempVar",
                "iVar6": "tempVar2",
                "local_8c": "bufferPosition",
                "local_88": "formatFlags",
                "local_84": "precision",
                "local_80": "localeInfo",
                "local_7c": "fieldWidth",
                "local_74": "totalLength",
                "local_70": "conversionSpecifier",
                "local_6f": "spaceFlag",
                "local_6e": "zeroFlag",
                "local_45": "signFlag",
                "local_30": "reservedField"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "memchr",
                "__swsetup_r",
                "_printf_i",
                "__sinit",
                "__sfputs_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cb0": {
            "entrypoint": "0x08004cb0",
            "current_name": "process_data_08004cb0",
            "code": "\nundefined4\nprocessData_08004cb0(undefined4 input,uint *data,uint *outputSize,undefined4 param4,code *callback)\n\n{\n  int index1;\n  int index2;\n  uint counter2;\n  uint counter1;\n  bool flag;\n  \n  counter2 = data[4];\n  if ((int)data[4] < limit) {\n    counter2 = data[2];\n  }\n  *outputSize = counter2;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *outputSize = counter2 + 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *outputSize = *outputSize + 2;\n  }\n  if ((*data & 6) == 0) {\n    for (index1 = 0; index1 < (int)(dataSize - *outputSize); index1 = index1 + 1) {\n      index2 = (*callback)(input,param4,(int)data + 0x19,1);\n      if (index2 == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  counter2 = (uint)*(byte *)((int)data + 0x43);\n  if (counter2 != 0) {\n    counter2 = 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *(undefined *)((int)data + counter2 + 0x43) = 0x30;\n    *(undefined *)((int)data + counter2 + 0x44) = *(undefined *)((int)data + 0x45);\n    counter2 = counter2 + 2;\n  }\n  index1 = (*callback)(input,param4,(int)data + 0x43,counter2);\n  if (index1 != -1) {\n    counter2 = dataSize;\n    flag = (*data & 6) == 4;\n    if (flag) {\n      counter2 = counter2 - *outputSize;\n    }\n    if (flag) {\n      counter2 = counter2 & ~((int)counter2 >> 0x1f);\n    }\n    else {\n      counter2 = 0;\n    }\n    if ((int)data[4] < limit) {\n      counter2 = counter2 + (data[2] - data[4]);\n    }\n    counter1 = 0;\n    while( true ) {\n      if (counter2 == counter1) {\n        return 0;\n      }\n      index1 = (*callback)(input,param4,(int)data + 0x1a,1);\n      if (index1 == -1) break;\n      counter1 = counter1 + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004cb0": "process_data_08004cb0",
                "param_1": "input",
                "param_2": "data",
                "param_3": "outputSize",
                "param_4": "param4",
                "param_5": "callback",
                "iVar1": "index1",
                "iVar2": "index2",
                "uVar3": "counter2",
                "uVar4": "counter1",
                "bVar5": "flag",
                "param_2[3]": "dataSize",
                "(int)param_2[2]": "limit"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d9c": {
            "entrypoint": "0x08004d9c",
            "current_name": "format_and_print_08004d9c",
            "code": "\nuint formatAndPrint_08004d9c(undefined4 formatString,uint *arguments,undefined4 width,code *printFunction,uint **argList)\n\n{\n  byte byteValue;\n  int index;\n  uint *ptr;\n  int result;\n  char *hexDigits;\n  uint arg;\n  uint **ppuVar7;\n  char **ppcVar8;\n  uint argSigned;\n  uint widthCopy;\n  char *output;\n  char *formatSpecifier;\n  uint widthAdjustment [2];\n  \n  byteValue = *(byte *)(arguments + 6);\n  formatSpecifier = (char *)((int)arguments + 0x43);\n  if (byteValue != 0x6e) {\n    if (byteValue < 0x6f) {\n      if (byteValue != 99) {\n        if (byteValue < 100) {\n          if (byteValue == 0) goto LAB_08004f56;\n          if (byteValue != 0x58) goto LAB_08004dcc;\n          *(undefined *)((int)arguments + 0x45) = 0x58;\n          hexDigits = \"0123456789ABCDEF\";\nLAB_08004ee6:\n          arg = *arguments;\n          ptr = *argList;\n          *argList = ptr + 1;\n          if (((arg & 0x80) == 0) && ((int)(arg << 0x19) < 0)) {\n            argSigned = (uint)*(ushort *)ptr;\n          }\n          else {\n            argSigned = *ptr;\n          }\n          if ((int)(arg << 0x1f) < 0) {\n            *arguments = arg | 0x20;\n          }\n          if (argSigned == 0) {\n            *arguments = *arguments & 0xffffffdf;\n          }\n          arg = 0x10;\nLAB_08004e7c:\n          *(undefined *)((int)arguments + 0x43) = 0;\n        }\n        else {\n          if ((byteValue != 100) && (byteValue != 0x69)) goto LAB_08004dcc;\n          argSigned = *arguments;\n          ptr = *argList;\n          if ((argSigned & 0x80) == 0) {\n            *argList = ptr + 1;\n            if ((argSigned & 0x40) == 0) goto LAB_08004dec;\n            argSigned = (uint)(short)*(ushort *)ptr;\n          }\n          else {\n            *argList = ptr + 1;\nLAB_08004dec:\n            argSigned = *ptr;\n          }\n          if ((int)argSigned < 0) {\n            argSigned = -argSigned;\n            *(undefined *)((int)arguments + 0x43) = 0x2d;\n          }\n          hexDigits = \"0123456789ABCDEF\";\n          arg = 10;\n        }\n        widthCopy = arguments[1];\n        arguments[2] = widthCopy;\n        output = formatSpecifier;\n        if ((int)widthCopy < 0) {\n          if (argSigned != 0) goto LAB_08004f1a;\nLAB_08004fc8:\n          *(char *)((int)arguments + 0x42) = *hexDigits;\n          output = (char *)((int)arguments + 0x42);\n        }\n        else {\n          *arguments = *arguments & 0xfffffffb;\n          if (argSigned == 0) {\n            if (widthCopy != 0) goto LAB_08004fc8;\n          }\n          else {\nLAB_08004f1a:\n            do {\n              widthCopy = argSigned / arg;\n              output = output + -1;\n              *output = hexDigits[argSigned - arg * widthCopy];\n              argSigned = widthCopy;\n            } while (widthCopy != 0);\n          }\n        }\n        if (((arg == 8) && ((int)(*arguments << 0x1f) < 0)) && ((int)arguments[1] <= (int)arguments[4]))\n        {\n          output[-1] = '0';\n          output = output + -1;\n        }\n        arguments[4] = (int)formatSpecifier - (int)output;\n        formatSpecifier = output;\n        goto LAB_08004ec2;\n      }\n      ptr = *argList;\n      *argList = ptr + 1;\n      *(char *)((int)arguments + 0x42) = (char)*ptr;\nLAB_08004e2c:\n      formatSpecifier = (char *)((int)arguments + 0x42);\n      argSigned = 1;\n    }\n    else {\n      if (byteValue != 0x73) {\n        if (byteValue < 0x74) {\n          if (byteValue == 0x6f) {\nLAB_08004e52:\n            argSigned = *arguments;\n            ptr = *argList;\n            if ((argSigned & 0x80) == 0) {\n              *argList = ptr + 1;\n              if ((argSigned & 0x40) == 0) goto LAB_08004e60;\n              argSigned = (uint)*(ushort *)ptr;\n            }\n            else {\n              *argList = ptr + 1;\nLAB_08004e60:\n              argSigned = *ptr;\n            }\n            hexDigits = \"0123456789ABCDEF\";\n            if (byteValue == 0x6f) {\n              arg = 8;\n            }\n            else {\n              arg = 10;\n            }\n            goto LAB_08004e7c;\n          }\n          if (byteValue == 0x70) {\n            *arguments = *arguments | 0x20;\nLAB_08004e12:\n            *(undefined *)((int)arguments + 0x45) = 0x78;\n            hexDigits = \"0123456789abcdef\";\n            goto LAB_08004ee6;\n          }\n        }\n        else {\n          if (byteValue == 0x75) goto LAB_08004e52;\n          if (byteValue == 0x78) goto LAB_08004e12;\n        }\nLAB_08004dcc:\n        *(byte *)((int)arguments + 0x42) = byteValue;\n        goto LAB_08004e2c;\n      }\n      ppcVar8 = (char **)*argList;\n      *argList = (uint *)(ppcVar8 + 1);\n      formatSpecifier = *ppcVar8;\n      index = memchr(formatSpecifier,0,arguments[1]);\n      if (index != 0) {\n        arguments[1] = index - (int)formatSpecifier;\n      }\n      argSigned = arguments[1];\n    }\n    arguments[4] = argSigned;\n    *(undefined *)((int)arguments + 0x43) = 0;\n    goto LAB_08004ec2;\n  }\n  argSigned = *arguments;\n  ppuVar7 = (uint **)*argList;\n  arg = arguments[5];\n  if ((argSigned & 0x80) == 0) {\n    *argList = (uint *)(ppuVar7 + 1);\n    ptr = *ppuVar7;\n    if ((argSigned & 0x40) == 0) goto LAB_08004f42;\n    *(short *)ptr = (short)arg;\n  }\n  else {\n    *argList = (uint *)(ppuVar7 + 1);\n    ptr = *ppuVar7;\nLAB_08004f42:\n    *ptr = arg;\n  }\nLAB_08004f56:\n  arguments[4] = 0;\nLAB_08004ec2:\n  index = _printf_common(formatString,arguments,widthAdjustment,width,printFunction);\n  if ((index == -1) || (index = (*printFunction)(formatString,width,formatSpecifier,arguments[4]), index == -1)) {\nLAB_08004ed6:\n    argSigned = 0xffffffff;\n  }\n  else {\n    if ((int)(*arguments << 0x1e) < 0) {\n      for (index = 0; index < (int)(arguments[3] - widthAdjustment[0]); index = index + 1) {\n        result = (*printFunction)(formatString,width,(int)arguments + 0x19,1);\n        if (result == -1) goto LAB_08004ed6;\n      }\n    }\n    argSigned = arguments[3];\n    if ((int)arguments[3] < (int)widthAdjustment[0]) {\n      argSigned = widthAdjustment[0];\n    }\n  }\n  return argSigned;\n}\n\n",
            "renaming": {
                "FUN_08004d9c": "format_and_print_08004d9c",
                "param_1": "formatString",
                "param_2": "arguments",
                "param_3": "width",
                "param_4": "printFunction",
                "param_5": "argList",
                "bVar1": "byteValue",
                "iVar2": "index",
                "puVar3": "ptr",
                "iVar4": "result",
                "pcVar5": "hexDigits",
                "uVar6": "arg",
                "uVar9": "argSigned",
                "uVar10": "widthCopy",
                "pcVar11": "output",
                "pcVar12": "formatSpecifier",
                "local_24": "widthAdjustment"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "memchr",
                "_printf_common"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fdc": {
            "entrypoint": "0x08004fdc",
            "current_name": "print_formatted_string_08004fdc",
            "code": "\nvoid printFormattedString_08004fdc(undefined4 formatString,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  int dataAddress;\n  undefined4 formatStringPtr;\n  undefined4 tempArg1;\n  undefined4 tempArg2;\n  undefined4 tempArg3;\n  \n  dataAddress = DAT_200000a0;\n  formatStringPtr = formatString;\n  tempArg1 = arg1;\n  tempArg2 = arg2;\n  tempArg3 = arg3;\n  if ((DAT_200000a0 != 0) && (*(int *)(DAT_200000a0 + 0x18) == 0)) {\n    __sinit(DAT_200000a0);\n  }\n  _vfiprintf_r(dataAddress,*(undefined4 *)(dataAddress + 8),formatString,&tempArg1,formatStringPtr,&tempArg1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004fdc": "print_formatted_string_08004fdc",
                "param_1": "formatString",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "iVar1": "dataAddress",
                "uVar2": "formatStringPtr",
                "uStack_c": "tempArg1",
                "uStack_8": "tempArg2",
                "uStack_4": "tempArg3"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800500c": {
            "entrypoint": "0x0800500c",
            "current_name": "allocate_memory_0800500c",
            "code": "\nvoid allocateMemory_0800500c(int *outputPointer,undefined4 size)\n\n{\n  int allocatedMemory;\n  \n  DAT_20000674 = 0;\n  allocatedMemory = _sbrk(size);\n  if ((allocatedMemory == -1) && (DAT_20000674 != 0)) {\n    *outputPointer = DAT_20000674;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800500c": "allocate_memory_0800500c",
                "param_1": "outputPointer",
                "param_2": "size",
                "iVar1": "allocatedMemory"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080050d0": {
            "entrypoint": "0x080050d0",
            "current_name": "process_data_080050d0",
            "code": "\nuint processData_080050d0(undefined4 *outputBuffer,undefined4 *inputBuffer)\n\n{\n  int dataAddress;\n  uint result;\n  ushort flags;\n  \n  dataAddress = DAT_200000a0;\n  if ((DAT_200000a0 != 0) && (*(int *)(DAT_200000a0 + 0x18) == 0)) {\n    initializeData(DAT_200000a0);\n  }\n  if (inputBuffer == &DAT_08005fc0) {\n    inputBuffer = *(undefined4 **)(dataAddress + 4);\n  }\n  else if (inputBuffer == (undefined4 *)&DAT_08005fe0) {\n    inputBuffer = *(undefined4 **)(dataAddress + 8);\n  }\n  else if (inputBuffer == (undefined4 *)&DAT_08005fa0) {\n    inputBuffer = *(undefined4 **)(dataAddress + 0xc);\n  }\n  flags = *(ushort *)(inputBuffer + 3);\n  result = (uint)flags;\n  if (-1 < (int)(result << 0x1c)) {\n    if (-1 < (int)(result << 0x1b)) {\n      *outputBuffer = 9;\n      goto LAB_08005100;\n    }\n    if ((int)(result << 0x1d) < 0) {\n      if ((undefined4 *)inputBuffer[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)inputBuffer[0xd] != inputBuffer + 0x11) {\n          deallocateMemory(outputBuffer);\n        }\n        inputBuffer[0xd] = 0;\n      }\n      *(ushort *)(inputBuffer + 3) = *(ushort *)(inputBuffer + 3) & 0xffdb;\n      initializeFlag = 0;\n      *inputBuffer = checkValue;\n    }\n    *(ushort *)(inputBuffer + 3) = *(ushort *)(inputBuffer + 3) | 8;\n  }\n  if ((checkValue == 0) && ((*(ushort *)(inputBuffer + 3) & 0x280) != 0x200)) {\n    createBuffer(outputBuffer,inputBuffer);\n  }\n  flags = *(ushort *)(inputBuffer + 3);\n  result = flags & 1;\n  if ((flags & 1) == 0) {\n    if (-1 < (int)((uint)flags << 0x1e)) {\n      result = flagValue;\n    }\n    modifiedFlag = result;\n  }\n  else {\n    modifiedFlag = 0;\n    negativeFlag = -flagValue;\n  }\n  if (checkValue == 0) {\n    flags = *(ushort *)(inputBuffer + 3);\n    result = (int)(short)flags & 0x80;\n    if (result != 0) {\nLAB_08005100:\n      *(ushort *)(inputBuffer + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080050d0": "process_data_080050d0",
                "param_1": "outputBuffer",
                "param_2": "inputBuffer",
                "iVar1": "dataAddress",
                "uVar2": "result",
                "uVar3": "flags",
                "__sinit": "initializeData",
                "_free_r": "deallocateMemory",
                "param_2[1]": "initializeFlag",
                "param_2[4]": "checkValue",
                "__smakebuf_r": "createBuffer",
                "param_2[5]": "flagValue",
                "param_2[2]": "modifiedFlag",
                "param_2[6]": "negativeFlag"
            },
            "calling": [
                "__sfputc_r",
                "_vfiprintf_r"
            ],
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051ac": {
            "entrypoint": "0x080051ac",
            "current_name": "execute_binary_function_080051ac",
            "code": "\nvoid executeBinaryFunction_080051ac(void)\n\n{\n  uint *binaryOutput;\n  int offset;\n  int *binaryParams;\n  int *memoryBlock;\n  uint ushortValue;\n  ushort bitmask;\n  int increment;\n  code *binaryFunction;\n  int totalSize;\n  uint tempValue;\n  code *exitFunction;\n  bool isZero;\n  undefined8 exitValue;\n  \n  raise(6);\n  exitFunction = (code *)0x80051bb;\n  exitValue = _exit(1);\n  binaryParams = (int *)((ulonglong)exitValue >> 0x20);\n  binaryOutput = (uint *)exitValue;\n  bitmask = *(ushort *)(binaryParams + 3);\n  ushortValue = (uint)bitmask;\n  if ((int)(ushortValue << 0x1c) < 0) {\n    offset = binaryParams[4];\n    if (offset != 0) {\n      increment = ushortValue << 0x1e;\n      isZero = increment == 0;\n      totalSize = *binaryParams;\n      if (isZero) {\n        increment = binaryParams[5];\n      }\n      *binaryParams = offset;\n      if (!isZero) {\n        increment = 0;\n      }\n      binaryParams[2] = increment;\n      for (totalSize = totalSize - offset; 0 < totalSize; totalSize = totalSize - increment) {\n        increment = (*(code *)binaryParams[10])(binaryOutput,binaryParams[8],offset,totalSize);\n        if (increment < 1) {\n          bitmask = *(ushort *)(binaryParams + 3);\n          goto LAB_080052b2;\n        }\n        offset = offset + increment;\n      }\n    }\n  }\n  else if (((0 < binaryParams[1]) || (0 < binaryParams[0x10])) &&\n          (binaryFunction = (code *)binaryParams[0xb], binaryFunction != (code *)0x0)) {\n    tempValue = *binaryOutput;\n    *binaryOutput = 0;\n    if ((bitmask & 0x1000) == 0) {\n      offset = (*binaryFunction)(binaryOutput,binaryParams[8],ushortValue & 0x1000,1);\n      if ((offset == -1) && (ushortValue = *binaryOutput, ushortValue != 0)) {\n        if ((ushortValue != 0x1d) && (ushortValue != 0x16)) {\n          *(ushort *)(binaryParams + 3) = *(ushort *)(binaryParams + 3) | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x0800527c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          (*exitFunction)();\n          return;\n        }\n        *binaryOutput = tempValue;\n        goto LAB_080051d6;\n      }\n    }\n    else {\n      offset = binaryParams[0x15];\n    }\n    if (((int)((uint)*(ushort *)(binaryParams + 3) << 0x1d) < 0) &&\n       (offset = offset - binaryParams[1], binaryParams[0xd] != 0)) {\n      offset = offset - binaryParams[0x10];\n    }\n    offset = (*(code *)binaryParams[0xb])(binaryOutput,binaryParams[8],offset,0);\n    bitmask = *(ushort *)(binaryParams + 3);\n    if ((offset == -1) &&\n       ((0x1d < *binaryOutput || (-1 < (int)((0x20400001U >> (*binaryOutput & 0xff)) << 0x1f))))) {\nLAB_080052b2:\n      *(ushort *)(binaryParams + 3) = bitmask | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x080052bc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*exitFunction)(0xffffffff);\n      return;\n    }\n    binaryParams[1] = 0;\n    *binaryParams = binaryParams[4];\n    if (((int)((uint)bitmask << 0x13) < 0) && ((offset != -1 || (*binaryOutput == 0)))) {\n      binaryParams[0x15] = offset;\n    }\n    memoryBlock = (int *)binaryParams[0xd];\n    *binaryOutput = tempValue;\n    if (memoryBlock != (int *)0x0) {\n      if (memoryBlock != binaryParams + 0x11) {\n        _free_r(binaryOutput);\n      }\n      binaryParams[0xd] = 0;\n                    /* WARNING: Could not recover jumptable at 0x08005252. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*exitFunction)();\n      return;\n    }\n  }\nLAB_080051d6:\n                    /* WARNING: Could not recover jumptable at 0x080051d8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*exitFunction)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080051ac": "execute_binary_function_080051ac",
                "piVar3": "binaryParams",
                "puVar1": "binaryOutput",
                "iVar2": "offset",
                "piVar4": "memoryBlock",
                "uVar5": "ushortValue",
                "uVar6": "bitmask",
                "iVar7": "increment",
                "pcVar8": "binaryFunction",
                "iVar9": "totalSize",
                "uVar10": "tempValue",
                "UNRECOVERED_JUMPTABLE_00": "exitFunction",
                "bVar11": "isZero",
                "uVar12": "exitValue"
            },
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "called": [
                "_exit",
                "_free_r",
                "raise"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052cc": {
            "entrypoint": "0x080052cc",
            "current_name": "process_data_080052cc",
            "code": "\nundefined4 processData_080052cc(uint *dataPtr,int *configPtr)\n\n{\n  undefined4 returnValue;\n  int offset;\n  int *dynamicConfig;\n  uint configValue;\n  ushort configFlags;\n  int increment;\n  undefined4 arg4;\n  undefined4 arg5;\n  code *callback;\n  int size;\n  uint originalValue;\n  code *UNRECOVERED_JUMPTABLE_00;\n  bool bVar10;\n  \n  if (configPtr[4] != 0) {\n    if ((dataPtr != (uint *)0x0) && (dataPtr[6] == 0)) {\n      __sinit();\n    }\n    if (configPtr == &DAT_08005fc0) {\n      configPtr = (int *)dataPtr[1];\n    }\n    else if (configPtr == (int *)&DAT_08005fe0) {\n      configPtr = (int *)dataPtr[2];\n    }\n    else if (configPtr == (int *)&DAT_08005fa0) {\n      configPtr = (int *)dataPtr[3];\n    }\n    if (*(short *)(configPtr + 3) != 0) {\n      configFlags = *(ushort *)(configPtr + 3);\n      configValue = (uint)configFlags;\n      if ((int)(configValue << 0x1c) < 0) {\n        offset = configPtr[4];\n        if (offset != 0) {\n          increment = configValue << 0x1e;\n          bVar10 = increment == 0;\n          size = *configPtr;\n          if (bVar10) {\n            increment = configPtr[5];\n          }\n          *configPtr = offset;\n          if (!bVar10) {\n            increment = 0;\n          }\n          configPtr[2] = increment;\n          for (size = size - offset; 0 < size; size = size - increment) {\n            increment = (*(code *)configPtr[10])(dataPtr,configPtr[8],offset,size,arg4,arg5);\n            if (increment < 1) {\n              configFlags = *(ushort *)(configPtr + 3);\n              goto LAB_080052b2;\n            }\n            offset = offset + increment;\n          }\n        }\n      }\n      else if (((0 < configPtr[1]) || (0 < configPtr[0x10])) &&\n              (callback = (code *)configPtr[0xb], callback != (code *)0x0)) {\n        originalValue = *dataPtr;\n        *dataPtr = 0;\n        if ((configFlags & 0x1000) == 0) {\n          offset = (*callback)(dataPtr,configPtr[8],configValue & 0x1000,1);\n          if ((offset == -1) && (configValue = *dataPtr, configValue != 0)) {\n            if ((configValue != 0x1d) && (configValue != 0x16)) {\n              *(ushort *)(configPtr + 3) = *(ushort *)(configPtr + 3) | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x0800527c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n              returnValue = (*UNRECOVERED_JUMPTABLE_00)();\n              return returnValue;\n            }\n            *dataPtr = originalValue;\n            goto LAB_080051d6;\n          }\n        }\n        else {\n          offset = configPtr[0x15];\n        }\n        if (((int)((uint)*(ushort *)(configPtr + 3) << 0x1d) < 0) &&\n           (offset = offset - configPtr[1], configPtr[0xd] != 0)) {\n          offset = offset - configPtr[0x10];\n        }\n        offset = (*(code *)configPtr[0xb])(dataPtr,configPtr[8],offset,0);\n        configFlags = *(ushort *)(configPtr + 3);\n        if ((offset == -1) &&\n           ((0x1d < *dataPtr || (-1 < (int)((0x20400001U >> (*dataPtr & 0xff)) << 0x1f))))) {\nLAB_080052b2:\n          *(ushort *)(configPtr + 3) = configFlags | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x080052bc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          returnValue = (*UNRECOVERED_JUMPTABLE_00)(0xffffffff);\n          return returnValue;\n        }\n        configPtr[1] = 0;\n        *configPtr = configPtr[4];\n        if (((int)((uint)configFlags << 0x13) < 0) && ((offset != -1 || (*dataPtr == 0)))) {\n          configPtr[0x15] = offset;\n        }\n        dynamicConfig = (int *)configPtr[0xd];\n        *dataPtr = originalValue;\n        if (dynamicConfig != (int *)0x0) {\n          if (dynamicConfig != configPtr + 0x11) {\n            _free_r(dataPtr);\n          }\n          configPtr[0xd] = 0;\n                    /* WARNING: Could not recover jumptable at 0x08005252. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          returnValue = (*UNRECOVERED_JUMPTABLE_00)();\n          return returnValue;\n        }\n      }\nLAB_080051d6:\n                    /* WARNING: Could not recover jumptable at 0x080051d8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      returnValue = (*UNRECOVERED_JUMPTABLE_00)(0);\n      return returnValue;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080052cc": "process_data_080052cc",
                "param_1": "dataPtr",
                "param_2": "configPtr",
                "uVar1": "returnValue",
                "iVar2": "offset",
                "piVar3": "dynamicConfig",
                "uVar4": "configValue",
                "uVar5": "configFlags",
                "iVar6": "increment",
                "unaff_r4": "arg4",
                "unaff_r5": "arg5",
                "pcVar7": "callback",
                "iVar8": "size",
                "uVar9": "originalValue"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800532c": {
            "entrypoint": "0x0800532c",
            "current_name": "initialize_data_structures_0800532c",
            "code": "\nvoid initializeDataStructures_0800532c(undefined4 *data,undefined2 value1,undefined2 value2)\n\n{\n  *data = 0;\n  data[1] = 0;\n  data[2] = 0;\n  *(undefined2 *)(data + 3) = value1;\n  data[25] = 0;\n  *(undefined2 *)((int)data + 0xe) = value2;\n  data[4] = 0;\n  data[5] = 0;\n  data[6] = 0;\n  memset(data + 0x17,0,8);\n  data[9] = 0x8005609;\n  data[10] = 0x800562b;\n  data[11] = 0x8005663;\n  data[8] = data;\n  data[12] = &LABEL_08005686_1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800532c": "initialize_data_structures_0800532c",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[1]": "data[1]",
                "param_1[2]": "data[2]",
                "param_1[0x19]": "data[25]",
                "param_1[4]": "data[4]",
                "param_1[5]": "data[5]",
                "param_1[6]": "data[6]",
                "param_1[9]": "data[9]",
                "param_1[10]": "data[10]",
                "param_1[0xb]": "data[11]",
                "param_1[8]": "data[8]",
                "param_1[0xc]": "data[12]",
                "&LAB_08005686_1": "&LABEL_08005686_1"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005374": {
            "entrypoint": "0x08005374",
            "current_name": "initialize_memory_block_08005374",
            "code": "\nundefined4 * initializeMemoryBlock_08005374(undefined4 size,int numElements)\n\n{\n  undefined4 *memoryBlock;\n  int totalSize;\n  \n  totalSize = (numElements + -1) * 0x68;\n  memoryBlock = (undefined4 *)_malloc_r(size,totalSize + 0x74);\n  if (memoryBlock != (undefined4 *)0x0) {\n    *memoryBlock = 0;\n    memoryBlock[1] = numElements;\n    memoryBlock[2] = memoryBlock + 3;\n    memset(memoryBlock + 3,0,totalSize + 0x68);\n  }\n  return memoryBlock;\n}\n\n",
            "renaming": {
                "FUN_08005374": "initialize_memory_block_08005374",
                "param_1": "size",
                "param_2": "numElements",
                "puVar1": "memoryBlock",
                "iVar2": "totalSize"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "memset",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053a0": {
            "entrypoint": "0x080053a0",
            "current_name": "initialize_parameter_080053a0",
            "code": "\nvoid initializeParameter_080053a0(undefined4 *parameterList)\n\n{\n  undefined4 result;\n  undefined4 *pointer;\n  \n  if (parameterList[6] == 0) {\n    parameterList[0x12] = 0;\n    parameterList[0x13] = 0;\n    parameterList[0x14] = 0;\n    pointer = &DAT_200000a4;\n    parameterList[10] = &LAB_08005320_1;\n    if (parameterList == &DAT_200000a4) {\n      pointer = (undefined4 *)0x1;\n    }\n    if (parameterList == &DAT_200000a4) {\n      parameterList[6] = pointer;\n    }\n    result = __sfp();\n    parameterList[1] = result;\n    result = __sfp(parameterList);\n    parameterList[2] = result;\n    result = __sfp(parameterList);\n    parameterList[3] = result;\n    std_isra_0(parameterList[1],4,0);\n    std_isra_0(parameterList[2],9,1);\n    std_isra_0(parameterList[3],0x12,2);\n    parameterList[6] = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053a0": "initialize_parameter_080053a0",
                "param_1": "parameterList",
                "uVar1": "result",
                "puVar2": "pointer"
            },
            "calling": [
                "__swsetup_r",
                "__sfputc_r",
                "__sfp",
                "iprintf",
                "_fflush_r",
                "_vfiprintf_r"
            ],
            "called": [
                "__sfp",
                "std.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005400": {
            "entrypoint": "0x08005400",
            "current_name": "initialize_data_structure_08005400",
            "code": "\nint * initializeDataStructure_08005400(undefined4 *outputPointer,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  int *currentPointer;\n  int *innerPointer;\n  int **dataStructurePointer;\n  \n  if (DAT_200000bc == 0) {\n    initializeData(&DAT_200000a4);\n  }\n  dataStructurePointer = (int **)&DAT_200000ec;\n  do {\n    innerPointer = dataStructurePointer[2];\n    currentPointer = dataStructurePointer[1];\n    while (currentPointer = (int *)((int)currentPointer + -1), -1 < (int)currentPointer) {\n      if (*(short *)(innerPointer + 3) == 0) {\n        *(undefined2 *)((int)innerPointer + 0xe) = 0xffff;\n        *(undefined2 *)(innerPointer + 3) = 1;\n        innerPointer[0x19] = 0;\n        *innerPointer = 0;\n        innerPointer[2] = 0;\n        innerPointer[1] = 0;\n        innerPointer[4] = 0;\n        innerPointer[5] = 0;\n        innerPointer[6] = 0;\n        fillMemory(innerPointer + 0x17,0,8,1,param4);\n        innerPointer[0xd] = 0;\n        innerPointer[0xe] = 0;\n        innerPointer[0x12] = 0;\n        innerPointer[0x13] = 0;\n        return innerPointer;\n      }\n      innerPointer = innerPointer + 0x1a;\n    }\n    if (*dataStructurePointer == (int *)0x0) {\n      currentPointer = (int *)__sfmoreglue(outputPointer,4);\n      *dataStructurePointer = currentPointer;\n      if (currentPointer == (int *)0x0) {\n        *outputPointer = 0xc;\n        return (int *)0x0;\n      }\n    }\n    dataStructurePointer = (int **)*dataStructurePointer;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005400": "initialize_data_structure_08005400",
                "param_1": "outputPointer",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "piVar1": "currentPointer",
                "piVar2": "innerPointer",
                "ppiVar3": "dataStructurePointer",
                "__sinit": "initializeData",
                "memset": "fillMemory"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset",
                "__sfmoreglue",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054b4": {
            "entrypoint": "0x080054b4",
            "current_name": "check_and_set_permissions_080054b4",
            "code": "\nundefined4 checkAndSetPermissions_080054b4(undefined4 fileDescriptor,int fileInfo,undefined4 *permissionInfo,uint *isExecutable)\n\n{\n  int fileStatResult;\n  undefined4 permission;\n  undefined auxiliaryStack [4];\n  uint fileType;\n  \n  if ((*(short *)(fileInfo + 0xe) < 0) ||\n     (fileStatResult = _fstat_r(fileDescriptor,(int)*(short *)(fileInfo + 0xe),auxiliaryStack), fileStatResult < 0)) {\n    *isExecutable = 0;\n    if ((int)((uint)*(ushort *)(fileInfo + 0xc) << 0x18) < 0) {\n      permission = 0x40;\n      goto LAB_080054f4;\n    }\n  }\n  else {\n    *isExecutable = (uint)((fileType & 0xf000) == 0x2000);\n  }\n  permission = 0x400;\nLAB_080054f4:\n  *permissionInfo = permission;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080054b4": "check_and_set_permissions_080054b4",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "param_3": "permissionInfo",
                "param_4": "isExecutable",
                "iVar1": "fileStatResult",
                "uVar2": "permission",
                "auStack_4c": "auxiliaryStack",
                "local_48": "fileType"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054fc": {
            "entrypoint": "0x080054fc",
            "current_name": "process_data_080054fc",
            "code": "\nvoid processData_080054fc(int dataSize,int *data)\n\n{\n  ushort result;\n  int allocatedMemory;\n  int dataSizeCopy;\n  int *dataCopy;\n  \n  if (-1 < (int)((uint)*(ushort *)(data + 3) << 0x1e)) {\n    dataSizeCopy = dataSize;\n    dataCopy = data;\n    result = __swhatbuf_r(dataSize,data,&dataSizeCopy,&dataCopy);\n    allocatedMemory = _malloc_r(dataSize,dataSizeCopy);\n    if (allocatedMemory != 0) {\n      *(undefined **)(dataSize + 0x28) = &LAB_08005320_1;\n      *data = allocatedMemory;\n      *(ushort *)(data + 3) = *(ushort *)(data + 3) | 0x80;\n      data[5] = dataSizeCopy;\n      data[4] = allocatedMemory;\n      if ((dataCopy != (int *)0x0) &&\n         (allocatedMemory = _isatty_r(dataSize,(int)*(short *)((int)data + 0xe)), allocatedMemory != 0)) {\n        *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(data + 3) = result | *(ushort *)(data + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(data + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xfffc | 2;\n  }\n  *data = (int)data + 0x47;\n  data[4] = (int)data + 0x47;\n  data[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080054fc": "process_data_080054fc",
                "param_1": "dataSize",
                "param_2": "data",
                "uVar1": "result",
                "iVar2": "allocatedMemory",
                "local_18": "dataSizeCopy",
                "local_14": "dataCopy"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_isatty_r",
                "__swhatbuf_r",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800557c": {
            "entrypoint": "0x0800557c",
            "current_name": "FUNC_0800557c",
            "code": "\nvoid FUNC_0800557c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557c": "FUNC_0800557c"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800557e": {
            "entrypoint": "0x0800557e",
            "current_name": "FUNC_0800557e",
            "code": "\nvoid FUNC_0800557e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557e": "FUNC_0800557e"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080055d0": {
            "entrypoint": "0x080055d0",
            "current_name": "reverse_kill_process_080055d0",
            "code": "\nint reverseKillProcess_080055d0(uint processID)\n\n{\n  int *pProcessID;\n  undefined4 pid;\n  int result;\n  code *functionPtr;\n  undefined4 unusedVar1;\n  undefined4 unusedVar2;\n  undefined4 unusedVar3;\n  undefined4 *pProcessVar;\n  \n  pProcessID = DAT_200000a0;\n  pProcessVar = &DAT_200000a0;\n  if (0x1f < processID) {\n    *DAT_200000a0 = 0x16;\n    return -1;\n  }\n  result = DAT_200000a0[0x11];\n  if ((result != 0) && (functionPtr = *(code **)(result + processID * 4), functionPtr != (code *)0x0)) {\n    if (functionPtr != (code *)0x1) {\n      if (functionPtr == (code *)0xffffffff) {\n        *DAT_200000a0 = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(result + processID * 4) = 0;\n      (*functionPtr)(processID);\n    }\n    return 0;\n  }\n  pid = _getpid_r(DAT_200000a0);\n  DAT_20000674 = 0;\n  result = _kill(pid,processID,processID,0,pProcessVar,unusedVar1,unusedVar2,unusedVar3);\n  if ((result == -1) && (DAT_20000674 != 0)) {\n    *pProcessID = DAT_20000674;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080055d0": "reverse_kill_process_080055d0",
                "param_1": "processID",
                "piVar1": "pProcessID",
                "uVar2": "pid",
                "iVar3": "result",
                "pcVar4": "functionPtr",
                "unaff_r4": "unusedVar1",
                "unaff_r5": "unusedVar2",
                "in_lr": "unusedVar3",
                "puVar5": "pProcessVar"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_kill",
                "_getpid_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005604": {
            "entrypoint": "0x08005604",
            "current_name": "FUN_08005604",
            "code": "\nundefined4 _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "raise"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005608": {
            "entrypoint": "0x08005608",
            "current_name": "calculate_new_value_08005608",
            "code": "\nvoid calculate_new_value_08005608(undefined4 buffer,int data)\n\n{\n  int read_result;\n  uint new_value;\n  bool read_success;\n  \n  read_result = _read_r(buffer,(int)*(short *)(data + 0xe));\n  read_success = -1 < read_result;\n  if (read_success) {\n    new_value = *(int *)(data + 0x54) + read_result;\n  }\n  else {\n    new_value = *(ushort *)(data + 0xc) & 0xffffefff;\n  }\n  if (read_success) {\n    *(uint *)(data + 0x54) = new_value;\n  }\n  if (!read_success) {\n    *(short *)(data + 0xc) = (short)new_value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005608": "calculate_new_value_08005608",
                "param_1": "buffer",
                "param_2": "data",
                "iVar1": "read_result",
                "uVar2": "new_value",
                "bVar3": "read_success"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800562a": {
            "entrypoint": "0x0800562a",
            "current_name": "write_to_file_0800562a",
            "code": "\nvoid writeToFile_0800562a(int *fileDescriptor,int metadataAddress,undefined4 data,undefined4 size)\n\n{\n  int writeResult;\n  undefined4 unusedVar1;\n  undefined4 unusedVar2;\n  undefined4 unusedVar3;\n  \n  if ((int)((uint)*(ushort *)(metadataAddress + 0xc) << 0x17) < 0) {\n    _lseek_r(fileDescriptor,(int)*(short *)(metadataAddress + 0xe),0,2);\n  }\n  *(ushort *)(metadataAddress + 0xc) = *(ushort *)(metadataAddress + 0xc) & 0xefff;\n  DAT_20000674 = 0;\n  writeResult = _write((int)*(short *)(metadataAddress + 0xe),data,size,size,size,unusedVar1,unusedVar2,\n                 unusedVar3);\n  if ((writeResult == -1) && (DAT_20000674 != 0)) {\n    *fileDescriptor = DAT_20000674;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800562a": "write_to_file_0800562a",
                "param_1": "fileDescriptor",
                "param_2": "metadataAddress",
                "param_3": "data",
                "param_4": "size",
                "iVar1": "writeResult",
                "unaff_r4": "unusedVar1",
                "unaff_r5": "unusedVar2",
                "in_lr": "unusedVar3"
            },
            "calling": [],
            "called": [
                "_lseek_r",
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005662": {
            "entrypoint": "0x08005662",
            "current_name": "seek_and_set_flag_08005662",
            "code": "\nvoid seekAndSetFlag_08005662(undefined4 fileDescriptor,int structPtr)\n\n{\n  int seekResult;\n  ushort flag;\n  bool seekFailed;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(structPtr + 0xe));\n  seekFailed = seekResult == -1;\n  if (seekFailed) {\n    flag = *(ushort *)(structPtr + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(structPtr + 0x54) = seekResult;\n    flag = *(ushort *)(structPtr + 0xc) | 0x1000;\n  }\n  if (seekFailed) {\n    *(ushort *)(structPtr + 0xc) = flag;\n  }\n  if (!seekFailed) {\n    *(ushort *)(structPtr + 0xc) = flag;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005662": "seek_and_set_flag_08005662",
                "param_1": "fileDescriptor",
                "param_2": "structPtr",
                "iVar1": "seekResult",
                "uVar2": "flag",
                "bVar3": "seekFailed"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d4": {
            "entrypoint": "0x080056d4",
            "current_name": "check_and_assign_file_size_080056d4",
            "code": "\nvoid checkAndAssignFileSize_080056d4(int *result,undefined4 fileDescriptor,undefined4 statStructBuffer,undefined4 bufferSize)\n\n{\n  int result;\n  \n  DAT_20000674 = 0;\n  result = _fstat(fileDescriptor,statStructBuffer,statStructBuffer,0,bufferSize);\n  if ((result == -1) && (DAT_20000674 != 0)) {\n    *result = DAT_20000674;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056d4": "check_and_assign_file_size_080056d4",
                "param_1": "result",
                "param_2": "fileDescriptor",
                "param_3": "statStructBuffer",
                "param_4": "bufferSize",
                "iVar1": "result"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056f8": {
            "entrypoint": "0x080056f8",
            "current_name": "check_terminal_is_interactive_080056f8",
            "code": "\nvoid checkTerminalIsInteractive_080056f8(int *outputValue,undefined4 fileDescriptor)\n\n{\n  int isTTY;\n  \n  DAT_20000674 = 0;\n  isTTY = _isatty(fileDescriptor);\n  if ((isTTY == -1) && (DAT_20000674 != 0)) {\n    *outputValue = DAT_20000674;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056f8": "check_terminal_is_interactive_080056f8",
                "param_1": "outputValue",
                "param_2": "fileDescriptor",
                "iVar1": "isTTY"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005718": {
            "entrypoint": "0x08005718",
            "current_name": "seek_and_assign_value_08005718",
            "code": "\nvoid seekAndAssignValue_08005718(int *result,undefined4 fileDescriptor,undefined4 offset,undefined4 whence)\n\n{\n  int seekResult;\n  \n  DAT_20000674 = 0;\n  seekResult = _lseek(fileDescriptor,offset,whence,whence,whence);\n  if ((seekResult == -1) && (DAT_20000674 != 0)) {\n    *result = DAT_20000674;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005718": "seek_and_assign_value_08005718",
                "param_1": "result",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "whence",
                "iVar1": "seekResult"
            },
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800573c": {
            "entrypoint": "0x0800573c",
            "current_name": "read_and_store_value_0800573c",
            "code": "\nvoid readAndStoreValue_0800573c(int *outputValue,undefined4 fileDescriptor,undefined4 buffer,undefined4 count)\n\n{\n  int returnValue;\n  \n  DAT_20000674 = 0;\n  returnValue = _read(fileDescriptor,buffer,count,count,count);\n  if ((returnValue == -1) && (DAT_20000674 != 0)) {\n    *outputValue = DAT_20000674;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800573c": "read_and_store_value_0800573c",
                "param_1": "outputValue",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "returnValue"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005760": {
            "entrypoint": "0x08005760",
            "current_name": "initialize_flags_08005760",
            "code": "\nvoid initializeFlags_08005760(void)\n\n{\n  code *jumpTable;\n  \n  jumpTable = initializeFlags_08005760;\n  abort();\n  if (-1 < DAT_200005fc << 0x1f) {\n    DAT_200005fc = 1;\n  }\n  if (-1 < DAT_200005f8 << 0x1f) {\n    DAT_200005f8 = 1;\n  }\n  if (-1 < DAT_200005f4 << 0x1f) {\n    DAT_200005f4 = 1;\n  }\n  if (-1 < DAT_200005f0 << 0x1f) {\n    DAT_200005f0 = 1;\n  }\n  if (-1 < DAT_200005ec << 0x1f) {\n    DAT_200005ec = 1;\n  }\n  if (-1 < DAT_200005e8 << 0x1f) {\n    DAT_200005e8 = 1;\n  }\n  if (-1 < DAT_200005e4 << 0x1f) {\n    DAT_200005e4 = 1;\n  }\n  if (-1 < DAT_200005e0 << 0x1f) {\n    DAT_200005e0 = 1;\n  }\n  if (-1 < DAT_200005dc << 0x1f) {\n    DAT_200005dc = 1;\n  }\n  if (-1 < DAT_200005d8 << 0x1f) {\n    DAT_200005d8 = 1;\n  }\n  if (-1 < DAT_200005d4 << 0x1f) {\n    DAT_200005d4 = 1;\n  }\n  if (-1 < DAT_200005d0 << 0x1f) {\n    DAT_200005d0 = 1;\n  }\n                    /* WARNING: Could not recover jumptable at 0x080057f8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005760": "initialize_flags_08005760",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f8": {
            "entrypoint": "0x080059f8",
            "current_name": "FUNC_080059f8",
            "code": "\nvoid FUNC_080059f8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080059f8": "FUNC_080059f8"
            },
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a04": {
            "entrypoint": "0x08005a04",
            "current_name": "FUNC_08005a04",
            "code": "\nvoid FUNC_08005a04(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a04": "FUNC_08005a04"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 118894,
    "layers": [
        [
            "FUN_080001ac",
            "FUN_08000230",
            "FUN_080002d0",
            "FUN_08000300",
            "FUN_080005e0",
            "FUN_080005e4",
            "FUN_08000600",
            "FUN_0800066c",
            "FUN_08000690",
            "FUN_080006b4",
            "FUN_08000728",
            "FUN_0800076c",
            "FUN_080007f0",
            "FUN_080008cc",
            "FUN_080008e2",
            "FUN_08000998",
            "FUN_08000a00",
            "FUN_08000a4e",
            "FUN_08000a7a",
            "FUN_08000b04",
            "FUN_08000b54",
            "FUN_08000c64",
            "FUN_08000c8c",
            "FUN_08000d3c",
            "FUN_08000d8e",
            "FUN_08000d98",
            "FUN_08000de4",
            "FUN_08000e18",
            "FUN_08000e30",
            "FUN_08000e3c",
            "FUN_08000e60",
            "FUN_08000ec4",
            "FUN_08000ee0",
            "FUN_08000f0c",
            "FUN_08000f2c",
            "FUN_08000f4e",
            "FUN_08000f56",
            "FUN_08000f72",
            "FUN_08000f8c",
            "FUN_08000fb4",
            "FUN_08001198",
            "FUN_080011a4",
            "FUN_080011c0",
            "FUN_0800124a",
            "FUN_08001256",
            "FUN_08001420",
            "FUN_08001440",
            "FUN_08001460",
            "FUN_080014ec",
            "FUN_08001578",
            "FUN_080015bc",
            "FUN_0800160e",
            "FUN_0800165a",
            "FUN_08001684",
            "FUN_0800171a",
            "FUN_08001864",
            "FUN_08001904",
            "FUN_080019a0",
            "FUN_08001ab0",
            "FUN_08001bfc",
            "FUN_08001d00",
            "FUN_08001e68",
            "FUN_08001f9c",
            "FUN_0800201c",
            "FUN_080023b4",
            "FUN_08002488",
            "FUN_080025e0",
            "FUN_080025ec",
            "FUN_0800260c",
            "FUN_0800262c",
            "FUN_0800268e",
            "FUN_080026ce",
            "FUN_08002848",
            "FUN_08002864",
            "FUN_080028d4",
            "FUN_080028f0",
            "FUN_08002940",
            "FUN_0800295c",
            "FUN_080029c8",
            "FUN_08002d0c",
            "FUN_08002d72",
            "FUN_08002dd0",
            "FUN_08002eb2",
            "FUN_08002efa",
            "FUN_08002f4c",
            "FUN_08002f66",
            "FUN_08002ffc",
            "FUN_0800312c",
            "FUN_08003138",
            "FUN_0800314e",
            "FUN_0800316c",
            "FUN_0800318c",
            "FUN_080031fc",
            "FUN_08003380",
            "FUN_0800339c",
            "FUN_080033c8",
            "FUN_080033d8",
            "FUN_0800340c",
            "FUN_08003414",
            "FUN_0800346c",
            "FUN_08003476",
            "FUN_08003486",
            "FUN_080034b6",
            "FUN_080034ce",
            "FUN_080034da",
            "FUN_080034f4",
            "FUN_08003506",
            "FUN_0800351e",
            "FUN_0800352e",
            "FUN_0800354a",
            "FUN_0800355e",
            "FUN_08003582",
            "FUN_08003594",
            "FUN_080035bc",
            "FUN_080035fc",
            "FUN_08003750",
            "FUN_08003754",
            "FUN_0800376e",
            "FUN_0800377c",
            "FUN_0800387c",
            "FUN_08003880",
            "FUN_080038d0",
            "FUN_08003900",
            "FUN_08003978",
            "FUN_08003cc8",
            "FUN_08003d18",
            "FUN_08003dd0",
            "FUN_08003df4",
            "FUN_08003e18",
            "FUN_08003e54",
            "FUN_08003eac",
            "FUN_08003f00",
            "FUN_08003f24",
            "FUN_08003f48",
            "FUN_08004094",
            "FUN_080040d0",
            "FUN_080040d6",
            "FUN_080040e0",
            "FUN_080040e4",
            "FUN_080040e8",
            "FUN_080040ec",
            "FUN_080040f8",
            "FUN_080040fc",
            "FUN_0800410c",
            "FUN_08004110",
            "FUN_080041bc",
            "FUN_08004204",
            "FUN_08004240",
            "FUN_080042ac",
            "FUN_080042e8",
            "FUN_08004364",
            "FUN_08004388",
            "FUN_08004444",
            "FUN_08004460",
            "FUN_0800447c",
            "FUN_080044d8",
            "FUN_08004544",
            "FUN_08004560",
            "FUN_08004640",
            "FUN_08004658",
            "FUN_08004678",
            "FUN_080046b4",
            "FUN_080047d0",
            "FUN_080047fe",
            "FUN_08004808",
            "FUN_08004844",
            "FUN_08004860",
            "FUN_08004884",
            "FUN_080048cc",
            "FUN_080048dc",
            "FUN_08004978",
            "FUN_08004a34",
            "FUN_08004a60",
            "FUN_08004a84",
            "FUN_08004cb0",
            "FUN_08004d9c",
            "FUN_08004fdc",
            "FUN_0800500c",
            "FUN_080050d0",
            "FUN_080051ac",
            "FUN_080052cc",
            "FUN_0800532c",
            "FUN_08005374",
            "FUN_080053a0",
            "FUN_08005400",
            "FUN_080054b4",
            "FUN_080054fc",
            "FUN_080055d0",
            "FUN_08005608",
            "FUN_0800562a",
            "FUN_08005662",
            "FUN_080056d4",
            "FUN_080056f8",
            "FUN_08005718",
            "FUN_0800573c"
        ],
        [
            "FUN_08000682",
            "FUN_08000c4c",
            "FUN_08004648"
        ],
        [
            "FUN_080047c0",
            "FUN_08005760"
        ]
    ],
    "locked_functions": []
}