{
    "functions": {
        "FUN_000800f4": {
            "entrypoint": "0x000800f4",
            "current_name": "initialize_data_if_needed_000800f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080100) */\n\nundefined4 initializeDataIfNeeded_000800f4(undefined4 inputValue)\n\n{\n  if ((char)DAT_200708a0 == '\\0') {\n    DAT_200708a0._0_1_ = '\\x01';\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_000800f4": "initialize_data_if_needed_000800f4",
                "param_1": "inputValue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080118": {
            "entrypoint": "0x00080118",
            "current_name": "FUNC_00080118",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0008011e) */\n/* WARNING: Removing unreachable block (ram,0x00080130) */\n\n\nvoid FUNC_00080118(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080118": "FUNC_00080118"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080164": {
            "entrypoint": "0x00080164",
            "current_name": "calculate_interpolation_00080164",
            "code": "\nvoid calculate_interpolation_00080164(undefined4 input_parameter_1,undefined4 input_parameter_2,undefined4 input_parameter_3,undefined4 input_parameter_4)\n\n{\n  calculate_interpolation_00080164_000806f8(&DAT_200708e8,0x5a);\n  calculate_interpolation_00080164_000806f8(&DAT_200708d4,0x5a,input_parameter_3,input_parameter_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080164": "calculate_interpolation_00080164",
                "param_1": "input_parameter_1",
                "param_2": "input_parameter_2",
                "param_3": "input_parameter_3",
                "param_4": "input_parameter_4"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000801e0"
            ],
            "called": [
                "FUN_000806f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000801e0": {
            "entrypoint": "0x000801e0",
            "current_name": "initialize_and_calculate_000801e0",
            "code": "\nundefined8 initialize_and_calculate_000801e0(undefined4 input_1,undefined4 input_2,undefined4 param_3,undefined4 param_4)\n\n{\n  initialize_data(&DAT_20070be8,0xe100,param_3,param_4,param_4);\n  update_parameter_and_set_bit(0xd,1);\n  update_parameter_and_set_bit(6,1);\n  update_parameter_and_set_bit(0x39,0);\n  update_parameter_and_set_bit(4,0);\n  update_parameter_and_set_bit(3,0);\n  update_parameter_and_set_bit(2,0);\n  update_parameter(&DAT_200708d4,5);\n  update_parameter(&DAT_200708e8,6);\n  calculate_interpolation();\n  FUNC_00080f08(1000);\n  if (DAT_200708bc == 0) {\n    software_interrupt(0x3f);\n    return 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000801e0": "initialize_and_calculate_000801e0",
                "param_1": "input_1",
                "param_2": "input_2",
                "initialize_data_000813dc": "initialize_data",
                "update_parameter_and_set_bit_00080f0c": "update_parameter_and_set_bit",
                "update_parameter_000806a0": "update_parameter",
                "calculate_interpolation_00080164": "calculate_interpolation"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_00080f0c",
                "FUN_000813dc",
                "FUN_000806a0",
                "FUN_00080164",
                "FUN_00080f08"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080250": {
            "entrypoint": "0x00080250",
            "current_name": "control_function_00080250",
            "code": "\nvoid controlFunction_00080250(void)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined *puVar3;\n  undefined auStack_1c [12];\n  \n  DAT_200708c0 = calculateResult(4,1,20000);\n  FUNC_00080f08(10);\n  DAT_200708c4 = DAT_200708c4 ^ 1;\n  updateAndSetBit(0xd);\n  if (DAT_200708c0 < 0x641) {\n    if (DAT_200708c0 - 0x385U < 299) {\n      if (DAT_200708eb != '\\0') {\n        calculateInterpolation();\n        calculateSum(&DAT_20070be8,\"Entered manual control mode.\");\n        DAT_200708eb = '\\0';\n      }\n      FUNC_00080f08(10);\n      uVar1 = calculateResult(3,1,20000);\n      DAT_200708d8 = calculate_interpolation_0008145c(0,1000,2000,0x28,0x96);\n      DAT_200708ec = calculate_interpolation_0008145c(uVar1,1000,2000,0x28,0x96);\n      while (iVar2 = calculateDifference(&DAT_20070be8), 0 < iVar2) {\n        extractByteFromBuffer(&DAT_20070be8);\n        convertNumberToBase(&DAT_20070be8,DAT_200708d8,10);\n        initializeProcess(&DAT_20070be8,&DAT_00084b13);\n        addConvertedNumberAndParam(&DAT_20070be8,DAT_200708ec,10);\n      }\n      calculateInterpolation(&DAT_200708e8,DAT_200708ec);\n      calculateInterpolation(&DAT_200708d4,DAT_200708d8);\n    }\n    else {\n      if (DAT_200708eb == '\\0') {\n        calculateInterpolation();\n        calculateSum(&DAT_20070be8,\"Entered autonomous control mode.\");\n      }\n      DAT_200708eb = '\\x01';\nLAB_00080346:\n      iVar2 = calculateDifference(&DAT_20070be8);\n      if (0 < iVar2) {\n        processAndUpdateArray(auStack_1c,&DAT_20070be8,0x2c);\n        clearParametersIfDifferent(&DAT_200708dc,auStack_1c);\n        processRelocation(auStack_1c);\n        processAndUpdateArray(auStack_1c,&DAT_20070be8,10);\n        clearParametersIfDifferent(&DAT_200708c8,auStack_1c);\n        processRelocation(auStack_1c);\n        extractByteFromBuffer(&DAT_20070be8);\n        iVar2 = checkArrayValues(&DAT_200708dc,\"steer\");\n        if (iVar2 == 0) goto LAB_0008039c;\n        uVar1 = parseInteger(&DAT_200708c8);\n        puVar3 = &DAT_200708d4;\n        goto LAB_000803b2;\n      }\n    }\n  }\n  else {\n    calculateInterpolation();\n    calculateSum(&DAT_20070be8,\"error\");\n  }\n  return;\nLAB_0008039c:\n  iVar2 = checkArrayValues(&DAT_200708dc,\"motor\");\n  if (iVar2 != 0) {\n    uVar1 = parseInteger(&DAT_200708c8);\n    puVar3 = &DAT_200708e8;\nLAB_000803b2:\n    calculateInterpolation(puVar3,uVar1);\n  }\n  goto LAB_00080346;\n}\n\n",
            "renaming": {
                "FUN_00080250": "control_function_00080250",
                "calculate_result_00081624": "calculateResult",
                "update_and_set_bit_00081014": "updateAndSetBit",
                "calculate_interpolation_00080164": "calculateInterpolation",
                "calculate_sum_000810e8": "calculateSum",
                "calculate_difference_00081248": "calculateDifference",
                "extract_byte_from_buffer_00081276": "extractByteFromBuffer",
                "thunk_convert_number_to_base_0008113a": "convertNumberToBase",
                "initialize_process_000810c4": "initializeProcess",
                "add_converted_number_and_param_0008117a": "addConvertedNumberAndParam",
                "calculate_interpolation_000806f8": "calculateInterpolation",
                "process_and_update_array_00081214": "processAndUpdateArray",
                "clear_parameters_if_different_00081560": "clearParametersIfDifferent",
                "process_relocation_00081472": "processRelocation",
                "check_array_values_000815b8": "checkArrayValues",
                "parse_integer_000815de": "parseInteger"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_00081560",
                "FUN_000815b8",
                "FUN_000815de",
                "FUN_00080164",
                "FUN_000806f8",
                "FUN_00081624",
                "FUN_00080f08",
                "FUN_00081248",
                "thunk_FUN_0008113a",
                "FUN_000810e8",
                "FUN_000810c4",
                "FUN_00081214",
                "FUN_00081276",
                "FUN_0008145c",
                "FUN_00081014",
                "FUN_0008117a",
                "FUN_00081472"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000803fc": {
            "entrypoint": "0x000803fc",
            "current_name": "initialize_tc_000803fc",
            "code": "\nvoid initializeTC_000803fc(int channelIndex,uint param2,undefined4 param3,uint bitIndex)\n\n{\n  undefined4 variable1;\n  undefined4 variable2;\n  undefined8 combinedParams;\n  \n  combinedParams = CONCAT44(param2,channelIndex);\n  set_bit_in_data_00080aa8(param3);\n  configure_tc_channel_00080b2c(channelIndex,param2,0xc002);\n  store_value_at_index_00080b90(channelIndex,param2,0xa41);\n  *(int *)((bitIndex >> 5) * 4 + -0x1fff1f00) = 1 << (bitIndex & 0x1f);\n  *(undefined4 *)(channelIndex + param2 * 0x40 + 0x24) = 4;\n  if (2 < param2) {\n    combinedParams = print_assertion_failed_message_000816f8(\"../source/tc.c\",0x5c,\"TC_Start\",\n                         \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\",\n                         variable1,variable2);\n  }\n  *(undefined4 *)((int)combinedParams + (int)((ulonglong)combinedParams >> 0x20) * 0x40) = 5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000803fc": "initialize_tc_000803fc",
                "param_1": "channelIndex",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "bitIndex",
                "unaff_r4": "variable1",
                "in_lr": "variable2",
                "uVar1": "combinedParams"
            },
            "calling": [
                "FUN_000806a0"
            ],
            "called": [
                "FUN_00080aa8",
                "FUN_00080b90",
                "FUN_00080b2c",
                "FUN_000816f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008044c": {
            "entrypoint": "0x0008044c",
            "current_name": "update_data_0008044c",
            "code": "\nvoid updateData_0008044c(int index,int base,int offset)\n\n{\n  uint limit;\n  int count;\n  \n  offset = offset * 0x40;\n  if (((&DAT_200708f1)[index] & 0x80) == 0) {\n    count = index * 0xc;\n    if (((char)(&DAT_200708f1)[index] + count < (int)(uint)DAT_200708f0) &&\n       ((int)((uint)(byte)(&DAT_200708f8)[((char)(&DAT_200708f1)[index] + count) * 8] << 0x19) < 0\n       )) {\n      update_and_set_bit_00081014((&DAT_200708f8)[(count + (char)(&DAT_200708f1)[index]) * 8] & 0x3f,0);\n    }\n  }\n  else {\n    *(uint *)(base + offset) = *(uint *)(base + offset) | 4;\n  }\n  limit = (uint)DAT_200708f0;\n  (&DAT_200708f1)[index] = (&DAT_200708f1)[index] + '\\x01';\n  count = index * 0xc;\n  if (((char)(&DAT_200708f1)[index] + count < (int)limit) &&\n     ((char)(&DAT_200708f1)[index] < '\\f')) {\n    *(int *)(base + offset + 0x14) =\n         *(int *)(base + offset + 0x10) +\n         *(int *)(&DAT_200708fc + ((char)(&DAT_200708f1)[index] + count) * 8);\n    if (-1 < (int)((uint)(byte)(&DAT_200708f8)[((char)(&DAT_200708f1)[index] + count) * 8] << 0x19\n                  )) {\n      return;\n    }\n    update_and_set_bit_00081014((&DAT_200708f8)[(count + (char)(&DAT_200708f1)[index]) * 8] & 0x3f,1);\n    return;\n  }\n  base = base + offset;\n  limit = (Elf32_Rel_ARRAY_20070000[6].r_offset / 1000000) * 20000 >> 5;\n  if (limit <= *(int *)(base + 0x10) + 4U) {\n    limit = *(int *)(base + 0x10) + 4;\n  }\n  *(uint *)(base + 0x14) = limit;\n  (&DAT_200708f1)[index] = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008044c": "update_data_0008044c",
                "param_1": "index",
                "param_2": "base",
                "param_3": "offset",
                "uVar1": "limit",
                "iVar2": "count"
            },
            "calling": [],
            "called": [
                "FUN_00081014"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000805a8": {
            "entrypoint": "0x000805a8",
            "current_name": "process_data_000805a8",
            "code": "\nvoid processData_000805a8(byte *outputBuffer)\n\n{\n  char nextValue;\n  uint currentValue;\n  \n  currentValue = (uint)DAT_200708f0;\n  if (currentValue < 0x3c) {\n    nextValue = DAT_200708f0 + 1;\n    *outputBuffer = DAT_200708f0;\n    DAT_200708f0 = nextValue;\n    *(uint *)(&DAT_200708fc + currentValue * 8) =\n         (dataArray[6].r_offset / 1000000) * 0x5dc >> 5;\n    return;\n  }\n  *outputBuffer = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000805a8": "process_data_000805a8",
                "param_1": "outputBuffer",
                "cVar1": "nextValue",
                "uVar2": "currentValue",
                "Elf32_Rel_ARRAY_20070000": "dataArray"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806a0": {
            "entrypoint": "0x000806a0",
            "current_name": "update_parameter_000806a0",
            "code": "\nbyte updateParameter_000806a0(byte *input,undefined4 value)\n\n{\n  byte tempByte;\n  undefined4 baseAddress;\n  uint index;\n  undefined4 start;\n  int counter;\n  uint byteValue;\n  \n  if (0x3b < *input) goto LAB_00080660;\n  update_parameter_and_set_bit_00080f0c(value,1,0x220,*input,0x960);\n  byteValue = (uint)*input;\n  tempByte = (&DAT_200708f8)[byteValue * 8];\n  input[2] = 0;\n  index = byteValue / 0xc;\n  (&DAT_200708f8)[byteValue * 8] = tempByte & 0xc0 | (byte)value & 0x3f;\n  input[1] = 0;\n  counter = 0;\n  do {\n    if ((int)((uint)(byte)(&DAT_200708f8)[(counter + index * 0xc) * 8] << 0x19) < 0)\n    goto LAB_00080652;\n    counter = counter + 1;\n  } while (counter != 0xc);\n  if (index == 0) {\n    baseAddress = 0x40084000;\n    start = 0x1e;\nLAB_0008064c:\n    initialize_tc_000803fc(baseAddress,index,start,start);\n  }\n  else {\n    if (index == 1) {\n      baseAddress = 0x40084000;\n      start = 0x1f;\n      goto LAB_0008064c;\n    }\n    if (index == 2) {\n      baseAddress = 0x40084000;\n      start = 0x20;\n      goto LAB_0008064c;\n    }\n    if (index == 3) {\n      baseAddress = 0x40080000;\n      index = 2;\n      start = 0x1d;\n      goto LAB_0008064c;\n    }\n    if (index == 4) {\n      baseAddress = 0x40080000;\n      index = 0;\n      start = 0x1b;\n      goto LAB_0008064c;\n    }\n  }\nLAB_00080652:\n  (&DAT_200708f8)[(uint)*input * 8] = (&DAT_200708f8)[(uint)*input * 8] | 0x40;\nLAB_00080660:\n  return *input;\n}\n\n",
            "renaming": {
                "FUN_000806a0": "update_parameter_000806a0",
                "param_1": "input",
                "param_2": "value",
                "bVar1": "tempByte",
                "uVar2": "baseAddress",
                "uVar3": "index",
                "uVar4": "start",
                "iVar5": "counter",
                "uVar6": "byteValue"
            },
            "calling": [
                "FUN_000801e0"
            ],
            "called": [
                "FUN_000803fc",
                "FUN_00080f0c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806f8": {
            "entrypoint": "0x000806f8",
            "current_name": "calculate_interpolation_000806f8",
            "code": "\nvoid calculate_interpolation_000806f8(byte *byte_array,uint array_length)\n\n{\n  uint tempVariable1;\n  \n  if ((int)array_length < 0x220) {\n    tempVariable1 = array_length;\n    if (0xb3 < (int)array_length) {\n      tempVariable1 = 0xb4;\n    }\n    array_length = calculate_interpolation_000806f8_0008145c(tempVariable1 & ~((int)tempVariable1 >> 0x1f),0,0xb4,(0x88 - (char)byte_array[1]) * 4,\n                           (600 - (char)byte_array[2]) * 4,array_length);\n  }\n  if (*byte_array < 0x3c) {\n    tempVariable1 = (0x88 - (char)byte_array[1]) * 4;\n    if (((int)(array_length + (0x88 - (char)byte_array[1]) * -4) < 0 == SBORROW4(array_length,tempVariable1)) &&\n       (tempVariable1 = (600 - (char)byte_array[2]) * 4, (int)array_length <= (int)tempVariable1)) {\n      tempVariable1 = array_length;\n    }\n    *(uint *)(&DAT_200708fc + (uint)*byte_array * 8) =\n         (Elf32_Rel_ARRAY_20070000[6].r_offset / 1000000) * (tempVariable1 - 2) >> 5;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000806f8": "calculate_interpolation_000806f8",
                "param_1": "byte_array",
                "param_2": "array_length",
                "uVar1": "tempVariable1"
            },
            "calling": [
                "FUN_00080250",
                "FUN_00080164"
            ],
            "called": [
                "FUN_0008145c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008073a": {
            "entrypoint": "0x0008073a",
            "current_name": "FUNC_0008073a",
            "code": "\nvoid FUNC_0008073a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008073a": "FUNC_0008073a"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080748": {
            "entrypoint": "0x00080748",
            "current_name": "FUNC_00080748",
            "code": "\nvoid FUNC_00080748(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080748": "FUNC_00080748"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074a": {
            "entrypoint": "0x0008074a",
            "current_name": "FUNC_0008074a",
            "code": "\nvoid FUNC_0008074a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074a": "FUNC_0008074a"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074c": {
            "entrypoint": "0x0008074c",
            "current_name": "FUNC_0008074c",
            "code": "\nvoid FUNC_0008074c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074c": "FUNC_0008074c"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080774": {
            "entrypoint": "0x00080774",
            "current_name": "initialize_application_00080774",
            "code": "\n\n\nvoid initializeApplication_00080774(void)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  initializeMemory();\n  _DAT_e000e014 = relocationTable[6].r_offset / 1000 - 1;\n  DAT_e000ed23 = 0xf0;\n  _DAT_e000e018 = 0;\n  _DAT_e000e010 = 7;\n  executeNestedFunctions();\n  iVar1 = 0;\n  do {\n    iVar2 = iVar1 + 1;\n    updateAndSetBit(iVar1,0);\n    iVar1 = iVar2;\n  } while (iVar2 != 0x4f);\n  _DAT_400e0ea0 = 0xffffffff;\n  _DAT_400e10a0 = 0xffffffff;\n  _DAT_400e12a0 = 0xffffffff;\n  _DAT_400e14a0 = 0xffffffff;\n  updateParameter(0x400e0e00,1,0x300,0);\n  updateAndSetBit(0,1);\n  updateParameter(0x400e0e00,1,0xc00,0);\n  updateParameter(0x400e0e00,1,0x3000,0);\n  updateParameter(0x400e1400,2,0x30,0);\n  updateParameter(0x400e1000,1,0xc00,0);\n  updateParameter(0x400e0e00,1,3,0);\n  updateParameter(0x400e1000,1,0xc000,0);\n  setBitInData(0x25);\n  findMatchingThreshold(0x400c0000,relocationTable[6].r_offset,20000000,0xc);\n  updateParams(0x400c0000,0,0x300000,1);\n  updateRegister(0x400c0000,0,0);\n  setParamValue(0x400c0000,0xffffffff);\n  initializeValue(0x400c0000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080774": "initialize_application_00080774",
                "initialize_memory_00080b98": "initializeMemory",
                "Elf32_Rel_ARRAY_20070000": "relocationTable",
                "run_nested_functions_00081778": "executeNestedFunctions",
                "update_and_set_bit_00081014": "updateAndSetBit",
                "update_parameter_00080a30": "updateParameter",
                "set_bit_in_data_00080aa8": "setBitInData",
                "find_matching_threshold_00080c98": "findMatchingThreshold",
                "update_params_00080d3e": "updateParams",
                "update_register_00080d30": "updateRegister",
                "set_param_value_00080d6a": "setParamValue",
                "initialize_value_00080d62": "initializeValue"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_00081778",
                "FUN_00080a30",
                "FUN_00080b98",
                "FUN_00081014",
                "FUN_00080d30",
                "FUN_00080c98",
                "FUN_00080d62",
                "FUN_00080d3e",
                "FUN_00080d6a",
                "FUN_00080aa8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008089c": {
            "entrypoint": "0x0008089c",
            "current_name": "initialize_and_assign_update_data_0008089c",
            "code": "\nvoid initialize_and_assign_update_data_0008089c(undefined4 unused_param_1,undefined4 unused_param_2,undefined4 param_3)\n\n{\n  initialize_memory(&DAT_20070c0c);\n  initialize_memory(&DAT_20070b60);\n  initialize_function(&DAT_20070be8,0x400e0800,8,8,&DAT_20070c0c,&DAT_20070b60,param_3);\n  initialize_memory(&DAT_20070e6c);\n  initialize_memory(&DAT_20070ef4);\n  initialize_memory(&DAT_20070f7c);\n  initialize_memory(&DAT_20070ad8);\n  initialize_memory(&DAT_20070d0c);\n  initialize_memory(&DAT_20070d94);\n  initialize_and_assign_data(&DAT_20070c94,0x40098000,0x11,0x11,&DAT_20070e6c,&DAT_20070ad8);\n  initialize_and_assign_data(&DAT_20070cbc,0x4009c000,0x12,0x12,&DAT_20070ef4,&DAT_20070d0c);\n  initialize_and_assign_data(&DAT_20070ce4,0x400a4000,0x14,0x14,&DAT_20070f7c,&DAT_20070d94);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008089c": "initialize_and_assign_update_data_0008089c",
                "param_1": "unused_param_1",
                "param_2": "unused_param_2",
                "initialize_memory_000811b0": "initialize_memory",
                "initialize_function_00081348": "initialize_function",
                "initialize_and_assign_update_data_00081438": "initialize_and_assign_data"
            },
            "calling": [],
            "called": [
                "FUN_000811b0",
                "FUN_00081438",
                "FUN_00081348"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080970": {
            "entrypoint": "0x00080970",
            "current_name": "check_and_handle_differences_00080970",
            "code": "\nvoid checkAndHandleDifferences_00080970(void)\n\n{\n  int result;\n  \n  result = calculateDifference(&DAT_20070be8);\n  if (result != 0) {\n    FUNC_0008073a();\n  }\n  result = calculateDifference(&DAT_20070c94);\n  if (result != 0) {\n    FUNC_00080748();\n  }\n  result = calculateDifference(&DAT_20070cbc);\n  if (result != 0) {\n    FUNC_0008074a();\n  }\n  result = calculateDifference(&DAT_20070ce4);\n  if (result != 0) {\n    FUNC_0008074c();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080970": "check_and_handle_differences_00080970",
                "iVar1": "result",
                "calculate_difference_00081248": "calculateDifference"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_0008074c",
                "FUN_0008074a",
                "FUN_0008073a",
                "FUN_00081248",
                "FUN_00080748"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809be": {
            "entrypoint": "0x000809be",
            "current_name": "update_parameter_value_000809be",
            "code": "\nvoid updateParameterValue_000809be(int structPtr,undefined4 option,uint newValue)\n\n{\n  uint updatedValue;\n  \n  *(uint *)(structPtr + 0x44) = newValue;\n  switch(option) {\n  case 0:\n  case 3:\n  case 4:\n  case 5:\n    return;\n  case 1:\n    updatedValue = *(uint *)(structPtr + 0x70) & *(uint *)(structPtr + 0x70) & ~newValue;\n    break;\n  case 2:\n    updatedValue = *(uint *)(structPtr + 0x70) | newValue;\n    break;\n  default:\n    goto switchD_000809c4_caseD_6;\n  }\n  *(uint *)(structPtr + 0x70) = updatedValue;\nswitchD_000809c4_caseD_6:\n  *(uint *)(structPtr + 4) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809be": "update_parameter_value_000809be",
                "param_1": "structPtr",
                "param_2": "option",
                "param_3": "newValue",
                "uVar1": "updatedValue"
            },
            "calling": [
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809e4": {
            "entrypoint": "0x000809e4",
            "current_name": "set_values_000809e4",
            "code": "\nvoid setValues_000809e4(undefined4 *outputArray,undefined4 value,uint flags)\n\n{\n  bool isNegative;\n  \n  isNegative = (int)(flags << 0x1f) < 0;\n  outputArray[0x11] = value;\n  if (isNegative) {\n    outputArray[0x19] = value;\n  }\n  if (!isNegative) {\n    outputArray[0x18] = value;\n  }\n  isNegative = (flags & 10) != 0;\n  if (isNegative) {\n    outputArray[8] = value;\n  }\n  if (!isNegative) {\n    outputArray[9] = value;\n  }\n  if (((int)(flags << 0x1e) < 0) || ((int)(flags << 0x1c) < 0)) {\n    outputArray[0x20] = value;\n  }\n  outputArray[5] = value;\n  *outputArray = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809e4": "set_values_000809e4",
                "param_1": "outputArray",
                "param_2": "value",
                "param_3": "flags",
                "bVar1": "isNegative"
            },
            "calling": [
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a0a": {
            "entrypoint": "0x00080a0a",
            "current_name": "update_param1_00080a0a",
            "code": "\nvoid updateParam1_00080a0a(undefined4 *ptrArray,undefined4 newValue,int condition3,int condition4,int condition5)\n\n{\n  ptrArray[0x11] = newValue;\n  if (condition5 == 0) {\n    ptrArray[0x18] = newValue;\n  }\n  else {\n    ptrArray[0x19] = newValue;\n  }\n  if (condition4 == 0) {\n    ptrArray[0x15] = newValue;\n  }\n  else {\n    ptrArray[0x14] = newValue;\n  }\n  if (condition3 == 0) {\n    ptrArray[0xd] = newValue;\n  }\n  else {\n    ptrArray[0xc] = newValue;\n  }\n  ptrArray[4] = newValue;\n  *ptrArray = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080a0a": "update_param1_00080a0a",
                "param_1": "ptrArray",
                "param_2": "newValue",
                "param_3": "condition3",
                "param_4": "condition4",
                "param_5": "condition5"
            },
            "calling": [
                "FUN_00080a30",
                "FUN_00081014"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a30": {
            "entrypoint": "0x00080a30",
            "current_name": "update_parameter_00080a30",
            "code": "\nundefined4 updateParameter_00080a30(int device,int parameterType,undefined4 newValue,uint flags)\n\n{\n  bool isNegativeFlag;\n  \n  switch(parameterType) {\n  case 1:\n  case 2:\n    updateParameter_00080a30Value(device,parameterType,newValue);\n    isNegativeFlag = (int)(flags << 0x1f) < 0;\n    *(undefined4 *)(device + 0x44) = newValue;\n    if (isNegativeFlag) {\n      *(undefined4 *)(device + 100) = newValue;\n    }\n    if (!isNegativeFlag) {\n      *(undefined4 *)(device + 0x60) = newValue;\n    }\n    break;\n  case 3:\n    setValues(device,newValue,flags,0x809e5,device);\n    break;\n  case 4:\n  case 5:\n    updateParam1(device,newValue,parameterType == 5,(flags << 0x1d) >> 0x1f,flags & 1,parameterType,newValue)\n    ;\n    break;\n  default:\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080a30": "update_parameter_00080a30",
                "param_1": "device",
                "param_2": "parameterType",
                "param_3": "newValue",
                "param_4": "flags",
                "bVar1": "isNegativeFlag",
                "update_parameter_value_000809be": "updateParameterValue",
                "set_values_000809e4": "setValues",
                "update_param1_00080a0a": "updateParam1"
            },
            "calling": [
                "FUN_00080f0c",
                "FUN_00080774"
            ],
            "called": [
                "FUN_000809e4",
                "FUN_000809be",
                "FUN_00080a0a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a94": {
            "entrypoint": "0x00080a94",
            "current_name": "check_bitwise_conditions_00080a94",
            "code": "\nuint checkBitwiseConditions_00080a94(int inputValue,uint bitMask)\n\n{\n  uint result;\n  \n  result = *(uint *)(inputValue + 8) & bitMask;\n  if (result != 0) {\n    if ((bitMask & *(uint *)(inputValue + 0x18)) == 0) {\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00080a94": "check_bitwise_conditions_00080a94",
                "param_1": "inputValue",
                "param_2": "bitMask",
                "uVar1": "result"
            },
            "calling": [
                "FUN_00081014"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080aa8": {
            "entrypoint": "0x00080aa8",
            "current_name": "set_bit_in_data_00080aa8",
            "code": "\n\n\nundefined4 setBitInData_00080aa8(uint bitPosition)\n\n{\n  uint bitMask;\n  \n  if (bitPosition < 0x2d) {\n    if (bitPosition < 0x20) {\n      bitMask = 1 << (bitPosition & 0xff);\n      if ((bitMask & _DAT_400e0618) != bitMask) {\n        _DAT_400e0610 = bitMask;\n      }\n    }\n    else {\n      bitMask = 1 << (bitPosition - 0x20 & 0xff);\n      if ((bitMask & _DAT_400e0708) != bitMask) {\n        _DAT_400e0700 = bitMask;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080aa8": "set_bit_in_data_00080aa8",
                "param_1": "bitPosition",
                "uVar1": "bitMask"
            },
            "calling": [
                "FUN_00080f0c",
                "FUN_000803fc",
                "FUN_00080774",
                "FUN_000813dc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b2c": {
            "entrypoint": "0x00080b2c",
            "current_name": "configure_tc_channel_00080b2c",
            "code": "\nvoid configureTcChannel_00080b2c(undefined4 value1,uint value2,char *message)\n\n{\n  int offset;\n  int address;\n  undefined8 combinedValue;\n  \n  combinedValue = CONCAT44(value2,value1);\n  if (2 < value2) {\n    message = \"TC_Configure\";\n    combinedValue = print_assertion_failed_message_000816f8(\"../source/tc.c\",0x40,\"TC_Configure\",\n                         \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\");\n  }\n  offset = (int)((ulonglong)combinedValue >> 0x20) * 0x40;\n  address = (int)combinedValue + offset;\n  *(undefined4 *)((int)combinedValue + offset) = 2;\n  *(undefined4 *)(address + 0x28) = 0xffffffff;\n  *(char **)(address + 4) = message;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b2c": "configure_tc_channel_00080b2c",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "message",
                "iVar1": "offset",
                "iVar2": "address",
                "uVar3": "combinedValue"
            },
            "calling": [
                "FUN_000803fc"
            ],
            "called": [
                "FUN_000816f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b90": {
            "entrypoint": "0x00080b90",
            "current_name": "store_value_at_index_00080b90",
            "code": "\nvoid storeValueAtIndex_00080b90(int arrayBaseAddress,int index,undefined4 value)\n\n{\n  *(undefined4 *)(arrayBaseAddress + index * 0x40 + 0x14) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b90": "store_value_at_index_00080b90",
                "param_1": "arrayBaseAddress",
                "param_2": "index",
                "param_3": "value"
            },
            "calling": [
                "FUN_000803fc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b98": {
            "entrypoint": "0x00080b98",
            "current_name": "initialize_memory_00080b98",
            "code": "\n\n\nvoid initializeMemory_00080b98(void)\n\n{\n  _DAT_400e0a00 = 0x400;\n  _DAT_400e0c00 = 0x400;\n  _DAT_400e0620 = _DAT_400e0620 << 7;\n  while (-1 < _DAT_400e0620) {\n    _DAT_400e0620 = _DAT_400e0668 << 0x1f;\n  }\n  _DAT_400e0620 = 0x1370809;\n  do {\n  } while (-1 < _DAT_400e0668 << 0xf);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0628 = 0x200d3f01;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1e);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0630 = 0x12;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  elfRelocationOffset = 84000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b98": "initialize_memory_00080b98",
                "Elf32_Rel_ARRAY_20070000[6].r_offset": "elfRelocationOffset"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "entry": {
            "entrypoint": "0x00080c20",
            "current_name": "entry",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080c6a) */\n\n\nvoid entry(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  \n  for (iVar1 = 0; (undefined4 *)((int)&Elf32_Rel_ARRAY_20070000[0].r_offset + iVar1) < &DAT_200708a0\n      ; iVar1 = iVar1 + 4) {\n    *(undefined4 *)((int)&Elf32_Rel_ARRAY_20070000[0].r_offset + iVar1) =\n         *(undefined4 *)(&DAT_00085878 + iVar1);\n  }\n  for (puVar2 = &DAT_200708a0; puVar2 < (undefined4 *)0x20071248; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  _DAT_e000ed08 = 0x80000;\n  main_loop_000815ec();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "FUN_000815ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080c98": {
            "entrypoint": "0x00080c98",
            "current_name": "find_matching_threshold_00080c98",
            "code": "\nundefined4 findMatchingThreshold_00080c98(undefined4 *result,uint totalTime,int numElements,int threshold)\n\n{\n  uint divisor;\n  uint index;\n  uint thresholds [16];\n  \n  thresholds[0] = 0;\n  thresholds[1] = 8;\n  thresholds[2] = 0x10;\n  thresholds[3] = 0x18;\n  thresholds[4] = 0x40;\n  thresholds[5] = 0x50;\n  thresholds[6] = 0x60;\n  thresholds[7] = 0x70;\n  thresholds[8] = 0x200;\n  thresholds[9] = 0x240;\n  thresholds[10] = 0x280;\n  thresholds[11] = 0x2c0;\n  thresholds[12] = 0x300;\n  thresholds[13] = 0x340;\n  thresholds[14] = 0x380;\n  thresholds[15] = 0x3c0;\n  *result = 1;\n  result[1] = 0;\n  result[0x48] = 0x202;\n  result[0x41] = 0;\n  result[0x45] = 0;\n  divisor = totalTime / (uint)(numElements * 2);\n  if (totalTime == numElements * 2 * divisor) {\n    divisor = divisor - 1;\n  }\n  index = 0;\n  do {\n    if ((uint)(threshold * (int)(((ulonglong)totalTime / (ulonglong)((divisor + 1) * 2)) / 1000000)) <=\n        thresholds[index]) {\n      result[1] = (index & 0xf) << 0x10 | (divisor & 0xff) << 8 | result[1];\n      return 0;\n    }\n    index = index + 1;\n  } while (index != 0x10);\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080c98": "find_matching_threshold_00080c98",
                "param_1": "result",
                "param_2": "totalTime",
                "param_3": "numElements",
                "param_4": "threshold",
                "uVar1": "divisor",
                "uVar2": "index",
                "local_58": "thresholds"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d30": {
            "entrypoint": "0x00080d30",
            "current_name": "update_register_00080d30",
            "code": "\nvoid updateRegister_00080d30(int registerAddress,uint data,uint flag)\n\n{\n  *(uint *)(registerAddress + 4) = data | *(uint *)(registerAddress + 4) | (flag & 1) << 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d30": "update_register_00080d30",
                "param_1": "registerAddress",
                "param_2": "data",
                "param_3": "flag"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d3e": {
            "entrypoint": "0x00080d3e",
            "current_name": "update_params_00080d3e",
            "code": "\nvoid updateParams_00080d3e(int inputAddress,uint bitmask1,uint bitmask2,uint bitmask3)\n\n{\n  *(uint *)(inputAddress + 4) =\n       bitmask2 | *(uint *)(inputAddress + 4) | (bitmask1 & 0xf) << 0x18 | (bitmask3 & 3) << 0x1c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d3e": "update_params_00080d3e",
                "param_1": "inputAddress",
                "param_2": "bitmask1",
                "param_3": "bitmask2",
                "param_4": "bitmask3"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d58": {
            "entrypoint": "0x00080d58",
            "current_name": "set_bit_in_value_00080d58",
            "code": "\nvoid setBitInValue_00080d58(int baseAddress,uint bitPosition)\n\n{\n  *(int *)(baseAddress + 0x14) = 1 << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d58": "set_bit_in_value_00080d58",
                "param_1": "baseAddress",
                "param_2": "bitPosition"
            },
            "calling": [
                "FUN_00080f0c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d62": {
            "entrypoint": "0x00080d62",
            "current_name": "initialize_value_00080d62",
            "code": "\nvoid initializeValue_00080d62(int address)\n\n{\n  *(undefined4 *)(address + 0x14) = 0xffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d62": "initialize_value_00080d62",
                "param_1": "address"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d6a": {
            "entrypoint": "0x00080d6a",
            "current_name": "set_param_value_00080d6a",
            "code": "\nvoid setParamValue_00080d6a(int objAddress,undefined4 newValue)\n\n{\n  *(undefined4 *)(objAddress + 0x28) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d6a": "set_param_value_00080d6a",
                "param_1": "objAddress",
                "param_2": "newValue"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e80": {
            "entrypoint": "0x00080e80",
            "current_name": "get_zero_00080e80",
            "code": "\nundefined4 getZero_00080e80(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080e80": "get_zero_00080e80"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e88": {
            "entrypoint": "0x00080e88",
            "current_name": "calculate_sum_00080e88",
            "code": "\nint calculateSum_00080e88(int inputValue)\n\n{\n  int previousValue;\n  \n  if (DAT_20071208 == 0) {\n    DAT_20071208 = 0x20071248;\n  }\n  previousValue = DAT_20071208;\n  DAT_20071208 = inputValue + DAT_20071208;\n  return previousValue;\n}\n\n",
            "renaming": {
                "FUN_00080e88": "calculate_sum_00080e88",
                "param_1": "inputValue",
                "iVar1": "previousValue"
            },
            "calling": [
                "FUN_0008236c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eaa": {
            "entrypoint": "0x00080eaa",
            "current_name": "get_default_value_00080eaa",
            "code": "\nuint32_t get_default_value_00080eaa(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080eaa": "get_default_value_00080eaa",
                "undefined4": "uint32_t"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eb0": {
            "entrypoint": "0x00080eb0",
            "current_name": "initialize_memory_00080eb0",
            "code": "\nundefined4 initializeMemory_00080eb0(undefined4 param1,int param2)\n\n{\n  *(undefined4 *)(param2 + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080eb0": "initialize_memory_00080eb0",
                "param_1": "param1",
                "param_2": "param2"
            },
            "calling": [
                "FUN_00084494"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eba": {
            "entrypoint": "0x00080eba",
            "current_name": "get_return_value_00080eba",
            "code": "\nint getReturnValue_00080eba(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080eba": "get_return_value_00080eba",
                "undefined4": "int"
            },
            "calling": [
                "FUN_000844bc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ebe": {
            "entrypoint": "0x00080ebe",
            "current_name": "initialize_00080ebe",
            "code": "\nvoid initialize_00080ebe(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ebe": "initialize_00080ebe",
                "undefined4": "void"
            },
            "calling": [
                "FUN_000844e0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec2": {
            "entrypoint": "0x00080ec2",
            "current_name": "clear_data_00080ec2",
            "code": "\nundefined4 clear_data_00080ec2(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ec2": "clear_data_00080ec2"
            },
            "calling": [
                "FUN_00084508"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec8": {
            "entrypoint": "0x00080ec8",
            "current_name": "copy_byte_array_00080ec8",
            "code": "\n\n\nuint copyByteArray_00080ec8(undefined4 param1,int sourceArray,uint arrayLength)\n\n{\n  int index;\n  \n  for (index = 0; index < (int)arrayLength; index = index + 1) {\n    do {\n    } while (-1 < _DAT_400e0814 << 0x1e);\n    _DAT_400e081c = (uint)*(byte *)(sourceArray + index);\n  }\n  return arrayLength & ~((int)arrayLength >> 0x1f);\n}\n\n",
            "renaming": {
                "FUN_00080ec8": "copy_byte_array_00080ec8",
                "param_1": "param1",
                "param_2": "sourceArray",
                "param_3": "arrayLength",
                "iVar1": "index"
            },
            "calling": [
                "FUN_00084244"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eec": {
            "entrypoint": "0x00080eec",
            "current_name": "exit_with_status_00080eec",
            "code": "\nvoid exitWithStatus_00080eec(undefined4 status,undefined4 unused,undefined4 param_3,undefined4 param_4)\n\n{\n  printExitStatus(\"Exiting with status %d.\\n\",status,param_3,param_4,param_4);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080eec": "exit_with_status_00080eec",
                "param_1": "status",
                "param_2": "unused",
                "apply_function_to_stack_and_offset_000817c8": "printExitStatus"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_000817c8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080efc": {
            "entrypoint": "0x00080efc",
            "current_name": "FUNC_00080efc",
            "code": "\nvoid FUNC_00080efc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080efc": "FUNC_00080efc"
            },
            "calling": [
                "FUN_000841e4"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080efe": {
            "entrypoint": "0x00080efe",
            "current_name": "get_return_value_00080efe",
            "code": "\nundefined4 getReturnValue_00080efe(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080efe": "get_return_value_00080efe"
            },
            "calling": [
                "thunk_FUN_00080efe"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_000816d8": {
            "entrypoint": "0x00080f04",
            "current_name": "get_dat_value_thunk_000816d8",
            "code": "\nundefined4 get_dat_value_thunk_000816d8(void)\n\n{\n  return DAT_2007120c;\n}\n\n",
            "renaming": {
                "thunk_FUN_000816d8": "get_dat_value_thunk_000816d8"
            },
            "calling": [
                "FUN_000811e8"
            ],
            "called": [
                "FUN_000816d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f08": {
            "entrypoint": "0x00080f08",
            "current_name": "FUNC_00080f08",
            "code": "\nvoid FUNC_00080f08(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080f08": "FUNC_00080f08"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000815ec",
                "FUN_000801e0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080f0c": {
            "entrypoint": "0x00080f0c",
            "current_name": "update_parameter_and_set_bit_00080f0c",
            "code": "\n\n\nint updateParameterAndSetBit_00080f0c(int deviceId,int parameterId)\n\n{\n  int result;\n  uint bitMask;\n  undefined4 paramType;\n  uint tempMask;\n  byte paramTypeLower;\n  byte paramTypeFull;\n  int tempVar1;\n  int tempVar2;\n  \n  result = deviceId;\n  if ((&DAT_00084b50)[deviceId * 0x1c] != '\\0') {\n    if (((&DAT_20070e1c)[deviceId] & 0xf) == 4) {\n      result = set_bit_in_value_00080d58(0x400c0000,(&DAT_00084b5d)[deviceId * 0x1c]);\n    }\n    paramTypeFull = (&DAT_20070e1c)[deviceId];\n    paramTypeLower = paramTypeFull & 0xf;\n    if ((paramTypeLower < 3) && (paramTypeFull != 0)) {\n      if (paramTypeLower == 2) {\n        if (parameterId == 0) {\n          return result;\n        }\n      }\n      else if (paramTypeLower == 1) {\n        if (parameterId == 2) {\n          return result;\n        }\n      }\n      else if (paramTypeLower == 3) {\n        if (parameterId == 1) {\n          return result;\n        }\n        goto LAB_00080f68;\n      }\n    }\n    if (parameterId != 1) {\nLAB_00080f68:\n      if (parameterId == 0) {\n        result = deviceId * 0x1c;\n        set_bit_in_data_00080aa8(*(undefined4 *)(&DAT_00084b4c + result));\n        result = update_parameter_00080a30(*(undefined4 *)(&DAT_00084b44 + result),3,\n                             *(undefined4 *)(&DAT_00084b48 + result),0);\n        paramTypeFull = (&DAT_20070e1c)[deviceId] & 0xf0 | 2;\n      }\n      else {\n        if (parameterId != 2) {\n          return result;\n        }\n        result = deviceId * 0x1c;\n        set_bit_in_data_00080aa8(*(undefined4 *)(&DAT_00084b4c + result));\n        result = update_parameter_00080a30(*(undefined4 *)(&DAT_00084b44 + result),3,\n                             *(undefined4 *)(&DAT_00084b48 + result),1);\n        paramTypeFull = (&DAT_20070e1c)[deviceId] & 0xf0 | 1;\n      }\n      (&DAT_20070e1c)[deviceId] = paramTypeFull;\n      return result;\n    }\n    tempVar1 = deviceId * 0x1c;\n    tempVar2 = *(int *)(&DAT_00084b44 + tempVar1);\n    if (paramTypeFull >> 4 == 0) {\n      paramType = 4;\n    }\n    else {\n      paramType = 5;\n    }\n    result = update_parameter_00080a30(tempVar2,paramType,*(undefined4 *)(&DAT_00084b48 + tempVar1),\n                         *(undefined4 *)(&DAT_00084b54 + tempVar1));\n    (&DAT_20070e1c)[deviceId] = (&DAT_20070e1c)[deviceId] & 0xf0 | 3;\n    if (*(int *)(tempVar2 + 0x18) == -1) {\n      bitMask = *(uint *)(&DAT_00084b4c + tempVar1);\n      if (0x2c < bitMask) {\n        return 1;\n      }\n      if (bitMask < 0x20) {\n        bitMask = 1 << (bitMask & 0xff);\n        tempMask = _DAT_400e0618 & bitMask;\n        if (tempMask == bitMask) {\n          _DAT_400e0614 = tempMask;\n        }\n      }\n      else {\n        bitMask = 1 << (bitMask - 0x20 & 0xff);\n        tempMask = _DAT_400e0708 & bitMask;\n        if (tempMask == bitMask) {\n          _DAT_400e0704 = tempMask;\n        }\n      }\n      return 0;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00080f0c": "update_parameter_and_set_bit_00080f0c",
                "param_1": "deviceId",
                "param_2": "parameterId",
                "iVar1": "result",
                "iVar7": "tempVar1",
                "iVar8": "tempVar2",
                "uVar2": "bitMask",
                "uVar3": "paramType",
                "uVar4": "tempMask",
                "bVar5": "paramTypeLower",
                "bVar6": "paramTypeFull"
            },
            "calling": [
                "FUN_00081014",
                "FUN_000806a0",
                "FUN_000801e0"
            ],
            "called": [
                "FUN_00080a30",
                "FUN_00080aa8",
                "FUN_00080d58"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081014": {
            "entrypoint": "0x00081014",
            "current_name": "update_and_set_bit_00081014",
            "code": "\nvoid updateAndSetBit_00081014(int index,int value,undefined4 param)\n\n{\n  int result;\n  undefined4 paramValue;\n  int dataAddress;\n  \n  if ((&DAT_00084b50)[index * 0x1c] != '\\0') {\n    if (((&DAT_20070e1c)[index] & 0xf) == 5) {\n      update_parameter_and_set_bit_00080f0c(index,1,param,5,index,value,param);\n    }\n    (&DAT_20070e1c)[index] = (&DAT_20070e1c)[index] & 0xf | (byte)(value << 4);\n    dataAddress = *(int *)(&DAT_00084b44 + index * 0x1c);\n    paramValue = *(undefined4 *)(&DAT_00084b48 + index * 0x1c);\n    result = check_bitwise_conditions_00080a94(dataAddress,paramValue);\n    if (result == 0) {\n      if (value != 0) {\n        *(undefined4 *)(dataAddress + 100) = paramValue;\n        return;\n      }\n      *(undefined4 *)(dataAddress + 0x60) = paramValue;\n      return;\n    }\n    update_param1_00080a0a(dataAddress,paramValue,value,0,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081014": "update_and_set_bit_00081014",
                "param_1": "index",
                "param_2": "value",
                "param_3": "param",
                "iVar1": "result",
                "uVar2": "paramValue",
                "iVar3": "dataAddress"
            },
            "calling": [
                "FUN_00080774",
                "FUN_0008044c",
                "FUN_00080250"
            ],
            "called": [
                "FUN_00080f0c",
                "FUN_00080a94",
                "FUN_00080a0a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810a6": {
            "entrypoint": "0x000810a6",
            "current_name": "process_param_000810a6",
            "code": "\nvoid processParam_000810a6(int *paramArr,int paramVal,undefined4 param1,undefined4 param2)\n\n{\n  undefined4 trailingZeros;\n  \n  if (paramVal != 0) {\n    trailingZeros = count_trailing_zeros_00082688(paramVal);\n    (**(code **)(*paramArr + 4))(paramArr,paramVal,trailingZeros,*(code **)(*paramArr + 4),param2);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810a6": "process_param_000810a6",
                "param_1": "paramArr",
                "param_2": "paramVal",
                "param_3": "param1",
                "param_4": "param2",
                "uVar1": "trailingZeros"
            },
            "calling": [
                "FUN_000810e8",
                "FUN_000810c4",
                "FUN_000810fc",
                "FUN_000810d8"
            ],
            "called": [
                "FUN_00082688"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810c4": {
            "entrypoint": "0x000810c4",
            "current_name": "initialize_process_000810c4",
            "code": "\nvoid initializeProcess_000810c4(void)\n\n{\n  setupParameters();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810c4": "initialize_process_000810c4",
                "process_param_000810a6": "setupParameters"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810cc": {
            "entrypoint": "0x000810cc",
            "current_name": "execute_code_000810cc",
            "code": "\nvoid executeCode_000810cc(undefined4 *functionPointer)\n\n{\n  (**(code **)*functionPointer)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810cc": "execute_code_000810cc",
                "param_1": "functionPointer"
            },
            "calling": [
                "FUN_0008113a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810d8": {
            "entrypoint": "0x000810d8",
            "current_name": "process_parameters_000810d8",
            "code": "\nvoid processParameters_000810d8(undefined4 input1,undefined4 input2,undefined4 input3,undefined4 input4)\n\n{\n  processData(input1,&DAT_00085635,input3,input4,input4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810d8": "process_parameters_000810d8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "process_param_000810a6": "processData"
            },
            "calling": [
                "FUN_000810e8",
                "FUN_0008117a"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810e8": {
            "entrypoint": "0x000810e8",
            "current_name": "calculate_sum_000810e8",
            "code": "\nint calculateSum_000810e8(undefined4 input)\n\n{\n  int result1;\n  int result2;\n  \n  result1 = process_param_000810a6();\n  result2 = process_parameters_000810d8(input);\n  return result2 + result1;\n}\n\n",
            "renaming": {
                "FUN_000810e8": "calculate_sum_000810e8",
                "param_1": "input",
                "iVar1": "result1",
                "iVar2": "result2"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810d8",
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810fc": {
            "entrypoint": "0x000810fc",
            "current_name": "convert_number_to_base_000810fc",
            "code": "\nvoid convertNumberToBase_000810fc(undefined4 outputBuffer,uint number,uint base)\n\n{\n  char *currentChar;\n  uint quotient;\n  char *previousChar;\n  char digitChar;\n  uint remainder;\n  char buffer [5];\n  \n  buffer[1] = 0;\n  if (base < 2) {\n    base = 10;\n  }\n  currentChar = buffer;\n  do {\n    previousChar = currentChar;\n    quotient = number / base;\n    remainder = number - base * quotient & 0xff;\n    digitChar = (char)remainder;\n    if (remainder < 10) {\n      digitChar = digitChar + '0';\n    }\n    else {\n      digitChar = digitChar + '7';\n    }\n    *previousChar = digitChar;\n    number = quotient;\n    currentChar = previousChar + -1;\n  } while (quotient != 0);\n  process_param_000810a6(outputBuffer,previousChar);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810fc": "convert_number_to_base_000810fc",
                "param_1": "outputBuffer",
                "param_2": "number",
                "param_3": "base",
                "pcVar1": "currentChar",
                "uVar2": "quotient",
                "pcVar3": "previousChar",
                "cVar4": "digitChar",
                "uVar5": "remainder",
                "local_15": "buffer"
            },
            "calling": [
                "FUN_0008113a"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008113a": {
            "entrypoint": "0x0008113a",
            "current_name": "convert_number_to_base_0008113a",
            "code": "\nint convertNumberToBase_0008113a(undefined4 *dataBuffer,uint inputNumber,uint base,undefined4 param_4)\n\n{\n  int result;\n  int negativeResult;\n  \n  if (base == 0) {\n    result = (**(code **)*dataBuffer)(dataBuffer,inputNumber & 0xff);\n    return result;\n  }\n  if (base == 10) {\n    base = 10;\n    if ((int)inputNumber < 0) {\n      result = execute_code_000810cc(dataBuffer,0x2d);\n      negativeResult = convert_number_to_base_000810fc(dataBuffer,-inputNumber,10);\n      return negativeResult + result;\n    }\n  }\n  else {\n    base = base & 0xff;\n  }\n  result = convert_number_to_base_000810fc(dataBuffer,inputNumber,base,param_4);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0008113a": "convert_number_to_base_0008113a",
                "param_1": "dataBuffer",
                "param_2": "inputNumber",
                "param_3": "base",
                "iVar1": "result",
                "iVar2": "negativeResult"
            },
            "calling": [
                "thunk_FUN_0008113a",
                "FUN_0008117a"
            ],
            "called": [
                "FUN_000810fc",
                "FUN_000810cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_0008113a": {
            "entrypoint": "0x00081176",
            "current_name": "convert_and_execute_number_base_thunk_0008113a",
            "code": "\nint convert_and_execute_number_base_thunk_0008113a(undefined4 *input_array,uint number,uint base,undefined4 param_4)\n\n{\n  int returnValue;\n  int negativeValue;\n  \n  if (base == 0) {\n    returnValue = (**(code **)*input_array)(input_array,number & 0xff);\n    return returnValue;\n  }\n  if (base == 10) {\n    base = 10;\n    if ((int)number < 0) {\n      returnValue = execute_code_000810cc(input_array,0x2d);\n      negativeValue = convert_number_to_base_000810fc(input_array,-number,10);\n      return negativeValue + returnValue;\n    }\n  }\n  else {\n    base = base & 0xff;\n  }\n  returnValue = convert_number_to_base_000810fc(input_array,number,base,param_4);\n  return returnValue;\n}\n\n",
            "renaming": {
                "thunk_FUN_0008113a": "convert_and_execute_number_base_thunk_0008113a",
                "param_1": "input_array",
                "param_2": "number",
                "param_3": "base",
                "iVar1": "returnValue",
                "iVar2": "negativeValue"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008113a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008117a": {
            "entrypoint": "0x0008117a",
            "current_name": "add_converted_number_and_param_0008117a",
            "code": "\nint addConvertedNumberAndParam_0008117a(undefined4 input)\n\n{\n  int convertedNumber;\n  int processedParam;\n  \n  convertedNumber = convert_number_to_base_0008113a();\n  processedParam = process_parameters_000810d8(input);\n  return processedParam + convertedNumber;\n}\n\n",
            "renaming": {
                "FUN_0008117a": "add_converted_number_and_param_0008117a",
                "param_1": "input",
                "iVar1": "convertedNumber",
                "iVar2": "processedParam"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810d8",
                "FUN_0008113a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081190": {
            "entrypoint": "0x00081190",
            "current_name": "execute_if_rel_info_equal_zero_00081190",
            "code": "\nvoid execute_if_rel_info_equal_zero_00081190(void)\n\n{\n  if ((rel_info_array[6].info != 0xffffffff) &&\n     (rel_info_array[6].info = rel_info_array[6].info - 1,\n     rel_info_array[6].info == 0)) {\n    (*(code *)((int)&rel_info_array[0].offset + 1))();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081190": "execute_if_rel_info_equal_zero_00081190",
                "Elf32_Rel_ARRAY_20070000": "rel_info_array",
                "r_info": "info",
                "r_offset": "offset"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811b0": {
            "entrypoint": "0x000811b0",
            "current_name": "initialize_memory_000811b0",
            "code": "\nint initializeMemory_000811b0(int startAddress)\n\n{\n  fillMemoryWithByte(startAddress,0,0x80);\n  *(undefined4 *)(startAddress + 0x80) = 0;\n  *(undefined4 *)(startAddress + 0x84) = 0;\n  return startAddress;\n}\n\n",
            "renaming": {
                "FUN_000811b0": "initialize_memory_000811b0",
                "param_1": "startAddress",
                "fill_memory_with_byte_00081f00": "fillMemoryWithByte"
            },
            "calling": [
                "FUN_0008089c"
            ],
            "called": [
                "FUN_00081f00"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811ca": {
            "entrypoint": "0x000811ca",
            "current_name": "update_buffer_000811ca",
            "code": "\nvoid updateBuffer_000811ca(int buffer,undefined value)\n\n{\n  uint newIndex;\n  \n  newIndex = *(int *)(buffer + 0x80) + 1U & 0x7f;\n  if (newIndex != *(uint *)(buffer + 0x84)) {\n    *(undefined *)(buffer + *(int *)(buffer + 0x80)) = value;\n    *(uint *)(buffer + 0x80) = newIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000811ca": "update_buffer_000811ca",
                "param_1": "buffer",
                "param_2": "value",
                "uVar1": "newIndex"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811e8": {
            "entrypoint": "0x000811e8",
            "current_name": "update_value_and_check_000811e8",
            "code": "\nint updateValueAndCheck_000811e8(int *data)\n\n{\n  int newValue;\n  \n  newValue = getNewValueFromData();\n  data[3] = newValue;\n  do {\n    newValue = (**(code **)(*data + 0xc))(data);\n    if (-1 < newValue) {\n      return newValue;\n    }\n    newValue = getNewValueFromData();\n  } while ((uint)(newValue - data[3]) < (uint)data[2]);\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000811e8": "update_value_and_check_000811e8",
                "param_1": "data",
                "iVar1": "newValue",
                "get_dat_value_thunk_000816d8": "getNewValueFromData"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "thunk_FUN_000816d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081214": {
            "entrypoint": "0x00081214",
            "current_name": "process_and_update_array_00081214",
            "code": "\nvoid processAndUpdateArray_00081214(undefined4 arrayPointer,undefined4 valuePointer,uint targetValue)\n\n{\n  uint updateResult;\n  \n  initialize_param_with_zeros_000814f6(arrayPointer,&DAT_00085637);\n  while ((updateResult = update_value_and_check_000811e8(valuePointer), -1 < (int)updateResult && (updateResult != targetValue))) {\n    copy_and_update_string_array_0008159e(arrayPointer,updateResult & 0xff);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081214": "process_and_update_array_00081214",
                "param_1": "arrayPointer",
                "param_2": "valuePointer",
                "param_3": "targetValue",
                "uVar1": "updateResult"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000811e8",
                "FUN_000814f6",
                "FUN_0008159e"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081248": {
            "entrypoint": "0x00081248",
            "current_name": "calculate_difference_00081248",
            "code": "\nuint calculate_difference_00081248(int input_value)\n\n{\n  return *(int *)(*(int *)(input_value + 0x10) + 0x80) - *(int *)(*(int *)(input_value + 0x10) + 0x84) &\n         0x7f;\n}\n\n",
            "renaming": {
                "FUN_00081248": "calculate_difference_00081248",
                "param_1": "input_value"
            },
            "calling": [
                "FUN_00080250",
                "FUN_00080970"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081276": {
            "entrypoint": "0x00081276",
            "current_name": "extract_byte_from_buffer_00081276",
            "code": "\nuint extractByteFromBuffer_00081276(int bufferAddress)\n\n{\n  byte extractedByte;\n  int bufferPointer;\n  \n  bufferPointer = *(int *)(bufferAddress + 0x10);\n  if (*(int *)(bufferPointer + 0x80) != *(int *)(bufferPointer + 0x84)) {\n    extractedByte = *(byte *)(bufferPointer + *(int *)(bufferPointer + 0x84));\n    *(uint *)(bufferPointer + 0x84) = *(int *)(bufferPointer + 0x84) + 1U & 0x7f;\n    return (uint)extractedByte;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00081276": "extract_byte_from_buffer_00081276",
                "param_1": "bufferAddress",
                "bVar1": "extractedByte",
                "iVar2": "bufferPointer"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000812b8": {
            "entrypoint": "0x000812b8",
            "current_name": "update_data_000812b8",
            "code": "\nundefined4 updateData_000812b8(int dataPtr,undefined4 newValue)\n\n{\n  int ptr1;\n  uint nextIndex;\n  \n  ptr1 = *(int *)(dataPtr + 0x14);\n  if ((*(int *)(*(int *)(dataPtr + 0x18) + 0x14) << 0x1e < 0) &&\n     (*(int *)(ptr1 + 0x84) == *(int *)(ptr1 + 0x80))) {\n    *(undefined4 *)(*(int *)(dataPtr + 0x18) + 0x1c) = newValue;\n  }\n  else {\n    nextIndex = *(int *)(ptr1 + 0x80) + 1U & 0x8000007f;\n    if ((int)nextIndex < 0) {\n      nextIndex = (nextIndex - 1 | 0xffffff80) + 1;\n    }\n    do {\n    } while (*(uint *)(ptr1 + 0x84) == nextIndex);\n    *(char *)(ptr1 + *(int *)(ptr1 + 0x80)) = (char)newValue;\n    *(uint *)(*(int *)(dataPtr + 0x14) + 0x80) = nextIndex;\n    *(undefined4 *)(*(int *)(dataPtr + 0x18) + 8) = 2;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000812b8": "update_data_000812b8",
                "param_1": "dataPtr",
                "param_2": "newValue",
                "iVar1": "ptr1",
                "uVar2": "nextIndex"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081348": {
            "entrypoint": "0x00081348",
            "current_name": "initialize_function_00081348",
            "code": "\nvoid initializeFunction_00081348(undefined4 *functionParams,undefined4 param2,undefined param3,undefined4 param4,\n                 undefined4 param5,undefined4 param6)\n\n{\n  functionParams[1] = 0;\n  functionParams[2] = 1000;\n  functionParams[6] = param2;\n  *functionParams = &PTR_FUN_000812b8_1_00085650;\n  *(undefined *)(functionParams + 7) = param3;\n  functionParams[4] = param5;\n  functionParams[8] = param4;\n  functionParams[5] = param6;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081348": "initialize_function_00081348",
                "param_1": "functionParams",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6"
            },
            "calling": [
                "FUN_0008089c",
                "FUN_00081438"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813dc": {
            "entrypoint": "0x000813dc",
            "current_name": "initialize_data_000813dc",
            "code": "\nvoid initializeData_000813dc(int inputParameter,uint divisor)\n\n{\n  int tempVariable1;\n  undefined4 *dataPointer;\n  \n  set_bit_in_data_00080aa8(*(undefined4 *)(inputParameter + 0x20));\n  dataPointer = *(undefined4 **)(inputParameter + 0x18);\n  dataPointer[0x48] = 0x202;\n  *dataPointer = 0xac;\n  dataPointer[1] = 0x800;\n  dataPointer[8] = arrayPointer[6].relOffset / divisor >> 4;\n  dataPointer[3] = 0xffffffff;\n  dataPointer[2] = 0x61;\n  *(int *)(((uint)(int)(char)*(byte *)(inputParameter + 0x1c) >> 5) * 4 + -0x1fff1f00) =\n       1 << (uint)(*(byte *)(inputParameter + 0x1c) & 0x1f);\n  tempVariable1 = *(int *)(inputParameter + 0x10);\n  *(undefined4 *)(tempVariable1 + 0x84) = 0;\n  *(undefined4 *)(tempVariable1 + 0x80) = 0;\n  tempVariable1 = *(int *)(inputParameter + 0x14);\n  *(undefined4 *)(tempVariable1 + 0x84) = 0;\n  *(undefined4 *)(tempVariable1 + 0x80) = 0;\n  *dataPointer = 0x50;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000813dc": "initialize_data_000813dc",
                "param_1": "inputParameter",
                "param_2": "divisor",
                "iVar1": "tempVariable1",
                "puVar2": "dataPointer",
                "Elf32_Rel_ARRAY_20070000": "arrayPointer",
                "r_offset": "relOffset"
            },
            "calling": [
                "FUN_000801e0"
            ],
            "called": [
                "FUN_00080aa8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081438": {
            "entrypoint": "0x00081438",
            "current_name": "initialize_and_assign_update_data_00081438",
            "code": "\nundefined4 * initialize_and_assign_update_data_00081438(undefined4 *output_array,undefined4 input_value)\n\n{\n  initialize_function_00081348();\n  *output_array = &PTR_update_data_000812b8_1_00085680;\n  output_array[9] = input_value;\n  return output_array;\n}\n\n",
            "renaming": {
                "FUN_00081438": "initialize_and_assign_update_data_00081438",
                "param_1": "output_array",
                "param_2": "input_value"
            },
            "calling": [
                "FUN_0008089c"
            ],
            "called": [
                "FUN_00081348"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008145c": {
            "entrypoint": "0x0008145c",
            "current_name": "calculate_interpolation_0008145c",
            "code": "\nint calculateInterpolation_0008145c(int startValue,int startRange,int endRange,int startOutput,int endOutput)\n\n{\n  return (uint)((startValue - startRange) * (endOutput - startOutput)) / (uint)(endRange - startRange) + startOutput;\n}\n\n",
            "renaming": {
                "FUN_0008145c": "calculate_interpolation_0008145c",
                "param_1": "startValue",
                "param_2": "startRange",
                "param_3": "endRange",
                "param_4": "startOutput",
                "param_5": "endOutput"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000806f8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081472": {
            "entrypoint": "0x00081472",
            "current_name": "process_relocation_00081472",
            "code": "\nundefined4 * process_relocation_00081472(undefined4 *relocation_data)\n\n{\n  process_relocation_00081472_00081800(*relocation_data);\n  return relocation_data;\n}\n\n",
            "renaming": {
                "FUN_00081472": "process_relocation_00081472",
                "param_1": "relocation_data"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00081800"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081480": {
            "entrypoint": "0x00081480",
            "current_name": "reset_memory_00081480",
            "code": "\nvoid resetMemory_00081480(int *memoryPointer)\n\n{\n  if (*memoryPointer != 0) {\n    performRelocation();\n  }\n  *memoryPointer = 0;\n  memoryPointer[2] = 0;\n  memoryPointer[1] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081480": "reset_memory_00081480",
                "param_1": "memoryPointer",
                "process_relocation_00081800": "performRelocation"
            },
            "calling": [
                "FUN_000814d0"
            ],
            "called": [
                "FUN_00081800"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081496": {
            "entrypoint": "0x00081496",
            "current_name": "reallocate_and_update_array_00081496",
            "code": "\nint reallocate_and_update_array_00081496(int *array,int size,undefined4 arg_3,undefined4 arg_4)\n\n{\n  int result;\n  \n  result = reallocate_memory_00081f9c(*array,size + 1,arg_3,arg_4,arg_4);\n  if (result != 0) {\n    *array = result;\n    array[1] = size;\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00081496": "reallocate_and_update_array_00081496",
                "param_1": "array",
                "param_2": "size",
                "param_3": "arg_3",
                "param_4": "arg_4",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000814ae"
            ],
            "called": [
                "FUN_00081f9c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814ae": {
            "entrypoint": "0x000814ae",
            "current_name": "check_and_update_array_000814ae",
            "code": "\nundefined4 checkAndUpdateArray_000814ae(int *array,uint size)\n\n{\n  int result;\n  \n  if ((*array == 0) || ((uint)array[1] < size)) {\n    result = reallocate_and_update_array_00081496(array);\n    if (result == 0) {\n      return 0;\n    }\n    if (array[2] == 0) {\n      *(undefined *)*array = 0;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000814ae": "check_and_update_array_000814ae",
                "param_1": "array",
                "param_2": "size",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000814d0",
                "FUN_00081570"
            ],
            "called": [
                "FUN_00081496"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814d0": {
            "entrypoint": "0x000814d0",
            "current_name": "update_and_copy_string_000814d0",
            "code": "\nundefined4 * updateAndCopyString_000814d0(undefined4 *array,undefined4 sourceString,undefined4 newValue)\n\n{\n  int result;\n  \n  result = check_and_update_array_000814ae(array,newValue);\n  if (result == 0) {\n    reset_memory_00081480(array);\n  }\n  else {\n    array[2] = newValue;\n    copy_string_000825cc(*array,sourceString);\n  }\n  return array;\n}\n\n",
            "renaming": {
                "FUN_000814d0": "update_and_copy_string_000814d0",
                "param_1": "array",
                "param_2": "sourceString",
                "param_3": "newValue",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000814f6"
            ],
            "called": [
                "FUN_00081480",
                "FUN_000825cc",
                "FUN_000814ae"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814f6": {
            "entrypoint": "0x000814f6",
            "current_name": "initialize_param_with_zeros_000814f6",
            "code": "\nundefined4 * initialize_param_with_zeros_000814f6(undefined4 *output_array,int input_value)\n\n{\n  undefined4 trailing_zeros_count;\n  \n  *output_array = 0;\n  output_array[1] = 0;\n  output_array[2] = 0;\n  if (input_value != 0) {\n    trailing_zeros_count = count_trailing_zeros_00082688(input_value);\n    update_and_copy_string_000814d0(output_array,input_value,trailing_zeros_count);\n  }\n  return output_array;\n}\n\n",
            "renaming": {
                "FUN_000814f6": "initialize_param_with_zeros_000814f6",
                "param_1": "output_array",
                "param_2": "input_value",
                "uVar1": "trailing_zeros_count"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "FUN_000814d0",
                "FUN_00082688"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008151c": {
            "entrypoint": "0x0008151c",
            "current_name": "copy_and_clear_parameters_0008151c",
            "code": "\nvoid copyAndClearParameters_0008151c(int *destination,int *source)\n\n{\n  if (*destination != 0) {\n    if ((*source != 0) && ((uint)source[2] <= (uint)destination[1])) {\n      copyString();\n      destination[2] = source[2];\n      goto LAB_00081558;\n    }\n    performRelocation();\n  }\n  *destination = *source;\n  destination[1] = source[1];\n  destination[2] = source[2];\n  *source = 0;\n  source[1] = 0;\nLAB_00081558:\n  source[2] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008151c": "copy_and_clear_parameters_0008151c",
                "param_1": "destination",
                "param_2": "source",
                "copy_string_000825cc": "copyString",
                "process_relocation_00081800": "performRelocation"
            },
            "calling": [
                "FUN_00081560"
            ],
            "called": [
                "FUN_00081800",
                "FUN_000825cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081560": {
            "entrypoint": "0x00081560",
            "current_name": "clear_parameters_if_different_00081560",
            "code": "\nint clearParametersIfDifferent_00081560(int inputParam,int comparisonParam)\n\n{\n  if (inputParam != comparisonParam) {\n    copy_and_clear_parameters_0008151c();\n  }\n  return inputParam;\n}\n\n",
            "renaming": {
                "FUN_00081560": "clear_parameters_if_different_00081560",
                "param_1": "inputParam",
                "param_2": "comparisonParam"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008151c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081570": {
            "entrypoint": "0x00081570",
            "current_name": "copy_and_update_string_array_00081570",
            "code": "\nundefined4 copyAndUpdateStringArray_00081570(int *array,int length,int updateOffset)\n\n{\n  int updateResult;\n  int currentOffset;\n  \n  currentOffset = array[2];\n  if (length == 0) {\n    return 0;\n  }\n  if (updateOffset != 0) {\n    updateResult = check_and_update_array_000814ae(array,currentOffset + updateOffset);\n    if (updateResult == 0) {\n      return 0;\n    }\n    copy_string_000825cc(*array + array[2],length);\n    array[2] = currentOffset + updateOffset;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00081570": "copy_and_update_string_array_00081570",
                "param_1": "array",
                "param_2": "length",
                "param_3": "updateOffset",
                "iVar1": "updateResult",
                "iVar2": "currentOffset"
            },
            "calling": [
                "FUN_0008159e"
            ],
            "called": [
                "FUN_000825cc",
                "FUN_000814ae"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008159e": {
            "entrypoint": "0x0008159e",
            "current_name": "copy_and_update_string_array_0008159e",
            "code": "\nvoid copyAndUpdateStringArray_0008159e(undefined4 sourceArray,undefined4 destinationArray,undefined4 arraySize)\n\n{\n  undefined4 tempArray;\n  undefined4 tempValue;\n  \n  tempValue = arraySize;\n  copy_and_update_string_array_00081570(sourceArray,&tempArray,1,0,sourceArray);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008159e": "copy_and_update_string_array_0008159e",
                "param_1": "sourceArray",
                "param_2": "destinationArray",
                "param_3": "arraySize",
                "local_c": "tempArray",
                "uStack_8": "tempValue"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "FUN_00081570"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815b8": {
            "entrypoint": "0x000815b8",
            "current_name": "check_array_values_000815b8",
            "code": "\nint checkArrayValues_000815b8(byte **arrayPtrs,byte *valuePtr)\n\n{\n  uint arrayComparisonResult;\n  int result;\n  \n  if (arrayPtrs[2] == (byte *)0x0) {\n    if (valuePtr == (byte *)0x0) {\n      return 1;\n    }\n  }\n  else {\n    if (valuePtr != (byte *)0x0) {\n      arrayComparisonResult = compare_uint_arrays_00082390(*arrayPtrs);\n      goto LAB_000815d4;\n    }\n    valuePtr = *arrayPtrs;\n  }\n  arrayComparisonResult = (uint)*valuePtr;\nLAB_000815d4:\n  result = 1 - arrayComparisonResult;\n  if (1 < arrayComparisonResult) {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000815b8": "check_array_values_000815b8",
                "param_1": "arrayPtrs",
                "param_2": "valuePtr",
                "uVar1": "arrayComparisonResult",
                "iVar2": "result"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00082390"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815de": {
            "entrypoint": "0x000815de",
            "current_name": "parse_integer_000815de",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000827e8) */\n/* WARNING: Removing unreachable block (ram,0x000827a8) */\n/* WARNING: Removing unreachable block (ram,0x000827a0) */\n/* WARNING: Removing unreachable block (ram,0x000827da) */\n/* WARNING: Removing unreachable block (ram,0x000827ec) */\n/* WARNING: Removing unreachable block (ram,0x000827e4) */\n/* WARNING: Removing unreachable block (ram,0x000827a4) */\n/* WARNING: Removing unreachable block (ram,0x0008278a) */\n/* WARNING: Removing unreachable block (ram,0x000827c8) */\n/* WARNING: Removing unreachable block (ram,0x0008278c) */\n\nuint parseInteger_000815de(byte **byteArray)\n\n{\n  byte byteValue;\n  byte isNegative;\n  uint intValue;\n  byte *bytePointer;\n  uint byteValue2;\n  byte *currentByte;\n  int valueDifference;\n  int lastValue;\n  uint maxValueDividedBy10;\n  uint maxValue;\n  \n  bytePointer = *byteArray;\n  if (*byteArray == (byte *)0x0) {\n    return 0;\n  }\n  do {\n    currentByte = bytePointer;\n    bytePointer = currentByte + 1;\n    byteValue2 = (uint)*currentByte;\n    byteValue = *(byte *)(Elf32_Rel_ARRAY_20070000[270].r_info + byteValue2 + 1);\n    isNegative = byteValue & 8;\n  } while ((byteValue & 8) != 0);\n  if (byteValue2 == 0x2d) {\n    bytePointer = currentByte + 2;\n    byteValue2 = (uint)currentByte[1];\n    isNegative = 1;\n  }\n  else if (byteValue2 == 0x2b) {\n    byteValue2 = (uint)currentByte[1];\n    bytePointer = currentByte + 2;\n  }\n  if (isNegative == 0) {\n    maxValue = 0x7fffffff;\n  }\n  else {\n    maxValue = 0x80000000;\n  }\n  maxValueDividedBy10 = maxValue / 10;\n  lastValue = 0;\n  intValue = 0;\n  do {\n    byteValue = *(byte *)(Elf32_Rel_ARRAY_20070000[270].r_info + byteValue2 + 1);\n    if ((byteValue & 4) == 0) {\n      if ((byteValue & 3) == 0) {\nLAB_0008277e:\n        if (lastValue == -1) {\n          if (isNegative == 0) {\n            intValue = 0x7fffffff;\n          }\n          else {\n            intValue = 0x80000000;\n          }\n          *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x22;\n        }\n        else if (isNegative != 0) {\n          intValue = -intValue;\n        }\n        return intValue;\n      }\n      if ((byteValue & 3) == 1) {\n        valueDifference = 0x37;\n      }\n      else {\n        valueDifference = 0x57;\n      }\n      valueDifference = byteValue2 - valueDifference;\n    }\n    else {\n      valueDifference = byteValue2 - 0x30;\n    }\n    if (9 < valueDifference) goto LAB_0008277e;\n    if (lastValue != -1) {\n      if ((maxValueDividedBy10 <= intValue && intValue != maxValueDividedBy10) || ((intValue == maxValueDividedBy10 && ((int)(maxValue % 10) < valueDifference))))\n      {\n        lastValue = -1;\n      }\n      else {\n        intValue = intValue * 10 + valueDifference;\n        lastValue = 1;\n      }\n    }\n    byteValue2 = (uint)*bytePointer;\n    bytePointer = bytePointer + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000815de": "parse_integer_000815de",
                "param_1": "byteArray",
                "bVar1": "byteValue",
                "bVar2": "isNegative",
                "uVar3": "intValue",
                "pbVar4": "bytePointer",
                "uVar5": "byteValue2",
                "pbVar6": "currentByte",
                "iVar7": "valueDifference",
                "iVar8": "lastValue",
                "uVar9": "maxValueDividedBy10",
                "uVar10": "maxValue"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815e8": {
            "entrypoint": "0x000815e8",
            "current_name": "FUNC_000815e8",
            "code": "\nvoid FUNC_000815e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000815e8": "FUNC_000815e8"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000815ec": {
            "entrypoint": "0x000815ec",
            "current_name": "main_loop_000815ec",
            "code": "\nvoid mainLoop_000815ec(void)\n\n{\n  initializeMemory();\n  initializeApplication();\n  FUNC_000815e8();\n  FUNC_00080f08(1);\n  initializeAndCalculate();\n  do {\n    controlFunction();\n    checkAndHandleDifferences();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000815ec": "main_loop_000815ec",
                "initialize_memory_00081618": "initializeMemory",
                "initialize_application_00080774": "initializeApplication",
                "initialize_and_calculate_000801e0": "initializeAndCalculate",
                "control_function_00080250": "controlFunction",
                "check_and_handle_differences_00080970": "checkAndHandleDifferences"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_000815e8",
                "FUN_00080774",
                "FUN_00080250",
                "FUN_00080970",
                "FUN_00081618",
                "FUN_00080f08",
                "FUN_000801e0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081618": {
            "entrypoint": "0x00081618",
            "current_name": "initialize_memory_00081618",
            "code": "\n\n\nvoid initializeMemory_00081618(void)\n\n{\n  _DAT_400e1a54 = 0x8000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081618": "initialize_memory_00081618"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081624": {
            "entrypoint": "0x00081624",
            "current_name": "calculate_result_00081624",
            "code": "\nint calculateResult_00081624(int index,int condition,int multiplier,undefined4 constant)\n\n{\n  int result;\n  undefined4 value;\n  \n  value = *(undefined4 *)(&DAT_00084b48 + index * 0x1c);\n  if (condition == 0) {\n    value = 0;\n  }\n  result = checkParam(*(int *)(&DAT_00084b44 + index * 0x1c) + 0x3c,\n                       *(undefined4 *)(&DAT_00084b48 + index * 0x1c),value,\n                       ((array[6].r_offset / 1000000) * multiplier) / 0x12,constant);\n  if (result != 0) {\n    result = (int)((ulonglong)(result * 18000 + 16000) /\n                 ((ulonglong)array[6].r_offset / 1000));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00081624": "calculate_result_00081624",
                "param_1": "index",
                "param_2": "condition",
                "param_3": "multiplier",
                "param_4": "constant",
                "iVar1": "result",
                "uVar2": "value",
                "check_param_00081684": "checkParam",
                "Elf32_Rel_ARRAY_20070000": "array"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00081684"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081684": {
            "entrypoint": "0x00081684",
            "current_name": "check_param_00081684",
            "code": "\nint check_param_00081684(uint *param,uint mask,uint expected,int count)\n\n{\n  int index;\n  \n  do {\n    if ((*param & mask) != expected) {\n      do {\n        if ((*param & mask) == expected) {\n          index = 0;\n          do {\n            if ((*param & mask) != expected) {\n              return index;\n            }\n            index = index + 1;\n          } while (count != index);\n          return 0;\n        }\n        count = count + -1;\n      } while (count != 0);\n      return 0;\n    }\n    count = count + -1;\n  } while (count != 0);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00081684": "check_param_00081684",
                "param_1": "param",
                "param_2": "mask",
                "param_3": "expected",
                "param_4": "count",
                "iVar1": "index"
            },
            "calling": [
                "FUN_00081624"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816d8": {
            "entrypoint": "0x000816d8",
            "current_name": "get_data_000816d8",
            "code": "\nundefined4 get_data_000816d8(void)\n\n{\n  return DAT_2007120c;\n}\n\n",
            "renaming": {
                "FUN_000816d8": "get_data_000816d8"
            },
            "calling": [
                "thunk_FUN_000816d8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816ec": {
            "entrypoint": "0x000816ec",
            "current_name": "update_relocation_entry_000816ec",
            "code": "\nvoid updateRelocationEntry_000816ec(dword address,dword value,dword flag)\n\n{\n  dword *currentEntry;\n  uint entryIndex;\n  uint flagMask;\n  code *jumpTable;\n  \n  if (relocationEntries[48].r_offset == 0) {\n    relocationEntries[48].r_offset = 0x20070184;\n  }\n  entryIndex = *(uint *)(relocationEntries[48].r_offset + 4);\n  currentEntry = (dword *)relocationEntries[48].r_offset;\n  if (0x1f < (int)entryIndex) {\n    currentEntry = (dword *)relocate_function_000817f0(400);\n    if (currentEntry == (dword *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x00083652. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*jumpTable)(0xffffffff);\n      return;\n    }\n    *currentEntry = relocationEntries[48].r_offset;\n    currentEntry[1] = 0;\n    entryIndex = 0;\n    relocationEntries[48].r_offset = (dword)currentEntry;\n    currentEntry[0x62] = 0;\n    currentEntry[99] = 0;\n  }\n  flagMask = 1 << (entryIndex & 0xff);\n  currentEntry[entryIndex + 0x22] = address;\n  currentEntry[0x62] = currentEntry[0x62] | flagMask;\n  currentEntry[entryIndex + 0x42] = flag;\n  currentEntry[99] = flagMask | currentEntry[99];\n  currentEntry[1] = entryIndex + 1;\n  currentEntry[entryIndex + 2] = value;\n                    /* WARNING: Could not recover jumptable at 0x00083696. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816ec": "update_relocation_entry_000816ec",
                "param_1": "address",
                "param_2": "value",
                "param_3": "flag",
                "Elf32_Rel_ARRAY_20070000": "relocationEntries",
                "pdVar1": "currentEntry",
                "uVar2": "entryIndex",
                "uVar3": "flagMask",
                "UNRECOVERED_JUMPTABLE_00": "jumpTable"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816f8": {
            "entrypoint": "0x000816f8",
            "current_name": "print_assertion_failed_message_000816f8",
            "code": "\nvoid printAssertionFailedMessage_000816f8(undefined4 file,undefined4 line,char *assertion,undefined4 function)\n\n{\n  undefined4 assertionMessage;\n  undefined4 functionName;\n  char *extraInfo;\n  undefined8 result;\n  \n  assertionMessage = *(undefined4 *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0xc);\n  if (assertion == (char *)0x0) goto LAB_0008171c;\n  functionName = function;\n  extraInfo = \", function: \";\n  do {\n    function = file;\n    perform_function_00081750(assertionMessage,\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",functionName,file,line,\n                 extraInfo,assertion);\n    result = process_and_call_function_000836ec();\n    line = (undefined4)((ulonglong)result >> 0x20);\n    assertionMessage = (undefined4)result;\nLAB_0008171c:\n    assertion = \"\";\n    functionName = function;\n    extraInfo = assertion;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000816f8": "print_assertion_failed_message_000816f8",
                "param_1": "file",
                "param_2": "line",
                "param_3": "assertion",
                "param_4": "function",
                "uVar1": "assertionMessage",
                "uVar2": "functionName",
                "pcVar3": "extraInfo",
                "uVar4": "result"
            },
            "calling": [
                "FUN_000803fc",
                "FUN_00080b2c"
            ],
            "called": [
                "FUN_000836ec",
                "FUN_00081750"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081750": {
            "entrypoint": "0x00081750",
            "current_name": "perform_function_00081750",
            "code": "\nvoid performFunction_00081750(undefined4 input1,undefined4 input2,undefined4 data1,undefined4 data2)\n\n{\n  undefined4 stackData1;\n  undefined4 stackData2;\n  \n  stackData1 = data1;\n  stackData2 = data2;\n  parse_format_string_0008289c(Elf32_Rel_ARRAY_20070000[140].r_offset,input1,input2,&stackData1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081750": "perform_function_00081750",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "data1",
                "param_4": "data2",
                "uStack_8": "stackData1",
                "uStack_4": "stackData2"
            },
            "calling": [
                "FUN_000816f8"
            ],
            "called": [
                "FUN_0008289c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": [],
            "code_backup": "\nvoid FUN_00081750(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  uStack_8 = param_3;\n  uStack_4 = param_4;\n  FUNC_0008289c(Elf32_Rel_ARRAY_20070000[140].r_offset,param_1,param_2,&uStack_8);\n  return;\n}\n\n"
        },
        "FUN_00081778": {
            "entrypoint": "0x00081778",
            "current_name": "run_nested_functions_00081778",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00081784) */\n/* WARNING: Removing unreachable block (ram,0x00081788) */\n/* WARNING: Removing unreachable block (ram,0x000817b4) */\n\nvoid runNestedFunctions_00081778(void)\n\n{\n  int iterationCount;\n  code **functionPointer;\n  \n  FUNC_00085844();\n  functionPointer = (code **)0x8584c;\n  iterationCount = 0;\n  do {\n    iterationCount = iterationCount + 1;\n    functionPointer = functionPointer + 1;\n    (**functionPointer)();\n  } while (iterationCount != 4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081778": "run_nested_functions_00081778",
                "iVar1": "iterationCount",
                "ppcVar2": "functionPointer"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [
                "FUN_000836d8",
                "FUN_00080118",
                "FUN_00085844"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000817c8": {
            "entrypoint": "0x000817c8",
            "current_name": "apply_function_to_stack_and_offset_000817c8",
            "code": "\nvoid applyFunctionToStackAndOffset_000817c8(undefined4 functionOffset,undefined4 stackVar1,undefined4 stackVar2,undefined4 stackVar3)\n\n{\n  undefined4 newStackVar1;\n  undefined4 newStackVar2;\n  undefined4 newStackVar3;\n  \n  newStackVar1 = stackVar1;\n  newStackVar2 = stackVar2;\n  newStackVar3 = stackVar3;\n  parse_format_string_0008289c(Elf32_Rel_ARRAY_20070000[140].r_offset,\n               *(undefined4 *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 8),functionOffset,&newStackVar1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000817c8": "apply_function_to_stack_and_offset_000817c8",
                "param_1": "functionOffset",
                "param_2": "stackVar1",
                "param_3": "stackVar2",
                "param_4": "stackVar3",
                "uStack_c": "newStackVar1",
                "uStack_8": "newStackVar2",
                "uStack_4": "newStackVar3"
            },
            "calling": [
                "FUN_00080eec"
            ],
            "called": [
                "FUN_0008289c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": [],
            "code_backup": "\nvoid FUN_000817c8(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  uStack_c = param_2;\n  uStack_8 = param_3;\n  uStack_4 = param_4;\n  FUNC_0008289c(Elf32_Rel_ARRAY_20070000[140].r_offset,\n               *(undefined4 *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 8),param_1,&uStack_c);\n  return;\n}\n\n"
        },
        "FUN_000817f0": {
            "entrypoint": "0x000817f0",
            "current_name": "relocate_function_000817f0",
            "code": "\nvoid relocateFunction_000817f0(undefined4 param)\n\n{\n  relocate_function_00081810(relArray[140].offset,param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000817f0": "relocate_function_000817f0",
                "param_1": "param",
                "Elf32_Rel_ARRAY_20070000": "relArray",
                "r_offset": "offset"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_00081810"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081800": {
            "entrypoint": "0x00081800",
            "current_name": "process_relocation_00081800",
            "code": "\nvoid processRelocation_00081800(undefined4 param)\n\n{\n  process_relocation_00083b10(relocationArray[140].offset,param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081800": "process_relocation_00081800",
                "param_1": "param",
                "Elf32_Rel_ARRAY_20070000": "relocationArray",
                "r_offset": "offset"
            },
            "calling": [
                "FUN_0008151c",
                "FUN_00081480",
                "FUN_00081472"
            ],
            "called": [
                "FUN_00083b10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081810": {
            "entrypoint": "0x00081810",
            "current_name": "relocate_function_00081810",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * relocateFunction_00081810(undefined4 *inputArray,uint arrayLength)\n\n{\n  dword info1;\n  int tempVar1;\n  uint tempVar2;\n  uint tempVar3;\n  int tempVar4;\n  uint tempVar5;\n  dword offset;\n  uint tempVar6;\n  int tempVar7;\n  undefined *ptr1;\n  dword ptr2;\n  dword ptr3;\n  int tempVar8;\n  dword *ptr4;\n  uint tempVar9;\n  undefined *ptr5;\n  dword *ptr6;\n  uint tempVar10;\n  \n  if (arrayLength + 0xb < 0x17) {\n    tempVar9 = 0x10;\n    if (0x10 < arrayLength) goto LAB_00081876;\n  }\n  else {\n    tempVar9 = arrayLength + 0xb & 0xfffffff8;\n    if (((int)tempVar9 < 0) || (tempVar9 < arrayLength)) {\nLAB_00081876:\n      *inputArray = 0xc;\n      return (int *)0x0;\n    }\n  }\n  FUNC_00081f94(inputArray);\n  info1 = Elf32_Rel_ARRAY_20070000[142].r_info;\n  if (tempVar9 < 0x1f8) {\n    tempVar8 = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8e].r_offset + tempVar9);\n    if ((tempVar8 != tempVar9 + 0x20070464) ||\n       (tempVar1 = tempVar8 + 8, tempVar8 = *(int *)(tempVar8 + 0x14), tempVar1 != tempVar8)) {\n      tempVar4 = *(int *)(tempVar8 + 0xc);\n      tempVar7 = (*(uint *)(tempVar8 + 4) & 0xfffffffc) + tempVar8;\n      tempVar9 = *(uint *)(tempVar7 + 4);\n      tempVar1 = *(int *)(tempVar8 + 8);\n      *(int *)(tempVar1 + 0xc) = tempVar4;\n      *(int *)(tempVar4 + 8) = tempVar1;\n      *(uint *)(tempVar7 + 4) = tempVar9 | 1;\n      FUNC_00081f98(inputArray);\n      return (int *)(tempVar8 + 8);\n    }\n    tempVar10 = (tempVar9 >> 3) + 2;\n  }\n  else {\n    tempVar10 = tempVar9 >> 9;\n    if (tempVar10 == 0) {\n      tempVar1 = 0x7e;\n      tempVar8 = 0x3f;\n    }\n    else if (tempVar10 < 5) {\n      tempVar8 = (tempVar9 >> 6) + 0x38;\n      tempVar1 = tempVar8 * 2;\n    }\n    else if (tempVar10 < 0x15) {\n      tempVar8 = tempVar10 + 0x5b;\n      tempVar1 = tempVar8 * 2;\n    }\n    else if (tempVar10 < 0x55) {\n      tempVar8 = (tempVar9 >> 0xc) + 0x6e;\n      tempVar1 = tempVar8 * 2;\n    }\n    else if (tempVar10 < 0x155) {\n      tempVar8 = (tempVar9 >> 0xf) + 0x77;\n      tempVar1 = tempVar8 * 2;\n    }\n    else if (tempVar10 < 0x555) {\n      tempVar8 = (tempVar9 >> 0x12) + 0x7c;\n      tempVar1 = tempVar8 * 2;\n    }\n    else {\n      tempVar1 = 0xfc;\n      tempVar8 = 0x7e;\n    }\n    for (offset = (&Elf32_Rel_ARRAY_20070000[0x8e].r_offset)[tempVar1]; tempVar1 * 4 + 0x20070464U != offset\n        ; offset = *(dword *)(offset + 0xc)) {\n      tempVar10 = *(uint *)(offset + 4) & 0xfffffffc;\n      tempVar4 = tempVar10 - tempVar9;\n      if (0xf < tempVar4) {\n        tempVar8 = tempVar8 + -1;\n        break;\n      }\n      if (-1 < tempVar4) {\n        tempVar1 = tempVar10 + offset;\n        tempVar9 = *(uint *)(tempVar1 + 4);\n        tempVar4 = *(int *)(offset + 0xc);\n        tempVar8 = *(int *)(offset + 8);\n        *(int *)(tempVar8 + 0xc) = tempVar4;\n        *(int *)(tempVar4 + 8) = tempVar8;\n        *(uint *)(tempVar1 + 4) = tempVar9 | 1;\n        FUNC_00081f98(inputArray);\n        return (int *)(offset + 8);\n      }\n    }\n    tempVar10 = tempVar8 + 1;\n  }\n  offset = Elf32_Rel_ARRAY_20070000[141].r_offset;\n  if (Elf32_Rel_ARRAY_20070000[142].r_info != 0x2007046c) {\n    tempVar2 = *(uint *)(Elf32_Rel_ARRAY_20070000[142].r_info + 4);\n    tempVar3 = tempVar2 & 0xfffffffc;\n    tempVar5 = tempVar3 - tempVar9;\n    if (0xf < (int)tempVar5) {\n      offset = tempVar9 + Elf32_Rel_ARRAY_20070000[142].r_info;\n      *(uint *)(Elf32_Rel_ARRAY_20070000[142].r_info + 4) = tempVar9 | 1;\n      Elf32_Rel_ARRAY_20070000[142].r_info = offset;\n      Elf32_Rel_ARRAY_20070000[143].r_offset = offset;\n      *(undefined4 *)(offset + 0xc) = 0x2007046c;\n      *(undefined4 *)(offset + 8) = 0x2007046c;\n      *(uint *)(offset + 4) = tempVar5 | 1;\n      *(uint *)(offset + tempVar5) = tempVar5;\n      FUNC_00081f98(inputArray);\n      return (int *)(info1 + 8);\n    }\n    Elf32_Rel_ARRAY_20070000[143].r_offset = 0x2007046c;\n    Elf32_Rel_ARRAY_20070000[142].r_info = 0x2007046c;\n    if (-1 < (int)tempVar5) {\n      *(uint *)(tempVar3 + info1 + 4) = *(uint *)(tempVar3 + info1 + 4) | 1;\n      FUNC_00081f98(inputArray);\n      return (int *)(info1 + 8);\n    }\n    if (tempVar3 < 0x200) {\n      tempVar3 = tempVar2 & 0xfffffff8;\n      tempVar8 = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + tempVar3);\n      offset = 1 << ((int)(tempVar2 >> 3) >> 2 & 0xffU) | Elf32_Rel_ARRAY_20070000[141].r_offset;\n      *(int *)(info1 + 8) = tempVar8;\n      *(uint *)(info1 + 0xc) = tempVar3 + 0x20070464;\n      Elf32_Rel_ARRAY_20070000[141].r_offset = offset;\n      *(dword *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + tempVar3) = info1;\n      *(dword *)(tempVar8 + 0xc) = info1;\n    }\n    else {\n      tempVar5 = tempVar2 >> 9;\n      if (tempVar5 < 5) {\n        tempVar1 = (tempVar2 >> 6) + 0x38;\n        tempVar8 = tempVar1 * 2;\n      }\n      else if (tempVar5 < 0x15) {\n        tempVar1 = tempVar5 + 0x5b;\n        tempVar8 = tempVar1 * 2;\n      }\n      else if (tempVar5 < 0x55) {\n        tempVar1 = (tempVar2 >> 0xc) + 0x6e;\n        tempVar8 = tempVar1 * 2;\n      }\n      else if (tempVar5 < 0x155) {\n        tempVar1 = (tempVar2 >> 0xf) + 0x77;\n        tempVar8 = tempVar1 * 2;\n      }\n      else if (tempVar5 < 0x555) {\n        tempVar1 = (tempVar2 >> 0x12) + 0x7c;\n        tempVar8 = tempVar1 * 2;\n      }\n      else {\n        tempVar8 = 0xfc;\n        tempVar1 = 0x7e;\n      }\n      offset = tempVar8 * 4 + 0x20070464;\n      ptr2 = (&Elf32_Rel_ARRAY_20070000[0x8d].r_info)[tempVar8];\n      if (ptr2 == offset) {\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << (tempVar1 >> 2 & 0xffU);\n        ptr3 = ptr2;\n      }\n      else {\n        do {\n          ptr3 = ptr2;\n          if ((*(uint *)(ptr2 + 4) & 0xfffffffc) <= tempVar3) break;\n          ptr2 = *(dword *)(ptr2 + 8);\n          ptr3 = ptr2;\n        } while (offset != ptr2);\n        ptr2 = *(dword *)(ptr3 + 0xc);\n      }\n      offset = Elf32_Rel_ARRAY_20070000[141].r_offset;\n      *(dword *)(info1 + 0xc) = ptr2;\n      *(dword *)(info1 + 8) = ptr3;\n      *(dword *)(ptr2 + 8) = info1;\n      *(dword *)(ptr3 + 0xc) = info1;\n    }\n  }\n  info1 = Elf32_Rel_ARRAY_20070000[141].r_info;\n  tempVar2 = 1 << ((int)tempVar10 >> 2 & 0xffU);\n  if (tempVar2 <= offset) {\n    if ((offset & tempVar2) == 0) {\n      tempVar10 = tempVar10 & 0xfffffffc;\n      do {\n        tempVar2 = tempVar2 << 1;\n        tempVar10 = tempVar10 + 4;\n      } while ((offset & tempVar2) == 0);\n    }\n    do {\n      ptr6 = &Elf32_Rel_ARRAY_20070000[tempVar10 + 0x8c].r_info;\n      ptr4 = ptr6;\n      tempVar3 = tempVar10;\n      do {\n        for (ptr1 = (undefined *)ptr4[3]; ptr4 != (dword *)ptr1;\n            ptr1 = *(undefined **)(ptr1 + 0xc)) {\n          tempVar5 = *(uint *)(ptr1 + 4) & 0xfffffffc;\n          tempVar6 = tempVar5 - tempVar9;\n          if (0xf < (int)tempVar6) {\n            tempVar1 = *(int *)(ptr1 + 8);\n            tempVar8 = *(int *)(ptr1 + 0xc);\n            ptr5 = ptr1 + tempVar9;\n            *(uint *)(ptr1 + 4) = tempVar9 | 1;\n            *(int *)(tempVar1 + 0xc) = tempVar8;\n            *(int *)(tempVar8 + 8) = tempVar1;\n            Elf32_Rel_ARRAY_20070000[142].r_info = (dword)ptr5;\n            Elf32_Rel_ARRAY_20070000[143].r_offset = (dword)ptr5;\n            *(undefined4 *)(ptr5 + 0xc) = 0x2007046c;\n            *(undefined4 *)(ptr5 + 8) = 0x2007046c;\n            *(uint *)(ptr5 + 4) = tempVar6 | 1;\n            *(uint *)(ptr5 + tempVar6) = tempVar6;\n            FUNC_00081f98(inputArray);\n            return (int *)(ptr1 + 8);\n          }\n          if (-1 < (int)tempVar6) {\n            tempVar8 = *(int *)(ptr1 + 8);\n            tempVar1 = *(int *)(ptr1 + 0xc);\n            *(uint *)(ptr1 + tempVar5 + 4) = *(uint *)(ptr1 + tempVar5 + 4) | 1;\n            *(int *)(tempVar8 + 0xc) = tempVar1;\n            *(int *)(tempVar1 + 8) = tempVar8;\n            FUNC_00081f98(inputArray);\n            return (int *)(ptr1 + 8);\n          }\n        }\n        tempVar3 = tempVar3 + 1;\n        ptr4 = ptr4 + 2;\n      } while ((tempVar3 & 3) != 0);\n      do {\n        tempVar5 = tempVar10 & 3;\n        ptr1 = (undefined *)(ptr6 + -2);\n        tempVar10 = tempVar10 - 1;\n        if (tempVar5 == 0) {\n          Elf32_Rel_ARRAY_20070000[141].r_offset = Elf32_Rel_ARRAY_20070000[141].r_offset & ~tempVar2;\n          break;\n        }\n        ptr6 = (dword *)*ptr6;\n      } while (ptr6 == (dword *)ptr1);\n      tempVar2 = tempVar2 * 2;\n      if ((Elf32_Rel_ARRAY_20070000[141].r_offset <= tempVar2 &&\n           tempVar2 - Elf32_Rel_ARRAY_20070000[141].r_offset != 0) || (tempVar10 = tempVar3, tempVar2 == 0))\n      break;\n      for (; (Elf32_Rel_ARRAY_20070000[141].r_offset & tempVar2) == 0; tempVar2 = tempVar2 << 1) {\n        tempVar10 = tempVar10 + 4;\n      }\n    } while( true );\n  }\n  tempVar10 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n  if ((tempVar9 <= tempVar10) &&\n     (tempVar2 = tempVar10 - tempVar9, offset = Elf32_Rel_ARRAY_20070000[141].r_info, 0xf < (int)tempVar2))\n  goto LAB_00081b1a;\n  tempVar2 = Elf32_Rel_ARRAY_20070000[141].r_info + tempVar10;\n  if (Elf32_Rel_ARRAY_20070000[270].r_offset == 0xffffffff) {\n    tempVar3 = tempVar9 + DAT_20071218 + 0x10;\n  }\n  else {\n    tempVar3 = tempVar9 + DAT_20071218 + 0x100f & 0xfffff000;\n  }\n  offset = calculate_and_check_sum_0008236c(inputArray,tempVar3);\n  if ((offset == 0xffffffff) || ((offset < tempVar2 && (info1 != 0x20070464)))) {\n    tempVar10 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n    offset = Elf32_Rel_ARRAY_20070000[141].r_info;\n  }\n  else {\n    tempVar5 = DAT_2007121c + tempVar3;\n    DAT_2007121c = tempVar5;\n    if ((tempVar2 == offset) && ((tempVar2 & 0xfff) == 0)) {\n      *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = tempVar3 + tempVar10 | 1;\n    }\n    else {\n      ptr2 = offset;\n      if (Elf32_Rel_ARRAY_20070000[270].r_offset != 0xffffffff) {\n        ptr2 = Elf32_Rel_ARRAY_20070000[270].r_offset;\n        DAT_2007121c = tempVar5 + (offset - tempVar2);\n      }\n      Elf32_Rel_ARRAY_20070000[270].r_offset = ptr2;\n      tempVar2 = offset & 7;\n      if (tempVar2 == 0) {\n        tempVar8 = 0x1000;\n      }\n      else {\n        offset = offset + (8 - tempVar2);\n        tempVar8 = 0x1008 - tempVar2;\n      }\n      tempVar8 = tempVar8 - (tempVar3 + offset & 0xfff);\n      tempVar1 = calculate_and_check_sum_0008236c(inputArray,tempVar8);\n      if (tempVar1 == -1) {\n        tempVar2 = 1;\n        tempVar8 = 0;\n      }\n      else {\n        tempVar2 = (tempVar1 - offset) + tempVar8 | 1;\n      }\n      tempVar5 = DAT_2007121c + tempVar8;\n      Elf32_Rel_ARRAY_20070000[141].r_info = offset;\n      DAT_2007121c = tempVar5;\n      *(uint *)(offset + 4) = tempVar2;\n      if (info1 != 0x20070464) {\n        if (tempVar10 < 0x10) {\n          *(undefined4 *)(offset + 4) = 1;\n          tempVar10 = 0;\n          goto LAB_00081b04;\n        }\n        tempVar10 = tempVar10 - 0xc & 0xfffffff8;\n        *(uint *)(info1 + 4) = tempVar10 | *(uint *)(info1 + 4) & 1;\n        *(undefined4 *)(info1 + tempVar10 + 4) = 5;\n        *(undefined4 *)(info1 + tempVar10 + 8) = 5;\n        if (0xf < tempVar10) {\n          process_relocation_00083b10(inputArray,info1 + 8);\n          tempVar5 = DAT_2007121c;\n        }\n      }\n    }\n    if (DAT_20071214 < tempVar5) {\n      DAT_20071214 = tempVar5;\n    }\n    if (DAT_20071210 < tempVar5) {\n      DAT_20071210 = tempVar5;\n    }\n    tempVar10 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n    offset = Elf32_Rel_ARRAY_20070000[141].r_info;\n  }\nLAB_00081b04:\n  tempVar2 = tempVar10 - tempVar9;\n  if ((tempVar10 < tempVar9) || ((int)tempVar2 < 0x10)) {\n    FUNC_00081f98(inputArray);\n    return (int *)0x0;\n  }\nLAB_00081b1a:\n  Elf32_Rel_ARRAY_20070000[141].r_info = tempVar9 + offset;\n  *(uint *)(offset + 4) = tempVar9 | 1;\n  *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = tempVar2 | 1;\n  FUNC_00081f98(inputArray);\n  return (int *)(offset + 8);\n}\n\n",
            "renaming": {
                "FUN_00081810": "relocate_function_00081810",
                "param_1": "inputArray",
                "param_2": "arrayLength",
                "dVar1": "info1",
                "iVar2": "tempVar1",
                "uVar3": "tempVar2",
                "uVar4": "tempVar3",
                "iVar5": "tempVar4",
                "uVar6": "tempVar5",
                "dVar7": "offset",
                "uVar8": "tempVar6",
                "iVar9": "tempVar7",
                "puVar10": "ptr1",
                "dVar11": "ptr2",
                "dVar12": "ptr3",
                "iVar13": "tempVar8",
                "pdVar14": "ptr4",
                "uVar15": "tempVar9",
                "puVar16": "ptr5",
                "pdVar17": "ptr6",
                "uVar18": "tempVar10"
            },
            "calling": [
                "FUN_00083ca8",
                "FUN_00084018",
                "FUN_000817f0",
                "FUN_00081fac"
            ],
            "called": [
                "FUN_0008236c",
                "FUN_00081f94",
                "FUN_00081f98",
                "FUN_00083b10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d48": {
            "entrypoint": "0x00081d48",
            "current_name": "memcpy_aligned_00081d48",
            "code": "\nundefined4 * memcpy_aligned_00081d48(undefined4 *dst,undefined4 *src,uint size)\n\n{\n  undefined4 *dst_ptr;\n  undefined4 *dst_ptr;\n  undefined4 *src_ptr;\n  uint size_remaining;\n  uint copy_count;\n  bool loop_flag;\n  \n  dst_ptr = dst;\n  if ((((uint)src | (uint)dst) & 3) != 0) {\n    if (size < 8) {\n      copy_count = size - 4;\n      if (3 < size) {\n        do {\n          dst_ptr = src;\n          src_ptr = dst_ptr;\n          loop_flag = copy_count != 0;\n          copy_count = copy_count - 1;\n          *(undefined *)src_ptr = *(undefined *)dst_ptr;\n          dst_ptr = (undefined4 *)((int)src_ptr + 1);\n          src = (undefined4 *)((int)dst_ptr + 1);\n        } while (loop_flag);\n        *(undefined *)(undefined4 *)((int)src_ptr + 1) =\n             *(undefined *)(undefined4 *)((int)dst_ptr + 1);\n        *(undefined *)((int)src_ptr + 2) = *(undefined *)((int)dst_ptr + 2);\n        *(undefined *)((int)src_ptr + 3) = *(undefined *)((int)dst_ptr + 3);\n        return dst;\n      }\n      goto LAB_00081dcc;\n    }\n    if ((((uint)src & 3) != 0) && (((uint)dst & 3) != 0)) {\n      copy_count = 4 - ((uint)dst & 3);\n      size = size - copy_count;\n      dst_ptr = dst;\n      src_ptr = src;\n      if (((uint)dst & 1) != 0) {\n        src_ptr = (undefined4 *)((int)src + 1);\n        dst_ptr = (undefined4 *)((int)dst + 1);\n        *(undefined *)dst = *(undefined *)src;\n      }\n      dst_ptr = dst_ptr;\n      src = src_ptr;\n      if ((copy_count & 2) != 0) {\n        src = (undefined4 *)((int)src_ptr + 2);\n        dst_ptr = (undefined4 *)((int)dst_ptr + 2);\n        *(undefined2 *)dst_ptr = *(undefined2 *)src_ptr;\n      }\n    }\n  }\n  while (0x3f < size) {\n    *dst_ptr = *src;\n    dst_ptr[1] = src[1];\n    dst_ptr[2] = src[2];\n    dst_ptr[3] = src[3];\n    dst_ptr[4] = src[4];\n    dst_ptr[5] = src[5];\n    dst_ptr[6] = src[6];\n    dst_ptr[7] = src[7];\n    dst_ptr[8] = src[8];\n    dst_ptr[9] = src[9];\n    dst_ptr[10] = src[10];\n    dst_ptr[0xb] = src[0xb];\n    dst_ptr[0xc] = src[0xc];\n    dst_ptr[0xd] = src[0xd];\n    dst_ptr[0xe] = src[0xe];\n    dst_ptr[0xf] = src[0xf];\n    dst_ptr = dst_ptr + 0x10;\n    src = src + 0x10;\n    size = size - 0x40;\n  }\n  size_remaining = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n      *dst_ptr = *src;\n      dst_ptr[1] = src[1];\n      dst_ptr[2] = src[2];\n      dst_ptr[3] = src[3];\n      dst_ptr = dst_ptr + 4;\n      src = src + 4;\n      loop_flag = 0xf < size_remaining;\n      size_remaining = size_remaining - 0x10;\n    } while (loop_flag);\n  }\n  copy_count = size_remaining + 0xc;\n  src_ptr = dst_ptr;\n  dst_ptr = src;\n  if (0xfffffff3 < size_remaining) {\n    do {\n      src = dst_ptr + 1;\n      *src_ptr = *dst_ptr;\n      loop_flag = 3 < copy_count;\n      copy_count = copy_count - 4;\n      dst_ptr = src_ptr + 1;\n      src_ptr = src_ptr + 1;\n      dst_ptr = src;\n    } while (loop_flag);\n  }\nLAB_00081dcc:\n  if (copy_count + 4 != 0) {\n    dst_ptr = dst_ptr;\n    src_ptr = src;\n    if ((copy_count & 1) != 0) {\n      src_ptr = (undefined4 *)((int)src + 1);\n      dst_ptr = (undefined4 *)((int)dst_ptr + 1);\n      *(undefined *)dst_ptr = *(undefined *)src;\n    }\n    if ((copy_count + 4 & 2) != 0) {\n      *(undefined2 *)dst_ptr = *(undefined2 *)src_ptr;\n    }\n  }\n  return dst;\n}\n\n",
            "renaming": {
                "FUN_00081d48": "memcpy_aligned_00081d48",
                "param_1": "dst",
                "param_2": "src",
                "param_3": "size",
                "puVar1": "dst_ptr",
                "puVar2": "dst_ptr",
                "puVar3": "src_ptr",
                "uVar4": "size_remaining",
                "uVar5": "copy_count",
                "bVar6": "loop_flag"
            },
            "calling": [
                "FUN_00083ca8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081e34": {
            "entrypoint": "0x00081e34",
            "current_name": "copy_memory_00081e34",
            "code": "\nvoid copyMemory_00081e34(undefined4 *dest,undefined4 *src,uint size)\n\n{\n  int count;\n  undefined4 *destPtr;\n  undefined4 *srcPtr;\n  undefined4 *tempPtr;\n  uint remainingSize;\n  undefined *temp;\n  uint modSize;\n  \n  if ((src < dest) && (tempPtr = (undefined4 *)((int)src + size), dest < tempPtr)) {\n    temp = (undefined *)((int)dest + size);\n    count = size - 1;\n    if (size != 0) {\n      do {\n        tempPtr = (undefined4 *)((int)tempPtr + -1);\n        count = count + -1;\n        temp = temp + -1;\n        *temp = *(undefined *)tempPtr;\n      } while (count != -1);\n    }\n    return;\n  }\n  if (size < 0x10) {\n    if (size == 0) {\n      return;\n    }\n  }\n  else if ((((uint)dest | (uint)src) & 3) == 0) {\n    tempPtr = dest;\n    srcPtr = src;\n    do {\n      destPtr = tempPtr + 4;\n      *tempPtr = *srcPtr;\n      tempPtr[1] = srcPtr[1];\n      tempPtr[2] = srcPtr[2];\n      tempPtr[3] = srcPtr[3];\n      tempPtr = destPtr;\n      srcPtr = srcPtr + 4;\n    } while (destPtr != (undefined4 *)((int)dest + (size - 0x10 & 0xfffffff0) + 0x10));\n    count = (size - 0x10 >> 4) + 1;\n    modSize = size & 0xf;\n    src = src + count * 4;\n    dest = dest + count * 4;\n    remainingSize = modSize;\n    tempPtr = dest;\n    srcPtr = src;\n    if (3 < modSize) {\n      do {\n        remainingSize = remainingSize - 4;\n        *tempPtr = *srcPtr;\n        tempPtr = tempPtr + 1;\n        srcPtr = srcPtr + 1;\n      } while (3 < remainingSize);\n      count = (modSize - 4 & 0xfffffffc) + 4;\n      dest = (undefined4 *)((int)dest + count);\n      src = (undefined4 *)((int)src + count);\n      modSize = size & 3;\n    }\n    size = modSize;\n    if (size == 0) {\n      return;\n    }\n  }\n  tempPtr = dest;\n  do {\n    srcPtr = (undefined4 *)((int)tempPtr + 1);\n    *(undefined *)tempPtr = *(undefined *)src;\n    src = (undefined4 *)((int)src + 1);\n    tempPtr = srcPtr;\n  } while (srcPtr != (undefined4 *)(size + (int)dest));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081e34": "copy_memory_00081e34",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "puVar2": "destPtr",
                "puVar3": "srcPtr",
                "puVar4": "tempPtr",
                "uVar5": "remainingSize",
                "puVar6": "temp",
                "uVar7": "modSize",
                "iVar1": "count"
            },
            "calling": [
                "FUN_00083ca8",
                "FUN_00081fac"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f00": {
            "entrypoint": "0x00081f00",
            "current_name": "fill_memory_with_byte_00081f00",
            "code": "\nvoid fillMemoryWithByte_00081f00(undefined4 *dest,undefined byte,uint size)\n\n{\n  undefined4 *destPtr;\n  undefined4 *nextPtr;\n  undefined4 pattern;\n  uint remainingSize;\n  bool isZero;\n  \n  if (((uint)dest & 3) != 0) {\n    isZero = size == 0;\n    destPtr = dest;\n    size = size - 1;\n    if (isZero) {\n      return;\n    }\n    while( true ) {\n      dest = (undefined4 *)((int)destPtr + 1);\n      *(undefined *)destPtr = byte;\n      if (((uint)dest & 3) == 0) break;\n      isZero = size == 0;\n      destPtr = dest;\n      size = size - 1;\n      if (isZero) {\n        return;\n      }\n    }\n  }\n  if (3 < size) {\n    pattern = CONCAT22(CONCAT11(byte,byte),CONCAT11(byte,byte));\n    remainingSize = size;\n    destPtr = dest;\n    if (0xf < size) {\n      remainingSize = size - 0x10;\n      do {\n        *destPtr = pattern;\n        destPtr[1] = pattern;\n        destPtr[2] = pattern;\n        destPtr[3] = pattern;\n        destPtr = destPtr + 4;\n      } while (destPtr != (undefined4 *)((int)dest + (remainingSize & 0xfffffff0) + 0x10));\n      size = size & 0xf;\n      dest = dest + ((remainingSize >> 4) + 1) * 4;\n      remainingSize = size;\n      destPtr = dest;\n      if (size < 4) goto LAB_00081f7c;\n    }\n    do {\n      size = size - 4;\n      *dest = pattern;\n      dest = dest + 1;\n    } while (3 < size);\n    dest = (undefined4 *)((int)destPtr + (remainingSize - 4 & 0xfffffffc) + 4);\n    size = remainingSize & 3;\n  }\nLAB_00081f7c:\n  if (size != 0) {\n    destPtr = dest;\n    do {\n      nextPtr = (undefined4 *)((int)destPtr + 1);\n      *(undefined *)destPtr = byte;\n      destPtr = nextPtr;\n    } while (nextPtr != (undefined4 *)(size + (int)dest));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f00": "fill_memory_with_byte_00081f00",
                "param_1": "dest",
                "param_2": "byte",
                "param_3": "size",
                "puVar1": "destPtr",
                "puVar2": "nextPtr",
                "uVar3": "pattern",
                "uVar4": "remainingSize",
                "bVar5": "isZero"
            },
            "calling": [
                "FUN_00083888",
                "FUN_000811b0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f94": {
            "entrypoint": "0x00081f94",
            "current_name": "FUNC_00081f94",
            "code": "\nvoid FUNC_00081f94(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f94": "FUNC_00081f94"
            },
            "calling": [
                "FUN_00083a74",
                "FUN_00083b10",
                "FUN_00081fac",
                "FUN_00081810"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f98": {
            "entrypoint": "0x00081f98",
            "current_name": "FUNC_00081f98",
            "code": "\nvoid FUNC_00081f98(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f98": "FUNC_00081f98"
            },
            "calling": [
                "FUN_00083a74",
                "FUN_00083b10",
                "FUN_00081fac",
                "FUN_00081810"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f9c": {
            "entrypoint": "0x00081f9c",
            "current_name": "reallocate_memory_00081f9c",
            "code": "\nvoid reallocateMemory_00081f9c(undefined4 offset,undefined4 param)\n\n{\n  reallocate_memory_00081fac(relArray[140].r_offset,offset,param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f9c": "reallocate_memory_00081f9c",
                "param_1": "offset",
                "param_2": "param",
                "Elf32_Rel_ARRAY_20070000": "relArray"
            },
            "calling": [
                "FUN_00081496"
            ],
            "called": [
                "FUN_00081fac"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081fac": {
            "entrypoint": "0x00081fac",
            "current_name": "reallocate_memory_00081fac",
            "code": "\nint * reallocateMemory_00081fac(undefined4 *functionPtr,int *allocatedMemory,uint size)\n\n{\n  dword temp;\n  int *newMemory;\n  uint tempSize;\n  int tempVar;\n  uint allocatedSize;\n  int tempVar2;\n  int *tempPtr;\n  uint adjustedSize;\n  uint roundedSize;\n  int *relocatedMemory;\n  \n  if (allocatedMemory == (int *)0x0) {\n    newMemory = (int *)relocate_function_00081810(functionPtr,size);\n    return newMemory;\n  }\n  FUNC_00081f94();\n  allocatedSize = allocatedMemory[-1];\n  adjustedSize = allocatedSize & 0xfffffffc;\n  newMemory = allocatedMemory + -2;\n  if (size + 0xb < 0x17) {\n    roundedSize = 0x10;\n  }\n  else {\n    roundedSize = size + 0xb & 0xfffffff8;\n    if ((int)roundedSize < 0) goto LAB_00082078;\n  }\n  if (roundedSize < size) {\nLAB_00082078:\n    *functionPtr = 0xc;\n    return (int *)0x0;\n  }\n  if ((int)adjustedSize < (int)roundedSize) {\n    temp = (int)newMemory + adjustedSize;\n    if (Elf32_Rel_ARRAY_20070000[141].r_info == temp) {\n      tempSize = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n      temp = Elf32_Rel_ARRAY_20070000[141].r_info;\n      if ((int)(roundedSize + 0x10) <= (int)(tempSize + adjustedSize)) {\n        Elf32_Rel_ARRAY_20070000[141].r_info = (int)newMemory + roundedSize;\n        *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = (tempSize + adjustedSize) - roundedSize | 1;\n        allocatedMemory[-1] = roundedSize | allocatedMemory[-1] & 1U;\n        FUNC_00081f98(functionPtr);\n        return allocatedMemory;\n      }\n    }\n    else if ((*(uint *)((*(uint *)(temp + 4) & 0xfffffffe) + temp + 4) & 1) == 0) {\n      tempSize = *(uint *)(temp + 4) & 0xfffffffc;\n      if ((int)roundedSize <= (int)(tempSize + adjustedSize)) {\n        tempVar2 = *(int *)(temp + 0xc);\n        tempVar = *(int *)(temp + 8);\n        *(int *)(tempVar + 0xc) = tempVar2;\n        *(int *)(tempVar2 + 8) = tempVar;\n        adjustedSize = tempSize + adjustedSize;\n        goto LAB_00082088;\n      }\n    }\n    else {\n      tempSize = 0;\n      temp = 0;\n    }\n    if (-1 < (int)(allocatedSize << 0x1f)) {\n      relocatedMemory = (int *)((int)newMemory - allocatedMemory[-2]);\n      allocatedSize = (relocatedMemory[1] & 0xfffffffcU) + adjustedSize;\n      if (temp != 0) {\n        if (temp == Elf32_Rel_ARRAY_20070000[141].r_info) {\n          if ((int)(roundedSize + 0x10) <= (int)(tempSize + allocatedSize)) {\n            newMemory = relocatedMemory + 2;\n            tempVar = *newMemory;\n            tempVar2 = relocatedMemory[3];\n            adjustedSize = adjustedSize - 4;\n            *(int *)(tempVar + 0xc) = tempVar2;\n            *(int *)(tempVar2 + 8) = tempVar;\n            if (adjustedSize < 0x25) {\n              tempPtr = newMemory;\n              if (0x13 < adjustedSize) {\n                relocatedMemory[2] = *allocatedMemory;\n                relocatedMemory[3] = allocatedMemory[1];\n                if (adjustedSize < 0x1c) {\n                  allocatedMemory = allocatedMemory + 2;\n                  tempPtr = relocatedMemory + 4;\n                }\n                else {\n                  relocatedMemory[4] = allocatedMemory[2];\n                  relocatedMemory[5] = allocatedMemory[3];\n                  if (adjustedSize == 0x24) {\n                    relocatedMemory[6] = allocatedMemory[4];\n                    tempPtr = allocatedMemory + 5;\n                    allocatedMemory = allocatedMemory + 6;\n                    relocatedMemory[7] = *tempPtr;\n                    tempPtr = relocatedMemory + 8;\n                  }\n                  else {\n                    allocatedMemory = allocatedMemory + 4;\n                    tempPtr = relocatedMemory + 6;\n                  }\n                }\n              }\n              *tempPtr = *allocatedMemory;\n              tempPtr[1] = allocatedMemory[1];\n              tempPtr[2] = allocatedMemory[2];\n            }\n            else {\n              copy_memory_00081e34(newMemory,allocatedMemory);\n            }\n            Elf32_Rel_ARRAY_20070000[141].r_info = (int)relocatedMemory + roundedSize;\n            *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = (tempSize + allocatedSize) - roundedSize | 1;\n            relocatedMemory[1] = roundedSize | relocatedMemory[1] & 1U;\n            FUNC_00081f98(functionPtr);\n            return newMemory;\n          }\n        }\n        else {\n          tempSize = tempSize + allocatedSize;\n          if ((int)roundedSize <= (int)tempSize) {\n            tempVar2 = *(int *)(temp + 0xc);\n            tempVar = *(int *)(temp + 8);\n            *(int *)(tempVar + 0xc) = tempVar2;\n            *(int *)(tempVar2 + 8) = tempVar;\n            tempPtr = relocatedMemory + 2;\n            tempVar = *tempPtr;\n            tempVar2 = relocatedMemory[3];\n            allocatedSize = adjustedSize - 4;\n            *(int *)(tempVar + 0xc) = tempVar2;\n            *(int *)(tempVar2 + 8) = tempVar;\n            adjustedSize = tempSize;\n            if (allocatedSize < 0x25) {\n              newMemory = tempPtr;\n              if (0x13 < allocatedSize) {\n                relocatedMemory[2] = *allocatedMemory;\n                relocatedMemory[3] = allocatedMemory[1];\n                if (allocatedSize < 0x1c) {\n                  allocatedMemory = allocatedMemory + 2;\n                  newMemory = relocatedMemory + 4;\n                }\n                else {\n                  relocatedMemory[4] = allocatedMemory[2];\n                  relocatedMemory[5] = allocatedMemory[3];\n                  if (allocatedSize == 0x24) {\n                    relocatedMemory[6] = allocatedMemory[4];\n                    newMemory = allocatedMemory + 5;\n                    allocatedMemory = allocatedMemory + 6;\n                    relocatedMemory[7] = *newMemory;\n                    newMemory = relocatedMemory + 8;\n                  }\n                  else {\n                    allocatedMemory = allocatedMemory + 4;\n                    newMemory = relocatedMemory + 6;\n                  }\n                }\n              }\n              *newMemory = *allocatedMemory;\n              newMemory[1] = allocatedMemory[1];\n              newMemory[2] = allocatedMemory[2];\n              allocatedSize = relocatedMemory[1];\n              newMemory = relocatedMemory;\n              allocatedMemory = tempPtr;\n            }\n            else {\n              copy_memory_00081e34(tempPtr,allocatedMemory);\n              allocatedSize = relocatedMemory[1];\n              newMemory = relocatedMemory;\n              allocatedMemory = tempPtr;\n            }\n            goto LAB_00082088;\n          }\n        }\n      }\n      if ((int)roundedSize <= (int)allocatedSize) {\n        tempPtr = relocatedMemory + 2;\n        tempVar = *tempPtr;\n        tempVar2 = relocatedMemory[3];\n        tempSize = adjustedSize - 4;\n        *(int *)(tempVar + 0xc) = tempVar2;\n        *(int *)(tempVar2 + 8) = tempVar;\n        adjustedSize = allocatedSize;\n        if (tempSize < 0x25) {\n          newMemory = tempPtr;\n          if (0x13 < tempSize) {\n            relocatedMemory[2] = *allocatedMemory;\n            relocatedMemory[3] = allocatedMemory[1];\n            if (tempSize < 0x1c) {\n              allocatedMemory = allocatedMemory + 2;\n              newMemory = relocatedMemory + 4;\n            }\n            else {\n              relocatedMemory[4] = allocatedMemory[2];\n              relocatedMemory[5] = allocatedMemory[3];\n              if (tempSize == 0x24) {\n                relocatedMemory[6] = allocatedMemory[4];\n                newMemory = allocatedMemory + 5;\n                allocatedMemory = allocatedMemory + 6;\n                relocatedMemory[7] = *newMemory;\n                newMemory = relocatedMemory + 8;\n              }\n              else {\n                allocatedMemory = allocatedMemory + 4;\n                newMemory = relocatedMemory + 6;\n              }\n            }\n          }\n          *newMemory = *allocatedMemory;\n          newMemory[1] = allocatedMemory[1];\n          newMemory[2] = allocatedMemory[2];\n          allocatedSize = relocatedMemory[1];\n          newMemory = relocatedMemory;\n          allocatedMemory = tempPtr;\n        }\n        else {\n          copy_memory_00081e34(tempPtr,allocatedMemory);\n          allocatedSize = relocatedMemory[1];\n          newMemory = relocatedMemory;\n          allocatedMemory = tempPtr;\n        }\n        goto LAB_00082088;\n      }\n    }\n    relocatedMemory = (int *)relocate_function_00081810(functionPtr,size);\n    if (relocatedMemory == (int *)0x0) goto LAB_000820a0;\n    allocatedSize = allocatedMemory[-1];\n    if (relocatedMemory + -2 != (int *)((allocatedSize & 0xfffffffe) + (int)newMemory)) {\n      adjustedSize = adjustedSize - 4;\n      if (adjustedSize < 0x25) {\n        newMemory = allocatedMemory;\n        tempPtr = relocatedMemory;\n        if (0x13 < adjustedSize) {\n          *relocatedMemory = *allocatedMemory;\n          relocatedMemory[1] = allocatedMemory[1];\n          if (adjustedSize < 0x1c) {\n            newMemory = allocatedMemory + 2;\n            tempPtr = relocatedMemory + 2;\n          }\n          else {\n            relocatedMemory[2] = allocatedMemory[2];\n            relocatedMemory[3] = allocatedMemory[3];\n            if (adjustedSize == 0x24) {\n              relocatedMemory[4] = allocatedMemory[4];\n              relocatedMemory[5] = allocatedMemory[5];\n              newMemory = allocatedMemory + 6;\n              tempPtr = relocatedMemory + 6;\n            }\n            else {\n              newMemory = allocatedMemory + 4;\n              tempPtr = relocatedMemory + 4;\n            }\n          }\n        }\n        *tempPtr = *newMemory;\n        tempPtr[1] = newMemory[1];\n        tempPtr[2] = newMemory[2];\n      }\n      else {\n        copy_memory_00081e34(relocatedMemory,allocatedMemory);\n      }\n      process_relocation_00083b10(functionPtr,allocatedMemory);\n      goto LAB_000820a0;\n    }\n    adjustedSize = adjustedSize + (relocatedMemory[-1] & 0xfffffffcU);\n  }\nLAB_00082088:\n  tempSize = adjustedSize - roundedSize;\n  relocatedMemory = allocatedMemory;\n  if (tempSize < 0x10) {\n    newMemory[1] = allocatedSize & 1 | adjustedSize;\n    *(uint *)((int)newMemory + adjustedSize + 4) = *(uint *)((int)newMemory + adjustedSize + 4) | 1;\n  }\n  else {\n    newMemory[1] = allocatedSize & 1 | roundedSize;\n    *(uint *)((int)newMemory + roundedSize + 4) = tempSize | 1;\n    *(uint *)((int)newMemory + tempSize + roundedSize + 4) = *(uint *)((int)newMemory + tempSize + roundedSize + 4) | 1;\n    process_relocation_00083b10(functionPtr,(int)newMemory + roundedSize + 8);\n  }\nLAB_000820a0:\n  FUNC_00081f98(functionPtr);\n  return relocatedMemory;\n}\n\n",
            "renaming": {
                "FUN_00081fac": "reallocate_memory_00081fac",
                "param_1": "functionPtr",
                "param_2": "allocatedMemory",
                "param_3": "size",
                "dVar1": "temp",
                "piVar2": "newMemory",
                "uVar3": "tempSize",
                "iVar4": "tempVar",
                "uVar5": "allocatedSize",
                "iVar6": "tempVar2",
                "piVar7": "tempPtr",
                "uVar8": "adjustedSize",
                "uVar9": "roundedSize",
                "piVar10": "relocatedMemory"
            },
            "calling": [
                "FUN_00083ca8",
                "FUN_00081f9c"
            ],
            "called": [
                "FUN_00081f94",
                "FUN_00081e34",
                "FUN_00081f98",
                "FUN_00083b10",
                "FUN_00081810"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008236c": {
            "entrypoint": "0x0008236c",
            "current_name": "calculate_and_check_sum_0008236c",
            "code": "\nvoid calculate_and_check_sum_0008236c(int *result_ptr,undefined4 input_value)\n\n{\n  int sum_result;\n  \n  DAT_20071244 = 0;\n  sum_result = calculate_sum_00080e88(input_value);\n  if ((sum_result == -1) && (DAT_20071244 != 0)) {\n    *result_ptr = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008236c": "calculate_and_check_sum_0008236c",
                "param_1": "result_ptr",
                "param_2": "input_value",
                "iVar1": "sum_result"
            },
            "calling": [
                "FUN_00083a74",
                "FUN_00081810"
            ],
            "called": [
                "FUN_00080e88"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082390": {
            "entrypoint": "0x00082390",
            "current_name": "compare_uint_arrays_00082390",
            "code": "\nint compare_uint_arrays_00082390(uint *array1,uint *array2)\n\n{\n  uint *ptr1;\n  int result;\n  uint *ptr2;\n  uint *ptr3;\n  uint value1;\n  uint value2;\n  uint value3;\n  uint value4;\n  uint value5;\n  \n  if ((((uint)array1 | (uint)array2) & 7) != 0) {\n    ptr1 = array1;\n    if (((uint)array1 & 3) != 0) {\n      ptr1 = (uint *)((uint)array1 & 0xfffffffc) + 1;\n      value1 = *(uint *)((uint)array1 & 0xfffffffc);\n      ptr2 = array2;\n      if (((uint)array1 & 1) == 0) {\nLAB_00082410:\n        ptr3 = (uint *)((int)ptr2 + 1);\n        value2 = value1 >> 0x10 & 0xff;\n        result = value2 - *(byte *)ptr2;\n        if (result != 0) {\n          return result;\n        }\n        if (value2 == 0) {\n          return 0;\n        }\n      }\n      else {\n        ptr3 = array2;\n        if (((uint)array1 & 2) == 0) {\n          ptr2 = (uint *)((int)array2 + 1);\n          value2 = value1 >> 8 & 0xff;\n          result = value2 - *(byte *)array2;\n          if (result != 0) {\n            return result;\n          }\n          if (value2 == 0) {\n            return 0;\n          }\n          goto LAB_00082410;\n        }\n      }\n      array2 = (uint *)((int)ptr3 + 1);\n      result = (value1 >> 0x18) - (uint)*(byte *)ptr3;\n      if ((result != 0) || (value1 >> 0x18 == 0)) {\n        return result;\n      }\n    }\n    value1 = (uint)array2 & 3;\n    if (value1 != 0) {\n      array2 = (uint *)((uint)array2 & 0xfffffffc);\n      if (value1 == 2) {\n        value1 = *array2;\n        do {\n          array2 = array2 + 1;\n          value3 = *ptr1;\n          value1 = value1 >> 0x10;\n          value4 = value3 + 0xfefefeff & ~value3;\n          value5 = value4 & 0x80808080;\n          value2 = value3 & 0xffff;\n          if ((value4 & 0x8080) != 0 || value2 != value1) goto LAB_0008258e;\n          value1 = *array2;\n          value2 = value2 ^ value3;\n          value3 = value1 * 0x10000;\n          ptr1 = ptr1 + 1;\n        } while (value5 == 0 && value2 == value3);\n      }\n      else if (value1 < 2) {\n        value1 = *array2;\n        do {\n          array2 = array2 + 1;\n          value3 = *ptr1;\n          value1 = value1 >> 8;\n          value4 = value3 + 0xfefefeff & ~value3;\n          value5 = value4 & 0x80808080;\n          value2 = value3 & 0xffffff;\n          if ((value4 & 0x808080) != 0 || value2 != value1) goto LAB_0008258e;\n          value1 = *array2;\n          value2 = value2 ^ value3;\n          value3 = value1 * 0x1000000;\n          ptr1 = ptr1 + 1;\n        } while (value5 == 0 && value2 == value3);\n      }\n      else {\n        value1 = *array2;\n        do {\n          array2 = array2 + 1;\n          value3 = *ptr1;\n          value1 = value1 >> 0x18;\n          value4 = value3 + 0xfefefeff & ~value3;\n          value5 = value4 & 0x80808080;\n          value2 = value3 & 0xff;\n          if ((value4 & 0x80) != 0 || value2 != value1) goto LAB_0008258e;\n          value1 = *array2;\n          value2 = value2 ^ value3;\n          value3 = value1 * 0x100;\n          ptr1 = ptr1 + 1;\n        } while (value5 == 0 && value2 == value3);\n      }\n      value2 = value2 << 0x18 | (value2 >> 8 & 0xff) << 0x10 | (value2 >> 0x10 & 0xff) << 8 |\n              value2 >> 0x18;\n      value1 = (value3 >> 8 & 0xff) << 0x10 | (value3 >> 0x10 & 0xff) << 8 | value3 >> 0x18;\n      goto LAB_0008259e;\n    }\n    array1 = ptr1;\n    ptr2 = array2;\n    if (((uint)ptr1 & 4) != 0) {\n      array1 = ptr1 + 1;\n      value1 = *ptr1;\n      ptr2 = array2 + 1;\n      value3 = *array2;\n      value5 = value1 + 0xfefefeff & ~value1 & 0x80808080;\n      if (value1 != value3 || value5 != 0) {\nLAB_0008259a:\n        value2 = value1 << 0x18 | (value1 >> 8 & 0xff) << 0x10 | (value1 >> 0x10 & 0xff) << 8 |\n                value1 >> 0x18;\n        value1 = value3 << 0x18 | (value3 >> 8 & 0xff) << 0x10 | (value3 >> 0x10 & 0xff) << 8 |\n                value3 >> 0x18;\n        goto LAB_0008259e;\n      }\n    }\n    array2 = ptr2;\n    if (((uint)ptr2 & 4) != 0) {\n      value1 = *ptr2;\n      ptr1 = ptr2 + 1;\n      do {\n        value2 = *array1;\n        value3 = array1[1];\n        value5 = value2 + 0xfefefeff & ~value2 & 0x80808080;\n        if (value2 != value1 || value5 != 0) goto LAB_0008258e;\n        value4 = *ptr1;\n        value1 = ptr1[1];\n        value5 = value3 + 0xfefefeff & ~value3 & 0x80808080;\n        array1 = array1 + 2;\n        ptr1 = ptr1 + 2;\n      } while (value3 == value4 && value5 == 0);\n      value2 = value3 << 0x18 | (value3 >> 8 & 0xff) << 0x10 | (value3 >> 0x10 & 0xff) << 8 |\n              value3 >> 0x18;\n      value1 = value4 << 0x18 | (value4 >> 8 & 0xff) << 0x10 | (value4 >> 0x10 & 0xff) << 8 |\n              value4 >> 0x18;\n      goto LAB_0008259e;\n    }\n  }\n  do {\n    value1 = *array1;\n    value2 = array1[1];\n    value3 = *array2;\n    value4 = array2[1];\n    value5 = value1 + 0xfefefeff & ~value1 & 0x80808080;\n    if (value1 != value3 || value5 != 0) goto LAB_0008259a;\n    value5 = value2 + 0xfefefeff & ~value2 & 0x80808080;\n    array1 = array1 + 2;\n    array2 = array2 + 2;\n  } while (value2 == value4 && value5 == 0);\n  value2 = value2 << 0x18 | (value2 >> 8 & 0xff) << 0x10 | (value2 >> 0x10 & 0xff) << 8 | value2 >> 0x18;\n  value1 = value4 << 0x18 | (value4 >> 8 & 0xff) << 0x10 | (value4 >> 0x10 & 0xff) << 8 | value4 >> 0x18;\nLAB_0008259e:\n  value3 = value5 << 0x18 | (value5 >> 8 & 0xff) << 0x10 | (value5 >> 0x10 & 0xff) << 8 | value5 >> 0x18;\n  if (value3 != 0) {\n    value3 = 0x18 - LZCOUNT(value3);\n    value2 = value2 >> (value3 & 0xff);\n    value1 = value1 >> (value3 & 0xff);\n  }\n  result = 1;\n  if (value2 <= value1) {\n    result = -(uint)(value2 < value1);\n  }\n  return result;\nLAB_0008258e:\n  value2 = value2 << 0x18 | (value2 >> 8 & 0xff) << 0x10 | (value2 >> 0x10 & 0xff) << 8 | value2 >> 0x18;\n  value1 = value1 << 0x18 | (value1 >> 8 & 0xff) << 0x10 | (value1 >> 0x10 & 0xff) << 8 | value1 >> 0x18;\n  goto LAB_0008259e;\n}\n\n",
            "renaming": {
                "FUN_00082390": "compare_uint_arrays_00082390",
                "param_1": "array1",
                "param_2": "array2",
                "puVar1": "ptr1",
                "iVar2": "result",
                "puVar3": "ptr2",
                "puVar4": "ptr3",
                "uVar5": "value1",
                "uVar6": "value2",
                "uVar7": "value3",
                "uVar8": "value4",
                "uVar9": "value5"
            },
            "calling": [
                "FUN_000815b8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000825cc": {
            "entrypoint": "0x000825cc",
            "current_name": "copy_string_000825cc",
            "code": "\nvoid copyString_000825cc(uint *destination,uint *source)\n\n{\n  char currentChar;\n  ushort currentShort;\n  uint *nextPointer;\n  uint *nextPointer2;\n  uint currentInt;\n  uint temp;\n  uint *destinationPointer;\n  bool isZeroByte;\n  \n  if ((((uint)destination ^ (uint)source) & 3) != 0) {\n    do {\n      currentChar = *(char *)source;\n      *(char *)destination = currentChar;\n      source = (uint *)((int)source + 1);\n      destination = (uint *)((int)destination + 1);\n    } while (currentChar != '\\0');\n    return;\n  }\n  if (((uint)source & 3) != 0) {\n    nextPointer2 = source;\n    if (((uint)source & 1) != 0) {\n      nextPointer2 = (uint *)((int)source + 1);\n      currentChar = *(char *)source;\n      *(char *)destination = currentChar;\n      destination = (uint *)((int)destination + 1);\n      if (currentChar == '\\0') {\n        return;\n      }\n    }\n    source = nextPointer2;\n    if (((uint)nextPointer2 & 2) != 0) {\n      source = (uint *)((int)nextPointer2 + 2);\n      currentShort = *(ushort *)nextPointer2;\n      isZeroByte = (currentShort & 0xff) == 0;\n      if (isZeroByte) {\n        *(char *)destination = (char)currentShort;\n      }\n      else {\n        *(ushort *)destination = currentShort;\n        isZeroByte = (currentShort & 0xff00) == 0;\n        destination = (uint *)((int)destination + 2);\n      }\n      if (isZeroByte) {\n        return;\n      }\n    }\n  }\n  currentInt = *source;\n  nextPointer2 = source + 1;\n  destinationPointer = destination;\n  if (((uint)source & 4) != 0) {\n    if ((currentInt + 0xfefefeff & ~currentInt & 0x80808080) != 0) goto LAB_00082630;\n    destinationPointer = destination + 1;\n    *destination = currentInt;\n    nextPointer2 = source + 2;\n    currentInt = source[1];\n  }\n  while( true ) {\n    nextPointer = nextPointer2 + 1;\n    temp = *nextPointer2;\n    destination = destinationPointer;\n    if ((currentInt + 0xfefefeff & ~currentInt & 0x80808080) != 0) break;\n    destination = destinationPointer + 1;\n    *destinationPointer = currentInt;\n    currentInt = temp;\n    if ((temp + 0xfefefeff & ~temp & 0x80808080) != 0) break;\n    nextPointer2 = nextPointer2 + 2;\n    currentInt = *nextPointer;\n    destinationPointer = destinationPointer + 2;\n    *destination = temp;\n  }\nLAB_00082630:\n  do {\n    *(char *)destination = (char)currentInt;\n    temp = currentInt & 0xff;\n    currentInt = currentInt >> 8 | currentInt << 0x18;\n    destination = (uint *)((int)destination + 1);\n  } while (temp != 0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000825cc": "copy_string_000825cc",
                "param_1": "destination",
                "param_2": "source",
                "cVar1": "currentChar",
                "uVar2": "currentShort",
                "puVar3": "nextPointer",
                "puVar4": "nextPointer2",
                "uVar5": "currentInt",
                "uVar6": "temp",
                "puVar7": "destinationPointer",
                "bVar8": "isZeroByte"
            },
            "calling": [
                "FUN_000814d0",
                "FUN_00081570",
                "FUN_0008151c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082688": {
            "entrypoint": "0x00082688",
            "current_name": "count_trailing_zeros_00082688",
            "code": "\nint countTrailingZeros_00082688(uint input)\n\n{\n  int trailingZerosCount;\n  uint *pInput;\n  uint inputValue;\n  bool isZero;\n  \n  pInput = (uint *)(input & 0xfffffffc);\n  trailingZerosCount = -(input & 3);\n  inputValue = *pInput;\n  if ((input & 3) != 0) {\n    inputValue = inputValue | 0xffffffffU >> ((trailingZerosCount + 4U & 0x1f) << 3);\n  }\n  while (pInput = pInput + 1, (inputValue + 0xfefefeff & ~inputValue & 0x80808080) == 0) {\n    trailingZerosCount = trailingZerosCount + 4;\n    inputValue = *pInput;\n  }\n  isZero = (inputValue & 0xff) == 0;\n  if (!isZero) {\n    trailingZerosCount = trailingZerosCount + 1;\n    isZero = (inputValue & 0xff00) == 0;\n  }\n  if (!isZero) {\n    trailingZerosCount = trailingZerosCount + 1;\n    isZero = (inputValue & 0xff0000) == 0;\n  }\n  if (!isZero) {\n    trailingZerosCount = trailingZerosCount + 1;\n  }\n  return trailingZerosCount;\n}\n\n",
            "renaming": {
                "FUN_00082688": "count_trailing_zeros_00082688",
                "param_1": "input",
                "iVar1": "trailingZerosCount",
                "puVar2": "pInput",
                "uVar3": "inputValue",
                "bVar4": "isZero"
            },
            "calling": [
                "FUN_000814f6",
                "FUN_000810a6",
                "FUN_0008289c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082824": {
            "entrypoint": "0x00082824",
            "current_name": "process_binary_data_00082824",
            "code": "\nint processBinaryData_00082824(undefined4 data,int length,int **dataList)\n\n{\n  int *dataPtr;\n  int result;\n  int *currentData;\n  uint iteration;\n  undefined4 *dataPtr2;\n  uint dataSize;\n  uint numIterations;\n  \n  if (-1 < *(int *)(length + 100) << 0x12) {\n    result = relocate_and_copy_data_00083ca8();\n    dataList[2] = (int *)0x0;\n    dataList[1] = (int *)0x0;\n    return result;\n  }\n  currentData = dataList[2];\n  dataPtr = *dataList;\n  while (currentData != (int *)0x0) {\n    dataSize = dataPtr[1];\n    numIterations = dataSize >> 2;\n    if (numIterations != 0) {\n      dataPtr2 = (undefined4 *)(*dataPtr + -4);\n      iteration = 0;\n      do {\n        dataPtr2 = dataPtr2 + 1;\n        result = process_binary_data_000839b4(data,*dataPtr2,length);\n        iteration = iteration + 1;\n        if (result == -1) goto LAB_00082864;\n      } while (numIterations != iteration);\n      currentData = dataList[2];\n    }\n    currentData = (int *)((int)currentData - (dataSize & 0xfffffffc));\n    dataList[2] = currentData;\n    dataPtr = dataPtr + 2;\n  }\n  result = 0;\nLAB_00082864:\n  dataList[2] = (int *)0x0;\n  dataList[1] = (int *)0x0;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082824": "process_binary_data_00082824",
                "param_1": "data",
                "param_2": "length",
                "param_3": "dataList",
                "piVar1": "dataPtr",
                "iVar2": "result",
                "piVar3": "currentData",
                "uVar4": "iteration",
                "puVar5": "dataPtr2",
                "uVar6": "dataSize",
                "uVar7": "numIterations"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_00083ca8",
                "FUN_000839b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008289c": {
            "entrypoint": "0x0008289c",
            "current_name": "parse_format_string_0008289c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint parseFormatString_0008289c(int arg1,int arg2,int *******formatString,int **args)\n\n{\n  bool isNegative;\n  bool hasSign;\n  bool hasSharp;\n  char sign;\n  bool hasZero;\n  int ********localVarsPointer;\n  int *localVar7;\n  int result;\n  char tempChar;\n  int *******formatStringPointer;\n  uint tempVar11;\n  int **localVar12;\n  uint tempVar13;\n  uint currentChar;\n  int tempVar15;\n  int ********localVarsPointer16;\n  int tempVar17;\n  int *******formatStringPointer18;\n  int *localVar19;\n  int *******tempVar20;\n  uint tempVar21;\n  int *localVar22;\n  int *******tempVar23;\n  undefined4 tempVar24;\n  int ********localVarsPointer25;\n  bool tempVar26;\n  longlong combinedVars;\n  int *******totalWidthPointer;\n  int *******argWidthPointer;\n  int **currentArgPointer;\n  int resultSize;\n  char *formatChars;\n  char signChar;\n  undefined zeroChar;\n  undefined hexFlagChar;\n  int ********localVarsPointer;\n  int numArgsProcessed;\n  int *******argsPointer;\n  undefined tempChar90;\n  char tempChar6a;\n  undefined tempChar69;\n  undefined localVarsArray [4];\n  int *******local64 [16];\n  \n  if ((arg1 != 0) && (*(int *)(arg1 + 0x38) == 0)) {\n    initialize_data_structures_00083888();\n  }\n  tempVar13 = (uint)*(ushort *)(arg2 + 0xc);\n  if (-1 < (int)((uint)*(ushort *)(arg2 + 0xc) << 0x12)) {\n    tempVar13 = tempVar13 | 0x2000;\n    *(short *)(arg2 + 0xc) = (short)tempVar13;\n    *(uint *)(arg2 + 100) = *(uint *)(arg2 + 100) & 0xffffdfff;\n  }\n  if (((int)(tempVar13 << 0x1c) < 0) && (*(int *)(arg2 + 0x10) != 0)) {\n    if ((tempVar13 & 0x1a) != 10) goto LAB_000828ee;\n  }\n  else {\n    result = initialize_relocation_0008356c(arg1,arg2);\n    if (result != 0) {\n      return -1;\n    }\n    if ((*(ushort *)(arg2 + 0xc) & 0x1a) != 10) goto LAB_000828ee;\n  }\n  if (-1 < *(short *)(arg2 + 0xe)) {\n    result = process_data_000834f0(arg1,arg2,formatString,args);\n    return result;\n  }\nLAB_000828ee:\n  formatChars = (char *)0x0;\n  argsPointer = (int *******)0x0;\n  numArgsProcessed = 0;\n  resultSize = 0;\n  localVarsPointer = (int ********)localVarsArray;\n  currentArgPointer = args;\n  localVarsPointer = (int ********)localVarsArray;\nLAB_00082902:\n  formatStringPointer = formatString;\n  if ((*(char *)formatString != '\\0') && (*(char *)formatString != '%')) {\n    do {\n      formatStringPointer = (int *******)((int)formatStringPointer + 1);\n      if (*(char *)formatStringPointer == '\\0') break;\n    } while (*(char *)formatStringPointer != '%');\n    tempVar20 = (int *******)((int)formatStringPointer - (int)formatString);\n    if (tempVar20 != (int *******)0x0) {\n      numArgsProcessed = numArgsProcessed + 1;\n      argsPointer = (int *******)((int)argsPointer + (int)tempVar20);\n      *localVarsPointer = formatString;\n      localVarsPointer[1] = tempVar20;\n      if (numArgsProcessed < 8) {\n        localVarsPointer = localVarsPointer + 2;\n      }\n      else {\n        if (argsPointer == (int *******)0x0) {\n          resultSize = resultSize + (int)tempVar20;\n          numArgsProcessed = 0;\n          localVarsPointer = (int ********)localVarsArray;\n          goto LAB_00082952;\n        }\n        result = process_binary_data_00082824(arg1,arg2,&localVarsPointer);\n        localVarsPointer = (int ********)localVarsArray;\n        if (result != 0) goto LAB_00083142;\n      }\n      resultSize = resultSize + (int)tempVar20;\n    }\n  }\nLAB_00082952:\n  if (*(char *)formatStringPointer != '\\0') {\n    signChar = '\\0';\n    currentChar = (uint)*(byte *)((int)formatStringPointer + 1);\n    tempVar13 = 0;\n    hasZero = false;\n    hasSign = false;\n    isNegative = false;\n    hasSharp = false;\n    tempVar26 = false;\n    tempVar20 = (int *******)0x0;\n    argWidthPointer = (int *******)0xffffffff;\n    formatString = (int *******)((int)formatStringPointer + 1);\nLAB_00082976:\n    formatString = (int *******)((int)formatString + 1);\nLAB_0008297a:\n    switch(currentChar) {\n    case 0x20:\n      goto switchD_00082984_caseD_20;\n    default:\n      if (currentChar != 0) {\n        totalWidthPointer = (int *******)0x1;\n        argWidthPointer = (int *******)0x1;\n        localVarsPointer25 = (int ********)&tempChar90;\n        tempChar90 = (char)currentChar;\n        goto LAB_00082d76;\n      }\n      goto LAB_00083134;\n    case 0x23:\n      hasSharp = true;\n      currentChar = (uint)*(byte *)formatString;\n      goto LAB_00082976;\n    case 0x2a:\n      tempVar20 = (int *******)*currentArgPointer;\n      currentArgPointer = currentArgPointer + 1;\n      if ((int)tempVar20 < 0) {\n        tempVar20 = (int *******)-(int)tempVar20;\n        goto switchD_00082984_caseD_2d;\n      }\n      currentChar = (uint)*(byte *)formatString;\n      goto LAB_00082976;\n    case 0x2b:\n      currentChar = (uint)*(byte *)formatString;\n      signChar = '+';\n      goto LAB_00082976;\n    case 0x2d:\nswitchD_00082984_caseD_2d:\n      tempVar13 = tempVar13 | 4;\n      currentChar = (uint)*(byte *)formatString;\n      goto LAB_00082976;\n    case 0x2e:\n      currentChar = (uint)*(byte *)formatString;\n      formatStringPointer = (int *******)((int)formatString + 1);\n      if (currentChar == 0x2a) {\n        currentChar = (uint)*(byte *)((int)formatString + 1);\n        argWidthPointer = (int *******)*currentArgPointer;\n        currentArgPointer = currentArgPointer + 1;\n        formatString = formatStringPointer;\n        if ((int)argWidthPointer < 0) {\n          argWidthPointer = (int *******)0xffffffff;\n        }\n        goto LAB_00082976;\n      }\n      tempVar11 = currentChar - 0x30;\n      if (tempVar11 < 10) {\n        tempVar21 = 0;\n        do {\n          formatString = (int *******)((int)formatStringPointer + 1);\n          currentChar = (uint)*(byte *)formatStringPointer;\n          tempVar21 = tempVar11 + tempVar21 * 10;\n          tempVar11 = currentChar - 0x30;\n          formatStringPointer = formatString;\n        } while (tempVar11 < 10);\n        argWidthPointer = (int *******)(tempVar21 | (int)tempVar21 >> 0x1f);\n      }\n      else {\n        argWidthPointer = (int *******)0x0;\n        formatString = formatStringPointer;\n      }\n      goto LAB_0008297a;\n    case 0x30:\n      tempVar13 = tempVar13 | 0x80;\n      currentChar = (uint)*(byte *)formatString;\n      goto LAB_00082976;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_00082984_caseD_31;\n    case 0x44:\n      hasSign = true;\n      if (isNegative == false) goto LAB_00082d8c;\nLAB_00082bfc:\n      currentArgPointer = (int **)((int)currentArgPointer + 7U & 0xfffffff8);\n      localVar19 = *currentArgPointer;\n      localVar22 = currentArgPointer[1];\n      currentArgPointer = currentArgPointer + 2;\n      goto LAB_00082c10;\n    case 0x4f:\n      hasSign = true;\n      if (isNegative != false) goto LAB_00082aa6;\nLAB_00082c8e:\n      result = (uint)hasSign << 4;\n      tempVar15 = (uint)isNegative << 5;\n      if ((hasSign == 0) && (tempVar15 = (uint)tempVar26 << 6, tempVar26 != 0)) {\n        localVar19 = (int *)(uint)*(ushort *)currentArgPointer;\n        currentArgPointer = currentArgPointer + 1;\n        localVar22 = (int *)0x0;\n      }\n      else {\n        result = tempVar15;\n        localVar19 = *currentArgPointer;\n        currentArgPointer = currentArgPointer + 1;\n        localVar22 = (int *)0x0;\n      }\n      break;\n    case 0x55:\n      hasSign = true;\n      if (isNegative != false) goto LAB_00082bc6;\nLAB_00082ce0:\n      if ((hasSign) || (tempVar26 == false)) {\n        result = 1;\n        localVar19 = *currentArgPointer;\n        currentArgPointer = currentArgPointer + 1;\n        localVar22 = (int *)0x0;\n      }\n      else {\n        localVar22 = (int *)0x0;\n        localVar19 = (int *)(uint)*(ushort *)currentArgPointer;\n        currentArgPointer = currentArgPointer + 1;\n        result = 1;\n      }\n      break;\n    case 0x58:\n      formatChars = \"0123456789ABCDEF\";\n      if (isNegative == false) goto LAB_00082efa;\nLAB_00082d1a:\n      localVar12 = (int **)((int)currentArgPointer + 7U & 0xfffffff8);\n      currentArgPointer = localVar12 + 2;\n      localVar19 = *localVar12;\n      localVar22 = localVar12[1];\n      goto LAB_00082d2e;\n    case 99:\n      localVar19 = *currentArgPointer;\n      currentArgPointer = currentArgPointer + 1;\n      totalWidthPointer = (int *******)0x1;\n      tempChar90 = SUB41(localVar19,0);\n      argWidthPointer = (int *******)0x1;\n      localVarsPointer25 = (int ********)&tempChar90;\n      goto LAB_00082d76;\n    case 100:\n    case 0x69:\n      if (isNegative != false) goto LAB_00082bfc;\nLAB_00082d8c:\n      if ((hasSign == false) && (tempVar26 != false)) {\n        localVar19 = (int *)(int)*(short *)currentArgPointer;\n        currentArgPointer = currentArgPointer + 1;\n        localVar22 = (int *)((int)localVar19 >> 0x1f);\n      }\n      else {\n        localVar19 = *currentArgPointer;\n        currentArgPointer = currentArgPointer + 1;\n        localVar22 = (int *)((int)localVar19 >> 0x1f);\n      }\nLAB_00082c10:\n      if ((int)localVar22 < 0) {\n        tempVar26 = localVar19 != (int *)0x0;\n        localVar19 = (int *)-(int)localVar19;\n        localVar22 = (int *)(-(int)localVar22 - (uint)tempVar26);\n        signChar = '-';\n        sign = '-';\n        result = 1;\n        goto LAB_00082ace;\n      }\n      if (-1 < (int)argWidthPointer) {\n        tempVar13 = tempVar13 & 0xffffff7f;\n      }\n      hasZero = false;\n      currentChar = (uint)localVar19 | (uint)localVar22;\n      result = 1;\n      sign = signChar;\n      goto joined_r0x00082adc;\n    case 0x68:\n      tempVar26 = true;\n      currentChar = (uint)*(byte *)formatString;\n      goto LAB_00082976;\n    case 0x6c:\n      currentChar = (uint)*(byte *)formatString;\n      if (currentChar == 0x6c) {\n        isNegative = true;\n        currentChar = (uint)*(byte *)((int)formatString + 1);\n        formatString = (int *******)((int)formatString + 1);\n      }\n      else {\n        hasSign = true;\n      }\n      goto LAB_00082976;\n    case 0x6e:\n      if (isNegative == false) {\n        if (hasSign == false) {\n          if (tempVar26) {\n            localVar19 = *currentArgPointer;\n            currentArgPointer = currentArgPointer + 1;\n            *(short *)localVar19 = (short)resultSize;\n          }\n          else {\n            localVar19 = *currentArgPointer;\n            currentArgPointer = currentArgPointer + 1;\n            *localVar19 = resultSize;\n          }\n        }\n        else {\n          localVar19 = *currentArgPointer;\n          currentArgPointer = currentArgPointer + 1;\n          *localVar19 = resultSize;\n        }\n      }\n      else {\n        localVar19 = *currentArgPointer;\n        currentArgPointer = currentArgPointer + 1;\n        *localVar19 = resultSize;\n        localVar19[1] = resultSize >> 0x1f;\n      }\n      goto LAB_00082902;\n    case 0x6f:\n      if (isNegative == false) goto LAB_00082c8e;\nLAB_00082aa6:\n      localVar12 = (int **)((int)currentArgPointer + 7U & 0xfffffff8);\n      currentArgPointer = localVar12 + 2;\n      localVar19 = *localVar12;\n      localVar22 = localVar12[1];\n      result = 0;\n      break;\n    case 0x70:\n      localVar19 = *currentArgPointer;\n      currentArgPointer = currentArgPointer + 1;\n      hexFlagChar = 0x78;\n      hasZero = true;\n      localVar22 = (int *)0x0;\n      zeroChar = 0x30;\n      formatChars = \"0123456789abcdef\";\n      result = 2;\n      break;\n    case 0x71:\n      isNegative = true;\n      currentChar = (uint)*(byte *)formatString;\n      goto LAB_00082976;\n    case 0x73:\n      localVarsPointer25 = (int ********)*currentArgPointer;\n      signChar = '\\0';\n      currentArgPointer = currentArgPointer + 1;\n      if (localVarsPointer25 != (int ********)0x0) {\n        if ((int)argWidthPointer < 0) {\n          argWidthPointer = (int *******)count_trailing_zeros_00082688(localVarsPointer25);\n          formatStringPointer = (int *******)0x0;\n          sign = signChar;\n        }\n        else {\n          result = find_character_000840f8(localVarsPointer25,0,argWidthPointer);\n          sign = signChar;\n          if (result == 0) {\n            formatStringPointer = (int *******)0x0;\n          }\n          else {\n            formatStringPointer18 = (int *******)(result - (int)localVarsPointer25);\n            if ((int)argWidthPointer <= (int)(int *******)(result - (int)localVarsPointer25)) {\n              formatStringPointer18 = argWidthPointer;\n            }\n            formatStringPointer = (int *******)0x0;\n            argWidthPointer = formatStringPointer18;\n          }\n        }\n        goto LAB_00082b04;\n      }\n      if ((int *******)0x5 < argWidthPointer) {\n        argWidthPointer = (int *******)0x6;\n      }\n      totalWidthPointer = (int *******)((uint)argWidthPointer & ~((int)argWidthPointer >> 0x1f));\n      localVarsPointer25 = (int ********)&UNK_00085728;\nLAB_00082d76:\n      signChar = '\\0';\n      formatStringPointer = (int *******)0x0;\n      goto LAB_00082b1e;\n    case 0x75:\n      if (!isNegative) goto LAB_00082ce0;\nLAB_00082bc6:\n      localVar12 = (int **)((int)currentArgPointer + 7U & 0xfffffff8);\n      currentArgPointer = localVar12 + 2;\n      localVar19 = *localVar12;\n      localVar22 = localVar12[1];\n      result = 1;\n      break;\n    case 0x78:\n      formatChars = \"0123456789abcdef\";\n      if (isNegative != false) goto LAB_00082d1a;\nLAB_00082efa:\n      if ((hasSign == false) && (tempVar26 != false)) {\n        localVar22 = (int *)0x0;\n        localVar19 = (int *)(uint)*(ushort *)currentArgPointer;\n        currentArgPointer = currentArgPointer + 1;\n      }\n      else {\n        localVar19 = *currentArgPointer;\n        currentArgPointer = currentArgPointer + 1;\n        localVar22 = (int *)0x0;\n      }\nLAB_00082d2e:\n      if ((hasSharp) && (((uint)localVar19 | (uint)localVar22) != 0)) {\n        hasZero = true;\n        zeroChar = 0x30;\n        result = 2;\n        hexFlagChar = (char)currentChar;\n      }\n      else {\n        result = 2;\n      }\n    }\n    signChar = '\\0';\n    sign = '\\0';\nLAB_00082ace:\n    if (-1 < (int)argWidthPointer) {\n      tempVar13 = tempVar13 & 0xffffff7f;\n    }\n    currentChar = (uint)localVar19 | (uint)localVar22;\njoined_r0x00082adc:\n    combinedVars = CONCAT44(localVar22,localVar19);\n    formatStringPointer = argWidthPointer;\n    if ((currentChar == 0) && (argWidthPointer == (int *******)0x0)) {\n      localVarsPointer25 = (int ********)localVarsArray;\n      if ((result != 0) || (!hasSharp)) goto LAB_00082b04;\n      localVarsPointer25 = (int ********)(&tempChar6a + 1);\n      tempChar69 = '0';\n      goto LAB_00082afe;\n    }\n    if (result == 1) {\n      if (localVar22 != (int *)0x0 || (int *)0x9 < localVar19) {\n        localVarsPointer16 = (int ********)(&tempChar6a + 1);\n        do {\n          localVarsPointer25 = localVarsPointer16;\n          tempVar24 = (undefined4)((ulonglong)combinedVars >> 0x20);\n          tempChar = '\\n';\n          calculate_difference_00084530((int)combinedVars,tempVar24,10,0);\n          *(char *)localVarsPointer25 = tempChar + '0';\n          combinedVars = calculate_difference_00084530((int)combinedVars,tempVar24,10,0);\n          localVarsPointer16 = (int ********)((int)localVarsPointer25 + -1);\n        } while (combinedVars != 0);\n        argWidthPointer = (int *******)((int)localVarsArray - (int)localVarsPointer25);\n        goto LAB_00082b04;\n      }\n      tempChar69 = (char)localVar19 + '0';\n      localVarsPointer25 = (int ********)(&tempChar6a + 1);\n      goto LAB_00083282;\n    }\n    localVarsPointer16 = (int ********)(&tempChar6a + 1);\n    if (result != 2) goto LAB_000830e2;\n    do {\n      localVarsPointer25 = localVarsPointer16;\n      currentChar = (uint)localVar19 & 0xf;\n      localVar19 = (int *)((uint)localVar19 >> 4 | (int)localVar22 << 0x1c);\n      localVar22 = (int *)((uint)localVar22 >> 4);\n      *(char *)localVarsPointer25 = formatChars[currentChar];\n      localVarsPointer16 = (int ********)((int)localVarsPointer25 + -1);\n    } while (((uint)localVar19 | (uint)localVar22) != 0);\n    argWidthPointer = (int *******)((int)localVarsArray - (int)localVarsPointer25);\n    goto LAB_00082b04;\n  }\nLAB_00083134:\n  if (argsPointer != (int *******)0x0) {\n    process_binary_data_00082824(arg1,arg2,&localVarsPointer);\n  }\nLAB_00083142:\n  if ((int)((uint)*(ushort *)(arg2 + 0xc) << 0x19) < 0) {\n    return -1;\n  }\n  return resultSize;\nLAB_000830e2:\n  do {\n    localVarsPointer25 = localVarsPointer16;\n    localVar7 = (int *)((uint)localVar19 >> 3 | (int)localVar22 << 0x1d);\n    localVar22 = (int *)((uint)localVar22 >> 3);\n    result = ((uint)localVar19 & 7) + 0x30;\n    *(char *)localVarsPointer25 = (char)result;\n    localVarsPointer16 = (int ********)((int)localVarsPointer25 + -1);\n    localVar19 = localVar7;\n  } while (((uint)localVar7 | (uint)localVar22) != 0);\n  if (hasSharp) {\n    if (result == 0x30) {\nLAB_00082afe:\n      argWidthPointer = (int *******)((int)localVarsArray - (int)localVarsPointer25);\n    }\n    else {\n      *(undefined *)((int)localVarsPointer25 + -1) = 0x30;\n      localVarsPointer25 = localVarsPointer16;\n      argWidthPointer = (int *******)((int)localVarsArray - (int)localVarsPointer16);\n    }\n  }\n  else {\nLAB_00083282:\n    argWidthPointer = (int *******)((int)localVarsArray - (int)localVarsPointer25);\n  }\nLAB_00082b04:\n  totalWidthPointer = argWidthPointer;\n  if ((int)argWidthPointer < (int)formatStringPointer) {\n    totalWidthPointer = formatStringPointer;\n  }\n  if (sign != '\\0') {\n    totalWidthPointer = (int *******)((int)totalWidthPointer + 1);\n  }\nLAB_00082b1e:\n  if (hasZero) {\n    totalWidthPointer = (int *******)((int)totalWidthPointer + 2);\n  }\n  if ((tempVar13 == 0) &&\n     (formatStringPointer18 = (int *******)((int)tempVar20 - (int)totalWidthPointer), 0 < (int)formatStringPointer18)) {\n    if ((int)formatStringPointer18 < 0x11) {\n      numArgsProcessed = numArgsProcessed + 1;\n    }\n    else {\n      do {\n        tempVar23 = formatStringPointer18;\n        result = numArgsProcessed + 1;\n        argsPointer = argsPointer + 4;\n        *localVarsPointer = (int *******)0x856f0;\n        localVarsPointer[1] = (int *******)0x10;\n        if (result < 8) {\n          tempVar15 = numArgsProcessed + 2;\n          localVarsPointer = localVarsPointer + 2;\n          numArgsProcessed = result;\n        }\n        else if (argsPointer == (int *******)0x0) {\n          tempVar15 = 1;\n          localVarsPointer = (int ********)localVarsArray;\n          numArgsProcessed = 0;\n        }\n        else {\n          numArgsProcessed = result;\n          result = process_binary_data_00082824(arg1,arg2,&localVarsPointer);\n          if (result != 0) goto LAB_00083142;\n          tempVar15 = numArgsProcessed + 1;\n          localVarsPointer = (int ********)localVarsArray;\n        }\n        formatStringPointer18 = tempVar23 + -4;\n      } while (0x10 < (int)formatStringPointer18);\n      formatStringPointer18 = tempVar23 + -4;\n      numArgsProcessed = tempVar15;\n    }\n    argsPointer = (int *******)((int)argsPointer + (int)formatStringPointer18);\n    *localVarsPointer = (int *******)0x856f0;\n    localVarsPointer[1] = formatStringPointer18;\n    if (numArgsProcessed < 8) {\n      result = numArgsProcessed + 1;\n      localVarsPointer = localVarsPointer + 2;\n    }\n    else if (argsPointer == (int *******)0x0) {\n      result = 1;\n      numArgsProcessed = 0;\n      localVarsPointer = (int ********)localVarsArray;\n    }\n    else {\n      result = process_binary_data_00082824(arg1,arg2,&localVarsPointer);\n      if (result != 0) goto LAB_00083142;\n      result = numArgsProcessed + 1;\n      localVarsPointer = (int ********)localVarsArray;\n    }\n  }\n  else {\n    result = numArgsProcessed + 1;\n  }\n  tempVar15 = result;\n  if (signChar != '\\0') {\n    argsPointer = (int *******)((int)argsPointer + 1);\n    tempVar15 = 1;\n    *localVarsPointer = (int *******)&signChar;\n    localVarsPointer[1] = (int *******)0x1;\n    numArgsProcessed = result;\n    if (result < 8) {\n      tempVar15 = result + 1;\n      localVarsPointer = localVarsPointer + 2;\n    }\n    else if (argsPointer == (int *******)0x0) {\n      numArgsProcessed = 0;\n      localVarsPointer = (int ********)localVarsArray;\n    }\n    else {\n      result = process_binary_data_00082824(arg1,arg2,&localVarsPointer);\n      if (result != 0) goto LAB_00083142;\n      tempVar15 = numArgsProcessed + 1;\n      localVarsPointer = (int ********)localVarsArray;\n    }\n  }\n  result = tempVar15;\n  tempVar17 = numArgsProcessed;\n  if (hasZero) {\n    argsPointer = (int *******)((int)argsPointer + 2);\n    *localVarsPointer = (int *******)&zeroChar;\n    localVarsPointer[1] = (int *******)0x2;\n    if (tempVar15 < 8) {\n      result = tempVar15 + 1;\n      tempVar17 = tempVar15;\n      localVarsPointer = localVarsPointer + 2;\n    }\n    else if (argsPointer == (int *******)0x0) {\n      result = 1;\n      tempVar17 = 0;\n      localVarsPointer = (int ********)localVarsArray;\n    }\n    else {\n      numArgsProcessed = tempVar15;\n      result = process_binary_data_00082824(arg1,arg2,&localVarsPointer);\n      if (result != 0) goto LAB_00083142;\n      result = numArgsProcessed + 1;\n      tempVar17 = numArgsProcessed;\n      localVarsPointer = (int ********)localVarsArray;\n    }\n  }\n  numArgsProcessed = tempVar17;\n  if ((tempVar13 == 0x80) &&\n     (formatStringPointer18 = (int *******)((int)tempVar20 - (int)totalWidthPointer), 0 < (int)formatStringPointer18)) {\n    if (0x10 < (int)formatStringPointer18) {\n      do {\n        while( true ) {\n          tempVar23 = formatStringPointer18;\n          numArgsProcessed = tempVar17 + 1;\n          argsPointer = argsPointer + 4;\n          *localVarsPointer = (int *******)\"0000000000000000\";\n          localVarsPointer[1] = (int *******)0x10;\n          if (7 < numArgsProcessed) break;\n          result = tempVar17 + 2;\n          localVarsPointer = localVarsPointer + 2;\nLAB_000831f2:\n          tempVar17 = numArgsProcessed;\n          formatStringPointer18 = tempVar23 + -4;\n          if ((int)(tempVar23 + -4) < 0x11) goto LAB_00083218;\n        }\n        if (argsPointer != (int *******)0x0) {\n          result = process_binary_data_00082824(arg1,arg2,&localVarsPointer);\n          if (result == 0) {\n            result = numArgsProcessed + 1;\n            localVarsPointer = (int ********)localVarsArray;\n            goto LAB_000831f2;\n          }\n          goto LAB_00083142;\n        }\n        result = 1;\n        tempVar17 = 0;\n        formatStringPointer18 = tempVar23 + -4;\n        localVarsPointer = (int ********)localVarsArray;\n      } while (0x10 < (int)(tempVar23 + -4));\nLAB_00083218:\n      formatStringPointer18 = tempVar23 + -4;\n    }\n    argsPointer = (int *******)((int)argsPointer + (int)formatStringPointer18);\n    *localVarsPointer = (int *******)\"0000000000000000\";\n    localVarsPointer[1] = formatStringPointer18;\n    numArgsProcessed = result;\n    if (result < 8) {\n      result = result + 1;\n      localVarsPointer = localVarsPointer + 2;\n    }\n    else if (argsPointer == (int *******)0x0) {\n      result = 1;\n      numArgsProcessed = 0;\n      localVarsPointer = (int ********)localVarsArray;\n    }\n    else {\n      result = process_binary_data_00082824(arg1,arg2,&localVarsPointer);\n      if (result != 0) goto LAB_00083142;\n      result = numArgsProcessed + 1;\n      localVarsPointer = (int ********)localVarsArray;\n    }\n  }\n  formatStringPointer = (int *******)((int)formatStringPointer - (int)argWidthPointer);\n  localVarsPointer16 = (int ********)localVarsArray;\n  if ((int)formatStringPointer < 1) {\nLAB_0008302a:\n    argsPointer = (int *******)((int)argsPointer + (int)argWidthPointer);\n    *localVarsPointer = (int *******)localVarsPointer25;\n    localVarsPointer[1] = argWidthPointer;\n    argWidthPointer = argsPointer;\n    numArgsProcessed = result;\n    if (result < 8) goto LAB_000831be;\n    if (argsPointer == (int *******)0x0) {\n      numArgsProcessed = 0;\n    }\n    else {\n      result = process_binary_data_00082824(arg1,arg2,&localVarsPointer);\n      if (result != 0) goto LAB_00083142;\n    }\n  }\n  else {\n    tempVar15 = numArgsProcessed;\n    if (0x10 < (int)formatStringPointer) {\n      do {\n        while( true ) {\n          formatStringPointer18 = formatStringPointer;\n          numArgsProcessed = tempVar15 + 1;\n          argsPointer = argsPointer + 4;\n          *localVarsPointer = (int *******)\"0000000000000000\";\n          localVarsPointer[1] = (int *******)0x10;\n          if (7 < numArgsProcessed) break;\n          result = tempVar15 + 2;\n          localVarsPointer = localVarsPointer + 2;\nLAB_00082fe6:\n          tempVar15 = numArgsProcessed;\n          formatStringPointer = formatStringPointer18 + -4;\n          if ((int)(formatStringPointer18 + -4) < 0x11) goto LAB_0008300e;\n        }\n        if (argsPointer != (int *******)0x0) {\n          result = process_binary_data_00082824(arg1,arg2,&localVarsPointer);\n          if (result == 0) {\n            result = numArgsProcessed + 1;\n            localVarsPointer = (int ********)localVarsArray;\n            goto LAB_00082fe6;\n          }\n          goto LAB_00083142;\n        }\n        result = 1;\n        localVarsPointer = (int ********)localVarsArray;\n        tempVar15 = 0;\n        formatStringPointer = formatStringPointer18 + -4;\n      } while (0x10 < (int)(formatStringPointer18 + -4));\nLAB_0008300e:\n      formatStringPointer = formatStringPointer18 + -4;\n    }\n    argsPointer = (int *******)((int)argsPointer + (int)formatStringPointer);\n    *localVarsPointer = (int *******)\"0000000000000000\";\n    localVarsPointer[1] = formatStringPointer;\n    if (result < 8) {\n      result = result + 1;\n      localVarsPointer = localVarsPointer + 2;\n      goto LAB_0008302a;\n    }\n    if (argsPointer != (int *******)0x0) {\n      numArgsProcessed = result;\n      result = process_binary_data_00082824(arg1,arg2,&localVarsPointer);\n      if (result != 0) goto LAB_00083142;\n      result = numArgsProcessed + 1;\n      localVarsPointer = (int ********)localVarsArray;\n      goto LAB_0008302a;\n    }\n    local64[0] = argWidthPointer;\n    numArgsProcessed = 1;\n    localVarsPointer = (int ********)localVarsArray;\n    localVarsArray = (undefined  [4])localVarsPointer25;\nLAB_000831be:\n    localVarsPointer16 = localVarsPointer + 2;\n    argsPointer = argWidthPointer;\n  }\n  if (((tempVar13 & 4) != 0) &&\n     (formatStringPointer = (int *******)((int)tempVar20 - (int)totalWidthPointer), 0 < (int)formatStringPointer)) {\n    result = numArgsProcessed;\n    if ((int)formatStringPointer < 0x11) {\n      tempVar15 = numArgsProcessed + 1;\n    }\n    else {\n      do {\n        while( true ) {\n          numArgsProcessed = result + 1;\n          argsPointer = argsPointer + 4;\n          *localVarsPointer16 = (int *******)0x856f0;\n          localVarsPointer16[1] = (int *******)0x10;\n          if (7 < numArgsProcessed) break;\n          tempVar15 = result + 2;\n          localVarsPointer16 = localVarsPointer16 + 2;\nLAB_0008307a:\n          formatStringPointer = formatStringPointer + -4;\n          result = numArgsProcessed;\n          if ((int)formatStringPointer < 0x11) goto LAB_000830a2;\n        }\n        if (argsPointer != (int *******)0x0) {\n          result = process_binary_data_00082824(arg1,arg2,&localVarsPointer);\n          if (result == 0) {\n            tempVar15 = numArgsProcessed + 1;\n            localVarsPointer16 = (int ********)localVarsArray;\n            goto LAB_0008307a;\n          }\n          goto LAB_00083142;\n        }\n        formatStringPointer = formatStringPointer + -4;\n        tempVar15 = 1;\n        result = 0;\n        localVarsPointer16 = (int ********)localVarsArray;\n      } while (0x10 < (int)formatStringPointer);\n    }\nLAB_000830a2:\n    argsPointer = (int *******)((int)argsPointer + (int)formatStringPointer);\n    *localVarsPointer16 = (int *******)0x856f0;\n    localVarsPointer16[1] = formatStringPointer;\n    numArgsProcessed = tempVar15;\n    if (7 < tempVar15) {\n      if (argsPointer == (int *******)0x0) {\n        if ((int)totalWidthPointer < (int)tempVar20) {\n          totalWidthPointer = tempVar20;\n        }\n        resultSize = resultSize + (int)totalWidthPointer;\n        goto LAB_00083186;\n      }\n      result = process_binary_data_00082824(arg1,arg2,&localVarsPointer);\n      if (result != 0) goto LAB_00083142;\n    }\n  }\n  if ((int)totalWidthPointer < (int)tempVar20) {\n    totalWidthPointer = tempVar20;\n  }\n  resultSize = resultSize + (int)totalWidthPointer;\n  if ((argsPointer != (int *******)0x0) &&\n     (result = process_binary_data_00082824(arg1,arg2,&localVarsPointer), result != 0)) goto LAB_00083142;\nLAB_00083186:\n  numArgsProcessed = 0;\n  localVarsPointer = (int ********)localVarsArray;\n  goto LAB_00082902;\nswitchD_00082984_caseD_31:\n  tempVar11 = currentChar - 0x30;\n  tempVar20 = (int *******)0x0;\n  formatStringPointer = formatString;\n  do {\n    formatString = (int *******)((int)formatStringPointer + 1);\n    currentChar = (uint)*(byte *)formatStringPointer;\n    tempVar20 = (int *******)(tempVar11 + (int)tempVar20 * 10);\n    tempVar11 = currentChar - 0x30;\n    formatStringPointer = formatString;\n  } while (tempVar11 < 10);\n  goto LAB_0008297a;\nswitchD_00082984_caseD_20:\n  currentChar = (uint)*(byte *)formatString;\n  if (signChar == '\\0') {\n    signChar = ' ';\n  }\n  goto LAB_00082976;\n}\n\n",
            "renaming": {
                "FUN_0008289c": "parse_format_string_0008289c",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "formatString",
                "param_4": "args",
                "bVar1": "isNegative",
                "bVar2": "hasSign",
                "bVar3": "hasSharp",
                "cVar4": "sign",
                "bVar5": "hasZero",
                "ppppppppiVar6": "localVarsPointer",
                "piVar7": "localVar7",
                "iVar8": "result",
                "cVar9": "tempChar",
                "pppppppiVar10": "formatStringPointer",
                "uVar11": "tempVar11",
                "ppiVar12": "localVar12",
                "uVar13": "tempVar13",
                "uVar14": "currentChar",
                "iVar15": "tempVar15",
                "ppppppppiVar16": "localVarsPointer16",
                "iVar17": "tempVar17",
                "pppppppiVar18": "formatStringPointer18",
                "piVar19": "localVar19",
                "pppppppiVar20": "tempVar20",
                "uVar21": "tempVar21",
                "piVar22": "localVar22",
                "pppppppiVar23": "tempVar23",
                "uVar24": "tempVar24",
                "ppppppppiVar25": "localVarsPointer25",
                "bVar26": "tempVar26",
                "lVar27": "combinedVars",
                "local_dc": "totalWidthPointer",
                "local_d4": "argWidthPointer",
                "local_c8": "currentArgPointer",
                "local_c4": "resultSize",
                "local_c0": "formatChars",
                "local_a1": "signChar",
                "local_a0": "zeroChar",
                "local_9f": "hexFlagChar",
                "local_9c": "localVarsPointer",
                "local_98": "numArgsProcessed",
                "local_94": "argsPointer",
                "local_90": "tempChar90",
                "cStack_6a": "tempChar6a",
                "local_69": "tempChar69",
                "local_68": "localVarsArray",
                "local_64": "local64"
            },
            "calling": [
                "FUN_000834f0",
                "FUN_00081750",
                "FUN_000817c8"
            ],
            "called": [
                "FUN_00083888",
                "FUN_000834f0",
                "FUN_0008356c",
                "FUN_000840f8",
                "FUN_00082824",
                "FUN_00082688",
                "FUN_00084530"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000834f0": {
            "entrypoint": "0x000834f0",
            "current_name": "process_data_000834f0",
            "code": "\nint processData_000834f0(undefined4 param1,int param2)\n\n{\n  int result;\n  int dataProcessingResult;\n  undefined *buffer [2];\n  undefined4 bufferSize;\n  ushort maskBitwise;\n  undefined2 value;\n  undefined *pointer;\n  undefined4 bufferSize1;\n  undefined4 counter;\n  undefined4 value2;\n  undefined4 bufferSize2;\n  undefined4 value3;\n  undefined stackArray [1024];\n  \n  value3 = *(undefined4 *)(param2 + 100);\n  value2 = *(undefined4 *)(param2 + 0x1c);\n  value = *(undefined2 *)(param2 + 0xe);\n  bufferSize2 = *(undefined4 *)(param2 + 0x24);\n  buffer[0] = stackArray;\n  maskBitwise = *(ushort *)(param2 + 0xc) & 0xfffd;\n  bufferSize = 0x400;\n  bufferSize1 = 0x400;\n  counter = 0;\n  pointer = buffer[0];\n  result = parse_format_string_0008289c(param1,buffer);\n  if ((-1 < result) && (dataProcessingResult = process_binary_data_00083850(param1,buffer), dataProcessingResult != 0)) {\n    result = -1;\n  }\n  if ((int)((uint)maskBitwise << 0x19) < 0) {\n    *(ushort *)(param2 + 0xc) = *(ushort *)(param2 + 0xc) | 0x40;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000834f0": "process_data_000834f0",
                "param_1": "param1",
                "param_2": "param2",
                "iVar1": "result",
                "iVar2": "dataProcessingResult",
                "local_488": "buffer",
                "local_480": "bufferSize",
                "local_47c": "maskBitwise",
                "local_47a": "value",
                "local_478": "pointer",
                "local_474": "bufferSize1",
                "local_470": "counter",
                "local_46c": "value2",
                "local_464": "bufferSize2",
                "local_424": "value3",
                "auStack_420": "stackArray"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_00083850",
                "FUN_0008289c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": [],
            "code_backup": "\nint FUN_000834f0(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined *local_488 [2];\n  undefined4 local_480;\n  ushort local_47c;\n  undefined2 local_47a;\n  undefined *local_478;\n  undefined4 local_474;\n  undefined4 local_470;\n  undefined4 local_46c;\n  undefined4 local_464;\n  undefined4 local_424;\n  undefined auStack_420 [1024];\n  \n  local_424 = *(undefined4 *)(param_2 + 100);\n  local_46c = *(undefined4 *)(param_2 + 0x1c);\n  local_47a = *(undefined2 *)(param_2 + 0xe);\n  local_464 = *(undefined4 *)(param_2 + 0x24);\n  local_488[0] = auStack_420;\n  local_47c = *(ushort *)(param_2 + 0xc) & 0xfffd;\n  local_480 = 0x400;\n  local_474 = 0x400;\n  local_470 = 0;\n  local_478 = local_488[0];\n  iVar1 = FUNC_0008289c(param_1,local_488);\n  if ((-1 < iVar1) && (iVar2 = process_binary_data_00083850(param_1,local_488), iVar2 != 0)) {\n    iVar1 = -1;\n  }\n  if ((int)((uint)local_47c << 0x19) < 0) {\n    *(ushort *)(param_2 + 0xc) = *(ushort *)(param_2 + 0xc) | 0x40;\n  }\n  return iVar1;\n}\n\n"
        },
        "FUN_0008356c": {
            "entrypoint": "0x0008356c",
            "current_name": "initialize_relocation_0008356c",
            "code": "\nundefined4 initialize_relocation_0008356c(undefined4 *error_code,int *relocation_array)\n\n{\n  int temp_var1;\n  int temp_var2;\n  uint uValue;\n  ushort uShortValue;\n  \n  if ((Elf32_Rel_ARRAY_20070000[140].r_offset != 0) &&\n     (*(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x38) == 0)) {\n    initialize_data_structures_00083888();\n  }\n  uShortValue = *(ushort *)(relocation_array + 3);\n  uValue = (uint)uShortValue;\n  if ((int)(uValue << 0x1c) < 0) {\n    temp_var2 = relocation_array[4];\n  }\n  else {\n    if (-1 < (int)(uValue << 0x1b)) {\n      *error_code = 9;\n      *(ushort *)(relocation_array + 3) = uShortValue | 0x40;\n      return 0xffffffff;\n    }\n    if ((int)(uValue << 0x1d) < 0) {\n      if ((int *)relocation_array[0xc] != (int *)0x0) {\n        if ((int *)relocation_array[0xc] != relocation_array + 0x10) {\n          process_relocation_00083b10(error_code);\n          uShortValue = *(ushort *)(relocation_array + 3);\n        }\n        relocation_array[0xc] = 0;\n      }\n      temp_var2 = relocation_array[4];\n      uShortValue = uShortValue & 0xffdb;\n      *relocation_array = temp_var2;\n      relocation_array[1] = 0;\n    }\n    else {\n      temp_var2 = relocation_array[4];\n    }\n    *(ushort *)(relocation_array + 3) = uShortValue | 8;\n    uValue = (uint)(uShortValue | 8);\n  }\n  if ((temp_var2 == 0) && ((uValue & 0x280) != 0x200)) {\n    perform_memory_init_00084018(error_code,relocation_array);\n    uValue = (uint)*(ushort *)(relocation_array + 3);\n    temp_var2 = relocation_array[4];\n  }\n  if ((uValue & 1) == 0) {\n    temp_var1 = 0;\n    if (-1 < (int)(uValue << 0x1e)) {\n      temp_var1 = relocation_array[5];\n    }\n    relocation_array[2] = temp_var1;\n  }\n  else {\n    relocation_array[6] = -relocation_array[5];\n    relocation_array[2] = 0;\n  }\n  if ((temp_var2 == 0) && ((int)((uint)*(ushort *)(relocation_array + 3) << 0x18) < 0)) {\n    *(ushort *)(relocation_array + 3) = *(ushort *)(relocation_array + 3) | 0x40;\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0008356c": "initialize_relocation_0008356c",
                "param_1": "error_code",
                "param_2": "relocation_array",
                "iVar1": "temp_var1",
                "iVar2": "temp_var2",
                "uVar3": "uValue",
                "uVar4": "uShortValue"
            },
            "calling": [
                "FUN_00083ca8",
                "FUN_000842a4",
                "FUN_0008289c"
            ],
            "called": [
                "FUN_00083888",
                "FUN_00084018",
                "FUN_00083b10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000836d8": {
            "entrypoint": "0x000836d8",
            "current_name": "FUNC_000836d8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00083698) */\n/* WARNING: Removing unreachable block (ram,0x00083630) */\n/* WARNING: Removing unreachable block (ram,0x000836c4) */\n/* WARNING: Removing unreachable block (ram,0x00083642) */\n/* WARNING: Removing unreachable block (ram,0x00083648) */\n/* WARNING: Removing unreachable block (ram,0x00083654) */\n/* WARNING: Removing unreachable block (ram,0x0008366e) */\n/* WARNING: Removing unreachable block (ram,0x0008364c) */\n/* WARNING: Removing unreachable block (ram,0x00083686) */\n/* WARNING: Removing unreachable block (ram,0x000836b8) */\n/* WARNING: Removing unreachable block (ram,0x00083688) */\n\nvoid FUNC_000836d8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000836d8": "FUNC_000836d8"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000836ec": {
            "entrypoint": "0x000836ec",
            "current_name": "process_and_call_function_000836ec",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00083698) */\n/* WARNING: Removing unreachable block (ram,0x000836b8) */\n\nvoid process_and_call_function_000836ec(void)\n\n{\n  dword *pointer;\n  dword exit_status;\n  int counter;\n  code *jumptable;\n  \n  process_relocation(6);\n  jumptable = (code *)0x836fb;\n  exit_status = show_exit_status(1);\n  if (relocation_array[48].r_offset == 0) {\n    relocation_array[48].r_offset = 0x20070184;\n  }\n  counter = *(int *)(relocation_array[48].r_offset + 4);\n  pointer = (dword *)relocation_array[48].r_offset;\n  if (0x1f < counter) {\n    pointer = (dword *)relocate_function(400);\n    if (pointer == (dword *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x00083652. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*jumptable)(0xffffffff);\n      return;\n    }\n    *pointer = relocation_array[48].r_offset;\n    pointer[1] = 0;\n    counter = 0;\n    relocation_array[48].r_offset = (dword)pointer;\n    pointer[0x62] = 0;\n    pointer[99] = 0;\n  }\n  pointer[1] = counter + 1;\n  pointer[counter + 2] = exit_status;\n                    /* WARNING: Could not recover jumptable at 0x00083696. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptable)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000836ec": "process_and_call_function_000836ec",
                "pdVar1": "pointer",
                "dVar2": "exit_status",
                "iVar3": "counter",
                "UNRECOVERED_JUMPTABLE_00": "jumptable",
                "process_relocation_000841e4": "process_relocation",
                "exit_with_status_00080eec": "show_exit_status",
                "Elf32_Rel_ARRAY_20070000": "relocation_array",
                "relocate_function_000817f0": "relocate_function"
            },
            "calling": [
                "FUN_000816f8"
            ],
            "called": [
                "FUN_00080eec",
                "FUN_000841e4",
                "FUN_000817f0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083850": {
            "entrypoint": "0x00083850",
            "current_name": "process_binary_data_00083850",
            "code": "\nundefined4 processBinaryData_00083850(int *binaryData,int *binaryInfo)\n\n{\n  int *tempPointer;\n  int length;\n  ushort flags;\n  uint tempValue;\n  int tempVar;\n  code *functionPointer;\n  undefined4 result;\n  int tempVar2;\n  \n  if ((binaryData != (int *)0x0) && (binaryData[0xe] == 0)) {\n    initialize_data_structures_00083888();\n  }\n  if (*(short *)(binaryInfo + 3) == 0) {\n    return 0;\n  }\n  flags = *(ushort *)(binaryInfo + 3);\n  if ((int)((uint)flags << 0x1c) < 0) {\n    tempVar2 = binaryInfo[4];\n    if (tempVar2 == 0) {\n      return 0;\n    }\n    length = *binaryInfo;\n    if ((flags & 3) == 0) {\n      tempVar = binaryInfo[5];\n    }\n    else {\n      tempVar = 0;\n    }\n    *binaryInfo = tempVar2;\n    length = length - tempVar2;\n    binaryInfo[2] = tempVar;\n    do {\n      if (length < 1) {\n        return 0;\n      }\n      tempVar = (*(code *)binaryInfo[9])(binaryData,binaryInfo[7],tempVar2,length,result);\n      length = length - tempVar;\n      tempVar2 = tempVar2 + tempVar;\n    } while (0 < tempVar);\nLAB_000837c8:\n    *(ushort *)(binaryInfo + 3) = *(ushort *)(binaryInfo + 3) | 0x40;\n    return 0xffffffff;\n  }\n  *(ushort *)(binaryInfo + 3) = flags | 0x800;\n  if ((binaryInfo[1] < 1) && (binaryInfo[0xf] < 1)) {\n    return 0;\n  }\n  functionPointer = (code *)binaryInfo[10];\n  if (functionPointer == (code *)0x0) {\n    return 0;\n  }\n  tempValue = (uint)(flags | 0x800);\n  tempVar2 = *binaryData;\n  *binaryData = 0;\n  if ((flags & 0x1000) == 0) {\n    length = (*functionPointer)(binaryData,binaryInfo[7],tempValue & 0x1000,1);\n    if ((length == -1) && (tempVar = *binaryData, tempVar != 0)) {\n      if ((tempVar == 0x1d) || (tempVar == 0x16)) {\n        *binaryData = tempVar2;\n        return 0;\n      }\n      goto LAB_000837c8;\n    }\n    tempValue = (uint)*(ushort *)(binaryInfo + 3);\n    functionPointer = (code *)binaryInfo[10];\n  }\n  else {\n    length = binaryInfo[0x14];\n  }\n  if (((int)(tempValue << 0x1d) < 0) && (length = length - binaryInfo[1], binaryInfo[0xc] != 0)) {\n    length = length - binaryInfo[0xf];\n  }\n  length = (*functionPointer)(binaryData,binaryInfo[7],length,0);\n  if (length == -1) {\n    tempVar = *binaryData;\n    if (tempVar != 0) {\n      if ((tempVar != 0x1d) && (tempVar != 0x16)) {\n        *(ushort *)(binaryInfo + 3) = *(ushort *)(binaryInfo + 3) | 0x40;\n        return 0xffffffff;\n      }\n      *(ushort *)(binaryInfo + 3) = *(ushort *)(binaryInfo + 3) & 0xf7ff;\n      *binaryInfo = binaryInfo[4];\n      binaryInfo[1] = 0;\n      goto LAB_00083774;\n    }\n    flags = *(ushort *)(binaryInfo + 3) & 0xf7ff;\n    binaryInfo[1] = 0;\n    *(ushort *)(binaryInfo + 3) = flags;\n    *binaryInfo = binaryInfo[4];\n  }\n  else {\n    flags = *(ushort *)(binaryInfo + 3) & 0xf7ff;\n    *binaryInfo = binaryInfo[4];\n    *(ushort *)(binaryInfo + 3) = flags;\n    binaryInfo[1] = 0;\n  }\n  if ((int)((uint)flags << 0x13) < 0) {\n    binaryInfo[0x14] = length;\n  }\nLAB_00083774:\n  tempPointer = (int *)binaryInfo[0xc];\n  *binaryData = tempVar2;\n  if (tempPointer == (int *)0x0) {\n    return 0;\n  }\n  if (tempPointer != binaryInfo + 0x10) {\n    process_relocation_00083b10(binaryData);\n  }\n  binaryInfo[0xc] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083850": "process_binary_data_00083850",
                "param_1": "binaryData",
                "param_2": "binaryInfo",
                "piVar1": "tempPointer",
                "iVar2": "length",
                "uVar3": "flags",
                "uVar4": "tempValue",
                "iVar5": "tempVar",
                "pcVar6": "functionPointer",
                "unaff_r4": "result",
                "iVar7": "tempVar2"
            },
            "calling": [
                "FUN_000834f0",
                "FUN_00084484",
                "FUN_00083ca8",
                "FUN_000842a4"
            ],
            "called": [
                "FUN_00083888",
                "FUN_00083b10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083888": {
            "entrypoint": "0x00083888",
            "current_name": "initialize_data_structures_00083888",
            "code": "\nvoid initializeDataStructures_00083888(int dataStructAddr)\n\n{\n  undefined4 *struct1;\n  undefined4 *struct2;\n  \n  if (*(int *)(dataStructAddr + 0x38) == 0) {\n    struct1 = *(undefined4 **)(dataStructAddr + 4);\n    *(undefined **)(dataStructAddr + 0x3c) = &LAB_0008387c_1;\n    *(undefined4 *)(dataStructAddr + 0x2e4) = 3;\n    *(int *)(dataStructAddr + 0x2e8) = dataStructAddr + 0x2ec;\n    *(undefined4 *)(dataStructAddr + 0x2e0) = 0;\n    *(undefined2 *)(struct1 + 3) = 4;\n    *struct1 = 0;\n    struct1[1] = 0;\n    struct1[2] = 0;\n    struct1[0x19] = 0;\n    *(undefined2 *)((int)struct1 + 0xe) = 0;\n    struct1[4] = 0;\n    struct1[5] = 0;\n    struct1[6] = 0;\n    fill_memory_with_byte_00081f00(struct1 + 0x17,0,8);\n    struct2 = *(undefined4 **)(dataStructAddr + 8);\n    struct1[7] = struct1;\n    struct1[8] = 0x84221;\n    struct1[9] = 0x84245;\n    struct1[10] = 0x8427d;\n    struct1[0xb] = &LAB_0008429c_1;\n    *(undefined2 *)((int)struct2 + 0xe) = 1;\n    *(undefined2 *)(struct2 + 3) = 9;\n    *struct2 = 0;\n    struct2[1] = 0;\n    struct2[2] = 0;\n    struct2[0x19] = 0;\n    struct2[4] = 0;\n    struct2[5] = 0;\n    struct2[6] = 0;\n    fill_memory_with_byte_00081f00(struct2 + 0x17,0,8);\n    struct1 = *(undefined4 **)(dataStructAddr + 0xc);\n    struct2[7] = struct2;\n    struct2[8] = 0x84221;\n    struct2[9] = 0x84245;\n    struct2[10] = 0x8427d;\n    struct2[0xb] = &LAB_0008429c_1;\n    *(undefined2 *)(struct1 + 3) = 0x12;\n    *(undefined2 *)((int)struct1 + 0xe) = 2;\n    *struct1 = 0;\n    struct1[1] = 0;\n    struct1[2] = 0;\n    struct1[0x19] = 0;\n    struct1[4] = 0;\n    struct1[5] = 0;\n    struct1[6] = 0;\n    fill_memory_with_byte_00081f00(struct1 + 0x17,0,8);\n    struct1[7] = struct1;\n    struct1[8] = 0x84221;\n    struct1[9] = 0x84245;\n    struct1[10] = 0x8427d;\n    struct1[0xb] = &LAB_0008429c_1;\n    *(undefined4 *)(dataStructAddr + 0x38) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083888": "initialize_data_structures_00083888",
                "param_1": "dataStructAddr",
                "puVar1": "struct1",
                "puVar2": "struct2"
            },
            "calling": [
                "FUN_00084484",
                "FUN_00083850",
                "FUN_000842a4",
                "FUN_0008356c",
                "FUN_0008289c"
            ],
            "called": [
                "FUN_00081f00"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008397c": {
            "entrypoint": "0x0008397c",
            "current_name": "FUNC_0008397c",
            "code": "\nvoid FUNC_0008397c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008397c": "FUNC_0008397c"
            },
            "calling": [
                "FUN_00084484"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083980": {
            "entrypoint": "0x00083980",
            "current_name": "FUNC_00083980",
            "code": "\nvoid FUNC_00083980(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083980": "FUNC_00083980"
            },
            "calling": [
                "FUN_00084484"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000839b4": {
            "entrypoint": "0x000839b4",
            "current_name": "process_binary_data_000839b4",
            "code": "\nuint processBinaryData_000839b4(undefined4 param1,uint param2,byte **param3)\n\n{\n  int relOffset;\n  uint relocationResult;\n  uint byteValue;\n  byte *bytePointer;\n  uint index;\n  byte byteValue1;\n  byte byteArray [3];\n  \n  if (-1 < (int)((uint)*(ushort *)(param3 + 3) << 0x12)) {\n    *(ushort *)(param3 + 3) = *(ushort *)(param3 + 3) | 0x2000;\n    param3[0x19] = (byte *)((uint)param3[0x19] | 0x2000);\n  }\n  relOffset = get_elf_rel_offset_0008400c();\n  if ((relOffset == 1) && (param2 - 1 < 0xff)) {\n    byteValue = param2 & 0xff;\n    byteValue1 = (byte)byteValue;\n    relocationResult = 1;\n  }\n  else {\n    relocationResult = process_relocation_0008434c(param1,&byteValue1,param2,param3 + 0x17);\n    if (relocationResult == 0xffffffff) {\n      *(ushort *)(param3 + 3) = *(ushort *)(param3 + 3) | 0x40;\n      return 0xffffffff;\n    }\n    if (relocationResult == 0) {\n      return param2;\n    }\n    byteValue = (uint)byteValue1;\n  }\n  index = 0;\n  do {\n    bytePointer = param3[2] + -1;\n    param3[2] = bytePointer;\n    if ((int)bytePointer < 0) {\n      if ((int)param3[6] <= (int)bytePointer) {\n        **param3 = (byte)byteValue;\n        bytePointer = *param3;\n        byteValue = (uint)*bytePointer;\n        if (byteValue != 10) goto LAB_00083a04;\n      }\n      relOffset = process_data_000842a4(param1,byteValue,param3);\n      if (relOffset == -1) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      **param3 = (byte)byteValue;\n      bytePointer = *param3;\nLAB_00083a04:\n      *param3 = bytePointer + 1;\n    }\n    if (relocationResult <= index + 1) {\n      return param2;\n    }\n    byteValue = (uint)byteArray[index];\n    index = index + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000839b4": "process_binary_data_000839b4",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "iVar1": "relOffset",
                "uVar2": "relocationResult",
                "uVar3": "byteValue",
                "pbVar4": "bytePointer",
                "uVar5": "index",
                "local_1c": "byteValue1",
                "abStack_1b": "byteArray"
            },
            "calling": [
                "FUN_00082824"
            ],
            "called": [
                "FUN_0008400c",
                "FUN_000842a4",
                "FUN_0008434c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083a74": {
            "entrypoint": "0x00083a74",
            "current_name": "calculate_and_update_offset_00083a74",
            "code": "\nundefined4 calculate_and_update_offset_00083a74(undefined4 base_address,int current_offset)\n\n{\n  int sum_result;\n  uint rel_info;\n  int new_offset;\n  \n  FUNC_00081f94();\n  rel_info = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n  new_offset = ((rel_info - current_offset) + 0xfef & 0xfffff000) - 0x1000;\n  if (0xfff < new_offset) {\n    sum_result = calculate_and_check_sum_0008236c(base_address,0);\n    if (sum_result == Elf32_Rel_ARRAY_20070000[141].r_info + rel_info) {\n      sum_result = calculate_and_check_sum_0008236c(base_address,-new_offset);\n      if (sum_result != -1) {\n        DAT_2007121c = DAT_2007121c - new_offset;\n        *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = rel_info - new_offset | 1;\n        FUNC_00081f98(base_address);\n        return 1;\n      }\n      new_offset = calculate_and_check_sum_0008236c(base_address,0);\n      if (0xf < (int)(new_offset - Elf32_Rel_ARRAY_20070000[141].r_info)) {\n        DAT_2007121c = new_offset - Elf32_Rel_ARRAY_20070000[270].r_offset;\n        *(dword *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) =\n             new_offset - Elf32_Rel_ARRAY_20070000[141].r_info | 1;\n      }\n    }\n  }\n  FUNC_00081f98(base_address);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083a74": "calculate_and_update_offset_00083a74",
                "param_1": "base_address",
                "param_2": "current_offset",
                "iVar1": "sum_result",
                "uVar2": "rel_info",
                "iVar3": "new_offset"
            },
            "calling": [
                "FUN_00083b10"
            ],
            "called": [
                "FUN_0008236c",
                "FUN_00081f94",
                "FUN_00081f98"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083b10": {
            "entrypoint": "0x00083b10",
            "current_name": "process_relocation_00083b10",
            "code": "\nvoid processRelocation_00083b10(undefined4 param,int relocationPtr)\n\n{\n  int index;\n  bool isFunc;\n  uint relocationInfo;\n  dword entry;\n  int nextIndex;\n  uint offset;\n  dword entryPtr;\n  uint nextOffset;\n  dword nextEntry;\n  \n  if (relocationPtr == 0) {\n    return;\n  }\n  FUNC_00081f94();\n  relocationInfo = *(uint *)(relocationPtr + -4);\n  entryPtr = relocationPtr - 8;\n  offset = relocationInfo & 0xfffffffe;\n  entry = entryPtr + offset;\n  nextOffset = *(uint *)(entry + 4) & 0xfffffffc;\n  if (Elf32_Rel_ARRAY_20070000[141].r_info == entry) {\n    nextOffset = nextOffset + offset;\n    if (-1 < (int)(relocationInfo << 0x1f)) {\n      entryPtr = entryPtr - *(int *)(relocationPtr + -8);\n      nextIndex = *(int *)(entryPtr + 0xc);\n      index = *(int *)(entryPtr + 8);\n      nextOffset = nextOffset + *(int *)(relocationPtr + -8);\n      *(int *)(index + 0xc) = nextIndex;\n      *(int *)(nextIndex + 8) = index;\n    }\n    entry = Elf32_Rel_ARRAY_20070000[269].r_info;\n    *(uint *)(entryPtr + 4) = nextOffset | 1;\n    Elf32_Rel_ARRAY_20070000[141].r_info = entryPtr;\n    if (entry <= nextOffset) {\n      calculate_and_update_offset_00083a74(param,DAT_20071218);\n    }\n  }\n  else {\n    *(uint *)(entry + 4) = nextOffset;\n    if ((relocationInfo & 1) == 0) {\n      entryPtr = entryPtr - *(int *)(relocationPtr + -8);\n      index = *(int *)(entryPtr + 8);\n      offset = offset + *(int *)(relocationPtr + -8);\n      if (index == 0x2007046c) {\n        isFunc = true;\n      }\n      else {\n        nextIndex = *(int *)(entryPtr + 0xc);\n        *(int *)(index + 0xc) = nextIndex;\n        *(int *)(nextIndex + 8) = index;\n        isFunc = false;\n      }\n    }\n    else {\n      isFunc = false;\n    }\n    if (-1 < *(int *)(entry + nextOffset + 4) << 0x1f) {\n      offset = offset + nextOffset;\n      index = *(int *)(entry + 8);\n      if ((!isFunc) && (index == 0x2007046c)) {\n        Elf32_Rel_ARRAY_20070000[142].r_info = entryPtr;\n        Elf32_Rel_ARRAY_20070000[143].r_offset = entryPtr;\n        *(undefined4 *)(entryPtr + 0xc) = 0x2007046c;\n        *(undefined4 *)(entryPtr + 8) = 0x2007046c;\n        *(uint *)(entryPtr + 4) = offset | 1;\n        *(uint *)(entryPtr + offset) = offset;\n        goto LAB_00083ba4;\n      }\n      nextIndex = *(int *)(entry + 0xc);\n      *(int *)(index + 0xc) = nextIndex;\n      *(int *)(nextIndex + 8) = index;\n    }\n    *(uint *)(entryPtr + 4) = offset | 1;\n    *(uint *)(entryPtr + offset) = offset;\n    if (!isFunc) {\n      if (offset < 0x200) {\n        relocationInfo = offset & 0xfffffff8;\n        index = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + relocationInfo);\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << ((int)(offset >> 3) >> 2 & 0xffU);\n        *(int *)(entryPtr + 8) = index;\n        *(uint *)(entryPtr + 0xc) = relocationInfo + 0x20070464;\n        *(dword *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + relocationInfo) = entryPtr;\n        *(dword *)(index + 0xc) = entryPtr;\n        FUNC_00081f98(param);\n        return;\n      }\n      relocationInfo = offset >> 9;\n      if (relocationInfo < 5) {\n        index = (offset >> 6) + 0x38;\n        nextIndex = index * 2;\n      }\n      else if (relocationInfo < 0x15) {\n        index = relocationInfo + 0x5b;\n        nextIndex = index * 2;\n      }\n      else if (relocationInfo < 0x55) {\n        index = (offset >> 0xc) + 0x6e;\n        nextIndex = index * 2;\n      }\n      else if (relocationInfo < 0x155) {\n        index = (offset >> 0xf) + 0x77;\n        nextIndex = index * 2;\n      }\n      else if (relocationInfo < 0x555) {\n        index = (offset >> 0x12) + 0x7c;\n        nextIndex = index * 2;\n      }\n      else {\n        nextIndex = 0xfc;\n        index = 0x7e;\n      }\n      nextEntry = nextIndex * 4 + 0x20070464;\n      entry = (&Elf32_Rel_ARRAY_20070000[0x8d].r_info)[nextIndex];\n      if (entry == nextEntry) {\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << (index >> 2 & 0xffU);\n        nextEntry = entry;\n      }\n      else {\n        do {\n          if ((*(uint *)(entry + 4) & 0xfffffffc) <= offset) break;\n          entry = *(dword *)(entry + 8);\n        } while (nextEntry != entry);\n        nextEntry = *(dword *)(entry + 0xc);\n      }\n      *(dword *)(entryPtr + 0xc) = nextEntry;\n      *(dword *)(entryPtr + 8) = entry;\n      *(dword *)(nextEntry + 8) = entryPtr;\n      *(dword *)(entry + 0xc) = entryPtr;\n    }\n  }\nLAB_00083ba4:\n  FUNC_00081f98(param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083b10": "process_relocation_00083b10",
                "param_1": "param",
                "param_2": "relocationPtr",
                "iVar1": "index",
                "bVar2": "isFunc",
                "uVar3": "relocationInfo",
                "dVar4": "entry",
                "iVar5": "nextIndex",
                "uVar6": "offset",
                "dVar7": "entryPtr",
                "uVar8": "nextOffset",
                "dVar9": "nextEntry"
            },
            "calling": [
                "FUN_00084484",
                "FUN_00083ca8",
                "FUN_00081800",
                "FUN_00083850",
                "FUN_0008356c",
                "FUN_00081fac",
                "FUN_00081810"
            ],
            "called": [
                "FUN_00083a74",
                "FUN_00081f94",
                "FUN_00081f98"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083ca8": {
            "entrypoint": "0x00083ca8",
            "current_name": "relocate_and_copy_data_00083ca8",
            "code": "\nundefined4 relocateAndCopyData_00083ca8(undefined4 *destination,uint *source,uint **relocation)\n\n{\n  int result;\n  uint readLength;\n  uint setFlag;\n  ushort sourceFlag;\n  uint sourceFlagValue;\n  uint *tempPointer1;\n  uint *tempPointer2;\n  uint copyLength;\n  uint newMemory;\n  uint tempValue1;\n  uint tempValue2;\n  uint tempValue3;\n  \n  if (relocation[2] != (uint *)0x0) {\n    sourceFlag = *(ushort *)(source + 3);\n    sourceFlagValue = (uint)sourceFlag;\n    if (((int)(sourceFlagValue << 0x1c) < 0) && (source[4] != 0)) {\n      tempPointer2 = *relocation;\n    }\n    else {\n      result = initialize_relocation_0008356c(destination,source);\n      if (result != 0) {\n        return 0xffffffff;\n      }\n      sourceFlag = *(ushort *)(source + 3);\n      sourceFlagValue = (uint)sourceFlag;\n      tempPointer2 = *relocation;\n    }\n    if ((sourceFlag & 2) == 0) {\n      readLength = sourceFlagValue & 2;\n      tempValue1 = readLength;\n      copyLength = readLength;\n      tempValue3 = readLength;\n      if ((sourceFlagValue & 1) == 0) {\n        readLength = 0;\n        tempValue1 = 0;\n        while( true ) {\n          while (readLength == 0) {\n            tempValue1 = *tempPointer2;\n            tempPointer1 = tempPointer2 + 1;\n            tempPointer2 = tempPointer2 + 2;\n            readLength = *tempPointer1;\n          }\n          copyLength = source[2];\n          if ((int)(sourceFlagValue << 0x16) < 0) {\n            if (readLength < copyLength) {\n              sourceFlagValue = *source;\n              copyLength = readLength;\n            }\n            else if ((sourceFlagValue & 0x480) == 0) {\n              sourceFlagValue = *source;\n            }\n            else {\n              result = *source - source[4];\n              copyLength = result + 1 + readLength;\n              newMemory = (int)(source[5] * 3) / 2;\n              if (copyLength <= newMemory) {\n                copyLength = newMemory;\n              }\n              if ((int)(sourceFlagValue << 0x15) < 0) {\n                newMemory = relocate_function_00081810(destination,copyLength);\n                if (newMemory == 0) {\n                  *destination = 0xc;\n                  sourceFlag = *(ushort *)(source + 3);\n                  goto LAB_00083da4;\n                }\n                memcpy_aligned_00081d48(newMemory,source[4],result);\n                *(ushort *)(source + 3) = *(ushort *)(source + 3) & 0xfb7f | 0x80;\n              }\n              else {\n                newMemory = reallocate_memory_00081fac(destination);\n                if (newMemory == 0) {\n                  process_relocation_00083b10(destination,source[4]);\n                  sourceFlag = *(ushort *)(source + 3) & 0xff7f;\n                  *destination = 0xc;\n                  goto LAB_00083da4;\n                }\n              }\n              sourceFlagValue = newMemory + result;\n              source[4] = newMemory;\n              source[5] = copyLength;\n              *source = sourceFlagValue;\n              source[2] = copyLength - result;\n              copyLength = readLength;\n            }\n            copy_memory_00081e34(sourceFlagValue,tempValue1,copyLength);\n            source[2] = source[2] - copyLength;\n            *source = *source + copyLength;\n            copyLength = readLength;\n          }\n          else if ((source[4] < *source) || (sourceFlagValue = source[5], readLength < sourceFlagValue)) {\n            if (readLength < copyLength) {\n              copyLength = readLength;\n            }\n            copy_memory_00081e34(*source,tempValue1,copyLength);\n            sourceFlagValue = source[2];\n            source[2] = sourceFlagValue - copyLength;\n            *source = *source + copyLength;\n            if ((sourceFlagValue - copyLength == 0) && (result = process_binary_data_00083850(destination,source), result != 0))\n            goto LAB_00083da2;\n          }\n          else {\n            copyLength = 0x7fffffff;\n            if (readLength < 0x7fffffff) {\n              copyLength = readLength;\n            }\n            copyLength = (*(code *)source[9])(destination,source[7],tempValue1,(copyLength / sourceFlagValue) * sourceFlagValue);\n            if ((int)copyLength < 1) goto LAB_00083da2;\n          }\n          tempPointer1 = relocation[2];\n          tempValue1 = tempValue1 + copyLength;\n          readLength = readLength - copyLength;\n          relocation[2] = (uint *)((int)tempPointer1 - copyLength);\n          if ((uint *)((int)tempPointer1 - copyLength) == (uint *)0x0) break;\n          sourceFlagValue = (uint)*(ushort *)(source + 3);\n        }\n      }\n      else {\n        do {\n          while (readLength == 0) {\n            copyLength = *tempPointer2;\n            readLength = tempPointer2[1];\n            tempValue3 = 0;\n            tempPointer2 = tempPointer2 + 2;\n          }\n          if (tempValue3 == 0) {\n            result = find_character_000840f8(copyLength,10,readLength);\n            if (result == 0) {\n              tempValue1 = readLength + 1;\n              tempValue3 = 1;\n            }\n            else {\n              tempValue1 = (result + 1) - copyLength;\n              tempValue3 = 1;\n            }\n          }\n          newMemory = *source;\n          sourceFlagValue = tempValue1;\n          if (readLength <= tempValue1) {\n            sourceFlagValue = readLength;\n          }\n          setFlag = source[5];\n          if ((source[4] < newMemory) && (tempValue2 = source[2] + setFlag, (int)tempValue2 < (int)sourceFlagValue)) {\n            copy_memory_00081e34(newMemory,copyLength,tempValue2);\n            *source = *source + tempValue2;\n            result = process_binary_data_00083850(destination,source);\n            if (result != 0) goto LAB_00083da2;\n          }\n          else if ((int)sourceFlagValue < (int)setFlag) {\n            copy_memory_00081e34(newMemory,copyLength,sourceFlagValue);\n            source[2] = source[2] - sourceFlagValue;\n            *source = sourceFlagValue + *source;\n            tempValue2 = sourceFlagValue;\n          }\n          else {\n            tempValue2 = (*(code *)source[9])(destination,source[7],copyLength,setFlag);\n            if ((int)tempValue2 < 1) goto LAB_00083da2;\n          }\n          tempValue1 = tempValue1 - tempValue2;\n          if (tempValue1 == 0) {\n            result = process_binary_data_00083850(destination,source);\n            if (result != 0) goto LAB_00083da2;\n            tempValue3 = 0;\n          }\n          tempPointer1 = relocation[2];\n          copyLength = copyLength + tempValue2;\n          readLength = readLength - tempValue2;\n          relocation[2] = (uint *)((int)tempPointer1 - tempValue2);\n        } while ((uint *)((int)tempPointer1 - tempValue2) != (uint *)0x0);\n      }\n    }\n    else {\n      readLength = 0;\n      sourceFlagValue = 0;\n      do {\n        while( true ) {\n          tempValue1 = sourceFlagValue;\n          if (0x7ffffbff < sourceFlagValue) {\n            tempValue1 = 0x7ffffc00;\n          }\n          if (sourceFlagValue != 0) break;\n          readLength = *tempPointer2;\n          sourceFlagValue = tempPointer2[1];\n          tempPointer2 = tempPointer2 + 2;\n        }\n        result = (*(code *)source[9])(destination,source[7],readLength,tempValue1);\n        if (result < 1) {\nLAB_00083da2:\n          sourceFlag = *(ushort *)(source + 3);\nLAB_00083da4:\n          *(ushort *)(source + 3) = sourceFlag | 0x40;\n          return 0xffffffff;\n        }\n        tempPointer1 = relocation[2];\n        readLength = readLength + result;\n        sourceFlagValue = sourceFlagValue - result;\n        relocation[2] = (uint *)((int)tempPointer1 - result);\n      } while ((uint *)((int)tempPointer1 - result) != (uint *)0x0);\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083ca8": "relocate_and_copy_data_00083ca8",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "relocation",
                "iVar1": "result",
                "uVar2": "readLength",
                "uVar3": "setFlag",
                "uVar4": "sourceFlag",
                "uVar5": "sourceFlagValue",
                "puVar6": "tempPointer1",
                "puVar7": "tempPointer2",
                "uVar8": "copyLength",
                "uVar9": "newMemory",
                "uVar10": "tempValue1",
                "uVar11": "tempValue2",
                "local_2c": "tempValue3"
            },
            "calling": [
                "FUN_00082824"
            ],
            "called": [
                "FUN_00083850",
                "FUN_0008356c",
                "FUN_00081e34",
                "FUN_00083b10",
                "FUN_000840f8",
                "FUN_00081d48",
                "FUN_00081810",
                "FUN_00081fac"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084004": {
            "entrypoint": "0x00084004",
            "current_name": "get_memory_address_00084004",
            "code": "\nundefined4 getMemoryAddress_00084004(void)\n\n{\n  return 0x20070878;\n}\n\n",
            "renaming": {
                "FUN_00084004": "get_memory_address_00084004"
            },
            "calling": [
                "FUN_0008434c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008400c": {
            "entrypoint": "0x0008400c",
            "current_name": "get_elf_rel_offset_0008400c",
            "code": "\ndword getElfRelOffset_0008400c(void)\n\n{\n  return elfRelArray[275].r_offset;\n}\n\n",
            "renaming": {
                "FUN_0008400c": "get_elf_rel_offset_0008400c",
                "Elf32_Rel_ARRAY_20070000": "elfRelArray"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084018": {
            "entrypoint": "0x00084018",
            "current_name": "perform_memory_init_00084018",
            "code": "\nvoid performMemoryInit_00084018(int memory_ptr,int *function_info_ptr)\n\n{\n  ushort function_flags;\n  int memory_init_result;\n  int relocation_result;\n  uint function_flags_copy;\n  bool is_condition_met;\n  undefined aux_stack_array [4];\n  uint local_var_1;\n  \n  function_flags = *(ushort *)(function_info_ptr + 3);\n  function_flags_copy = (uint)function_flags;\n  if ((int)(function_flags_copy << 0x1e) < 0) {\n    *function_info_ptr = (int)function_info_ptr + 0x43;\n    function_info_ptr[4] = (int)function_info_ptr + 0x43;\n    function_info_ptr[5] = 1;\n    return;\n  }\n  if (-1 < *(short *)((int)function_info_ptr + 0xe)) {\n    memory_init_result = initialize_memory_and_check_00084494(memory_ptr,(int)*(short *)((int)function_info_ptr + 0xe),aux_stack_array);\n    if (-1 < memory_init_result) {\n      is_condition_met = (local_var_1 & 0xf000) == 0x2000;\n      if (((local_var_1 & 0xf000) == 0x8000) && (function_info_ptr[10] == 0x8427d)) {\n        memory_init_result = 0x400;\n        *(ushort *)(function_info_ptr + 3) = *(ushort *)(function_info_ptr + 3) | 0x400;\n        function_info_ptr[0x13] = 0x400;\n      }\n      else {\n        memory_init_result = 0x400;\n        *(ushort *)(function_info_ptr + 3) = *(ushort *)(function_info_ptr + 3) | 0x800;\n      }\n      goto LAB_00084074;\n    }\n    function_flags = *(ushort *)(function_info_ptr + 3);\n    function_flags_copy = (uint)function_flags;\n  }\n  *(ushort *)(function_info_ptr + 3) = function_flags | 0x800;\n  if ((function_flags_copy & 0x80) == 0) {\n    memory_init_result = 0x400;\n  }\n  else {\n    memory_init_result = 0x40;\n  }\n  is_condition_met = false;\nLAB_00084074:\n  relocation_result = relocate_function_00081810(memory_ptr,memory_init_result);\n  function_flags = *(ushort *)(function_info_ptr + 3);\n  if (relocation_result == 0) {\n    if (-1 < (int)((uint)function_flags << 0x16)) {\n      *(ushort *)(function_info_ptr + 3) = function_flags | 2;\n      *function_info_ptr = (int)function_info_ptr + 0x43;\n      function_info_ptr[4] = (int)function_info_ptr + 0x43;\n      function_info_ptr[5] = 1;\n    }\n  }\n  else {\n    *(undefined **)(memory_ptr + 0x3c) = &LAB_0008387c_1;\n    *(ushort *)(function_info_ptr + 3) = function_flags | 0x80;\n    *function_info_ptr = relocation_result;\n    function_info_ptr[4] = relocation_result;\n    function_info_ptr[5] = memory_init_result;\n    if ((is_condition_met) && (memory_init_result = get_return_value_and_update_param_000844bc(memory_ptr,(int)*(short *)((int)function_info_ptr + 0xe)), memory_init_result != 0))\n    {\n      *(ushort *)(function_info_ptr + 3) = *(ushort *)(function_info_ptr + 3) | 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084018": "perform_memory_init_00084018",
                "param_1": "memory_ptr",
                "param_2": "function_info_ptr",
                "uVar1": "function_flags",
                "iVar2": "memory_init_result",
                "iVar3": "relocation_result",
                "uVar4": "function_flags_copy",
                "bVar5": "is_condition_met",
                "auStack_54": "aux_stack_array",
                "local_50": "local_var_1"
            },
            "calling": [
                "FUN_0008356c"
            ],
            "called": [
                "FUN_000844bc",
                "FUN_00084494",
                "FUN_00081810"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000840f8": {
            "entrypoint": "0x000840f8",
            "current_name": "find_character_000840f8",
            "code": "\nuint * find_character_000840f8(uint *array,char character,uint array_length)\n\n{\n  uint xor_result;\n  int index;\n  uint *current;\n  bool is_last_index;\n  \n  if (((uint)array & 3) == 0) {\nLAB_00084128:\n    if (3 < array_length) {\n      current = array;\n      do {\n        xor_result = *current ^ CONCAT22(CONCAT11(character,character),CONCAT11(character,character));\n        array = current;\n        if ((xor_result + 0xfefefeff & ~xor_result & 0x80808080) != 0) break;\n        array_length = array_length - 4;\n        array = current + 1;\n        current = current + 1;\n      } while (3 < array_length);\n    }\n    if (array_length == 0) {\n      array = (uint *)0x0;\n    }\n    else if (*(char *)array != character) {\n      index = 0;\n      do {\n        array = (uint *)((int)array + 1);\n        is_last_index = index == array_length - 1;\n        index = index + 1;\n        if (is_last_index) goto LAB_00084150;\n      } while (*(char *)array != character);\n    }\n  }\n  else if (array_length == 0) {\nLAB_00084150:\n    array = (uint *)0x0;\n  }\n  else if (*(char *)array != character) {\n    current = (uint *)((int)array + 1);\n    array_length = array_length - 1;\n    do {\n      array = current;\n      if (((uint)array & 3) == 0) goto LAB_00084128;\n      if (array_length == 0) goto LAB_00084150;\n      current = (uint *)((int)array + 1);\n      array_length = array_length - 1;\n    } while (*(char *)array != character);\n  }\n  return array;\n}\n\n",
            "renaming": {
                "FUN_000840f8": "find_character_000840f8",
                "param_1": "array",
                "param_2": "character",
                "param_3": "array_length",
                "uVar1": "xor_result",
                "iVar2": "index",
                "puVar3": "current",
                "bVar4": "is_last_index"
            },
            "calling": [
                "FUN_00083ca8",
                "FUN_0008289c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000841e4": {
            "entrypoint": "0x000841e4",
            "current_name": "process_relocation_000841e4",
            "code": "\nint processRelocation_000841e4(uint index)\n\n{\n  dword offset;\n  undefined4 returnValue;\n  int funcPtr;\n  code *callbackFunc;\n  undefined4 var1;\n  undefined4 var2;\n  undefined4 var3;\n  undefined4 var4;\n  \n  offset = Elf32_Rel_ARRAY_20070000[140].r_offset;\n  var4 = 0x20070460;\n  if (0x1f < index) {\n    *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x16;\n    return -1;\n  }\n  funcPtr = *(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x2dc);\n  if ((funcPtr == 0) || (callbackFunc = *(code **)(funcPtr + index * 4), callbackFunc == (code *)0x0)) {\n    returnValue = thunk_get_return_value_00080efe(Elf32_Rel_ARRAY_20070000[140].r_offset);\n    DAT_20071244 = 0;\n    funcPtr = FUNC_00080efc(returnValue,index,index,0,var4,var1,var2,var3);\n    if ((funcPtr == -1) && (DAT_20071244 != 0)) {\n      *(int *)offset = DAT_20071244;\n      return -1;\n    }\n    return funcPtr;\n  }\n  if (callbackFunc == (code *)0x1) {\n    return 0;\n  }\n  if (callbackFunc != (code *)0xffffffff) {\n    *(undefined4 *)(funcPtr + index * 4) = 0;\n    (*callbackFunc)(index);\n    return 0;\n  }\n  *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x16;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000841e4": "process_relocation_000841e4",
                "param_1": "index",
                "dVar1": "offset",
                "uVar2": "returnValue",
                "iVar3": "funcPtr",
                "pcVar4": "callbackFunc",
                "unaff_r4": "var1",
                "unaff_r5": "var2",
                "in_lr": "var3",
                "uVar5": "var4"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "thunk_FUN_00080efe",
                "FUN_00080efc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_00080efe": {
            "entrypoint": "0x0008421c",
            "current_name": "get_error_code_thunk_00080efe",
            "code": "\nundefined4 get_error_code_thunk_00080efe(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "thunk_FUN_00080efe": "get_error_code_thunk_00080efe"
            },
            "calling": [
                "FUN_000841e4"
            ],
            "called": [
                "FUN_00080efe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084220": {
            "entrypoint": "0x00084220",
            "current_name": "update_data_00084220",
            "code": "\nvoid updateData_00084220(undefined4 inputData,int dataBuffer)\n\n{\n  int result;\n  \n  result = initializeData(inputData,(int)*(short *)(dataBuffer + 0xe));\n  if (-1 < result) {\n    *(int *)(dataBuffer + 0x50) = *(int *)(dataBuffer + 0x50) + result;\n    return;\n  }\n  *(ushort *)(dataBuffer + 0xc) = *(ushort *)(dataBuffer + 0xc) & 0xefff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084220": "update_data_00084220",
                "param_1": "inputData",
                "param_2": "dataBuffer",
                "iVar1": "result",
                "initialize_data_00084508": "initializeData"
            },
            "calling": [],
            "called": [
                "FUN_00084508"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084244": {
            "entrypoint": "0x00084244",
            "current_name": "process_data_00084244",
            "code": "\nvoid processData_00084244(int *output,int input,undefined4 value1,undefined4 value2)\n\n{\n  int result;\n  ushort temp5;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  undefined4 temp4;\n  \n  temp5 = *(ushort *)(input + 0xc);\n  if ((int)((uint)temp5 << 0x17) < 0) {\n    initialize_and_check_000844e0(output,(int)*(short *)(input + 0xe),0,2);\n    temp5 = *(ushort *)(input + 0xc);\n  }\n  *(ushort *)(input + 0xc) = temp5 & 0xefff;\n  DAT_20071244 = 0;\n  result = copy_byte_array_00080ec8((int)*(short *)(input + 0xe),value1,value2,value2,temp1,temp2,\n                       temp3,temp4);\n  if ((result == -1) && (DAT_20071244 != 0)) {\n    *output = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084244": "process_data_00084244",
                "param_1": "output",
                "param_2": "input",
                "param_3": "value1",
                "param_4": "value2",
                "unaff_r4": "temp1",
                "unaff_r5": "temp2",
                "unaff_r6": "temp3",
                "in_lr": "temp4",
                "uVar2": "temp5",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "FUN_00080ec8",
                "FUN_000844e0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008427c": {
            "entrypoint": "0x0008427c",
            "current_name": "initialize_and_check_0008427c",
            "code": "\nvoid initializeAndCheck_0008427c(undefined4 param1,int param2)\n\n{\n  int result;\n  ushort modifiedValue;\n  \n  result = initialize_and_check_000844e0(param1,(int)*(short *)(param2 + 0xe));\n  if (result == -1) {\n    modifiedValue = *(ushort *)(param2 + 0xc) & 0xefff;\n  }\n  else {\n    modifiedValue = *(ushort *)(param2 + 0xc) | 0x1000;\n  }\n  if (result != -1) {\n    *(int *)(param2 + 0x50) = result;\n  }\n  *(ushort *)(param2 + 0xc) = modifiedValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008427c": "initialize_and_check_0008427c",
                "param_1": "param1",
                "param_2": "param2",
                "iVar1": "result",
                "uVar2": "modifiedValue"
            },
            "calling": [],
            "called": [
                "FUN_000844e0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000842a4": {
            "entrypoint": "0x000842a4",
            "current_name": "process_data_000842a4",
            "code": "\nuint process_data_000842a4(int input,uint value,undefined4 *data_struct,undefined4 param_4)\n\n{\n  ushort ushort_value;\n  uint uint_value;\n  undefined *ptr;\n  int index;\n  \n  if ((input != 0) && (*(int *)(input + 0x38) == 0)) {\n    initialize_data_structures();\n  }\n  ushort_value = *(ushort *)(data_struct + 3);\n  uint_value = (uint)ushort_value;\n  data_struct[2] = data_struct[6];\n  if ((-1 < (int)(uint_value << 0x1c)) || (index = data_struct[4], index == 0)) {\n    index = initialize_relocation(input,data_struct,ushort_value,uint_value,param_4);\n    if (index != 0) {\n      return 0xffffffff;\n    }\n    ushort_value = *(ushort *)(data_struct + 3);\n    index = data_struct[4];\n    uint_value = (uint)ushort_value;\n  }\n  value = value & 0xff;\n  if ((int)(uint_value << 0x12) < 0) {\n    ptr = (undefined *)*data_struct;\n    index = (int)ptr - index;\n    if (index < (int)data_struct[5]) {\nLAB_000842d6:\n      index = index + 1;\n      goto LAB_000842d8;\n    }\n  }\n  else {\n    data_struct[0x19] = data_struct[0x19] & 0xffffdfff;\n    ptr = (undefined *)*data_struct;\n    *(ushort *)(data_struct + 3) = ushort_value | 0x2000;\n    index = (int)ptr - index;\n    if (index < (int)data_struct[5]) goto LAB_000842d6;\n  }\n  index = process_binary_data(input,data_struct);\n  if (index != 0) {\n    return 0xffffffff;\n  }\n  ptr = (undefined *)*data_struct;\n  index = 1;\nLAB_000842d8:\n  data_struct[2] = data_struct[2] + -1;\n  *data_struct = ptr + 1;\n  *ptr = (char)value;\n  if (((data_struct[5] == index) ||\n      (((int)((uint)*(ushort *)(data_struct + 3) << 0x1f) < 0 && (value == 10)))) &&\n     (index = process_binary_data(input,data_struct), index != 0)) {\n    return 0xffffffff;\n  }\n  return value;\n}\n\n",
            "renaming": {
                "FUN_000842a4": "process_data_000842a4",
                "param_1": "input",
                "param_2": "value",
                "param_3": "data_struct",
                "uVar1": "ushort_value",
                "uVar2": "uint_value",
                "puVar3": "ptr",
                "iVar4": "index",
                "initialize_data_structures_00083888": "initialize_data_structures",
                "initialize_relocation_0008356c": "initialize_relocation",
                "process_binary_data_00083850": "process_binary_data"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [
                "FUN_00083888",
                "FUN_00083850",
                "FUN_0008356c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008434c": {
            "entrypoint": "0x0008434c",
            "current_name": "process_relocation_0008434c",
            "code": "\nvoid processRelocation_0008434c(undefined4 *output,int size,undefined4 param3,undefined4 *status)\n\n{\n  dword dynamicReloc;\n  undefined4 memoryAddress;\n  int result;\n  undefined stackBuffer [12];\n  \n  dynamicReloc = Elf32_Rel_ARRAY_20070000[275].r_info;\n  if (size == 0) {\n    memoryAddress = get_memory_address_00084004();\n    result = (*(code *)dynamicReloc)(output,stackBuffer,0,memoryAddress,status);\n  }\n  else {\n    memoryAddress = get_memory_address_00084004();\n    result = (*(code *)dynamicReloc)(output,size,param3,memoryAddress,status);\n  }\n  if (result == -1) {\n    *status = 0;\n    *output = 0x8a;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008434c": "process_relocation_0008434c",
                "param_1": "output",
                "param_2": "size",
                "param_3": "param3",
                "param_4": "status",
                "dVar1": "dynamicReloc",
                "uVar2": "memoryAddress",
                "iVar3": "result",
                "auStack_24": "stackBuffer"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [
                "FUN_0008439c",
                "FUN_00084004"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008439c": {
            "entrypoint": "0x0008439c",
            "current_name": "write_byte_to_memory_0008439c",
            "code": "\nundefined4 write_byte_to_memory_0008439c(undefined4 *destination,undefined *buffer,uint value)\n\n{\n  if (buffer == (undefined *)0x0) {\n    return 0;\n  }\n  if (value < 0x100) {\n    *buffer = (char)value;\n    return 1;\n  }\n  *destination = 0x8a;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0008439c": "write_byte_to_memory_0008439c",
                "param_1": "destination",
                "param_2": "buffer",
                "param_3": "value"
            },
            "calling": [
                "FUN_0008434c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084484": {
            "entrypoint": "0x00084484",
            "current_name": "process_relocation_and_initialize_data_00084484",
            "code": "\nundefined4 process_relocation_and_initialize_data_00084484(int input_param)\n\n{\n  dword rel_offset;\n  undefined4 result;\n  int relocation_result;\n  \n  rel_offset = Elf32_Rel_ARRAY_20070000[140].r_offset;\n  if (input_param != 0) {\n    if ((Elf32_Rel_ARRAY_20070000[140].r_offset != 0) &&\n       (*(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x38) == 0)) {\n      initialize_data_structures_00083888();\n    }\n    if (*(short *)(input_param + 0xc) != 0) {\n      result = process_binary_data_00083850(rel_offset,input_param);\n      if ((*(code **)(input_param + 0x2c) != (code *)0x0) &&\n         (relocation_result = (**(code **)(input_param + 0x2c))(rel_offset,*(undefined4 *)(input_param + 0x1c)), relocation_result < 0))\n      {\n        result = 0xffffffff;\n      }\n      if ((int)((uint)*(ushort *)(input_param + 0xc) << 0x18) < 0) {\n        process_relocation_00083b10(rel_offset,*(undefined4 *)(input_param + 0x10));\n      }\n      if (*(int *)(input_param + 0x30) != 0) {\n        if (*(int *)(input_param + 0x30) != input_param + 0x40) {\n          process_relocation_00083b10(rel_offset);\n        }\n        *(undefined4 *)(input_param + 0x30) = 0;\n      }\n      if (*(int *)(input_param + 0x44) != 0) {\n        process_relocation_00083b10(rel_offset);\n        *(undefined4 *)(input_param + 0x44) = 0;\n      }\n      FUNC_0008397c();\n      *(undefined2 *)(input_param + 0xc) = 0;\n      FUNC_00083980();\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00084484": "process_relocation_and_initialize_data_00084484",
                "param_1": "input_param",
                "dVar1": "rel_offset",
                "uVar2": "result",
                "iVar3": "relocation_result"
            },
            "calling": [],
            "called": [
                "FUN_0008397c",
                "FUN_00083888",
                "FUN_00083850",
                "FUN_00083b10",
                "FUN_00083980"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084494": {
            "entrypoint": "0x00084494",
            "current_name": "initialize_memory_and_check_00084494",
            "code": "\nvoid initializeMemoryAndCheck_00084494(int *result,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  int resultInitializeMem;\n  \n  DAT_20071244 = 0;\n  resultInitializeMem = initialize_memory_00080eb0(arg1,arg2,arg2,0,arg3);\n  if ((resultInitializeMem == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084494": "initialize_memory_and_check_00084494",
                "param_1": "result",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "iVar1": "resultInitializeMem"
            },
            "calling": [
                "FUN_00084018"
            ],
            "called": [
                "FUN_00080eb0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844bc": {
            "entrypoint": "0x000844bc",
            "current_name": "get_return_value_and_update_param_000844bc",
            "code": "\nvoid getReturnValueAndUpdateParam_000844bc(int *result,undefined4 value)\n\n{\n  int returnValue;\n  \n  DAT_20071244 = 0;\n  returnValue = get_return_value_00080eba(value);\n  if ((returnValue == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844bc": "get_return_value_and_update_param_000844bc",
                "param_1": "result",
                "param_2": "value",
                "iVar1": "returnValue"
            },
            "calling": [
                "FUN_00084018"
            ],
            "called": [
                "FUN_00080eba"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844e0": {
            "entrypoint": "0x000844e0",
            "current_name": "initialize_and_check_000844e0",
            "code": "\nvoid initializeAndCheck_000844e0(int *output,undefined4 input1,undefined4 input2,undefined4 input3)\n\n{\n  int result;\n  \n  DAT_20071244 = 0;\n  result = initialize_00080ebe(input1,input2,input3);\n  if ((result == -1) && (DAT_20071244 != 0)) {\n    *output = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844e0": "initialize_and_check_000844e0",
                "param_1": "output",
                "param_2": "input1",
                "param_3": "input2",
                "param_4": "input3",
                "iVar1": "result"
            },
            "calling": [
                "FUN_0008427c",
                "FUN_00084244"
            ],
            "called": [
                "FUN_00080ebe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084508": {
            "entrypoint": "0x00084508",
            "current_name": "initialize_data_00084508",
            "code": "\nvoid initializeData_00084508(int *result,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  int clearResult;\n  \n  DAT_20071244 = 0;\n  clearResult = clear_data_00080ec2(arg1,arg2,arg3);\n  if ((clearResult == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084508": "initialize_data_00084508",
                "param_1": "result",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "iVar1": "clearResult"
            },
            "calling": [
                "FUN_00084220"
            ],
            "called": [
                "FUN_00080ec2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084530": {
            "entrypoint": "0x00084530",
            "current_name": "calculate_difference_00084530",
            "code": "\nint calculateDifference_00084530(int input1,int input2,int flag1,int flag2)\n\n{\n  int difference;\n  \n  if ((flag2 == 0) && (flag1 == 0)) {\n    if (input2 != 0 || input1 != 0) {\n      input1 = -1;\n    }\n    return input1;\n  }\n  difference = calculate_difference_0008458c();\n  return difference;\n}\n\n",
            "renaming": {
                "FUN_00084530": "calculate_difference_00084530",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "flag1",
                "param_4": "flag2",
                "iVar1": "difference"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_0008458c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008455c": {
            "entrypoint": "0x0008455c",
            "current_name": "calculate_difference_0008455c",
            "code": "\nvoid calculate_difference_0008455c(uint input_value,int some_value,undefined4 concatenated_value1,undefined4 concatenated_value2,int *output_values)\n\n{\n  uint unsigned_value;\n  longlong result;\n  \n  result = get_divided_value();\n  result = result * CONCAT44(concatenated_value2,concatenated_value1);\n  unsigned_value = (uint)result;\n  *output_values = input_value - unsigned_value;\n  output_values[1] = (some_value - (int)((ulonglong)result >> 0x20)) - (uint)(input_value < unsigned_value);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008455c": "calculate_difference_0008455c",
                "param_1": "input_value",
                "param_2": "some_value",
                "param_3": "concatenated_value1",
                "param_4": "concatenated_value2",
                "param_5": "output_values",
                "uVar1": "unsigned_value",
                "lVar2": "result",
                "divide_with_remainder_000845c0": "get_divided_value"
            },
            "calling": [],
            "called": [
                "FUN_000845c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008458c": {
            "entrypoint": "0x0008458c",
            "current_name": "calculate_difference_0008458c",
            "code": "\nvoid calculate_difference_0008458c(uint dividend,int divisor,undefined4 high_32bits,undefined4 low_32bits,int *result)\n\n{\n  uint quotient;\n  longlong product;\n  \n  product = calculate_quotient_00084860();\n  product = product * CONCAT44(low_32bits,high_32bits);\n  quotient = (uint)product;\n  *result = dividend - quotient;\n  result[1] = (divisor - (int)((ulonglong)product >> 0x20)) - (uint)(dividend < quotient);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008458c": "calculate_difference_0008458c",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "high_32bits",
                "param_4": "low_32bits",
                "param_5": "result",
                "uVar1": "quotient",
                "lVar2": "product"
            },
            "calling": [
                "FUN_00084530"
            ],
            "called": [
                "FUN_00084860"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000845c0": {
            "entrypoint": "0x000845c0",
            "current_name": "divide_with_remainder_000845c0",
            "code": "\nundefined8 divide_with_remainder_000845c0(uint dividend,uint divisor,uint quotient,uint remainder)\n\n{\n  longlong temp_long_var;\n  uint temp_uvar2;\n  uint temp_uvar3;\n  uint temp_uvar4;\n  uint temp_uvar5;\n  int temp_var;\n  uint temp_uvar7;\n  uint temp_uvar8;\n  uint temp_uvar9;\n  uint temp_uvar10;\n  uint temp_uvar11;\n  uint temp_uvar12;\n  bool temp_bool_var;\n  \n  if ((int)divisor < 0) {\n    temp_bool_var = dividend != 0;\n    dividend = -dividend;\n    divisor = -divisor - (uint)temp_bool_var;\n    temp_uvar9 = 0xffffffff;\n  }\n  else {\n    temp_uvar9 = 0;\n  }\n  if ((int)remainder < 0) {\n    temp_uvar9 = ~temp_uvar9;\n    temp_bool_var = quotient != 0;\n    quotient = -quotient;\n    remainder = -remainder - (uint)temp_bool_var;\n  }\n  if (remainder == 0) {\n    if (divisor < quotient) {\n      temp_var = LZCOUNT(quotient);\n      if (temp_var != 0) {\n        temp_uvar3 = dividend >> (0x20U - temp_var & 0xff);\n        quotient = quotient << temp_var;\n        dividend = dividend << temp_var;\n        divisor = divisor << temp_var | temp_uvar3;\n      }\n      temp_uvar2 = quotient >> 0x10;\n      temp_uvar4 = divisor / temp_uvar2;\n      temp_uvar7 = (quotient & 0xffff) * temp_uvar4;\n      temp_uvar10 = dividend >> 0x10 | (divisor - temp_uvar2 * temp_uvar4) * 0x10000;\n      temp_uvar3 = temp_uvar4;\n      if (temp_uvar10 <= temp_uvar7 && temp_uvar7 - temp_uvar10 != 0) {\n        temp_bool_var = CARRY4(temp_uvar10,quotient);\n        temp_uvar10 = temp_uvar10 + quotient;\n        temp_uvar3 = temp_uvar4 - 1;\n        if ((temp_bool_var == false) && (temp_uvar10 <= temp_uvar7 && temp_uvar7 - temp_uvar10 != 0)) {\n          temp_uvar3 = temp_uvar4 - 2;\n          temp_uvar10 = temp_uvar10 + quotient;\n        }\n      }\n      temp_uvar8 = (temp_uvar10 - temp_uvar7) / temp_uvar2;\n      temp_uvar4 = (quotient & 0xffff) * temp_uvar8;\n      temp_uvar7 = dividend & 0xffff | ((temp_uvar10 - temp_uvar7) - temp_uvar2 * temp_uvar8) * 0x10000;\n      temp_uvar2 = temp_uvar8;\n      if (temp_uvar7 <= temp_uvar4 && temp_uvar4 - temp_uvar7 != 0) {\n        temp_uvar2 = temp_uvar8 - 1;\n        if ((CARRY4(temp_uvar7,quotient) == false) &&\n           (temp_uvar7 + quotient <= temp_uvar4 && temp_uvar4 - (temp_uvar7 + quotient) != 0)) {\n          temp_uvar2 = temp_uvar8 - 2;\n        }\n      }\n      temp_uvar2 = temp_uvar2 | temp_uvar3 << 0x10;\n      temp_uvar3 = 0;\n    }\n    else {\n      if (quotient == 0) {\n        quotient = 1 / 0;\n      }\n      temp_var = LZCOUNT(quotient);\n      if (temp_var == 0) {\n        divisor = divisor - quotient;\n        temp_uvar4 = quotient >> 0x10;\n        temp_uvar12 = quotient & 0xffff;\n        temp_uvar3 = 1;\n      }\n      else {\n        quotient = quotient << temp_var;\n        temp_uvar3 = divisor >> (0x20U - temp_var & 0xff);\n        temp_uvar4 = quotient >> 0x10;\n        temp_uvar10 = temp_uvar3 / temp_uvar4;\n        temp_uvar12 = quotient & 0xffff;\n        temp_uvar7 = temp_uvar12 * temp_uvar10;\n        temp_uvar8 = dividend >> (0x20U - temp_var & 0xff) | divisor << temp_var;\n        temp_uvar3 = temp_uvar8 >> 0x10 | (temp_uvar3 - temp_uvar4 * temp_uvar10) * 0x10000;\n        dividend = dividend << temp_var;\n        temp_uvar2 = temp_uvar10;\n        if (temp_uvar3 <= temp_uvar7 && temp_uvar7 - temp_uvar3 != 0) {\n          temp_bool_var = CARRY4(temp_uvar3,quotient);\n          temp_uvar3 = temp_uvar3 + quotient;\n          temp_uvar2 = temp_uvar10 - 1;\n          if ((temp_bool_var == false) && (temp_uvar3 <= temp_uvar7 && temp_uvar7 - temp_uvar3 != 0)) {\n            temp_uvar2 = temp_uvar10 - 2;\n            temp_uvar3 = temp_uvar3 + quotient;\n          }\n        }\n        temp_uvar5 = (temp_uvar3 - temp_uvar7) / temp_uvar4;\n        temp_uvar10 = temp_uvar12 * temp_uvar5;\n        divisor = temp_uvar8 & 0xffff | ((temp_uvar3 - temp_uvar7) - temp_uvar4 * temp_uvar5) * 0x10000;\n        temp_uvar3 = temp_uvar5;\n        if (divisor <= temp_uvar10 && temp_uvar10 - divisor != 0) {\n          temp_bool_var = CARRY4(divisor,quotient);\n          divisor = divisor + quotient;\n          temp_uvar3 = temp_uvar5 - 1;\n          if ((temp_bool_var == false) && (divisor <= temp_uvar10 && temp_uvar10 - divisor != 0)) {\n            temp_uvar3 = temp_uvar5 - 2;\n            divisor = divisor + quotient;\n          }\n        }\n        divisor = divisor - temp_uvar10;\n        temp_uvar3 = temp_uvar3 | temp_uvar2 << 0x10;\n      }\n      temp_uvar2 = divisor / temp_uvar4;\n      temp_uvar10 = temp_uvar12 * temp_uvar2;\n      temp_uvar8 = dividend >> 0x10 | (divisor - temp_uvar4 * temp_uvar2) * 0x10000;\n      temp_uvar7 = temp_uvar2;\n      if (temp_uvar8 <= temp_uvar10 && temp_uvar10 - temp_uvar8 != 0) {\n        temp_bool_var = CARRY4(temp_uvar8,quotient);\n        temp_uvar8 = temp_uvar8 + quotient;\n        temp_uvar7 = temp_uvar2 - 1;\n        if ((temp_bool_var == false) && (temp_uvar8 <= temp_uvar10 && temp_uvar10 - temp_uvar8 != 0)) {\n          temp_uvar7 = temp_uvar2 - 2;\n          temp_uvar8 = temp_uvar8 + quotient;\n        }\n      }\n      temp_uvar5 = (temp_uvar8 - temp_uvar10) / temp_uvar4;\n      temp_uvar12 = temp_uvar12 * temp_uvar5;\n      temp_uvar4 = dividend & 0xffff | ((temp_uvar8 - temp_uvar10) - temp_uvar4 * temp_uvar5) * 0x10000;\n      temp_uvar2 = temp_uvar5;\n      if (temp_uvar4 <= temp_uvar12 && temp_uvar12 - temp_uvar4 != 0) {\n        temp_uvar2 = temp_uvar5 - 1;\n        if ((CARRY4(temp_uvar4,quotient) == false) &&\n           (temp_uvar4 + quotient <= temp_uvar12 && temp_uvar12 - (temp_uvar4 + quotient) != 0)) {\n          temp_uvar2 = temp_uvar5 - 2;\n        }\n      }\n      temp_uvar2 = temp_uvar2 | temp_uvar7 << 0x10;\n    }\n  }\n  else if (divisor < remainder) {\n    temp_uvar3 = 0;\n    temp_uvar2 = 0;\n  }\n  else {\n    temp_var = LZCOUNT(remainder);\n    if (temp_var == 0) {\n      if ((remainder < divisor) || (quotient <= dividend)) {\n        temp_uvar3 = 0;\n        temp_uvar2 = 1;\n      }\n      else {\n        temp_uvar2 = 0;\n        temp_uvar3 = 0;\n      }\n    }\n    else {\n      temp_uvar3 = 0x20 - temp_var;\n      temp_uvar4 = divisor >> (temp_uvar3 & 0xff);\n      temp_uvar12 = quotient >> (temp_uvar3 & 0xff) | remainder << temp_var;\n      temp_uvar10 = temp_uvar12 >> 0x10;\n      temp_uvar2 = temp_uvar4 / temp_uvar10;\n      temp_uvar8 = (temp_uvar12 & 0xffff) * temp_uvar2;\n      temp_uvar7 = divisor << temp_var | dividend >> (temp_uvar3 & 0xff);\n      temp_uvar4 = temp_uvar7 >> 0x10 | (temp_uvar4 - temp_uvar10 * temp_uvar2) * 0x10000;\n      temp_uvar3 = temp_uvar2;\n      if (temp_uvar4 <= temp_uvar8 && temp_uvar8 - temp_uvar4 != 0) {\n        temp_bool_var = CARRY4(temp_uvar4,temp_uvar12);\n        temp_uvar4 = temp_uvar4 + temp_uvar12;\n        temp_uvar3 = temp_uvar2 - 1;\n        if ((temp_bool_var == false) && (temp_uvar4 <= temp_uvar8 && temp_uvar8 - temp_uvar4 != 0)) {\n          temp_uvar3 = temp_uvar2 - 2;\n          temp_uvar4 = temp_uvar4 + temp_uvar12;\n        }\n      }\n      temp_uvar5 = (temp_uvar4 - temp_uvar8) / temp_uvar10;\n      temp_uvar11 = (temp_uvar12 & 0xffff) * temp_uvar5;\n      temp_uvar4 = temp_uvar7 & 0xffff | ((temp_uvar4 - temp_uvar8) - temp_uvar10 * temp_uvar5) * 0x10000;\n      temp_uvar2 = temp_uvar5;\n      if (temp_uvar4 <= temp_uvar11 && temp_uvar11 - temp_uvar4 != 0) {\n        temp_bool_var = CARRY4(temp_uvar4,temp_uvar12);\n        temp_uvar4 = temp_uvar4 + temp_uvar12;\n        temp_uvar2 = temp_uvar5 - 1;\n        if ((temp_bool_var == false) && (temp_uvar4 <= temp_uvar11 && temp_uvar11 - temp_uvar4 != 0)) {\n          temp_uvar2 = temp_uvar5 - 2;\n          temp_uvar4 = temp_uvar4 + temp_uvar12;\n        }\n      }\n      temp_uvar2 = temp_uvar2 | temp_uvar3 << 0x10;\n      temp_long_var = (ulonglong)temp_uvar2 * (ulonglong)(quotient << temp_var);\n      temp_uvar7 = (uint)((ulonglong)temp_long_var >> 0x20);\n      temp_uvar3 = 0;\n      if ((temp_uvar4 - temp_uvar11 < temp_uvar7) ||\n         ((temp_uvar4 - temp_uvar11 == temp_uvar7 && (dividend << temp_var < (uint)temp_long_var)))) {\n        temp_uvar2 = temp_uvar2 - 1;\n        temp_uvar3 = 0;\n      }\n    }\n  }\n  if (temp_uvar9 != 0) {\n    temp_bool_var = temp_uvar2 != 0;\n    temp_uvar2 = -temp_uvar2;\n    temp_uvar3 = -temp_uvar3 - (uint)temp_bool_var;\n  }\n  return CONCAT44(temp_uvar3,temp_uvar2);\n}\n\n",
            "renaming": {
                "FUN_000845c0": "divide_with_remainder_000845c0",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "lVar1": "temp_long_var",
                "uVar2": "temp_uvar2",
                "uVar3": "temp_uvar3",
                "uVar4": "temp_uvar4",
                "uVar5": "temp_uvar5",
                "iVar6": "temp_var",
                "uVar7": "temp_uvar7",
                "uVar8": "temp_uvar8",
                "uVar9": "temp_uvar9",
                "uVar10": "temp_uvar10",
                "uVar11": "temp_uvar11",
                "uVar12": "temp_uvar12",
                "bVar13": "temp_bool_var"
            },
            "calling": [
                "FUN_0008455c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084860": {
            "entrypoint": "0x00084860",
            "current_name": "calculate_quotient_00084860",
            "code": "\nulonglong calculateQuotient_00084860(uint dividend,uint divisor,uint quotient,uint remainder)\n\n{\n  longlong tempVar1;\n  uint resultLower;\n  uint tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  uint tempVar6;\n  uint tempVar7;\n  uint resultUpper;\n  int shiftCount;\n  bool carryFlag;\n  \n  if (remainder == 0) {\n    if (quotient <= divisor) {\n      if (quotient == 0) {\n        quotient = 1 / 0;\n      }\n      shiftCount = LZCOUNT(quotient);\n      if (shiftCount == 0) {\n        divisor = divisor - quotient;\n        tempVar2 = quotient >> 0x10;\n        tempVar4 = quotient & 0xffff;\n        resultLower = 1;\n      }\n      else {\n        quotient = quotient << shiftCount;\n        tempVar7 = divisor >> (0x20U - shiftCount & 0xff);\n        tempVar2 = quotient >> 0x10;\n        resultUpper = tempVar7 / tempVar2;\n        tempVar4 = quotient & 0xffff;\n        resultLower = tempVar4 * resultUpper;\n        tempVar5 = dividend >> (0x20U - shiftCount & 0xff) | divisor << shiftCount;\n        tempVar3 = tempVar5 >> 0x10 | (tempVar7 - tempVar2 * resultUpper) * 0x10000;\n        dividend = dividend << shiftCount;\n        tempVar7 = resultUpper;\n        if (tempVar3 <= resultLower && resultLower - tempVar3 != 0) {\n          carryFlag = CARRY4(tempVar3,quotient);\n          tempVar3 = tempVar3 + quotient;\n          tempVar7 = resultUpper - 1;\n          if ((carryFlag == false) && (tempVar3 <= resultLower && resultLower - tempVar3 != 0)) {\n            tempVar7 = resultUpper - 2;\n            tempVar3 = tempVar3 + quotient;\n          }\n        }\n        tempVar6 = (tempVar3 - resultLower) / tempVar2;\n        resultUpper = tempVar4 * tempVar6;\n        divisor = tempVar5 & 0xffff | ((tempVar3 - resultLower) - tempVar2 * tempVar6) * 0x10000;\n        resultLower = tempVar6;\n        if (divisor <= resultUpper && resultUpper - divisor != 0) {\n          carryFlag = CARRY4(divisor,quotient);\n          divisor = divisor + quotient;\n          resultLower = tempVar6 - 1;\n          if ((carryFlag == false) && (divisor <= resultUpper && resultUpper - divisor != 0)) {\n            resultLower = tempVar6 - 2;\n            divisor = divisor + quotient;\n          }\n        }\n        divisor = divisor - resultUpper;\n        resultLower = resultLower | tempVar7 << 0x10;\n      }\n      resultUpper = divisor / tempVar2;\n      tempVar3 = tempVar4 * resultUpper;\n      tempVar5 = dividend >> 0x10 | (divisor - tempVar2 * resultUpper) * 0x10000;\n      tempVar7 = resultUpper;\n      if (tempVar5 <= tempVar3 && tempVar3 - tempVar5 != 0) {\n        carryFlag = CARRY4(tempVar5,quotient);\n        tempVar5 = tempVar5 + quotient;\n        tempVar7 = resultUpper - 1;\n        if ((carryFlag == false) && (tempVar5 <= tempVar3 && tempVar3 - tempVar5 != 0)) {\n          tempVar7 = resultUpper - 2;\n          tempVar5 = tempVar5 + quotient;\n        }\n      }\n      resultUpper = (tempVar5 - tempVar3) / tempVar2;\n      tempVar4 = tempVar4 * resultUpper;\n      tempVar5 = dividend & 0xffff | ((tempVar5 - tempVar3) - tempVar2 * resultUpper) * 0x10000;\n      tempVar2 = resultUpper;\n      if (tempVar5 <= tempVar4 && tempVar4 - tempVar5 != 0) {\n        tempVar2 = resultUpper - 1;\n        if ((CARRY4(tempVar5,quotient) == false) &&\n           (tempVar5 + quotient <= tempVar4 && tempVar4 - (tempVar5 + quotient) != 0)) {\n          tempVar2 = resultUpper - 2;\n        }\n      }\n      return CONCAT44(resultLower,tempVar2 | tempVar7 << 0x10);\n    }\n    shiftCount = LZCOUNT(quotient);\n    if (shiftCount != 0) {\n      tempVar7 = dividend >> (0x20U - shiftCount & 0xff);\n      quotient = quotient << shiftCount;\n      dividend = dividend << shiftCount;\n      divisor = tempVar7 | divisor << shiftCount;\n    }\n    resultLower = quotient >> 0x10;\n    tempVar2 = divisor / resultLower;\n    tempVar4 = (quotient & 0xffff) * tempVar2;\n    resultUpper = dividend >> 0x10 | (divisor - resultLower * tempVar2) * 0x10000;\n    tempVar7 = tempVar2;\n    if (resultUpper <= tempVar4 && tempVar4 - resultUpper != 0) {\n      carryFlag = CARRY4(resultUpper,quotient);\n      resultUpper = resultUpper + quotient;\n      tempVar7 = tempVar2 - 1;\n      if ((carryFlag == false) && (resultUpper <= tempVar4 && tempVar4 - resultUpper != 0)) {\n        tempVar7 = tempVar2 - 2;\n        resultUpper = resultUpper + quotient;\n      }\n    }\n    tempVar5 = (resultUpper - tempVar4) / resultLower;\n    tempVar2 = (quotient & 0xffff) * tempVar5;\n    tempVar4 = dividend & 0xffff | ((resultUpper - tempVar4) - resultLower * tempVar5) * 0x10000;\n    resultLower = tempVar5;\n    if (tempVar4 <= tempVar2 && tempVar2 - tempVar4 != 0) {\n      resultLower = tempVar5 - 1;\n      if ((CARRY4(tempVar4,quotient) == false) &&\n         (tempVar4 + quotient <= tempVar2 && tempVar2 - (tempVar4 + quotient) != 0)) {\n        resultLower = tempVar5 - 2;\n      }\n    }\n    resultLower = resultLower | tempVar7 << 0x10;\n  }\n  else {\n    if (divisor < remainder) {\n      return 0;\n    }\n    shiftCount = LZCOUNT(remainder);\n    if (shiftCount == 0) {\n      if ((remainder < divisor) || (quotient <= dividend)) {\n        return 1;\n      }\n      resultLower = 0;\n    }\n    else {\n      resultLower = 0x20 - shiftCount;\n      tempVar7 = divisor >> (resultLower & 0xff);\n      tempVar2 = remainder << shiftCount | quotient >> (resultLower & 0xff);\n      tempVar4 = tempVar2 >> 0x10;\n      tempVar3 = tempVar7 / tempVar4;\n      resultUpper = (tempVar2 & 0xffff) * tempVar3;\n      tempVar5 = dividend >> (resultLower & 0xff) | divisor << shiftCount;\n      resultLower = tempVar5 >> 0x10 | (tempVar7 - tempVar4 * tempVar3) * 0x10000;\n      tempVar7 = tempVar3;\n      if (resultLower <= resultUpper && resultUpper - resultLower != 0) {\n        carryFlag = CARRY4(resultLower,tempVar2);\n        resultLower = resultLower + tempVar2;\n        tempVar7 = tempVar3 - 1;\n        if ((carryFlag == false) && (resultLower <= resultUpper && resultUpper - resultLower != 0)) {\n          tempVar7 = tempVar3 - 2;\n          resultLower = resultLower + tempVar2;\n        }\n      }\n      tempVar3 = (resultLower - resultUpper) / tempVar4;\n      tempVar6 = (tempVar2 & 0xffff) * tempVar3;\n      tempVar4 = tempVar5 & 0xffff | ((resultLower - resultUpper) - tempVar4 * tempVar3) * 0x10000;\n      resultLower = tempVar3;\n      if (tempVar4 <= tempVar6 && tempVar6 - tempVar4 != 0) {\n        carryFlag = CARRY4(tempVar4,tempVar2);\n        tempVar4 = tempVar4 + tempVar2;\n        resultLower = tempVar3 - 1;\n        if ((carryFlag == false) && (tempVar4 <= tempVar6 && tempVar6 - tempVar4 != 0)) {\n          resultLower = tempVar3 - 2;\n          tempVar4 = tempVar4 + tempVar2;\n        }\n      }\n      resultLower = resultLower | tempVar7 << 0x10;\n      tempVar1 = (ulonglong)resultLower * (ulonglong)(quotient << shiftCount);\n      tempVar7 = (uint)((ulonglong)tempVar1 >> 0x20);\n      if ((tempVar4 - tempVar6 < tempVar7) || ((tempVar4 - tempVar6 == tempVar7 && (dividend << shiftCount < (uint)tempVar1)))\n         ) {\n        resultLower = resultLower - 1;\n      }\n    }\n  }\n  return (ulonglong)resultLower;\n}\n\n",
            "renaming": {
                "FUN_00084860": "calculate_quotient_00084860",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "lVar1": "tempVar1",
                "uVar2": "resultLower",
                "uVar3": "tempVar2",
                "uVar4": "tempVar3",
                "uVar5": "tempVar4",
                "uVar6": "tempVar5",
                "uVar7": "tempVar6",
                "uVar8": "tempVar7",
                "uVar9": "resultUpper",
                "iVar10": "shiftCount",
                "bVar11": "carryFlag"
            },
            "calling": [
                "FUN_0008458c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00085844": {
            "entrypoint": "0x00085844",
            "current_name": "FUNC_00085844",
            "code": "\nvoid FUNC_00085844(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085844": "FUNC_00085844"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 96906,
    "layers": [
        [
            "FUN_000800f4",
            "FUN_000805a8",
            "FUN_000809be",
            "FUN_000809e4",
            "FUN_00080a0a",
            "FUN_00080a94",
            "FUN_00080aa8",
            "FUN_00080b90",
            "FUN_00080b98",
            "FUN_00080c98",
            "FUN_00080d30",
            "FUN_00080d3e",
            "FUN_00080d58",
            "FUN_00080d62",
            "FUN_00080d6a",
            "FUN_00080e80",
            "FUN_00080e88",
            "FUN_00080eaa",
            "FUN_00080eb0",
            "FUN_00080eba",
            "FUN_00080ebe",
            "FUN_00080ec2",
            "FUN_00080ec8",
            "FUN_00080efe",
            "thunk_FUN_000816d8",
            "FUN_000810cc",
            "FUN_00081190",
            "FUN_000811ca",
            "FUN_00081248",
            "FUN_00081276",
            "FUN_000812b8",
            "FUN_00081348",
            "FUN_0008145c",
            "FUN_000815de",
            "FUN_00081618",
            "FUN_00081684",
            "FUN_000816d8",
            "FUN_000816ec",
            "FUN_00081778",
            "FUN_00081d48",
            "FUN_00081e34",
            "FUN_00081f00",
            "FUN_00082390",
            "FUN_000825cc",
            "FUN_00082688",
            "FUN_00084004",
            "FUN_0008400c",
            "FUN_000840f8",
            "thunk_FUN_00080efe",
            "FUN_0008439c",
            "FUN_000845c0",
            "FUN_00084860"
        ],
        [
            "FUN_000806f8",
            "FUN_00080970",
            "FUN_00080a30",
            "FUN_000810a6",
            "FUN_000811b0",
            "FUN_000811e8",
            "FUN_000813dc",
            "FUN_00081438",
            "FUN_000815b8",
            "FUN_00081624",
            "FUN_0008236c",
            "FUN_00083888",
            "FUN_000841e4",
            "FUN_0008434c",
            "FUN_00084494",
            "FUN_000844bc",
            "FUN_000844e0",
            "FUN_00084508",
            "FUN_0008455c",
            "FUN_0008458c"
        ],
        [
            "FUN_00080164",
            "FUN_0008089c",
            "FUN_00080f0c",
            "FUN_000810c4",
            "FUN_000810d8",
            "FUN_000810fc",
            "FUN_00083a74",
            "FUN_00084220",
            "FUN_00084244",
            "FUN_0008427c",
            "FUN_00084530"
        ],
        [
            "FUN_00081014",
            "FUN_000810e8",
            "FUN_0008113a",
            "thunk_FUN_0008113a",
            "FUN_00083b10"
        ],
        [
            "FUN_0008044c",
            "FUN_00080774",
            "FUN_0008117a",
            "FUN_00081800",
            "FUN_00081810",
            "FUN_00083850"
        ],
        [
            "FUN_00081472",
            "FUN_00081480",
            "FUN_0008151c",
            "FUN_000817f0",
            "FUN_00081fac",
            "FUN_00084018",
            "FUN_00084484"
        ],
        [
            "FUN_00081560",
            "FUN_00081f9c",
            "FUN_0008356c"
        ],
        [
            "FUN_00081496",
            "FUN_00083ca8",
            "FUN_000842a4"
        ],
        [
            "FUN_000814ae",
            "FUN_000839b4"
        ],
        [
            "FUN_000814d0",
            "FUN_00081570",
            "FUN_00082824"
        ],
        [
            "FUN_000814f6",
            "FUN_0008159e"
        ],
        [
            "FUN_00081214"
        ],
        [
            "FUN_00080250"
        ],
        [
            "FUN_00081750",
            "FUN_000817c8",
            "FUN_000834f0"
        ],
        [
            "FUN_00080eec",
            "FUN_0008289c"
        ],
        [
            "FUN_000836ec"
        ],
        [
            "FUN_000816f8"
        ],
        [
            "FUN_00080b2c"
        ],
        [
            "FUN_000803fc"
        ],
        [
            "FUN_000806a0"
        ],
        [
            "FUN_000801e0"
        ],
        [
            "FUN_000815ec"
        ]
    ],
    "locked_functions": []
}