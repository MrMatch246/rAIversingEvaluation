{
    "functions": {
        "FUN_000800f4": {
            "entrypoint": "0x000800f4",
            "current_name": "initialize_flag_000800f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080100) */\n\nundefined4 initializeFlag_000800f4(undefined4 input)\n\n{\n  if ((char)DAT_200708a0 == '\\0') {\n    DAT_200708a0._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_000800f4": "initialize_flag_000800f4",
                "param_1": "input"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080118": {
            "entrypoint": "0x00080118",
            "current_name": "FUNC_00080118",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0008011e) */\n/* WARNING: Removing unreachable block (ram,0x00080130) */\n\n\nvoid FUNC_00080118(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080118": "FUNC_00080118"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080164": {
            "entrypoint": "0x00080164",
            "current_name": "initialize_data_00080164",
            "code": "\nvoid initializeData_00080164(undefined4 arg1,undefined4 arg2,undefined4 arg3,undefined4 arg4)\n\n{\n  FUN_000806f8(&DAT_200708e8,0x5a);\n  FUN_000806f8(&DAT_200708d4,0x5a,arg3,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080164": "initialize_data_00080164",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000801e0"
            ],
            "called": [
                "FUN_000806f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000801e0": {
            "entrypoint": "0x000801e0",
            "current_name": "initialize_system_000801e0",
            "code": "\nundefined8 initialize_system_000801e0(undefined4 arg1,undefined4 arg2,undefined4 arg3,undefined4 arg4)\n\n{\n  FUN_000813dc(&DAT_20070be8,0xe100,arg3,arg4,arg4);\n  FUN_00080f0c(0xd,1);\n  FUN_00080f0c(6,1);\n  FUN_00080f0c(0x39,0);\n  FUN_00080f0c(4,0);\n  FUN_00080f0c(3,0);\n  FUN_00080f0c(2,0);\n  FUN_000806a0(&DAT_200708d4,5);\n  FUN_000806a0(&DAT_200708e8,6);\n  FUN_00080164();\n  FUNC_00080f08(1000);\n  if (DAT_200708bc == 0) {\n    software_interrupt(0x3f);\n    return 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000801e0": "initialize_system_000801e0",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_000806a0",
                "FUN_00080f0c",
                "FUN_00080f08",
                "FUN_00080164",
                "FUN_000813dc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080250": {
            "entrypoint": "0x00080250",
            "current_name": "control_mode_00080250",
            "code": "\nvoid controlMode_00080250(void)\n\n{\n  undefined4 returnValue;\n  int counter;\n  undefined *pointer;\n  undefined stackArray [12];\n  \n  DAT_200708c0 = FUN_00081624(4,1,20000);\n  FUNC_00080f08(10);\n  DAT_200708c4 = DAT_200708c4 ^ 1;\n  FUN_00081014(0xd);\n  if (DAT_200708c0 < 0x641) {\n    if (DAT_200708c0 - 0x385U < 299) {\n      if (DAT_200708eb != '\\0') {\n        FUN_00080164();\n        FUN_000810e8(&DAT_20070be8,\"Entered manual control mode.\");\n        DAT_200708eb = '\\0';\n      }\n      FUNC_00080f08(10);\n      returnValue = FUN_00081624(3,1,20000);\n      DAT_200708d8 = FUN_0008145c(0,1000,2000,0x28,0x96);\n      DAT_200708ec = FUN_0008145c(returnValue,1000,2000,0x28,0x96);\n      while (counter = FUN_00081248(&DAT_20070be8), 0 < counter) {\n        FUN_00081276(&DAT_20070be8);\n        thunk_FUN_0008113a(&DAT_20070be8,DAT_200708d8,10);\n        FUN_000810c4(&DAT_20070be8,&DAT_00084b13);\n        FUN_0008117a(&DAT_20070be8,DAT_200708ec,10);\n      }\n      FUN_000806f8(&DAT_200708e8,DAT_200708ec);\n      FUN_000806f8(&DAT_200708d4,DAT_200708d8);\n    }\n    else {\n      if (DAT_200708eb == '\\0') {\n        FUN_00080164();\n        FUN_000810e8(&DAT_20070be8,\"Entered autonomous control mode.\");\n      }\n      DAT_200708eb = '\\x01';\nautonomousMode:\n      counter = FUN_00081248(&DAT_20070be8);\n      if (0 < counter) {\n        FUN_00081214(stackArray,&DAT_20070be8,0x2c);\n        FUN_00081560(&DAT_200708dc,stackArray);\n        FUN_00081472(stackArray);\n        FUN_00081214(stackArray,&DAT_20070be8,10);\n        FUN_00081560(&DAT_200708c8,stackArray);\n        FUN_00081472(stackArray);\n        FUN_00081276(&DAT_20070be8);\n        counter = FUN_000815b8(&DAT_200708dc,\"steer\");\n        if (counter == 0) goto LAB_0008039c;\n        returnValue = FUN_000815de(&DAT_200708c8);\n        pointer = &DAT_200708d4;\n        goto steerCheck;\n      }\n    }\n  }\n  else {\n    FUN_00080164();\n    FUN_000810e8(&DAT_20070be8,\"error\");\n  }\n  return;\nLAB_0008039c:\n  counter = FUN_000815b8(&DAT_200708dc,\"motor\");\n  if (counter != 0) {\n    returnValue = FUN_000815de(&DAT_200708c8);\n    pointer = &DAT_200708e8;\nsteerCheck:\n    FUN_000806f8(pointer,returnValue);\n  }\n  goto autonomousMode;\n}\n\n",
            "renaming": {
                "FUN_00080250": "control_mode_00080250",
                "uVar1": "returnValue",
                "iVar2": "counter",
                "puVar3": "pointer",
                "auStack_1c": "stackArray",
                "LAB_00080346": "autonomousMode",
                "LAB_000803b2": "steerCheck"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_000810c4",
                "FUN_00081472",
                "FUN_000815b8",
                "FUN_00081248",
                "FUN_000806f8",
                "FUN_00081214",
                "FUN_00080164",
                "FUN_000810e8",
                "FUN_00080f08",
                "FUN_00081276",
                "FUN_00081560",
                "FUN_00081014",
                "FUN_00081624",
                "thunk_FUN_0008113a",
                "FUN_000815de",
                "FUN_0008117a",
                "FUN_0008145c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000803fc": {
            "entrypoint": "0x000803fc",
            "current_name": "initialize_tc_channel_000803fc",
            "code": "\nvoid initializeTcChannel_000803fc(int channelIndex,uint dwChannel,undefined4 unaff_r4,uint bitIndex)\n\n{\n  undefined4 pTc;\n  undefined4 unaff_r5;\n  undefined8 combinedParams;\n  \n  combinedParams = CONCAT44(dwChannel,channelIndex);\n  FUN_00080aa8(unaff_r4);\n  FUN_00080b2c(channelIndex,dwChannel,0xc002);\n  FUN_00080b90(channelIndex,dwChannel,0xa41);\n  *(int *)((bitIndex >> 5) * 4 + -0x1fff1f00) = 1 << (bitIndex & 0x1f);\n  *(undefined4 *)(channelIndex + dwChannel * 0x40 + 0x24) = 4;\n  if (2 < dwChannel) {\n    combinedParams = FUN_000816f8(\"../source/tc.c\",0x5c,\"TC_Start\",\n                         \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\",\n                         pTc,unaff_r5);\n  }\n  *(undefined4 *)((int)combinedParams + (int)((ulonglong)combinedParams >> 0x20) * 0x40) = 5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000803fc": "initialize_tc_channel_000803fc",
                "param_1": "channelIndex",
                "param_2": "dwChannel",
                "param_3": "unaff_r4",
                "param_4": "bitIndex",
                "unaff_r4": "pTc",
                "in_lr": "unaff_r5",
                "uVar1": "combinedParams"
            },
            "calling": [
                "FUN_000806a0"
            ],
            "called": [
                "FUN_00080b90",
                "FUN_00080b2c",
                "FUN_00080aa8",
                "FUN_000816f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008044c": {
            "entrypoint": "0x0008044c",
            "current_name": "update_memory_0008044c",
            "code": "\nvoid updateMemory_0008044c(int index,int memory,int offset)\n\n{\n  uint limit;\n  int temp;\n  \n  offset = offset * 0x40;\n  if (((&DAT_200708f1)[index] & 0x80) == 0) {\n    temp = index * 0xc;\n    if (((char)(&DAT_200708f1)[index] + temp < (int)(uint)DAT_200708f0) &&\n       ((int)((uint)(byte)(&DAT_200708f8)[((char)(&DAT_200708f1)[index] + temp) * 8] << 0x19) < 0\n       )) {\n      FUN_00081014((&DAT_200708f8)[(temp + (char)(&DAT_200708f1)[index]) * 8] & 0x3f,0);\n    }\n  }\n  else {\n    *(uint *)(memory + offset) = *(uint *)(memory + offset) | 4;\n  }\n  limit = (uint)DAT_200708f0;\n  (&DAT_200708f1)[index] = (&DAT_200708f1)[index] + '\\x01';\n  temp = index * 0xc;\n  if (((char)(&DAT_200708f1)[index] + temp < (int)limit) &&\n     ((char)(&DAT_200708f1)[index] < '\\f')) {\n    *(int *)(memory + offset + 0x14) =\n         *(int *)(memory + offset + 0x10) +\n         *(int *)(&DAT_200708fc + ((char)(&DAT_200708f1)[index] + temp) * 8);\n    if (-1 < (int)((uint)(byte)(&DAT_200708f8)[((char)(&DAT_200708f1)[index] + temp) * 8] << 0x19\n                  )) {\n      return;\n    }\n    FUN_00081014((&DAT_200708f8)[(temp + (char)(&DAT_200708f1)[index]) * 8] & 0x3f,1);\n    return;\n  }\n  memory = memory + offset;\n  limit = (rel_array[6].r_offset / 1000000) * 20000 >> 5;\n  if (limit <= *(int *)(memory + 0x10) + 4U) {\n    limit = *(int *)(memory + 0x10) + 4;\n  }\n  *(uint *)(memory + 0x14) = limit;\n  (&DAT_200708f1)[index] = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008044c": "update_memory_0008044c",
                "param_1": "index",
                "param_2": "memory",
                "param_3": "offset",
                "uVar1": "limit",
                "iVar2": "temp",
                "Elf32_Rel_ARRAY_20070000": "rel_array"
            },
            "calling": [],
            "called": [
                "FUN_00081014"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000805a8": {
            "entrypoint": "0x000805a8",
            "current_name": "process_data_000805a8",
            "code": "\nvoid processData_000805a8(byte *data)\n\n{\n  char newByte;\n  uint counter;\n  \n  counter = (uint)DAT_200708f0;\n  if (counter < 0x3c) {\n    newByte = DAT_200708f0 + 1;\n    *data = DAT_200708f0;\n    DAT_200708f0 = newByte;\n    *(uint *)(&DAT_200708fc + counter * 8) =\n         (Elf32_Rel_ARRAY_20070000[6].r_offset / 1000000) * 0x5dc >> 5;\n    return;\n  }\n  *data = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000805a8": "process_data_000805a8",
                "param_1": "data",
                "cVar1": "newByte",
                "uVar2": "counter"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806a0": {
            "entrypoint": "0x000806a0",
            "current_name": "process_data_000806a0",
            "code": "\nbyte processData_000806a0(byte *data,undefined4 param)\n\n{\n  byte value;\n  undefined4 baseAddress;\n  uint index;\n  undefined4 mask;\n  int count;\n  uint dataValue;\n  \n  if (0x3b < *data) goto LAB_00080660;\n  FUN_00080f0c(param,1,0x220,*data,0x960);\n  dataValue = (uint)*data;\n  value = (&DAT_200708f8)[dataValue * 8];\n  data[2] = 0;\n  index = dataValue / 0xc;\n  (&DAT_200708f8)[dataValue * 8] = value & 0xc0 | (byte)param & 0x3f;\n  data[1] = 0;\n  count = 0;\n  do {\n    if ((int)((uint)(byte)(&DAT_200708f8)[(count + index * 0xc) * 8] << 0x19) < 0)\n    goto LAB_00080652;\n    count = count + 1;\n  } while (count != 0xc);\n  if (index == 0) {\n    baseAddress = 0x40084000;\n    mask = 0x1e;\nLAB_0008064c:\n    FUN_000803fc(baseAddress,index,mask,mask);\n  }\n  else {\n    if (index == 1) {\n      baseAddress = 0x40084000;\n      mask = 0x1f;\n      goto LAB_0008064c;\n    }\n    if (index == 2) {\n      baseAddress = 0x40084000;\n      mask = 0x20;\n      goto LAB_0008064c;\n    }\n    if (index == 3) {\n      baseAddress = 0x40080000;\n      index = 2;\n      mask = 0x1d;\n      goto LAB_0008064c;\n    }\n    if (index == 4) {\n      baseAddress = 0x40080000;\n      index = 0;\n      mask = 0x1b;\n      goto LAB_0008064c;\n    }\n  }\nLAB_00080652:\n  (&DAT_200708f8)[(uint)*data * 8] = (&DAT_200708f8)[(uint)*data * 8] | 0x40;\nLAB_00080660:\n  return *data;\n}\n\n",
            "renaming": {
                "FUN_000806a0": "process_data_000806a0",
                "param_1": "data",
                "param_2": "param",
                "bVar1": "value",
                "uVar2": "baseAddress",
                "uVar3": "index",
                "uVar4": "mask",
                "iVar5": "count",
                "uVar6": "dataValue"
            },
            "calling": [
                "FUN_000801e0"
            ],
            "called": [
                "FUN_000803fc",
                "FUN_00080f0c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806f8": {
            "entrypoint": "0x000806f8",
            "current_name": "process_data_000806f8",
            "code": "\nvoid processData_000806f8(byte *dataPtr,uint dataSize)\n\n{\n  uint adjustedSize;\n  \n  if ((int)dataSize < 0x220) {\n    adjustedSize = dataSize;\n    if (0xb3 < (int)dataSize) {\n      adjustedSize = 0xb4;\n    }\n    dataSize = FUN_0008145c(adjustedSize & ~((int)adjustedSize >> 0x1f),0,0xb4,(0x88 - (char)dataPtr[1]) * 4,\n                           (600 - (char)dataPtr[2]) * 4,dataSize);\n  }\n  if (*dataPtr < 0x3c) {\n    adjustedSize = (0x88 - (char)dataPtr[1]) * 4;\n    if (((int)(dataSize + (0x88 - (char)dataPtr[1]) * -4) < 0 == SBORROW4(dataSize,adjustedSize)) &&\n       (adjustedSize = (600 - (char)dataPtr[2]) * 4, (int)dataSize <= (int)adjustedSize)) {\n      adjustedSize = dataSize;\n    }\n    *(uint *)(&DAT_200708fc + (uint)*dataPtr * 8) =\n         (Elf32_Rel_ARRAY_20070000[6].r_offset / 1000000) * (adjustedSize - 2) >> 5;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000806f8": "process_data_000806f8",
                "param_1": "dataPtr",
                "param_2": "dataSize",
                "uVar1": "adjustedSize"
            },
            "calling": [
                "FUN_00080250",
                "FUN_00080164"
            ],
            "called": [
                "FUN_0008145c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008073a": {
            "entrypoint": "0x0008073a",
            "current_name": "FUNC_0008073a",
            "code": "\nvoid FUNC_0008073a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008073a": "FUNC_0008073a"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080748": {
            "entrypoint": "0x00080748",
            "current_name": "FUNC_00080748",
            "code": "\nvoid FUNC_00080748(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080748": "FUNC_00080748"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074a": {
            "entrypoint": "0x0008074a",
            "current_name": "FUNC_0008074a",
            "code": "\nvoid FUNC_0008074a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074a": "FUNC_0008074a"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074c": {
            "entrypoint": "0x0008074c",
            "current_name": "FUNC_0008074c",
            "code": "\nvoid FUNC_0008074c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074c": "FUNC_0008074c"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080774": {
            "entrypoint": "0x00080774",
            "current_name": "initialize_system_00080774",
            "code": "\n\n\nvoid initializeSystem_00080774(void)\n\n{\n  int index;\n  int nextIndex;\n  \n  FUN_00080b98();\n  _DAT_e000e014 = Elf32_Rel_ARRAY_20070000[6].r_offset / 1000 - 1;\n  DAT_e000ed23 = 0xf0;\n  _DAT_e000e018 = 0;\n  _DAT_e000e010 = 7;\n  FUN_00081778();\n  index = 0;\n  do {\n    nextIndex = index + 1;\n    FUN_00081014(index,0);\n    index = nextIndex;\n  } while (nextIndex != 0x4f);\n  _DAT_400e0ea0 = 0xffffffff;\n  _DAT_400e10a0 = 0xffffffff;\n  _DAT_400e12a0 = 0xffffffff;\n  _DAT_400e14a0 = 0xffffffff;\n  FUN_00080a30(0x400e0e00,1,0x300,0);\n  FUN_00081014(0,1);\n  FUN_00080a30(0x400e0e00,1,0xc00,0);\n  FUN_00080a30(0x400e0e00,1,0x3000,0);\n  FUN_00080a30(0x400e1400,2,0x30,0);\n  FUN_00080a30(0x400e1000,1,0xc00,0);\n  FUN_00080a30(0x400e0e00,1,3,0);\n  FUN_00080a30(0x400e1000,1,0xc000,0);\n  FUN_00080aa8(0x25);\n  FUN_00080c98(0x400c0000,Elf32_Rel_ARRAY_20070000[6].r_offset,20000000,0xc);\n  FUN_00080d3e(0x400c0000,0,0x300000,1);\n  FUN_00080d30(0x400c0000,0,0);\n  FUN_00080d6a(0x400c0000,0xffffffff);\n  FUN_00080d62(0x400c0000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080774": "initialize_system_00080774",
                "iVar1": "index",
                "iVar2": "nextIndex"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_00080d3e",
                "FUN_00081778",
                "FUN_00081014",
                "FUN_00080c98",
                "FUN_00080b98",
                "FUN_00080a30",
                "FUN_00080d30",
                "FUN_00080aa8",
                "FUN_00080d6a",
                "FUN_00080d62"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008089c": {
            "entrypoint": "0x0008089c",
            "current_name": "initialize_data_structures_0008089c",
            "code": "\nvoid initializeDataStructures_0008089c(undefined4 param1,undefined4 param2,undefined4 param3)\n\n{\n  FUN_000811b0(&DAT_20070c0c);\n  FUN_000811b0(&DAT_20070b60);\n  FUN_00081348(&DAT_20070be8,0x400e0800,8,8,&DAT_20070c0c,&DAT_20070b60,param3);\n  FUN_000811b0(&DAT_20070e6c);\n  FUN_000811b0(&DAT_20070ef4);\n  FUN_000811b0(&DAT_20070f7c);\n  FUN_000811b0(&DAT_20070ad8);\n  FUN_000811b0(&DAT_20070d0c);\n  FUN_000811b0(&DAT_20070d94);\n  FUN_00081438(&DAT_20070c94,0x40098000,0x11,0x11,&DAT_20070e6c,&DAT_20070ad8);\n  FUN_00081438(&DAT_20070cbc,0x4009c000,0x12,0x12,&DAT_20070ef4,&DAT_20070d0c);\n  FUN_00081438(&DAT_20070ce4,0x400a4000,0x14,0x14,&DAT_20070f7c,&DAT_20070d94);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008089c": "initialize_data_structures_0008089c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3"
            },
            "calling": [],
            "called": [
                "FUN_000811b0",
                "FUN_00081348",
                "FUN_00081438"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080970": {
            "entrypoint": "0x00080970",
            "current_name": "check_and_execute_functions_00080970",
            "code": "\nvoid checkAndExecuteFunctions_00080970(void)\n\n{\n  int result;\n  \n  result = FUN_00081248(&DAT_20070be8);\n  if (result != 0) {\n    FUNC_0008073a();\n  }\n  result = FUN_00081248(&DAT_20070c94);\n  if (result != 0) {\n    FUNC_00080748();\n  }\n  result = FUN_00081248(&DAT_20070cbc);\n  if (result != 0) {\n    FUNC_0008074a();\n  }\n  result = FUN_00081248(&DAT_20070ce4);\n  if (result != 0) {\n    FUNC_0008074c();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080970": "check_and_execute_functions_00080970",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_0008074a",
                "FUN_0008073a",
                "FUN_00081248",
                "FUN_00080748",
                "FUN_0008074c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809be": {
            "entrypoint": "0x000809be",
            "current_name": "update_value_000809be",
            "code": "\nvoid updateValue_000809be(int baseAddr,undefined4 option,uint value)\n\n{\n  uint updatedValue;\n  \n  *(uint *)(baseAddr + 0x44) = value;\n  switch(option) {\n  case 0:\n  case 3:\n  case 4:\n  case 5:\n    return;\n  case 1:\n    updatedValue = *(uint *)(baseAddr + 0x70) & *(uint *)(baseAddr + 0x70) & ~value;\n    break;\n  case 2:\n    updatedValue = *(uint *)(baseAddr + 0x70) | value;\n    break;\n  default:\n    goto switchD_000809c4_caseD_6;\n  }\n  *(uint *)(baseAddr + 0x70) = updatedValue;\nswitchD_000809c4_caseD_6:\n  *(uint *)(baseAddr + 4) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809be": "update_value_000809be",
                "param_1": "baseAddr",
                "param_2": "option",
                "param_3": "value",
                "uVar1": "updatedValue"
            },
            "calling": [
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809e4": {
            "entrypoint": "0x000809e4",
            "current_name": "update_params_000809e4",
            "code": "\nvoid updateParams_000809e4(undefined4 *paramArray,undefined4 newValue,uint flags)\n\n{\n  bool isNegative;\n  \n  isNegative = (int)(flags << 0x1f) < 0;\n  paramArray[0x11] = newValue;\n  if (isNegative) {\n    paramArray[0x19] = newValue;\n  }\n  if (!isNegative) {\n    paramArray[0x18] = newValue;\n  }\n  isNegative = (flags & 10) != 0;\n  if (isNegative) {\n    paramArray[8] = newValue;\n  }\n  if (!isNegative) {\n    paramArray[9] = newValue;\n  }\n  if (((int)(flags << 0x1e) < 0) || ((int)(flags << 0x1c) < 0)) {\n    paramArray[0x20] = newValue;\n  }\n  paramArray[5] = newValue;\n  *paramArray = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809e4": "update_params_000809e4",
                "param_1": "paramArray",
                "param_2": "newValue",
                "param_3": "flags",
                "bVar1": "isNegative"
            },
            "calling": [
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a0a": {
            "entrypoint": "0x00080a0a",
            "current_name": "update_parameter_value_00080a0a",
            "code": "\nvoid updateParameterValue_00080a0a(undefined4 *paramArray,undefined4 newValue,int condition1,int condition2,int condition3)\n\n{\n  paramArray[0x11] = newValue;\n  if (condition3 == 0) {\n    paramArray[0x18] = newValue;\n  }\n  else {\n    paramArray[0x19] = newValue;\n  }\n  if (condition2 == 0) {\n    paramArray[0x15] = newValue;\n  }\n  else {\n    paramArray[0x14] = newValue;\n  }\n  if (condition1 == 0) {\n    paramArray[0xd] = newValue;\n  }\n  else {\n    paramArray[0xc] = newValue;\n  }\n  paramArray[4] = newValue;\n  *paramArray = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080a0a": "update_parameter_value_00080a0a",
                "param_1": "paramArray",
                "param_2": "newValue",
                "param_3": "condition1",
                "param_4": "condition2",
                "param_5": "condition3"
            },
            "calling": [
                "FUN_00081014",
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a30": {
            "entrypoint": "0x00080a30",
            "current_name": "update_config_00080a30",
            "code": "\nundefined4 updateConfig_00080a30(int configPtr,int type,undefined4 value,uint flags)\n\n{\n  bool isNegative;\n  \n  switch(type) {\n  case 1:\n  case 2:\n    FUN_000809be(configPtr,type,value);\n    isNegative = (int)(flags << 0x1f) < 0;\n    *(undefined4 *)(configPtr + 0x44) = value;\n    if (isNegative) {\n      *(undefined4 *)(configPtr + 100) = value;\n    }\n    if (!isNegative) {\n      *(undefined4 *)(configPtr + 0x60) = value;\n    }\n    break;\n  case 3:\n    FUN_000809e4(configPtr,value,flags,0x809e5,configPtr);\n    break;\n  case 4:\n  case 5:\n    FUN_00080a0a(configPtr,value,type == 5,(flags << 0x1d) >> 0x1f,flags & 1,type,value)\n    ;\n    break;\n  default:\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080a30": "update_config_00080a30",
                "param_1": "configPtr",
                "param_2": "type",
                "param_3": "value",
                "param_4": "flags",
                "bVar1": "isNegative"
            },
            "calling": [
                "FUN_00080f0c",
                "FUN_00080774"
            ],
            "called": [
                "FUN_00080a0a",
                "FUN_000809e4",
                "FUN_000809be"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a94": {
            "entrypoint": "0x00080a94",
            "current_name": "check_permissions_00080a94",
            "code": "\nuint check_permissions_00080a94(int input_ptr,uint mask)\n\n{\n  uint result;\n  \n  result = *(uint *)(input_ptr + 8) & mask;\n  if (result != 0) {\n    if ((mask & *(uint *)(input_ptr + 0x18)) == 0) {\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00080a94": "check_permissions_00080a94",
                "param_1": "input_ptr",
                "param_2": "mask",
                "uVar1": "result"
            },
            "calling": [
                "FUN_00081014"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080aa8": {
            "entrypoint": "0x00080aa8",
            "current_name": "check_bit_and_set_00080aa8",
            "code": "\n\n\nundefined4 checkBitAndSet_00080aa8(uint input)\n\n{\n  uint bitMask;\n  \n  if (input < 0x2d) {\n    if (input < 0x20) {\n      bitMask = 1 << (input & 0xff);\n      if ((bitMask & _DAT_400e0618) != bitMask) {\n        _DAT_400e0610 = bitMask;\n      }\n    }\n    else {\n      bitMask = 1 << (input - 0x20 & 0xff);\n      if ((bitMask & _DAT_400e0708) != bitMask) {\n        _DAT_400e0700 = bitMask;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080aa8": "check_bit_and_set_00080aa8",
                "param_1": "input",
                "uVar1": "bitMask"
            },
            "calling": [
                "FUN_000803fc",
                "FUN_00080f0c",
                "FUN_00080774",
                "FUN_000813dc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b2c": {
            "entrypoint": "0x00080b2c",
            "current_name": "initialize_channel_00080b2c",
            "code": "\nvoid initializeChannel_00080b2c(undefined4 param_1,uint param_2,char *param_3)\n\n{\n  int channelOffset;\n  int channelAddress;\n  undefined8 combinedParams;\n  \n  combinedParams = CONCAT44(param_2,param_1);\n  if (2 < param_2) {\n    param_3 = \"TC_Configure\";\n    combinedParams = FUN_000816f8(\"../source/tc.c\",0x40,\"TC_Configure\",\n                         \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\");\n  }\n  channelOffset = (int)((ulonglong)combinedParams >> 0x20) * 0x40;\n  channelAddress = (int)combinedParams + channelOffset;\n  *(undefined4 *)((int)combinedParams + channelOffset) = 2;\n  *(undefined4 *)(channelAddress + 0x28) = 0xffffffff;\n  *(char **)(channelAddress + 4) = param_3;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b2c": "initialize_channel_00080b2c",
                "iVar1": "channelOffset",
                "iVar2": "channelAddress",
                "uVar3": "combinedParams"
            },
            "calling": [
                "FUN_000803fc"
            ],
            "called": [
                "FUN_000816f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b90": {
            "entrypoint": "0x00080b90",
            "current_name": "set_param_value_00080b90",
            "code": "\nvoid setParamValue_00080b90(int baseAddress,int index,undefined4 newValue)\n\n{\n  *(undefined4 *)(baseAddress + index * 0x40 + 0x14) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b90": "set_param_value_00080b90",
                "param_1": "baseAddress",
                "param_2": "index",
                "param_3": "newValue"
            },
            "calling": [
                "FUN_000803fc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b98": {
            "entrypoint": "0x00080b98",
            "current_name": "initialize_settings_00080b98",
            "code": "\n\n\nvoid initializeSettings_00080b98(void)\n\n{\n  _DAT_400e0a00 = 0x400;\n  _DAT_400e0c00 = 0x400;\n  _DAT_400e0620 = _DAT_400e0620 << 7;\n  while (-1 < _DAT_400e0620) {\n    _DAT_400e0620 = _DAT_400e0668 << 0x1f;\n  }\n  _DAT_400e0620 = 0x1370809;\n  do {\n  } while (-1 < _DAT_400e0668 << 0xf);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0628 = 0x200d3f01;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1e);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0630 = 0x12;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  elfRelocationArray[6].r_offset = 84000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b98": "initialize_settings_00080b98",
                "Elf32_Rel_ARRAY_20070000": "elfRelocationArray"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "entry": {
            "entrypoint": "0x00080c20",
            "current_name": "entry",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080c6a) */\n\n\nvoid entry(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  \n  for (iVar1 = 0; (undefined4 *)((int)&Elf32_Rel_ARRAY_20070000[0].r_offset + iVar1) < &DAT_200708a0\n      ; iVar1 = iVar1 + 4) {\n    *(undefined4 *)((int)&Elf32_Rel_ARRAY_20070000[0].r_offset + iVar1) =\n         *(undefined4 *)(&DAT_00085878 + iVar1);\n  }\n  for (puVar2 = &DAT_200708a0; puVar2 < (undefined4 *)0x20071248; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  _DAT_e000ed08 = 0x80000;\n  FUN_000815ec();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "FUN_000815ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080c98": {
            "entrypoint": "0x00080c98",
            "current_name": "calculate_scaling_factor_00080c98",
            "code": "\nundefined4 calculateScalingFactor_00080c98(undefined4 *output,uint inputSize,int scaleFactor,int multiplier)\n\n{\n  uint numIterations;\n  uint index;\n  uint thresholds [16];\n  \n  thresholds[0] = 0;\n  thresholds[1] = 8;\n  thresholds[2] = 0x10;\n  thresholds[3] = 0x18;\n  thresholds[4] = 0x40;\n  thresholds[5] = 0x50;\n  thresholds[6] = 0x60;\n  thresholds[7] = 0x70;\n  thresholds[8] = 0x200;\n  thresholds[9] = 0x240;\n  thresholds[10] = 0x280;\n  thresholds[11] = 0x2c0;\n  thresholds[12] = 0x300;\n  thresholds[13] = 0x340;\n  thresholds[14] = 0x380;\n  thresholds[15] = 0x3c0;\n  *output = 1;\n  output[1] = 0;\n  output[72] = 0x202;\n  output[65] = 0;\n  output[69] = 0;\n  numIterations = inputSize / (uint)(scaleFactor * 2);\n  if (inputSize == scaleFactor * 2 * numIterations) {\n    numIterations = numIterations - 1;\n  }\n  index = 0;\n  do {\n    if ((uint)(multiplier * (int)(((ulonglong)inputSize / (ulonglong)((numIterations + 1) * 2)) / 1000000)) <=\n        thresholds[index]) {\n      output[1] = (index & 0xf) << 0x10 | (numIterations & 0xff) << 8 | output[1];\n      return 0;\n    }\n    index = index + 1;\n  } while (index != 0x10);\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080c98": "calculate_scaling_factor_00080c98",
                "param_1": "output",
                "param_2": "inputSize",
                "param_3": "scaleFactor",
                "param_4": "multiplier",
                "local_58": "thresholds",
                "param_1[1]": "output[1]",
                "param_1[0x48]": "output[72]",
                "param_1[0x41]": "output[65]",
                "param_1[0x45]": "output[69]",
                "uVar1": "numIterations",
                "uVar2": "index"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d30": {
            "entrypoint": "0x00080d30",
            "current_name": "update_flags_00080d30",
            "code": "\nvoid updateFlags_00080d30(int baseAddress,uint value,uint bitValue)\n\n{\n  *(uint *)(baseAddress + 4) = value | *(uint *)(baseAddress + 4) | (bitValue & 1) << 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d30": "update_flags_00080d30",
                "param_1": "baseAddress",
                "param_2": "value",
                "param_3": "bitValue"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d3e": {
            "entrypoint": "0x00080d3e",
            "current_name": "update_data_00080d3e",
            "code": "\nvoid updateData_00080d3e(int dataAddress,uint input1,uint input2,uint input3)\n\n{\n  *(uint *)(dataAddress + 4) =\n       input2 | *(uint *)(dataAddress + 4) | (input1 & 0xf) << 0x18 | (input3 & 3) << 0x1c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d3e": "update_data_00080d3e",
                "param_1": "dataAddress",
                "param_2": "input1",
                "param_3": "input2",
                "param_4": "input3"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d58": {
            "entrypoint": "0x00080d58",
            "current_name": "set_bit_00080d58",
            "code": "\nvoid setBit_00080d58(int baseAddress,uint bitPosition)\n\n{\n  *(int *)(baseAddress + 0x14) = 1 << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d58": "set_bit_00080d58",
                "param_1": "baseAddress",
                "param_2": "bitPosition"
            },
            "calling": [
                "FUN_00080f0c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d62": {
            "entrypoint": "0x00080d62",
            "current_name": "initialize_memory_00080d62",
            "code": "\nvoid initializeMemory_00080d62(int startAddress)\n\n{\n  *(undefined4 *)(startAddress + 0x14) = 0xffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d62": "initialize_memory_00080d62",
                "param_1": "startAddress"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d6a": {
            "entrypoint": "0x00080d6a",
            "current_name": "set_parameter_value_00080d6a",
            "code": "\nvoid setParameterValue_00080d6a(int functionPointer,undefined4 newValue)\n\n{\n  *(undefined4 *)(functionPointer + 0x28) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d6a": "set_parameter_value_00080d6a",
                "param_1": "functionPointer",
                "param_2": "newValue"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e80": {
            "entrypoint": "0x00080e80",
            "current_name": "initialize_system_00080e80",
            "code": "\nvoid initializeSystem_00080e80(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080e80": "initialize_system_00080e80",
                "undefined4": "void"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e88": {
            "entrypoint": "0x00080e88",
            "current_name": "calculate_sum_00080e88",
            "code": "\nint calculateSum_00080e88(int input)\n\n{\n  int previousValue;\n  \n  if (DAT_20071208 == 0) {\n    DAT_20071208 = 0x20071248;\n  }\n  previousValue = DAT_20071208;\n  DAT_20071208 = input + DAT_20071208;\n  return previousValue;\n}\n\n",
            "renaming": {
                "FUN_00080e88": "calculate_sum_00080e88",
                "param_1": "input",
                "iVar1": "previousValue"
            },
            "calling": [
                "FUN_0008236c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eaa": {
            "entrypoint": "0x00080eaa",
            "current_name": "get_default_value_00080eaa",
            "code": "\nuint32_t get_default_value_00080eaa(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080eaa": "get_default_value_00080eaa",
                "undefined4": "uint32_t"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eb0": {
            "entrypoint": "0x00080eb0",
            "current_name": "initialize_memory_00080eb0",
            "code": "\nundefined4 initializeMemory_00080eb0(undefined4 destination,int source)\n\n{\n  *(undefined4 *)(source + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080eb0": "initialize_memory_00080eb0",
                "param_1": "destination",
                "param_2": "source"
            },
            "calling": [
                "FUN_00084494"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eba": {
            "entrypoint": "0x00080eba",
            "current_name": "get_return_value_00080eba",
            "code": "\nReturnType getReturnValue_00080eba(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080eba": "get_return_value_00080eba",
                "undefined4": "ReturnType"
            },
            "calling": [
                "FUN_000844bc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ebe": {
            "entrypoint": "0x00080ebe",
            "current_name": "initialize_program_00080ebe",
            "code": "\nundefined4 initializeProgram_00080ebe(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ebe": "initialize_program_00080ebe"
            },
            "calling": [
                "FUN_000844e0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec2": {
            "entrypoint": "0x00080ec2",
            "current_name": "get_return_value_00080ec2",
            "code": "\nuint32_t getReturnValue_00080ec2(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ec2": "get_return_value_00080ec2",
                "undefined4": "uint32_t"
            },
            "calling": [
                "FUN_00084508"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec8": {
            "entrypoint": "0x00080ec8",
            "current_name": "copy_data_00080ec8",
            "code": "\n\n\nuint copyData_00080ec8(undefined4 param1,int source,uint size)\n\n{\n  int i;\n  \n  for (i = 0; i < (int)size; i = i + 1) {\n    do {\n    } while (-1 < _DAT_400e0814 << 0x1e);\n    _DAT_400e081c = (uint)*(byte *)(source + i);\n  }\n  return size & ~((int)size >> 0x1f);\n}\n\n",
            "renaming": {
                "FUN_00080ec8": "copy_data_00080ec8",
                "param_1": "param1",
                "param_2": "source",
                "param_3": "size",
                "iVar1": "i"
            },
            "calling": [
                "FUN_00084244"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eec": {
            "entrypoint": "0x00080eec",
            "current_name": "exit_with_status_00080eec",
            "code": "\nvoid exitWithStatus_00080eec(undefined4 status,undefined4 unused,undefined4 fmt,undefined4 args)\n\n{\n  FUN_000817c8(\"Exiting with status %d.\\n\",status,fmt,args,args);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080eec": "exit_with_status_00080eec",
                "param_1": "status",
                "param_2": "unused",
                "param_3": "fmt",
                "param_4": "args"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_000817c8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080efc": {
            "entrypoint": "0x00080efc",
            "current_name": "FUNC_00080efc",
            "code": "\nvoid FUNC_00080efc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080efc": "FUNC_00080efc"
            },
            "calling": [
                "FUN_000841e4"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080efe": {
            "entrypoint": "0x00080efe",
            "current_name": "get_error_value_00080efe",
            "code": "\nerror_value get_error_value_00080efe(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080efe": "get_error_value_00080efe",
                "undefined4": "error_value"
            },
            "calling": [
                "thunk_FUN_00080efe"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_000816d8": {
            "entrypoint": "0x00080f04",
            "current_name": "get_data_thunk_000816d8",
            "code": "\nundefined4 get_data_thunk_000816d8(void)\n\n{\n  return DAT_2007120c;\n}\n\n",
            "renaming": {
                "thunk_FUN_000816d8": "get_data_thunk_000816d8"
            },
            "calling": [
                "FUN_000811e8"
            ],
            "called": [
                "FUN_000816d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f08": {
            "entrypoint": "0x00080f08",
            "current_name": "FUNC_00080f08",
            "code": "\nvoid FUNC_00080f08(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080f08": "FUNC_00080f08"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000801e0",
                "FUN_000815ec"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080f0c": {
            "entrypoint": "0x00080f0c",
            "current_name": "check_and_modify_value_00080f0c",
            "code": "\n\n\nint check_and_modify_value_00080f0c(int index,int value_type)\n\n{\n  int result;\n  uint temp_uint1;\n  undefined4 temp_uint2;\n  uint temp_uint3;\n  byte lower_nibble;\n  byte full_byte;\n  int temp_int1;\n  int temp_int2;\n  \n  result = index;\n  if ((&DAT_00084b50)[index * 0x1c] != '\\0') {\n    if (((&DAT_20070e1c)[index] & 0xf) == 4) {\n      result = FUN_00080d58(0x400c0000,(&DAT_00084b5d)[index * 0x1c]);\n    }\n    full_byte = (&DAT_20070e1c)[index];\n    lower_nibble = full_byte & 0xf;\n    if ((lower_nibble < 3) && (full_byte != 0)) {\n      if (lower_nibble == 2) {\n        if (value_type == 0) {\n          return result;\n        }\n      }\n      else if (lower_nibble == 1) {\n        if (value_type == 2) {\n          return result;\n        }\n      }\n      else if (lower_nibble == 3) {\n        if (value_type == 1) {\n          return result;\n        }\n        goto LAB_00080f68;\n      }\n    }\n    if (value_type != 1) {\nLAB_00080f68:\n      if (value_type == 0) {\n        result = index * 0x1c;\n        FUN_00080aa8(*(undefined4 *)(&DAT_00084b4c + result));\n        result = FUN_00080a30(*(undefined4 *)(&DAT_00084b44 + result),3,\n                             *(undefined4 *)(&DAT_00084b48 + result),0);\n        full_byte = (&DAT_20070e1c)[index] & 0xf0 | 2;\n      }\n      else {\n        if (value_type != 2) {\n          return result;\n        }\n        result = index * 0x1c;\n        FUN_00080aa8(*(undefined4 *)(&DAT_00084b4c + result));\n        result = FUN_00080a30(*(undefined4 *)(&DAT_00084b44 + result),3,\n                             *(undefined4 *)(&DAT_00084b48 + result),1);\n        full_byte = (&DAT_20070e1c)[index] & 0xf0 | 1;\n      }\n      (&DAT_20070e1c)[index] = full_byte;\n      return result;\n    }\n    temp_int1 = index * 0x1c;\n    temp_int2 = *(int *)(&DAT_00084b44 + temp_int1);\n    if (full_byte >> 4 == 0) {\n      temp_uint2 = 4;\n    }\n    else {\n      temp_uint2 = 5;\n    }\n    result = FUN_00080a30(temp_int2,temp_uint2,*(undefined4 *)(&DAT_00084b48 + temp_int1),\n                         *(undefined4 *)(&DAT_00084b54 + temp_int1));\n    (&DAT_20070e1c)[index] = (&DAT_20070e1c)[index] & 0xf0 | 3;\n    if (*(int *)(temp_int2 + 0x18) == -1) {\n      temp_uint1 = *(uint *)(&DAT_00084b4c + temp_int1);\n      if (0x2c < temp_uint1) {\n        return 1;\n      }\n      if (temp_uint1 < 0x20) {\n        temp_uint1 = 1 << (temp_uint1 & 0xff);\n        temp_uint3 = _DAT_400e0618 & temp_uint1;\n        if (temp_uint3 == temp_uint1) {\n          _DAT_400e0614 = temp_uint3;\n        }\n      }\n      else {\n        temp_uint1 = 1 << (temp_uint1 - 0x20 & 0xff);\n        temp_uint3 = _DAT_400e0708 & temp_uint1;\n        if (temp_uint3 == temp_uint1) {\n          _DAT_400e0704 = temp_uint3;\n        }\n      }\n      return 0;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00080f0c": "check_and_modify_value_00080f0c",
                "param_1": "index",
                "param_2": "value_type",
                "iVar1": "result",
                "uVar2": "temp_uint1",
                "uVar3": "temp_uint2",
                "uVar4": "temp_uint3",
                "bVar5": "lower_nibble",
                "bVar6": "full_byte",
                "iVar7": "temp_int1",
                "iVar8": "temp_int2"
            },
            "calling": [
                "FUN_00081014",
                "FUN_000806a0",
                "FUN_000801e0"
            ],
            "called": [
                "FUN_00080a30",
                "FUN_00080aa8",
                "FUN_00080d58"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081014": {
            "entrypoint": "0x00081014",
            "current_name": "update_data_00081014",
            "code": "\nvoid updateData_00081014(int index,int value,undefined4 paramValue)\n\n{\n  int result;\n  undefined4 data;\n  int ptr;\n  \n  if ((&DAT_00084b50)[index * 0x1c] != '\\0') {\n    if (((&DAT_20070e1c)[index] & 0xf) == 5) {\n      FUN_00080f0c(index,1,paramValue,5,index,value,paramValue);\n    }\n    (&DAT_20070e1c)[index] = (&DAT_20070e1c)[index] & 0xf | (byte)(value << 4);\n    ptr = *(int *)(&DAT_00084b44 + index * 0x1c);\n    data = *(undefined4 *)(&DAT_00084b48 + index * 0x1c);\n    result = FUN_00080a94(ptr,data);\n    if (result == 0) {\n      if (value != 0) {\n        *(undefined4 *)(ptr + 100) = data;\n        return;\n      }\n      *(undefined4 *)(ptr + 0x60) = data;\n      return;\n    }\n    FUN_00080a0a(ptr,data,value,0,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081014": "update_data_00081014",
                "param_1": "index",
                "param_2": "value",
                "param_3": "paramValue",
                "iVar1": "result",
                "uVar2": "data",
                "iVar3": "ptr"
            },
            "calling": [
                "FUN_00080250",
                "FUN_0008044c",
                "FUN_00080774"
            ],
            "called": [
                "FUN_00080a0a",
                "FUN_00080f0c",
                "FUN_00080a94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810a6": {
            "entrypoint": "0x000810a6",
            "current_name": "execute_function_000810a6",
            "code": "\nvoid executeFunction_000810a6(int *functionPointer,int parameterValue,undefined4 param3,undefined4 param4)\n\n{\n  undefined4 result;\n  \n  if (parameterValue != 0) {\n    result = FUN_00082688(parameterValue);\n    (**(code **)(*functionPointer + 4))(functionPointer,parameterValue,result,*(code **)(*functionPointer + 4),param4);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810a6": "execute_function_000810a6",
                "param_1": "functionPointer",
                "param_2": "parameterValue",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "result"
            },
            "calling": [
                "FUN_000810c4",
                "FUN_000810d8",
                "FUN_000810fc",
                "FUN_000810e8"
            ],
            "called": [
                "FUN_00082688"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810c4": {
            "entrypoint": "0x000810c4",
            "current_name": "initialize_application_000810c4",
            "code": "\nvoid initializeApplication_000810c4(void)\n\n{\n  FUN_000810a6();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810c4": "initialize_application_000810c4"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810cc": {
            "entrypoint": "0x000810cc",
            "current_name": "execute_function_000810cc",
            "code": "\nvoid executeFunction_000810cc(undefined4 *functionPointer)\n\n{\n  (**(code **)*functionPointer)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810cc": "execute_function_000810cc",
                "param_1": "functionPointer"
            },
            "calling": [
                "FUN_0008113a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810d8": {
            "entrypoint": "0x000810d8",
            "current_name": "initialize_data_000810d8",
            "code": "\nvoid initializeData_000810d8(undefined4 data,undefined4 unusedParam,undefined4 buffer,undefined4 size)\n\n{\n  FUN_000810a6(data,&DAT_00085635,buffer,size,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810d8": "initialize_data_000810d8",
                "param_1": "data",
                "param_2": "unusedParam",
                "param_3": "buffer",
                "param_4": "size"
            },
            "calling": [
                "FUN_0008117a",
                "FUN_000810e8"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810e8": {
            "entrypoint": "0x000810e8",
            "current_name": "add_variables_000810e8",
            "code": "\nint addVariables_000810e8(undefined4 inputParam)\n\n{\n  int result1;\n  int result2;\n  \n  result1 = FUN_000810a6();\n  result2 = FUN_000810d8(inputParam);\n  return result2 + result1;\n}\n\n",
            "renaming": {
                "FUN_000810e8": "add_variables_000810e8",
                "param_1": "inputParam",
                "iVar1": "result1",
                "iVar2": "result2"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810a6",
                "FUN_000810d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810fc": {
            "entrypoint": "0x000810fc",
            "current_name": "convert_decimal_to_base_n_000810fc",
            "code": "\nvoid convertDecimalToBaseN_000810fc(undefined4 outputBuffer,uint decimalNumber,uint base)\n\n{\n  char *outputPtr;\n  uint quotient;\n  char *currentDigitPtr;\n  char currentDigit;\n  uint remainder;\n  char digitsBuffer [5];\n  \n  digitsBuffer[1] = 0;\n  if (base < 2) {\n    base = 10;\n  }\n  outputPtr = digitsBuffer;\n  do {\n    currentDigitPtr = outputPtr;\n    quotient = decimalNumber / base;\n    remainder = decimalNumber - base * quotient & 0xff;\n    currentDigit = (char)remainder;\n    if (remainder < 10) {\n      currentDigit = currentDigit + '0';\n    }\n    else {\n      currentDigit = currentDigit + '7';\n    }\n    *currentDigitPtr = currentDigit;\n    decimalNumber = quotient;\n    outputPtr = currentDigitPtr + -1;\n  } while (quotient != 0);\n  FUN_000810a6(outputBuffer,currentDigitPtr);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810fc": "convert_decimal_to_base_n_000810fc",
                "param_1": "outputBuffer",
                "param_2": "decimalNumber",
                "param_3": "base",
                "pcVar1": "outputPtr",
                "uVar2": "quotient",
                "pcVar3": "currentDigitPtr",
                "cVar4": "currentDigit",
                "uVar5": "remainder",
                "local_15": "digitsBuffer"
            },
            "calling": [
                "FUN_0008113a"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008113a": {
            "entrypoint": "0x0008113a",
            "current_name": "convert_number_to_string_0008113a",
            "code": "\nint convertNumberToString_0008113a(undefined4 *outputString,uint number,uint base,undefined4 undefined)\n\n{\n  int result;\n  int negative;\n  \n  if (base == 0) {\n    result = (**(code **)*outputString)(outputString,number & 0xff);\n    return result;\n  }\n  if (base == 10) {\n    base = 10;\n    if ((int)number < 0) {\n      result = FUN_000810cc(outputString,0x2d);\n      negative = FUN_000810fc(outputString,-number,10);\n      return negative + result;\n    }\n  }\n  else {\n    base = base & 0xff;\n  }\n  result = FUN_000810fc(outputString,number,base,undefined);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0008113a": "convert_number_to_string_0008113a",
                "param_1": "outputString",
                "param_2": "number",
                "param_3": "base",
                "param_4": "undefined",
                "iVar1": "result",
                "iVar2": "negative"
            },
            "calling": [
                "thunk_FUN_0008113a",
                "FUN_0008117a"
            ],
            "called": [
                "FUN_000810cc",
                "FUN_000810fc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_0008113a": {
            "entrypoint": "0x00081176",
            "current_name": "convert_number_thunk_0008113a",
            "code": "\nint convertNumber_thunk_0008113a(undefined4 *data,uint number,uint base,undefined4 unknown)\n\n{\n  int result;\n  int negative;\n  \n  if (base == 0) {\n    result = (**(code **)*data)(data,number & 0xff);\n    return result;\n  }\n  if (base == 10) {\n    base = 10;\n    if ((int)number < 0) {\n      result = FUN_000810cc(data,0x2d);\n      negative = FUN_000810fc(data,-number,10);\n      return negative + result;\n    }\n  }\n  else {\n    base = base & 0xff;\n  }\n  result = FUN_000810fc(data,number,base,unknown);\n  return result;\n}\n\n",
            "renaming": {
                "thunk_FUN_0008113a": "convert_number_thunk_0008113a",
                "param_1": "data",
                "param_2": "number",
                "param_3": "base",
                "param_4": "unknown",
                "iVar1": "result",
                "iVar2": "negative"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008113a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008117a": {
            "entrypoint": "0x0008117a",
            "current_name": "sum_of_function_results_0008117a",
            "code": "\nint sumOfFunctionResults_0008117a(undefined4 input)\n\n{\n  int result1;\n  int result2;\n  \n  result1 = FUN_0008113a();\n  result2 = FUN_000810d8(input);\n  return result2 + result1;\n}\n\n",
            "renaming": {
                "FUN_0008117a": "sum_of_function_results_0008117a",
                "param_1": "input",
                "iVar1": "result1",
                "iVar2": "result2"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810d8",
                "FUN_0008113a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081190": {
            "entrypoint": "0x00081190",
            "current_name": "execute_if_relocation_index_zero_00081190",
            "code": "\nvoid executeIfRelocationIndexZero_00081190(void)\n\n{\n  if ((relocationArray[6].relocationInfo != 0xffffffff) &&\n     (relocationArray[6].relocationInfo = relocationArray[6].relocationInfo - 1,\n     relocationArray[6].relocationInfo == 0)) {\n    (*(executeFunction *)((int)&relocationArray[0].relocationOffset + 1))();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081190": "execute_if_relocation_index_zero_00081190",
                "Elf32_Rel_ARRAY_20070000": "relocationArray",
                "r_info": "relocationInfo",
                "r_offset": "relocationOffset",
                "code": "executeFunction"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811b0": {
            "entrypoint": "0x000811b0",
            "current_name": "initialize_memory_000811b0",
            "code": "\nint initializeMemory_000811b0(int memoryAddress)\n\n{\n  FUN_00081f00(memoryAddress,0,0x80);\n  *(undefined4 *)(memoryAddress + 0x80) = 0;\n  *(undefined4 *)(memoryAddress + 0x84) = 0;\n  return memoryAddress;\n}\n\n",
            "renaming": {
                "FUN_000811b0": "initialize_memory_000811b0",
                "param_1": "memoryAddress"
            },
            "calling": [
                "FUN_0008089c"
            ],
            "called": [
                "FUN_00081f00"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811ca": {
            "entrypoint": "0x000811ca",
            "current_name": "update_data_000811ca",
            "code": "\nvoid updateData_000811ca(int data,undefined value)\n\n{\n  uint currentIndex;\n  \n  currentIndex = *(int *)(data + 0x80) + 1U & 0x7f;\n  if (currentIndex != *(uint *)(data + 0x84)) {\n    *(undefined *)(data + *(int *)(data + 0x80)) = value;\n    *(uint *)(data + 0x80) = currentIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000811ca": "update_data_000811ca",
                "param_1": "data",
                "param_2": "value",
                "uVar1": "currentIndex"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811e8": {
            "entrypoint": "0x000811e8",
            "current_name": "check_and_get_item_000811e8",
            "code": "\nint check_and_get_item_000811e8(int *item)\n\n{\n  int result;\n  \n  result = thunk_FUN_000816d8();\n  item[3] = result;\n  do {\n    result = (**(item_code **)(*item + 0xc))(item);\n    if (-1 < result) {\n      return result;\n    }\n    result = thunk_FUN_000816d8();\n  } while ((uint)(result - item[3]) < (uint)item[2]);\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000811e8": "check_and_get_item_000811e8",
                "param_1": "item",
                "iVar1": "result",
                "code": "item_code"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "thunk_FUN_000816d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081214": {
            "entrypoint": "0x00081214",
            "current_name": "process_data_00081214",
            "code": "\nvoid processData_00081214(undefined4 param1,undefined4 param2,uint targetValue)\n\n{\n  uint returnValue;\n  \n  FUN_000814f6(param1,&DAT_00085637);\n  while ((returnValue = FUN_000811e8(param2), -1 < (int)returnValue && (returnValue != targetValue))) {\n    FUN_0008159e(param1,returnValue & 0xff);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081214": "process_data_00081214",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "targetValue",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008159e",
                "FUN_000811e8",
                "FUN_000814f6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081248": {
            "entrypoint": "0x00081248",
            "current_name": "calculate_difference_00081248",
            "code": "\nuint calculateDifference_00081248(int input)\n\n{\n  return *(int *)(*(int *)(input + 0x10) + 0x80) - *(int *)(*(int *)(input + 0x10) + 0x84) &\n         0x7f;\n}\n\n",
            "renaming": {
                "FUN_00081248": "calculate_difference_00081248",
                "param_1": "input"
            },
            "calling": [
                "FUN_00080250",
                "FUN_00080970"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081276": {
            "entrypoint": "0x00081276",
            "current_name": "extract_byte_from_buffer_00081276",
            "code": "\nuint extractByteFromBuffer_00081276(int bufferAddress)\n\n{\n  byte extractedByte;\n  int bufferOffset;\n  \n  bufferOffset = *(int *)(bufferAddress + 0x10);\n  if (*(int *)(bufferOffset + 0x80) != *(int *)(bufferOffset + 0x84)) {\n    extractedByte = *(byte *)(bufferOffset + *(int *)(bufferOffset + 0x84));\n    *(uint *)(bufferOffset + 0x84) = *(int *)(bufferOffset + 0x84) + 1U & 0x7f;\n    return (uint)extractedByte;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00081276": "extract_byte_from_buffer_00081276",
                "param_1": "bufferAddress",
                "iVar2": "bufferOffset",
                "bVar1": "extractedByte"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000812b8": {
            "entrypoint": "0x000812b8",
            "current_name": "update_value_000812b8",
            "code": "\nundefined4 updateValue_000812b8(int dataStruct,undefined4 newValue)\n\n{\n  int var1;\n  uint updatedValue;\n  \n  var1 = *(int *)(dataStruct + 0x14);\n  if ((*(int *)(*(int *)(dataStruct + 0x18) + 0x14) << 0x1e < 0) &&\n     (*(int *)(var1 + 0x84) == *(int *)(var1 + 0x80))) {\n    *(undefined4 *)(*(int *)(dataStruct + 0x18) + 0x1c) = newValue;\n  }\n  else {\n    updatedValue = *(int *)(var1 + 0x80) + 1U & 0x8000007f;\n    if ((int)updatedValue < 0) {\n      updatedValue = (updatedValue - 1 | 0xffffff80) + 1;\n    }\n    do {\n    } while (*(uint *)(var1 + 0x84) == updatedValue);\n    *(char *)(var1 + *(int *)(var1 + 0x80)) = (char)newValue;\n    *(uint *)(*(int *)(dataStruct + 0x14) + 0x80) = updatedValue;\n    *(undefined4 *)(*(int *)(dataStruct + 0x18) + 8) = 2;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000812b8": "update_value_000812b8",
                "param_1": "dataStruct",
                "param_2": "newValue",
                "iVar1": "var1",
                "uVar2": "updatedValue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081348": {
            "entrypoint": "0x00081348",
            "current_name": "initialize_params_00081348",
            "code": "\nvoid initializeParams_00081348(undefined4 *outputArray,undefined4 param2Value,undefined param3Value,undefined4 param4Value,\n                 undefined4 param5Value,undefined4 param6Value)\n\n{\n  outputArray[1] = 0;\n  outputArray[2] = 1000;\n  outputArray[6] = param2Value;\n  *outputArray = &PTR_FUN_000812b8_1_00085650;\n  *(undefined *)(outputArray + 7) = param3Value;\n  outputArray[4] = param5Value;\n  outputArray[8] = param4Value;\n  outputArray[5] = param6Value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081348": "initialize_params_00081348",
                "param_1": "outputArray",
                "param_2": "param2Value",
                "param_3": "param3Value",
                "param_4": "param4Value",
                "param_5": "param5Value",
                "param_6": "param6Value"
            },
            "calling": [
                "FUN_00081438",
                "FUN_0008089c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813dc": {
            "entrypoint": "0x000813dc",
            "current_name": "initialize_component_000813dc",
            "code": "\nvoid initializeComponent_000813dc(int componentAddress,uint pageSize)\n\n{\n  int component1;\n  undefined4 *componentInfo;\n  \n  FUN_00080aa8(*(undefined4 *)(componentAddress + 0x20));\n  componentInfo = *(undefined4 **)(componentAddress + 0x18);\n  someValue = 0x202;\n  *componentInfo = 0xac;\n  value2 = 0x800;\n  relocationValue = relocationTable[6].r_offset / pageSize >> 4;\n  defaultConstant = 0xffffffff;\n  specificValue = 0x61;\n  *(int *)(((uint)(int)(char)*(byte *)(componentAddress + 0x1c) >> 5) * 4 + -0x1fff1f00) =\n       1 << (uint)(*(byte *)(componentAddress + 0x1c) & 0x1f);\n  component1 = *(int *)(componentAddress + 0x10);\n  *(undefined4 *)(component1 + 0x84) = 0;\n  *(undefined4 *)(component1 + 0x80) = 0;\n  component1 = *(int *)(componentAddress + 0x14);\n  *(undefined4 *)(component1 + 0x84) = 0;\n  *(undefined4 *)(component1 + 0x80) = 0;\n  *componentInfo = 0x50;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000813dc": "initialize_component_000813dc",
                "param_1": "componentAddress",
                "param_2": "pageSize",
                "iVar1": "component1",
                "puVar2": "componentInfo",
                "Elf32_Rel_ARRAY_20070000": "relocationTable",
                "puVar2[0x48]": "someValue",
                "puVar2[1]": "value2",
                "puVar2[8]": "relocationValue",
                "puVar2[3]": "defaultConstant",
                "puVar2[2]": "specificValue"
            },
            "calling": [
                "FUN_000801e0"
            ],
            "called": [
                "FUN_00080aa8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081438": {
            "entrypoint": "0x00081438",
            "current_name": "set_function_pointers_00081438",
            "code": "\nundefined4 * setFunctionPointers_00081438(undefined4 *outputArray,undefined4 inputValue)\n\n{\n  FUN_00081348();\n  *outputArray = &PTR_FUN_000812b8_1_00085680;\n  outputArray[9] = inputValue;\n  return outputArray;\n}\n\n",
            "renaming": {
                "FUN_00081438": "set_function_pointers_00081438",
                "param_1": "outputArray",
                "param_2": "inputValue"
            },
            "calling": [
                "FUN_0008089c"
            ],
            "called": [
                "FUN_00081348"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008145c": {
            "entrypoint": "0x0008145c",
            "current_name": "calculate_interpolation_0008145c",
            "code": "\nint calculateInterpolation_0008145c(int startValue,int startRange,int endRange,int startOutput,int endOutput)\n\n{\n  return (unsignedInt)((startValue - startRange) * (endOutput - startOutput)) / (unsignedInt)(endRange - startRange) + startOutput;\n}\n\n",
            "renaming": {
                "FUN_0008145c": "calculate_interpolation_0008145c",
                "param_1": "startValue",
                "param_2": "startRange",
                "param_3": "endRange",
                "param_4": "startOutput",
                "param_5": "endOutput",
                "uint": "unsignedInt"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000806f8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081472": {
            "entrypoint": "0x00081472",
            "current_name": "initialize_data_00081472",
            "code": "\nundefined4 * initializeData_00081472(undefined4 *dataPointer)\n\n{\n  FUN_00081800(*dataPointer);\n  return dataPointer;\n}\n\n",
            "renaming": {
                "FUN_00081472": "initialize_data_00081472",
                "param_1": "dataPointer"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00081800"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081480": {
            "entrypoint": "0x00081480",
            "current_name": "reset_pointer_00081480",
            "code": "\nvoid resetPointer_00081480(int *ptr)\n\n{\n  if (*ptr != 0) {\n    FUN_00081800();\n  }\n  *ptr = 0;\n  ptr[2] = 0;\n  ptr[1] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081480": "reset_pointer_00081480",
                "param_1": "ptr"
            },
            "calling": [
                "FUN_000814d0"
            ],
            "called": [
                "FUN_00081800"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081496": {
            "entrypoint": "0x00081496",
            "current_name": "update_array_00081496",
            "code": "\nint updateArray_00081496(int *array,int index,undefined4 value1,undefined4 value2)\n\n{\n  int result;\n  \n  result = FUN_00081f9c(*array,index + 1,value1,value2,value2);\n  if (result != 0) {\n    *array = result;\n    array[1] = index;\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00081496": "update_array_00081496",
                "param_1": "array",
                "param_2": "index",
                "param_3": "value1",
                "param_4": "value2",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000814ae"
            ],
            "called": [
                "FUN_00081f9c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814ae": {
            "entrypoint": "0x000814ae",
            "current_name": "check_and_update_data_000814ae",
            "code": "\nundefined4 checkAndUpdateData_000814ae(int *data,uint threshold)\n\n{\n  int result;\n  \n  if ((*data == 0) || ((uint)data[1] < threshold)) {\n    result = FUN_00081496(data);\n    if (result == 0) {\n      return 0;\n    }\n    if (data[2] == 0) {\n      *(undefined *)*data = 0;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000814ae": "check_and_update_data_000814ae",
                "param_1": "data",
                "param_2": "threshold",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000814d0",
                "FUN_00081570"
            ],
            "called": [
                "FUN_00081496"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814d0": {
            "entrypoint": "0x000814d0",
            "current_name": "process_data_000814d0",
            "code": "\nundefined4 * processData_000814d0(undefined4 *dataArray,undefined4 value1,undefined4 value2)\n\n{\n  int result;\n  \n  result = FUN_000814ae(dataArray,value2);\n  if (result == 0) {\n    FUN_00081480(dataArray);\n  }\n  else {\n    dataArray[2] = value2;\n    FUN_000825cc(*dataArray,value1);\n  }\n  return dataArray;\n}\n\n",
            "renaming": {
                "FUN_000814d0": "process_data_000814d0",
                "param_1": "dataArray",
                "param_2": "value1",
                "param_3": "value2",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000814f6"
            ],
            "called": [
                "FUN_00081480",
                "FUN_000814ae",
                "FUN_000825cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814f6": {
            "entrypoint": "0x000814f6",
            "current_name": "initialize_param_array_000814f6",
            "code": "\nundefined4 * initialize_param_array_000814f6(undefined4 *output_array,int input_value)\n\n{\n  undefined4 result_value;\n  \n  *output_array = 0;\n  output_array[1] = 0;\n  output_array[2] = 0;\n  if (input_value != 0) {\n    result_value = FUN_00082688(input_value);\n    FUN_000814d0(output_array,input_value,result_value);\n  }\n  return output_array;\n}\n\n",
            "renaming": {
                "FUN_000814f6": "initialize_param_array_000814f6",
                "param_1": "output_array",
                "param_2": "input_value",
                "uVar1": "result_value"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "FUN_000814d0",
                "FUN_00082688"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008151c": {
            "entrypoint": "0x0008151c",
            "current_name": "copy_params_0008151c",
            "code": "\nvoid copyParams_0008151c(int *destination,int *source)\n\n{\n  if (*destination != 0) {\n    if ((*source != 0) && ((uint)sourceLength <= (uint)destinationLength)) {\n      FUN_000825cc();\n      destination[2] = sourceLength;\n      goto LAB_00081558;\n    }\n    FUN_00081800();\n  }\n  *destination = *source;\n  destinationLength = source[1];\n  destination[2] = sourceLength;\n  *source = 0;\n  source[1] = 0;\nLAB_00081558:\n  sourceLength = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008151c": "copy_params_0008151c",
                "param_1": "destination",
                "param_2": "source",
                "param_1[1]": "destinationLength",
                "param_2[2]": "sourceLength"
            },
            "calling": [
                "FUN_00081560"
            ],
            "called": [
                "FUN_00081800",
                "FUN_000825cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081560": {
            "entrypoint": "0x00081560",
            "current_name": "check_parameters_equal_00081560",
            "code": "\nint check_parameters_equal_00081560(int input_1,int input_2)\n\n{\n  if (input_1 != input_2) {\n    FUN_0008151c();\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_00081560": "check_parameters_equal_00081560",
                "param_1": "input_1",
                "param_2": "input_2"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008151c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081570": {
            "entrypoint": "0x00081570",
            "current_name": "process_data_00081570",
            "code": "\nundefined4 process_data_00081570(int *data_array,int data_length,int offset)\n\n{\n  int result;\n  int current_offset;\n  \n  current_offset = data_array[2];\n  if (data_length == 0) {\n    return 0;\n  }\n  if (offset != 0) {\n    result = FUN_000814ae(data_array,current_offset + offset);\n    if (result == 0) {\n      return 0;\n    }\n    FUN_000825cc(*data_array + data_array[2],data_length);\n    data_array[2] = current_offset + offset;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00081570": "process_data_00081570",
                "param_1": "data_array",
                "param_2": "data_length",
                "param_3": "offset",
                "iVar1": "result",
                "iVar2": "current_offset"
            },
            "calling": [
                "FUN_0008159e"
            ],
            "called": [
                "FUN_000814ae",
                "FUN_000825cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008159e": {
            "entrypoint": "0x0008159e",
            "current_name": "process_data_0008159e",
            "code": "\nvoid processData_0008159e(undefined4 input1,undefined4 input2,undefined4 input3)\n\n{\n  undefined4 tempVar1;\n  undefined4 tempVar2;\n  \n  tempVar2 = input3;\n  FUN_00081570(input1,&tempVar1,1,0,input1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008159e": "process_data_0008159e",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "local_c": "tempVar1",
                "uStack_8": "tempVar2"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "FUN_00081570"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815b8": {
            "entrypoint": "0x000815b8",
            "current_name": "check_parameter_validity_000815b8",
            "code": "\nint checkParameterValidity_000815b8(byte **inputParams,byte *inputData)\n\n{\n  uint inputSize;\n  int isValid;\n  \n  if (inputParams[2] == (byte *)0x0) {\n    if (inputData == (byte *)0x0) {\n      return 1;\n    }\n  }\n  else {\n    if (inputData != (byte *)0x0) {\n      inputSize = FUN_00082390(*inputParams);\n      goto LAB_000815d4;\n    }\n    inputData = *inputParams;\n  }\n  inputSize = (uint)*inputData;\nLAB_000815d4:\n  isValid = 1 - inputSize;\n  if (1 < inputSize) {\n    isValid = 0;\n  }\n  return isValid;\n}\n\n",
            "renaming": {
                "FUN_000815b8": "check_parameter_validity_000815b8",
                "param_1": "inputParams",
                "param_2": "inputData",
                "uVar1": "inputSize",
                "iVar2": "isValid"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00082390"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815de": {
            "entrypoint": "0x000815de",
            "current_name": "parse_integer_000815de",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000827e8) */\n/* WARNING: Removing unreachable block (ram,0x000827a8) */\n/* WARNING: Removing unreachable block (ram,0x000827a0) */\n/* WARNING: Removing unreachable block (ram,0x000827da) */\n/* WARNING: Removing unreachable block (ram,0x000827ec) */\n/* WARNING: Removing unreachable block (ram,0x000827e4) */\n/* WARNING: Removing unreachable block (ram,0x000827a4) */\n/* WARNING: Removing unreachable block (ram,0x0008278a) */\n/* WARNING: Removing unreachable block (ram,0x000827c8) */\n/* WARNING: Removing unreachable block (ram,0x0008278c) */\n\nuint parseInteger_000815de(byte **param_1)\n\n{\n  byte flag;\n  byte negative;\n  uint result;\n  byte *ptr;\n  uint ch;\n  byte *current;\n  int digit;\n  int valid;\n  uint maxDiv;\n  uint maxValue;\n  \n  ptr = *param_1;\n  if (*param_1 == (byte *)0x0) {\n    return 0;\n  }\n  do {\n    current = ptr;\n    ptr = current + 1;\n    ch = (uint)*current;\n    flag = *(byte *)(Elf32_Rel_ARRAY_20070000[270].r_info + ch + 1);\n    negative = flag & 8;\n  } while ((flag & 8) != 0);\n  if (ch == 0x2d) {\n    ptr = current + 2;\n    ch = (uint)current[1];\n    negative = 1;\n  }\n  else if (ch == 0x2b) {\n    ch = (uint)current[1];\n    ptr = current + 2;\n  }\n  if (negative == 0) {\n    maxValue = 0x7fffffff;\n  }\n  else {\n    maxValue = 0x80000000;\n  }\n  maxDiv = maxValue / 10;\n  valid = 0;\n  result = 0;\n  do {\n    flag = *(byte *)(Elf32_Rel_ARRAY_20070000[270].r_info + ch + 1);\n    if ((flag & 4) == 0) {\n      if ((flag & 3) == 0) {\nLAB_0008277e:\n        if (valid == -1) {\n          if (negative == 0) {\n            result = 0x7fffffff;\n          }\n          else {\n            result = 0x80000000;\n          }\n          *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x22;\n        }\n        else if (negative != 0) {\n          result = -result;\n        }\n        return result;\n      }\n      if ((flag & 3) == 1) {\n        digit = 0x37;\n      }\n      else {\n        digit = 0x57;\n      }\n      digit = ch - digit;\n    }\n    else {\n      digit = ch - 0x30;\n    }\n    if (9 < digit) goto LAB_0008277e;\n    if (valid != -1) {\n      if ((maxDiv <= result && result != maxDiv) || ((result == maxDiv && ((int)(maxValue % 10) < digit))))\n      {\n        valid = -1;\n      }\n      else {\n        result = result * 10 + digit;\n        valid = 1;\n      }\n    }\n    ch = (uint)*ptr;\n    ptr = ptr + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000815de": "parse_integer_000815de",
                "bVar1": "flag",
                "bVar2": "negative",
                "uVar3": "result",
                "pbVar4": "ptr",
                "uVar5": "ch",
                "pbVar6": "current",
                "iVar7": "digit",
                "iVar8": "valid",
                "uVar9": "maxDiv",
                "uVar10": "maxValue"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815e8": {
            "entrypoint": "0x000815e8",
            "current_name": "FUNC_000815e8",
            "code": "\nvoid FUNC_000815e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000815e8": "FUNC_000815e8"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000815ec": {
            "entrypoint": "0x000815ec",
            "current_name": "run_main_loop_000815ec",
            "code": "\nvoid runMainLoop_000815ec(void)\n\n{\n  FUN_00081618();\n  FUN_00080774();\n  FUNC_000815e8();\n  FUNC_00080f08(1);\n  FUN_000801e0();\n  do {\n    FUN_00080250();\n    FUN_00080970();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000815ec": "run_main_loop_000815ec"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_00080250",
                "FUN_00080970",
                "FUN_000801e0",
                "FUN_000815e8",
                "FUN_00081618",
                "FUN_00080f08",
                "FUN_00080774"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081618": {
            "entrypoint": "0x00081618",
            "current_name": "initialize_memory_00081618",
            "code": "\n\n\nvoid initializeMemory_00081618(void)\n\n{\n  _DAT_400e1a54 = 0x8000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081618": "initialize_memory_00081618"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081624": {
            "entrypoint": "0x00081624",
            "current_name": "calculate_result_00081624",
            "code": "\nint calculateResult_00081624(int index,int condition,int factor,undefined4 additionalParameter)\n\n{\n  int result;\n  undefined4 tempVar;\n  \n  tempVar = *(undefined4 *)(&DAT_00084b48 + index * 0x1c);\n  if (condition == 0) {\n    tempVar = 0;\n  }\n  result = FUN_00081684(*(int *)(&DAT_00084b44 + index * 0x1c) + 0x3c,\n                       *(undefined4 *)(&DAT_00084b48 + index * 0x1c),tempVar,\n                       ((Elf32_Rel_ARRAY_20070000[6].r_offset / 1000000) * factor) / 0x12,additionalParameter);\n  if (result != 0) {\n    result = (int)((ulonglong)(result * 18000 + 16000) /\n                 ((ulonglong)Elf32_Rel_ARRAY_20070000[6].r_offset / 1000));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00081624": "calculate_result_00081624",
                "param_1": "index",
                "param_2": "condition",
                "param_3": "factor",
                "param_4": "additionalParameter",
                "iVar1": "result",
                "uVar2": "tempVar"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00081684"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081684": {
            "entrypoint": "0x00081684",
            "current_name": "check_bit_pattern_00081684",
            "code": "\nint check_bit_pattern_00081684(uint *bits,uint mask,uint pattern,int max_iterations)\n\n{\n  int iteration_count;\n  \n  do {\n    if ((*bits & mask) != pattern) {\n      do {\n        if ((*bits & mask) == pattern) {\n          iteration_count = 0;\n          do {\n            if ((*bits & mask) != pattern) {\n              return iteration_count;\n            }\n            iteration_count = iteration_count + 1;\n          } while (max_iterations != iteration_count);\n          return 0;\n        }\n        max_iterations = max_iterations + -1;\n      } while (max_iterations != 0);\n      return 0;\n    }\n    max_iterations = max_iterations + -1;\n  } while (max_iterations != 0);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00081684": "check_bit_pattern_00081684",
                "param_1": "bits",
                "param_2": "mask",
                "param_3": "pattern",
                "param_4": "max_iterations",
                "iVar1": "iteration_count"
            },
            "calling": [
                "FUN_00081624"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816d8": {
            "entrypoint": "0x000816d8",
            "current_name": "get_global_variable_value_000816d8",
            "code": "\nundefined4 getGlobalVariableValue_000816d8(void)\n\n{\n  return DAT_2007120c;\n}\n\n",
            "renaming": {
                "FUN_000816d8": "get_global_variable_value_000816d8"
            },
            "calling": [
                "thunk_FUN_000816d8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816ec": {
            "entrypoint": "0x000816ec",
            "current_name": "update_param_info_and_call_000816ec",
            "code": "\nvoid updateParamInfoAndCall_000816ec(dword newParam1,dword newParam2,dword newParam3)\n\n{\n  dword *ptrToRelArray;\n  uint relArrayIndex;\n  uint bitMask;\n  code *unrecoveredJumptable;\n  \n  if (Elf32_Rel_ARRAY_20070000[48].r_offset == 0) {\n    Elf32_Rel_ARRAY_20070000[48].r_offset = 0x20070184;\n  }\n  relArrayIndex = *(uint *)(Elf32_Rel_ARRAY_20070000[48].r_offset + 4);\n  ptrToRelArray = (dword *)Elf32_Rel_ARRAY_20070000[48].r_offset;\n  if (0x1f < (int)relArrayIndex) {\n    ptrToRelArray = (dword *)FUN_000817f0(400);\n    if (ptrToRelArray == (dword *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x00083652. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*unrecoveredJumptable)(0xffffffff);\n      return;\n    }\n    *ptrToRelArray = Elf32_Rel_ARRAY_20070000[48].r_offset;\n    ptrToRelArray[1] = 0;\n    relArrayIndex = 0;\n    Elf32_Rel_ARRAY_20070000[48].r_offset = (dword)ptrToRelArray;\n    ptrToRelArray[0x62] = 0;\n    ptrToRelArray[99] = 0;\n  }\n  bitMask = 1 << (relArrayIndex & 0xff);\n  ptrToRelArray[relArrayIndex + 0x22] = newParam1;\n  ptrToRelArray[0x62] = ptrToRelArray[0x62] | bitMask;\n  ptrToRelArray[relArrayIndex + 0x42] = newParam3;\n  ptrToRelArray[99] = bitMask | ptrToRelArray[99];\n  ptrToRelArray[1] = relArrayIndex + 1;\n  ptrToRelArray[relArrayIndex + 2] = newParam2;\n                    /* WARNING: Could not recover jumptable at 0x00083696. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*unrecoveredJumptable)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816ec": "update_param_info_and_call_000816ec",
                "param_1": "newParam1",
                "param_2": "newParam2",
                "param_3": "newParam3",
                "pdVar1": "ptrToRelArray",
                "uVar2": "relArrayIndex",
                "uVar3": "bitMask",
                "UNRECOVERED_JUMPTABLE_00": "unrecoveredJumptable"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816f8": {
            "entrypoint": "0x000816f8",
            "current_name": "assertion_failed_000816f8",
            "code": "\nvoid assertionFailed_000816f8(undefined4 filename,undefined4 lineNumber,char *message,undefined4 function)\n\n{\n  undefined4 lineNumber;\n  undefined4 function;\n  char *prefix;\n  undefined8 result;\n  \n  lineNumber = *(undefined4 *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0xc);\n  if (message == (char *)0x0) goto LAB_0008171c;\n  function = function;\n  prefix = \", function: \";\n  do {\n    function = filename;\n    FUN_00081750(lineNumber,\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",function,filename,lineNumber,\n                 prefix,message);\n    result = FUN_000836ec();\n    lineNumber = (undefined4)((ulonglong)result >> 0x20);\n    lineNumber = (undefined4)result;\nLAB_0008171c:\n    message = \"\";\n    function = function;\n    prefix = message;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000816f8": "assertion_failed_000816f8",
                "param_1": "filename",
                "param_2": "lineNumber",
                "param_3": "message",
                "param_4": "function",
                "uVar1": "lineNumber",
                "uVar2": "function",
                "pcVar3": "prefix",
                "uVar4": "result"
            },
            "calling": [
                "FUN_000803fc",
                "FUN_00080b2c"
            ],
            "called": [
                "FUN_00081750",
                "FUN_000836ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081750": {
            "entrypoint": "0x00081750",
            "current_name": "perform_relocation_00081750",
            "code": "\nvoid performRelocation_00081750(undefined4 offset,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  undefined4 arg2_copy;\n  undefined4 arg3_copy;\n  \n  arg2_copy = arg2;\n  arg3_copy = arg3;\n  FUN_0008289c(Elf32_Rel_ARRAY_20070000[140].r_offset,offset,arg1,&arg2_copy);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081750": "perform_relocation_00081750",
                "param_1": "offset",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "uStack_8": "arg2_copy",
                "uStack_4": "arg3_copy"
            },
            "calling": [
                "FUN_000816f8"
            ],
            "called": [
                "FUN_0008289c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081778": {
            "entrypoint": "0x00081778",
            "current_name": "execute_function_set_00081778",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00081784) */\n/* WARNING: Removing unreachable block (ram,0x00081788) */\n/* WARNING: Removing unreachable block (ram,0x000817b4) */\n\nvoid executeFunctionSet_00081778(void)\n\n{\n  int iterationCount;\n  code **functionSetPointer;\n  \n  FUNC_00085844();\n  functionSetPointer = (code **)0x8584c;\n  iterationCount = 0;\n  do {\n    iterationCount = iterationCount + 1;\n    functionSetPointer = functionSetPointer + 1;\n    (**functionSetPointer)();\n  } while (iterationCount != 4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081778": "execute_function_set_00081778",
                "ppcVar2": "functionSetPointer",
                "iVar1": "iterationCount"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [
                "FUN_00080118",
                "FUN_00085844",
                "FUN_000836d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000817c8": {
            "entrypoint": "0x000817c8",
            "current_name": "execute_function_000817c8",
            "code": "\nvoid executeFunction_000817c8(undefined4 functionPointer,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  undefined4 param2Copy;\n  undefined4 param3Copy;\n  undefined4 param4Copy;\n  \n  param2Copy = param2;\n  param3Copy = param3;\n  param4Copy = param4;\n  FUN_0008289c(relArray[140].offset,\n               *(undefined4 *)(relArray[140].offset + 8),functionPointer,&param2Copy);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000817c8": "execute_function_000817c8",
                "param_1": "functionPointer",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uStack_c": "param2Copy",
                "uStack_8": "param3Copy",
                "uStack_4": "param4Copy",
                "Elf32_Rel_ARRAY_20070000": "relArray",
                "r_offset": "offset"
            },
            "calling": [
                "FUN_00080eec"
            ],
            "called": [
                "FUN_0008289c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000817f0": {
            "entrypoint": "0x000817f0",
            "current_name": "perform_relocation_000817f0",
            "code": "\nvoid performRelocation_000817f0(undefined4 input)\n\n{\n  FUN_00081810(relArray[140].offset,input);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000817f0": "perform_relocation_000817f0",
                "param_1": "input",
                "Elf32_Rel_ARRAY_20070000": "relArray",
                "r_offset": "offset"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_00081810"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081800": {
            "entrypoint": "0x00081800",
            "current_name": "process_relocation_00081800",
            "code": "\nvoid processRelocation_00081800(undefined4 data)\n\n{\n  FUN_00083b10(relocationTable[140].r_offset,data);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081800": "process_relocation_00081800",
                "param_1": "data",
                "Elf32_Rel_ARRAY_20070000": "relocationTable"
            },
            "calling": [
                "FUN_0008151c",
                "FUN_00081472",
                "FUN_00081480"
            ],
            "called": [
                "FUN_00083b10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081810": {
            "entrypoint": "0x00081810",
            "current_name": "allocate_memory_00081810",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_memory_00081810(undefined4 *memory_address,uint size)\n\n{\n  dword next_entry;\n  int current_entry;\n  uint temp_var;\n  uint temp_var_2;\n  int temp_var_3;\n  uint temp_var_4;\n  dword current_address;\n  uint temp_var_5;\n  int temp_var_6;\n  undefined *ptr;\n  dword temp_var_7;\n  dword temp_var_8;\n  int temp_var_9;\n  dword *ptr_array;\n  uint temp_var_10;\n  undefined *ptr_2;\n  dword *ptr_array_2;\n  uint num_entries;\n  \n  if (size + 0xb < 0x17) {\n    temp_var_10 = 0x10;\n    if (0x10 < size) goto LAB_00081876;\n  }\n  else {\n    temp_var_10 = size + 0xb & 0xfffffff8;\n    if (((int)temp_var_10 < 0) || (temp_var_10 < size)) {\nLAB_00081876:\n      *memory_address = 0xc;\n      return (int *)0x0;\n    }\n  }\n  FUNC_00081f94(memory_address);\n  next_entry = Elf32_Rel_ARRAY_20070000[142].r_info;\n  if (temp_var_10 < 0x1f8) {\n    temp_var_9 = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8e].r_offset + temp_var_10);\n    if ((temp_var_9 != temp_var_10 + 0x20070464) ||\n       (current_entry = temp_var_9 + 8, temp_var_9 = *(int *)(temp_var_9 + 0x14), current_entry != temp_var_9)) {\n      temp_var_3 = *(int *)(temp_var_9 + 0xc);\n      temp_var_6 = (*(uint *)(temp_var_9 + 4) & 0xfffffffc) + temp_var_9;\n      temp_var_10 = *(uint *)(temp_var_6 + 4);\n      current_entry = *(int *)(temp_var_9 + 8);\n      *(int *)(current_entry + 0xc) = temp_var_3;\n      *(int *)(temp_var_3 + 8) = current_entry;\n      *(uint *)(temp_var_6 + 4) = temp_var_10 | 1;\n      FUNC_00081f98(memory_address);\n      return (int *)(temp_var_9 + 8);\n    }\n    num_entries = (temp_var_10 >> 3) + 2;\n  }\n  else {\n    num_entries = temp_var_10 >> 9;\n    if (num_entries == 0) {\n      current_entry = 0x7e;\n      temp_var_9 = 0x3f;\n    }\n    else if (num_entries < 5) {\n      temp_var_9 = (temp_var_10 >> 6) + 0x38;\n      current_entry = temp_var_9 * 2;\n    }\n    else if (num_entries < 0x15) {\n      temp_var_9 = num_entries + 0x5b;\n      current_entry = temp_var_9 * 2;\n    }\n    else if (num_entries < 0x55) {\n      temp_var_9 = (temp_var_10 >> 0xc) + 0x6e;\n      current_entry = temp_var_9 * 2;\n    }\n    else if (num_entries < 0x155) {\n      temp_var_9 = (temp_var_10 >> 0xf) + 0x77;\n      current_entry = temp_var_9 * 2;\n    }\n    else if (num_entries < 0x555) {\n      temp_var_9 = (temp_var_10 >> 0x12) + 0x7c;\n      current_entry = temp_var_9 * 2;\n    }\n    else {\n      current_entry = 0xfc;\n      temp_var_9 = 0x7e;\n    }\n    for (current_address = (&Elf32_Rel_ARRAY_20070000[0x8e].r_offset)[current_entry]; current_entry * 4 + 0x20070464U != current_address\n        ; current_address = *(dword *)(current_address + 0xc)) {\n      num_entries = *(uint *)(current_address + 4) & 0xfffffffc;\n      temp_var_3 = num_entries - temp_var_10;\n      if (0xf < temp_var_3) {\n        temp_var_9 = temp_var_9 + -1;\n        break;\n      }\n      if (-1 < temp_var_3) {\n        current_entry = num_entries + current_address;\n        temp_var_10 = *(uint *)(current_entry + 4);\n        temp_var_3 = *(int *)(current_address + 0xc);\n        temp_var_9 = *(int *)(current_address + 8);\n        *(int *)(temp_var_9 + 0xc) = temp_var_3;\n        *(int *)(temp_var_3 + 8) = temp_var_9;\n        *(uint *)(current_entry + 4) = temp_var_10 | 1;\n        FUNC_00081f98(memory_address);\n        return (int *)(current_address + 8);\n      }\n    }\n    num_entries = temp_var_9 + 1;\n  }\n  current_address = Elf32_Rel_ARRAY_20070000[141].r_offset;\n  if (Elf32_Rel_ARRAY_20070000[142].r_info != 0x2007046c) {\n    temp_var = *(uint *)(Elf32_Rel_ARRAY_20070000[142].r_info + 4);\n    temp_var_2 = temp_var & 0xfffffffc;\n    temp_var_4 = temp_var_2 - temp_var_10;\n    if (0xf < (int)temp_var_4) {\n      current_address = temp_var_10 + Elf32_Rel_ARRAY_20070000[142].r_info;\n      *(uint *)(Elf32_Rel_ARRAY_20070000[142].r_info + 4) = temp_var_10 | 1;\n      Elf32_Rel_ARRAY_20070000[142].r_info = current_address;\n      Elf32_Rel_ARRAY_20070000[143].r_offset = current_address;\n      *(undefined4 *)(current_address + 0xc) = 0x2007046c;\n      *(undefined4 *)(current_address + 8) = 0x2007046c;\n      *(uint *)(current_address + 4) = temp_var_4 | 1;\n      *(uint *)(current_address + temp_var_4) = temp_var_4;\n      FUNC_00081f98(memory_address);\n      return (int *)(next_entry + 8);\n    }\n    Elf32_Rel_ARRAY_20070000[143].r_offset = 0x2007046c;\n    Elf32_Rel_ARRAY_20070000[142].r_info = 0x2007046c;\n    if (-1 < (int)temp_var_4) {\n      *(uint *)(temp_var_2 + next_entry + 4) = *(uint *)(temp_var_2 + next_entry + 4) | 1;\n      FUNC_00081f98(memory_address);\n      return (int *)(next_entry + 8);\n    }\n    if (temp_var_2 < 0x200) {\n      temp_var_2 = temp_var & 0xfffffff8;\n      temp_var_9 = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + temp_var_2);\n      current_address = 1 << ((int)(temp_var >> 3) >> 2 & 0xffU) | Elf32_Rel_ARRAY_20070000[141].r_offset;\n      *(int *)(next_entry + 8) = temp_var_9;\n      *(uint *)(next_entry + 0xc) = temp_var_2 + 0x20070464;\n      Elf32_Rel_ARRAY_20070000[141].r_offset = current_address;\n      *(dword *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + temp_var_2) = next_entry;\n      *(dword *)(temp_var_9 + 0xc) = next_entry;\n    }\n    else {\n      temp_var_4 = temp_var >> 9;\n      if (temp_var_4 < 5) {\n        current_entry = (temp_var >> 6) + 0x38;\n        temp_var_9 = current_entry * 2;\n      }\n      else if (temp_var_4 < 0x15) {\n        current_entry = temp_var_4 + 0x5b;\n        temp_var_9 = current_entry * 2;\n      }\n      else if (temp_var_4 < 0x55) {\n        current_entry = (temp_var >> 0xc) + 0x6e;\n        temp_var_9 = current_entry * 2;\n      }\n      else if (temp_var_4 < 0x155) {\n        current_entry = (temp_var >> 0xf) + 0x77;\n        temp_var_9 = current_entry * 2;\n      }\n      else if (temp_var_4 < 0x555) {\n        current_entry = (temp_var >> 0x12) + 0x7c;\n        temp_var_9 = current_entry * 2;\n      }\n      else {\n        temp_var_9 = 0xfc;\n        current_entry = 0x7e;\n      }\n      current_address = temp_var_9 * 4 + 0x20070464;\n      temp_var_7 = (&Elf32_Rel_ARRAY_20070000[0x8d].r_info)[temp_var_9];\n      if (temp_var_7 == current_address) {\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << (current_entry >> 2 & 0xffU);\n        temp_var_8 = temp_var_7;\n      }\n      else {\n        do {\n          temp_var_8 = temp_var_7;\n          if ((*(uint *)(temp_var_7 + 4) & 0xfffffffc) <= temp_var_2) break;\n          temp_var_7 = *(dword *)(temp_var_7 + 8);\n          temp_var_8 = temp_var_7;\n        } while (current_address != temp_var_7);\n        temp_var_7 = *(dword *)(temp_var_8 + 0xc);\n      }\n      current_address = Elf32_Rel_ARRAY_20070000[141].r_offset;\n      *(dword *)(next_entry + 0xc) = temp_var_7;\n      *(dword *)(next_entry + 8) = temp_var_8;\n      *(dword *)(temp_var_7 + 8) = next_entry;\n      *(dword *)(temp_var_8 + 0xc) = next_entry;\n    }\n  }\n  next_entry = Elf32_Rel_ARRAY_20070000[141].r_info;\n  temp_var = 1 << ((int)num_entries >> 2 & 0xffU);\n  if (temp_var <= current_address) {\n    if ((current_address & temp_var) == 0) {\n      num_entries = num_entries & 0xfffffffc;\n      do {\n        temp_var = temp_var << 1;\n        num_entries = num_entries + 4;\n      } while ((current_address & temp_var) == 0);\n    }\n    do {\n      ptr_array_2 = &Elf32_Rel_ARRAY_20070000[num_entries + 0x8c].r_info;\n      ptr_array = ptr_array_2;\n      temp_var_2 = num_entries;\n      do {\n        for (ptr = (undefined *)ptr_array[3]; ptr_array != (dword *)ptr;\n            ptr = *(undefined **)(ptr + 0xc)) {\n          temp_var_4 = *(uint *)(ptr + 4) & 0xfffffffc;\n          temp_var_5 = temp_var_4 - temp_var_10;\n          if (0xf < (int)temp_var_5) {\n            current_entry = *(int *)(ptr + 8);\n            temp_var_9 = *(int *)(ptr + 0xc);\n            ptr_2 = ptr + temp_var_10;\n            *(uint *)(ptr + 4) = temp_var_10 | 1;\n            *(int *)(current_entry + 0xc) = temp_var_9;\n            *(int *)(temp_var_9 + 8) = current_entry;\n            Elf32_Rel_ARRAY_20070000[142].r_info = (dword)ptr_2;\n            Elf32_Rel_ARRAY_20070000[143].r_offset = (dword)ptr_2;\n            *(undefined4 *)(ptr_2 + 0xc) = 0x2007046c;\n            *(undefined4 *)(ptr_2 + 8) = 0x2007046c;\n            *(uint *)(ptr_2 + 4) = temp_var_5 | 1;\n            *(uint *)(ptr_2 + temp_var_5) = temp_var_5;\n            FUNC_00081f98(memory_address);\n            return (int *)(ptr + 8);\n          }\n          if (-1 < (int)temp_var_5) {\n            temp_var_9 = *(int *)(ptr + 8);\n            current_entry = *(int *)(ptr + 0xc);\n            *(uint *)(ptr + temp_var_4 + 4) = *(uint *)(ptr + temp_var_4 + 4) | 1;\n            *(int *)(temp_var_9 + 0xc) = current_entry;\n            *(int *)(current_entry + 8) = temp_var_9;\n            FUNC_00081f98(memory_address);\n            return (int *)(ptr + 8);\n          }\n        }\n        temp_var_2 = temp_var_2 + 1;\n        ptr_array = ptr_array + 2;\n      } while ((temp_var_2 & 3) != 0);\n      do {\n        temp_var_4 = num_entries & 3;\n        ptr = (undefined *)(ptr_array_2 + -2);\n        num_entries = num_entries - 1;\n        if (temp_var_4 == 0) {\n          Elf32_Rel_ARRAY_20070000[141].r_offset = Elf32_Rel_ARRAY_20070000[141].r_offset & ~temp_var;\n          break;\n        }\n        ptr_array_2 = (dword *)*ptr_array_2;\n      } while (ptr_array_2 == (dword *)ptr);\n      temp_var = temp_var * 2;\n      if ((Elf32_Rel_ARRAY_20070000[141].r_offset <= temp_var &&\n           temp_var - Elf32_Rel_ARRAY_20070000[141].r_offset != 0) || (num_entries = temp_var_2, temp_var == 0))\n      break;\n      for (; (Elf32_Rel_ARRAY_20070000[141].r_offset & temp_var) == 0; temp_var = temp_var << 1) {\n        num_entries = num_entries + 4;\n      }\n    } while( true );\n  }\n  num_entries = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n  if ((temp_var_10 <= num_entries) &&\n     (temp_var = num_entries - temp_var_10, current_address = Elf32_Rel_ARRAY_20070000[141].r_info, 0xf < (int)temp_var))\n  goto LAB_00081b1a;\n  temp_var = Elf32_Rel_ARRAY_20070000[141].r_info + num_entries;\n  if (Elf32_Rel_ARRAY_20070000[270].r_offset == 0xffffffff) {\n    temp_var_2 = temp_var_10 + DAT_20071218 + 0x10;\n  }\n  else {\n    temp_var_2 = temp_var_10 + DAT_20071218 + 0x100f & 0xfffff000;\n  }\n  current_address = FUN_0008236c(memory_address,temp_var_2);\n  if ((current_address == 0xffffffff) || ((current_address < temp_var && (next_entry != 0x20070464)))) {\n    num_entries = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n    current_address = Elf32_Rel_ARRAY_20070000[141].r_info;\n  }\n  else {\n    temp_var_4 = DAT_2007121c + temp_var_2;\n    DAT_2007121c = temp_var_4;\n    if ((temp_var == current_address) && ((temp_var & 0xfff) == 0)) {\n      *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = temp_var_2 + num_entries | 1;\n    }\n    else {\n      temp_var_7 = current_address;\n      if (Elf32_Rel_ARRAY_20070000[270].r_offset != 0xffffffff) {\n        temp_var_7 = Elf32_Rel_ARRAY_20070000[270].r_offset;\n        DAT_2007121c = temp_var_4 + (current_address - temp_var);\n      }\n      Elf32_Rel_ARRAY_20070000[270].r_offset = temp_var_7;\n      temp_var = current_address & 7;\n      if (temp_var == 0) {\n        temp_var_9 = 0x1000;\n      }\n      else {\n        current_address = current_address + (8 - temp_var);\n        temp_var_9 = 0x1008 - temp_var;\n      }\n      temp_var_9 = temp_var_9 - (temp_var_2 + current_address & 0xfff);\n      current_entry = FUN_0008236c(memory_address,temp_var_9);\n      if (current_entry == -1) {\n        temp_var = 1;\n        temp_var_9 = 0;\n      }\n      else {\n        temp_var = (current_entry - current_address) + temp_var_9 | 1;\n      }\n      temp_var_4 = DAT_2007121c + temp_var_9;\n      Elf32_Rel_ARRAY_20070000[141].r_info = current_address;\n      DAT_2007121c = temp_var_4;\n      *(uint *)(current_address + 4) = temp_var;\n      if (next_entry != 0x20070464) {\n        if (num_entries < 0x10) {\n          *(undefined4 *)(current_address + 4) = 1;\n          num_entries = 0;\n          goto LAB_00081b04;\n        }\n        num_entries = num_entries - 0xc & 0xfffffff8;\n        *(uint *)(next_entry + 4) = num_entries | *(uint *)(next_entry + 4) & 1;\n        *(undefined4 *)(next_entry + num_entries + 4) = 5;\n        *(undefined4 *)(next_entry + num_entries + 8) = 5;\n        if (0xf < num_entries) {\n          FUN_00083b10(memory_address,next_entry + 8);\n          temp_var_4 = DAT_2007121c;\n        }\n      }\n    }\n    if (DAT_20071214 < temp_var_4) {\n      DAT_20071214 = temp_var_4;\n    }\n    if (DAT_20071210 < temp_var_4) {\n      DAT_20071210 = temp_var_4;\n    }\n    num_entries = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n    current_address = Elf32_Rel_ARRAY_20070000[141].r_info;\n  }\nLAB_00081b04:\n  temp_var = num_entries - temp_var_10;\n  if ((num_entries < temp_var_10) || ((int)temp_var < 0x10)) {\n    FUNC_00081f98(memory_address);\n    return (int *)0x0;\n  }\nLAB_00081b1a:\n  Elf32_Rel_ARRAY_20070000[141].r_info = temp_var_10 + current_address;\n  *(uint *)(current_address + 4) = temp_var_10 | 1;\n  *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = temp_var | 1;\n  FUNC_00081f98(memory_address);\n  return (int *)(current_address + 8);\n}\n\n",
            "renaming": {
                "FUN_00081810": "allocate_memory_00081810",
                "param_1": "memory_address",
                "param_2": "size",
                "dVar1": "next_entry",
                "iVar2": "current_entry",
                "uVar3": "temp_var",
                "uVar4": "temp_var_2",
                "iVar5": "temp_var_3",
                "uVar6": "temp_var_4",
                "dVar7": "current_address",
                "uVar8": "temp_var_5",
                "iVar9": "temp_var_6",
                "puVar10": "ptr",
                "dVar11": "temp_var_7",
                "dVar12": "temp_var_8",
                "iVar13": "temp_var_9",
                "pdVar14": "ptr_array",
                "uVar15": "temp_var_10",
                "puVar16": "ptr_2",
                "pdVar17": "ptr_array_2",
                "uVar18": "num_entries"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00084018",
                "FUN_00083ca8",
                "FUN_000817f0"
            ],
            "called": [
                "FUN_00083b10",
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_0008236c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d48": {
            "entrypoint": "0x00081d48",
            "current_name": "copy_memory_00081d48",
            "code": "\nundefined4 * copyMemory_00081d48(undefined4 *destination,undefined4 *source,uint size)\n\n{\n  undefined4 *destPtr;\n  undefined4 *destEndPtr;\n  undefined4 *srcPtr;\n  uint remainingSize;\n  uint unrollSize;\n  bool loopCondition;\n  \n  destEndPtr = destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      unrollSize = size - 4;\n      if (3 < size) {\n        do {\n          destPtr = source;\n          srcPtr = destEndPtr;\n          loopCondition = unrollSize != 0;\n          unrollSize = unrollSize - 1;\n          *(undefined *)srcPtr = *(undefined *)destPtr;\n          destEndPtr = (undefined4 *)((int)srcPtr + 1);\n          source = (undefined4 *)((int)destPtr + 1);\n        } while (loopCondition);\n        *(undefined *)(undefined4 *)((int)srcPtr + 1) =\n             *(undefined *)(undefined4 *)((int)destPtr + 1);\n        *(undefined *)((int)srcPtr + 2) = *(undefined *)((int)destPtr + 2);\n        *(undefined *)((int)srcPtr + 3) = *(undefined *)((int)destPtr + 3);\n        return destination;\n      }\n      goto LAB_00081dcc;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      unrollSize = 4 - ((uint)destination & 3);\n      size = size - unrollSize;\n      destPtr = destination;\n      srcPtr = source;\n      if (((uint)destination & 1) != 0) {\n        srcPtr = (undefined4 *)((int)source + 1);\n        destPtr = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *(undefined *)source;\n      }\n      destEndPtr = destPtr;\n      source = srcPtr;\n      if ((unrollSize & 2) != 0) {\n        source = (undefined4 *)((int)srcPtr + 2);\n        destEndPtr = (undefined4 *)((int)destPtr + 2);\n        *(undefined2 *)destPtr = *(undefined2 *)srcPtr;\n      }\n    }\n  }\n  while (0x3f < size) {\n    *destEndPtr = *source;\n    destEndPtr[1] = source[1];\n    destEndPtr[2] = source[2];\n    destEndPtr[3] = source[3];\n    destEndPtr[4] = source[4];\n    destEndPtr[5] = source[5];\n    destEndPtr[6] = source[6];\n    destEndPtr[7] = source[7];\n    destEndPtr[8] = source[8];\n    destEndPtr[9] = source[9];\n    destEndPtr[10] = source[10];\n    destEndPtr[0xb] = source[0xb];\n    destEndPtr[0xc] = source[0xc];\n    destEndPtr[0xd] = source[0xd];\n    destEndPtr[0xe] = source[0xe];\n    destEndPtr[0xf] = source[0xf];\n    destEndPtr = destEndPtr + 0x10;\n    source = source + 0x10;\n    size = size - 0x40;\n  }\n  remainingSize = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n      *destEndPtr = *source;\n      destEndPtr[1] = source[1];\n      destEndPtr[2] = source[2];\n      destEndPtr[3] = source[3];\n      destEndPtr = destEndPtr + 4;\n      source = source + 4;\n      loopCondition = 0xf < remainingSize;\n      remainingSize = remainingSize - 0x10;\n    } while (loopCondition);\n  }\n  unrollSize = remainingSize + 0xc;\n  srcPtr = destEndPtr;\n  destPtr = source;\n  if (0xfffffff3 < remainingSize) {\n    do {\n      source = destPtr + 1;\n      *srcPtr = *destPtr;\n      loopCondition = 3 < unrollSize;\n      unrollSize = unrollSize - 4;\n      destEndPtr = srcPtr + 1;\n      srcPtr = srcPtr + 1;\n      destPtr = source;\n    } while (loopCondition);\n  }\nLAB_00081dcc:\n  if (unrollSize + 4 != 0) {\n    destPtr = destEndPtr;\n    srcPtr = source;\n    if ((unrollSize & 1) != 0) {\n      srcPtr = (undefined4 *)((int)source + 1);\n      destPtr = (undefined4 *)((int)destEndPtr + 1);\n      *(undefined *)destEndPtr = *(undefined *)source;\n    }\n    if ((unrollSize + 4 & 2) != 0) {\n      *(undefined2 *)destPtr = *(undefined2 *)srcPtr;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00081d48": "copy_memory_00081d48",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "puVar1": "destPtr",
                "puVar2": "destEndPtr",
                "puVar3": "srcPtr",
                "uVar4": "remainingSize",
                "uVar5": "unrollSize",
                "bVar6": "loopCondition"
            },
            "calling": [
                "FUN_00083ca8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081e34": {
            "entrypoint": "0x00081e34",
            "current_name": "copy_reverse_00081e34",
            "code": "\nvoid copyReverse_00081e34(undefined4 *dest,undefined4 *src,uint length)\n\n{\n  int index;\n  undefined4 *dest_ptr;\n  undefined4 *src_ptr;\n  undefined4 *temp_ptr;\n  uint remaining;\n  undefined *temp;\n  uint rem;\n  \n  if ((src < dest) && (temp_ptr = (undefined4 *)((int)src + length), dest < temp_ptr)) {\n    temp = (undefined *)((int)dest + length);\n    index = length - 1;\n    if (length != 0) {\n      do {\n        temp_ptr = (undefined4 *)((int)temp_ptr + -1);\n        index = index + -1;\n        temp = temp + -1;\n        *temp = *(undefined *)temp_ptr;\n      } while (index != -1);\n    }\n    return;\n  }\n  if (length < 0x10) {\n    if (length == 0) {\n      return;\n    }\n  }\n  else if ((((uint)dest | (uint)src) & 3) == 0) {\n    temp_ptr = dest;\n    src_ptr = src;\n    do {\n      dest_ptr = temp_ptr + 4;\n      *temp_ptr = *src_ptr;\n      temp_ptr[1] = src_ptr[1];\n      temp_ptr[2] = src_ptr[2];\n      temp_ptr[3] = src_ptr[3];\n      temp_ptr = dest_ptr;\n      src_ptr = src_ptr + 4;\n    } while (dest_ptr != (undefined4 *)((int)dest + (length - 0x10 & 0xfffffff0) + 0x10));\n    index = (length - 0x10 >> 4) + 1;\n    rem = length & 0xf;\n    src = src + index * 4;\n    dest = dest + index * 4;\n    remaining = rem;\n    temp_ptr = dest;\n    src_ptr = src;\n    if (3 < rem) {\n      do {\n        remaining = remaining - 4;\n        *temp_ptr = *src_ptr;\n        temp_ptr = temp_ptr + 1;\n        src_ptr = src_ptr + 1;\n      } while (3 < remaining);\n      index = (rem - 4 & 0xfffffffc) + 4;\n      dest = (undefined4 *)((int)dest + index);\n      src = (undefined4 *)((int)src + index);\n      rem = length & 3;\n    }\n    length = rem;\n    if (length == 0) {\n      return;\n    }\n  }\n  temp_ptr = dest;\n  do {\n    src_ptr = (undefined4 *)((int)temp_ptr + 1);\n    *(undefined *)temp_ptr = *(undefined *)src;\n    src = (undefined4 *)((int)src + 1);\n    temp_ptr = src_ptr;\n  } while (src_ptr != (undefined4 *)(length + (int)dest));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081e34": "copy_reverse_00081e34",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "length",
                "iVar1": "index",
                "puVar2": "dest_ptr",
                "puVar3": "src_ptr",
                "puVar4": "temp_ptr",
                "uVar5": "remaining",
                "puVar6": "temp",
                "uVar7": "rem"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00083ca8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f00": {
            "entrypoint": "0x00081f00",
            "current_name": "fill_memory_00081f00",
            "code": "\nvoid fillMemory_00081f00(undefined4 *destination,undefined value,uint size)\n\n{\n  undefined4 *dest_ptr;\n  undefined4 *next_dest_ptr;\n  undefined4 value_32;\n  uint size_remaining;\n  bool is_zero_size;\n  \n  if (((uint)destination & 3) != 0) {\n    is_zero_size = size == 0;\n    dest_ptr = destination;\n    size = size - 1;\n    if (is_zero_size) {\n      return;\n    }\n    while( true ) {\n      destination = (undefined4 *)((int)dest_ptr + 1);\n      *(undefined *)dest_ptr = value;\n      if (((uint)destination & 3) == 0) break;\n      is_zero_size = size == 0;\n      dest_ptr = destination;\n      size = size - 1;\n      if (is_zero_size) {\n        return;\n      }\n    }\n  }\n  if (3 < size) {\n    value_32 = CONCAT22(CONCAT11(value,value),CONCAT11(value,value));\n    size_remaining = size;\n    dest_ptr = destination;\n    if (0xf < size) {\n      size_remaining = size - 0x10;\n      do {\n        *dest_ptr = value_32;\n        dest_ptr[1] = value_32;\n        dest_ptr[2] = value_32;\n        dest_ptr[3] = value_32;\n        dest_ptr = dest_ptr + 4;\n      } while (dest_ptr != (undefined4 *)((int)destination + (size_remaining & 0xfffffff0) + 0x10));\n      size = size & 0xf;\n      destination = destination + ((size_remaining >> 4) + 1) * 4;\n      size_remaining = size;\n      dest_ptr = destination;\n      if (size < 4) goto LAB_00081f7c;\n    }\n    do {\n      size = size - 4;\n      *destination = value_32;\n      destination = destination + 1;\n    } while (3 < size);\n    destination = (undefined4 *)((int)dest_ptr + (size_remaining - 4 & 0xfffffffc) + 4);\n    size = size_remaining & 3;\n  }\nLAB_00081f7c:\n  if (size != 0) {\n    dest_ptr = destination;\n    do {\n      next_dest_ptr = (undefined4 *)((int)dest_ptr + 1);\n      *(undefined *)dest_ptr = value;\n      dest_ptr = next_dest_ptr;\n    } while (next_dest_ptr != (undefined4 *)(size + (int)destination));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f00": "fill_memory_00081f00",
                "param_1": "destination",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "dest_ptr",
                "puVar2": "next_dest_ptr",
                "uVar3": "value_32",
                "uVar4": "size_remaining",
                "bVar5": "is_zero_size"
            },
            "calling": [
                "FUN_000811b0",
                "FUN_00083888"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f94": {
            "entrypoint": "0x00081f94",
            "current_name": "FUNC_00081f94",
            "code": "\nvoid FUNC_00081f94(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f94": "FUNC_00081f94"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00083b10",
                "FUN_00081810",
                "FUN_00083a74"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f98": {
            "entrypoint": "0x00081f98",
            "current_name": "FUNC_00081f98",
            "code": "\nvoid FUNC_00081f98(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f98": "FUNC_00081f98"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00081810",
                "FUN_00083b10",
                "FUN_00083a74"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f9c": {
            "entrypoint": "0x00081f9c",
            "current_name": "process_elf32_rel_entry_00081f9c",
            "code": "\nvoid process_elf32_rel_entry_00081f9c(undefined4 param1,undefined4 param2)\n\n{\n  FUN_00081fac(Elf32_Rel_ARRAY_20070000[140].r_offset,param1,param2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f9c": "process_elf32_rel_entry_00081f9c",
                "param_1": "param1",
                "param_2": "param2"
            },
            "calling": [
                "FUN_00081496"
            ],
            "called": [
                "FUN_00081fac"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081fac": {
            "entrypoint": "0x00081fac",
            "current_name": "allocate_memory_00081fac",
            "code": "\nint * allocateMemory_00081fac(undefined4 *inputPointer,int *outputPointer,uint size)\n\n{\n  dword tempVar1;\n  int *tempPointer1;\n  uint tempVar2;\n  int tempVar3;\n  uint tempVar4;\n  int tempVar5;\n  int *tempPointer2;\n  uint tempVar6;\n  uint tempVar7;\n  int *tempPointer3;\n  \n  if (outputPointer == (int *)0x0) {\n    tempPointer1 = (int *)FUN_00081810(inputPointer,size);\n    return tempPointer1;\n  }\n  FUNC_00081f94();\n  tempVar4 = outputPointer[-1];\n  tempVar6 = tempVar4 & 0xfffffffc;\n  tempPointer1 = outputPointer + -2;\n  if (size + 0xb < 0x17) {\n    tempVar7 = 0x10;\n  }\n  else {\n    tempVar7 = size + 0xb & 0xfffffff8;\n    if ((int)tempVar7 < 0) goto LAB_00082078;\n  }\n  if (tempVar7 < size) {\nLAB_00082078:\n    *inputPointer = 0xc;\n    return (int *)0x0;\n  }\n  if ((int)tempVar6 < (int)tempVar7) {\n    tempVar1 = (int)tempPointer1 + tempVar6;\n    if (Elf32_Rel_ARRAY_20070000[141].r_info == tempVar1) {\n      tempVar2 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n      tempVar1 = Elf32_Rel_ARRAY_20070000[141].r_info;\n      if ((int)(tempVar7 + 0x10) <= (int)(tempVar2 + tempVar6)) {\n        Elf32_Rel_ARRAY_20070000[141].r_info = (int)tempPointer1 + tempVar7;\n        *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = (tempVar2 + tempVar6) - tempVar7 | 1;\n        outputPointer[-1] = tempVar7 | outputPointer[-1] & 1U;\n        FUNC_00081f98(inputPointer);\n        return outputPointer;\n      }\n    }\n    else if ((*(uint *)((*(uint *)(tempVar1 + 4) & 0xfffffffe) + tempVar1 + 4) & 1) == 0) {\n      tempVar2 = *(uint *)(tempVar1 + 4) & 0xfffffffc;\n      if ((int)tempVar7 <= (int)(tempVar2 + tempVar6)) {\n        tempVar5 = *(int *)(tempVar1 + 0xc);\n        tempVar3 = *(int *)(tempVar1 + 8);\n        *(int *)(tempVar3 + 0xc) = tempVar5;\n        *(int *)(tempVar5 + 8) = tempVar3;\n        tempVar6 = tempVar2 + tempVar6;\n        goto LAB_00082088;\n      }\n    }\n    else {\n      tempVar2 = 0;\n      tempVar1 = 0;\n    }\n    if (-1 < (int)(tempVar4 << 0x1f)) {\n      tempPointer3 = (int *)((int)tempPointer1 - outputPointer[-2]);\n      tempVar4 = (tempPointer3[1] & 0xfffffffcU) + tempVar6;\n      if (tempVar1 != 0) {\n        if (tempVar1 == Elf32_Rel_ARRAY_20070000[141].r_info) {\n          if ((int)(tempVar7 + 0x10) <= (int)(tempVar2 + tempVar4)) {\n            tempPointer1 = tempPointer3 + 2;\n            tempVar3 = *tempPointer1;\n            tempVar5 = tempPointer3[3];\n            tempVar6 = tempVar6 - 4;\n            *(int *)(tempVar3 + 0xc) = tempVar5;\n            *(int *)(tempVar5 + 8) = tempVar3;\n            if (tempVar6 < 0x25) {\n              tempPointer2 = tempPointer1;\n              if (0x13 < tempVar6) {\n                tempPointer3[2] = *outputPointer;\n                tempPointer3[3] = outputPointer[1];\n                if (tempVar6 < 0x1c) {\n                  outputPointer = outputPointer + 2;\n                  tempPointer2 = tempPointer3 + 4;\n                }\n                else {\n                  tempPointer3[4] = outputPointer[2];\n                  tempPointer3[5] = outputPointer[3];\n                  if (tempVar6 == 0x24) {\n                    tempPointer3[6] = outputPointer[4];\n                    tempPointer2 = outputPointer + 5;\n                    outputPointer = outputPointer + 6;\n                    tempPointer3[7] = *tempPointer2;\n                    tempPointer2 = tempPointer3 + 8;\n                  }\n                  else {\n                    outputPointer = outputPointer + 4;\n                    tempPointer2 = tempPointer3 + 6;\n                  }\n                }\n              }\n              *tempPointer2 = *outputPointer;\n              tempPointer2[1] = outputPointer[1];\n              tempPointer2[2] = outputPointer[2];\n            }\n            else {\n              FUN_00081e34(tempPointer1,outputPointer);\n            }\n            Elf32_Rel_ARRAY_20070000[141].r_info = (int)tempPointer3 + tempVar7;\n            *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = (tempVar2 + tempVar4) - tempVar7 | 1;\n            tempPointer3[1] = tempVar7 | tempPointer3[1] & 1U;\n            FUNC_00081f98(inputPointer);\n            return tempPointer1;\n          }\n        }\n        else {\n          tempVar2 = tempVar2 + tempVar4;\n          if ((int)tempVar7 <= (int)tempVar2) {\n            tempVar5 = *(int *)(tempVar1 + 0xc);\n            tempVar3 = *(int *)(tempVar1 + 8);\n            *(int *)(tempVar3 + 0xc) = tempVar5;\n            *(int *)(tempVar5 + 8) = tempVar3;\n            tempPointer2 = tempPointer3 + 2;\n            tempVar3 = *tempPointer2;\n            tempVar5 = tempPointer3[3];\n            tempVar4 = tempVar6 - 4;\n            *(int *)(tempVar3 + 0xc) = tempVar5;\n            *(int *)(tempVar5 + 8) = tempVar3;\n            tempVar6 = tempVar2;\n            if (tempVar4 < 0x25) {\n              tempPointer1 = tempPointer2;\n              if (0x13 < tempVar4) {\n                tempPointer3[2] = *outputPointer;\n                tempPointer3[3] = outputPointer[1];\n                if (tempVar4 < 0x1c) {\n                  outputPointer = outputPointer + 2;\n                  tempPointer1 = tempPointer3 + 4;\n                }\n                else {\n                  tempPointer3[4] = outputPointer[2];\n                  tempPointer3[5] = outputPointer[3];\n                  if (tempVar4 == 0x24) {\n                    tempPointer3[6] = outputPointer[4];\n                    tempPointer1 = outputPointer + 5;\n                    outputPointer = outputPointer + 6;\n                    tempPointer3[7] = *tempPointer1;\n                    tempPointer1 = tempPointer3 + 8;\n                  }\n                  else {\n                    outputPointer = outputPointer + 4;\n                    tempPointer1 = tempPointer3 + 6;\n                  }\n                }\n              }\n              *tempPointer1 = *outputPointer;\n              tempPointer1[1] = outputPointer[1];\n              tempPointer1[2] = outputPointer[2];\n              tempVar4 = tempPointer3[1];\n              tempPointer1 = tempPointer3;\n              outputPointer = tempPointer2;\n            }\n            else {\n              FUN_00081e34(tempPointer2,outputPointer);\n              tempVar4 = tempPointer3[1];\n              tempPointer1 = tempPointer3;\n              outputPointer = tempPointer2;\n            }\n            goto LAB_00082088;\n          }\n        }\n      }\n      if ((int)tempVar7 <= (int)tempVar4) {\n        tempPointer2 = tempPointer3 + 2;\n        tempVar3 = *tempPointer2;\n        tempVar5 = tempPointer3[3];\n        tempVar2 = tempVar6 - 4;\n        *(int *)(tempVar3 + 0xc) = tempVar5;\n        *(int *)(tempVar5 + 8) = tempVar3;\n        tempVar6 = tempVar4;\n        if (tempVar2 < 0x25) {\n          tempPointer1 = tempPointer2;\n          if (0x13 < tempVar2) {\n            tempPointer3[2] = *outputPointer;\n            tempPointer3[3] = outputPointer[1];\n            if (tempVar2 < 0x1c) {\n              outputPointer = outputPointer + 2;\n              tempPointer1 = tempPointer3 + 4;\n            }\n            else {\n              tempPointer3[4] = outputPointer[2];\n              tempPointer3[5] = outputPointer[3];\n              if (tempVar2 == 0x24) {\n                tempPointer3[6] = outputPointer[4];\n                tempPointer1 = outputPointer + 5;\n                outputPointer = outputPointer + 6;\n                tempPointer3[7] = *tempPointer1;\n                tempPointer1 = tempPointer3 + 8;\n              }\n              else {\n                outputPointer = outputPointer + 4;\n                tempPointer1 = tempPointer3 + 6;\n              }\n            }\n          }\n          *tempPointer1 = *outputPointer;\n          tempPointer1[1] = outputPointer[1];\n          tempPointer1[2] = outputPointer[2];\n          tempVar4 = tempPointer3[1];\n          tempPointer1 = tempPointer3;\n          outputPointer = tempPointer2;\n        }\n        else {\n          FUN_00081e34(tempPointer2,outputPointer);\n          tempVar4 = tempPointer3[1];\n          tempPointer1 = tempPointer3;\n          outputPointer = tempPointer2;\n        }\n        goto LAB_00082088;\n      }\n    }\n    tempPointer3 = (int *)FUN_00081810(inputPointer,size);\n    if (tempPointer3 == (int *)0x0) goto LAB_000820a0;\n    tempVar4 = outputPointer[-1];\n    if (tempPointer3 + -2 != (int *)((tempVar4 & 0xfffffffe) + (int)tempPointer1)) {\n      tempVar6 = tempVar6 - 4;\n      if (tempVar6 < 0x25) {\n        tempPointer1 = outputPointer;\n        tempPointer2 = tempPointer3;\n        if (0x13 < tempVar6) {\n          *tempPointer3 = *outputPointer;\n          tempPointer3[1] = outputPointer[1];\n          if (tempVar6 < 0x1c) {\n            tempPointer1 = outputPointer + 2;\n            tempPointer2 = tempPointer3 + 2;\n          }\n          else {\n            tempPointer3[2] = outputPointer[2];\n            tempPointer3[3] = outputPointer[3];\n            if (tempVar6 == 0x24) {\n              tempPointer3[4] = outputPointer[4];\n              tempPointer3[5] = outputPointer[5];\n              tempPointer1 = outputPointer + 6;\n              tempPointer2 = tempPointer3 + 6;\n            }\n            else {\n              tempPointer1 = outputPointer + 4;\n              tempPointer2 = tempPointer3 + 4;\n            }\n          }\n        }\n        *tempPointer2 = *tempPointer1;\n        tempPointer2[1] = tempPointer1[1];\n        tempPointer2[2] = tempPointer1[2];\n      }\n      else {\n        FUN_00081e34(tempPointer3,outputPointer);\n      }\n      FUN_00083b10(inputPointer,outputPointer);\n      goto LAB_000820a0;\n    }\n    tempVar6 = tempVar6 + (tempPointer3[-1] & 0xfffffffcU);\n  }\nLAB_00082088:\n  tempVar2 = tempVar6 - tempVar7;\n  tempPointer3 = outputPointer;\n  if (tempVar2 < 0x10) {\n    tempPointer1[1] = tempVar4 & 1 | tempVar6;\n    *(uint *)((int)tempPointer1 + tempVar6 + 4) = *(uint *)((int)tempPointer1 + tempVar6 + 4) | 1;\n  }\n  else {\n    tempPointer1[1] = tempVar4 & 1 | tempVar7;\n    *(uint *)((int)tempPointer1 + tempVar7 + 4) = tempVar2 | 1;\n    *(uint *)((int)tempPointer1 + tempVar2 + tempVar7 + 4) = *(uint *)((int)tempPointer1 + tempVar2 + tempVar7 + 4) | 1;\n    FUN_00083b10(inputPointer,(int)tempPointer1 + tempVar7 + 8);\n  }\nLAB_000820a0:\n  FUNC_00081f98(inputPointer);\n  return tempPointer3;\n}\n\n",
            "renaming": {
                "FUN_00081fac": "allocate_memory_00081fac",
                "param_1": "inputPointer",
                "param_2": "outputPointer",
                "param_3": "size",
                "dVar1": "tempVar1",
                "piVar2": "tempPointer1",
                "uVar3": "tempVar2",
                "iVar4": "tempVar3",
                "uVar5": "tempVar4",
                "iVar6": "tempVar5",
                "piVar7": "tempPointer2",
                "uVar8": "tempVar6",
                "uVar9": "tempVar7",
                "piVar10": "tempPointer3"
            },
            "calling": [
                "FUN_00081f9c",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00081810",
                "FUN_00083b10",
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_00081e34"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008236c": {
            "entrypoint": "0x0008236c",
            "current_name": "check_error_and_return_0008236c",
            "code": "\nvoid checkErrorAndReturn_0008236c(int *result,undefined4 inputValue)\n\n{\n  int errorCode;\n  \n  DAT_20071244 = 0;\n  errorCode = FUN_00080e88(inputValue);\n  if ((errorCode == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008236c": "check_error_and_return_0008236c",
                "param_1": "result",
                "param_2": "inputValue",
                "iVar1": "errorCode"
            },
            "calling": [
                "FUN_00081810",
                "FUN_00083a74"
            ],
            "called": [
                "FUN_00080e88"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082390": {
            "entrypoint": "0x00082390",
            "current_name": "compare_unsigned_integers_00082390",
            "code": "\nint compareUnsignedIntegers_00082390(uint *unsignedInts1,uint *unsignedInts2)\n\n{\n  uint *pUnsignedInt1;\n  int result;\n  uint *pUnsignedInt2;\n  uint *pTempUnsignedInt;\n  uint tempUnsignedInt1;\n  uint tempUnsignedInt2;\n  uint tempUnsignedInt3;\n  uint tempUnsignedInt4;\n  uint tempUnsignedInt5;\n  \n  if ((((uint)unsignedInts1 | (uint)unsignedInts2) & 7) != 0) {\n    pUnsignedInt1 = unsignedInts1;\n    if (((uint)unsignedInts1 & 3) != 0) {\n      pUnsignedInt1 = (uint *)((uint)unsignedInts1 & 0xfffffffc) + 1;\n      tempUnsignedInt1 = *(uint *)((uint)unsignedInts1 & 0xfffffffc);\n      pUnsignedInt2 = unsignedInts2;\n      if (((uint)unsignedInts1 & 1) == 0) {\nLAB_00082410:\n        pTempUnsignedInt = (uint *)((int)pUnsignedInt2 + 1);\n        tempUnsignedInt2 = tempUnsignedInt1 >> 0x10 & 0xff;\n        result = tempUnsignedInt2 - *(byte *)pUnsignedInt2;\n        if (result != 0) {\n          return result;\n        }\n        if (tempUnsignedInt2 == 0) {\n          return 0;\n        }\n      }\n      else {\n        pTempUnsignedInt = unsignedInts2;\n        if (((uint)unsignedInts1 & 2) == 0) {\n          pUnsignedInt2 = (uint *)((int)unsignedInts2 + 1);\n          tempUnsignedInt2 = tempUnsignedInt1 >> 8 & 0xff;\n          result = tempUnsignedInt2 - *(byte *)unsignedInts2;\n          if (result != 0) {\n            return result;\n          }\n          if (tempUnsignedInt2 == 0) {\n            return 0;\n          }\n          goto LAB_00082410;\n        }\n      }\n      unsignedInts2 = (uint *)((int)pTempUnsignedInt + 1);\n      result = (tempUnsignedInt1 >> 0x18) - (uint)*(byte *)pTempUnsignedInt;\n      if ((result != 0) || (tempUnsignedInt1 >> 0x18 == 0)) {\n        return result;\n      }\n    }\n    tempUnsignedInt1 = (uint)unsignedInts2 & 3;\n    if (tempUnsignedInt1 != 0) {\n      unsignedInts2 = (uint *)((uint)unsignedInts2 & 0xfffffffc);\n      if (tempUnsignedInt1 == 2) {\n        tempUnsignedInt1 = *unsignedInts2;\n        do {\n          unsignedInts2 = unsignedInts2 + 1;\n          tempUnsignedInt3 = *pUnsignedInt1;\n          tempUnsignedInt1 = tempUnsignedInt1 >> 0x10;\n          tempUnsignedInt4 = tempUnsignedInt3 + 0xfefefeff & ~tempUnsignedInt3;\n          tempUnsignedInt5 = tempUnsignedInt4 & 0x80808080;\n          tempUnsignedInt2 = tempUnsignedInt3 & 0xffff;\n          if ((tempUnsignedInt4 & 0x8080) != 0 || tempUnsignedInt2 != tempUnsignedInt1) goto LAB_0008258e;\n          tempUnsignedInt1 = *unsignedInts2;\n          tempUnsignedInt2 = tempUnsignedInt2 ^ tempUnsignedInt3;\n          tempUnsignedInt3 = tempUnsignedInt1 * 0x10000;\n          pUnsignedInt1 = pUnsignedInt1 + 1;\n        } while (tempUnsignedInt5 == 0 && tempUnsignedInt2 == tempUnsignedInt3);\n      }\n      else if (tempUnsignedInt1 < 2) {\n        tempUnsignedInt1 = *unsignedInts2;\n        do {\n          unsignedInts2 = unsignedInts2 + 1;\n          tempUnsignedInt3 = *pUnsignedInt1;\n          tempUnsignedInt1 = tempUnsignedInt1 >> 8;\n          tempUnsignedInt4 = tempUnsignedInt3 + 0xfefefeff & ~tempUnsignedInt3;\n          tempUnsignedInt5 = tempUnsignedInt4 & 0x80808080;\n          tempUnsignedInt2 = tempUnsignedInt3 & 0xffffff;\n          if ((tempUnsignedInt4 & 0x808080) != 0 || tempUnsignedInt2 != tempUnsignedInt1) goto LAB_0008258e;\n          tempUnsignedInt1 = *unsignedInts2;\n          tempUnsignedInt2 = tempUnsignedInt2 ^ tempUnsignedInt3;\n          tempUnsignedInt3 = tempUnsignedInt1 * 0x1000000;\n          pUnsignedInt1 = pUnsignedInt1 + 1;\n        } while (tempUnsignedInt5 == 0 && tempUnsignedInt2 == tempUnsignedInt3);\n      }\n      else {\n        tempUnsignedInt1 = *unsignedInts2;\n        do {\n          unsignedInts2 = unsignedInts2 + 1;\n          tempUnsignedInt3 = *pUnsignedInt1;\n          tempUnsignedInt1 = tempUnsignedInt1 >> 0x18;\n          tempUnsignedInt4 = tempUnsignedInt3 + 0xfefefeff & ~tempUnsignedInt3;\n          tempUnsignedInt5 = tempUnsignedInt4 & 0x80808080;\n          tempUnsignedInt2 = tempUnsignedInt3 & 0xff;\n          if ((tempUnsignedInt4 & 0x80) != 0 || tempUnsignedInt2 != tempUnsignedInt1) goto LAB_0008258e;\n          tempUnsignedInt1 = *unsignedInts2;\n          tempUnsignedInt2 = tempUnsignedInt2 ^ tempUnsignedInt3;\n          tempUnsignedInt3 = tempUnsignedInt1 * 0x100;\n          pUnsignedInt1 = pUnsignedInt1 + 1;\n        } while (tempUnsignedInt5 == 0 && tempUnsignedInt2 == tempUnsignedInt3);\n      }\n      tempUnsignedInt2 = tempUnsignedInt2 << 0x18 | (tempUnsignedInt2 >> 8 & 0xff) << 0x10 | (tempUnsignedInt2 >> 0x10 & 0xff) << 8 |\n              tempUnsignedInt2 >> 0x18;\n      tempUnsignedInt1 = (tempUnsignedInt3 >> 8 & 0xff) << 0x10 | (tempUnsignedInt3 >> 0x10 & 0xff) << 8 | tempUnsignedInt3 >> 0x18;\n      goto LAB_0008259e;\n    }\n    unsignedInts1 = pUnsignedInt1;\n    pUnsignedInt2 = unsignedInts2;\n    if (((uint)pUnsignedInt1 & 4) != 0) {\n      unsignedInts1 = pUnsignedInt1 + 1;\n      tempUnsignedInt1 = *pUnsignedInt1;\n      pUnsignedInt2 = unsignedInts2 + 1;\n      tempUnsignedInt3 = *unsignedInts2;\n      tempUnsignedInt5 = tempUnsignedInt1 + 0xfefefeff & ~tempUnsignedInt1 & 0x80808080;\n      if (tempUnsignedInt1 != tempUnsignedInt3 || tempUnsignedInt5 != 0) {\nLAB_0008259a:\n        tempUnsignedInt2 = tempUnsignedInt1 << 0x18 | (tempUnsignedInt1 >> 8 & 0xff) << 0x10 | (tempUnsignedInt1 >> 0x10 & 0xff) << 8 |\n                tempUnsignedInt1 >> 0x18;\n        tempUnsignedInt1 = tempUnsignedInt3 << 0x18 | (tempUnsignedInt3 >> 8 & 0xff) << 0x10 | (tempUnsignedInt3 >> 0x10 & 0xff) << 8 |\n                tempUnsignedInt3 >> 0x18;\n        goto LAB_0008259e;\n      }\n    }\n    unsignedInts2 = pUnsignedInt2;\n    if (((uint)pUnsignedInt2 & 4) != 0) {\n      tempUnsignedInt1 = *pUnsignedInt2;\n      pUnsignedInt1 = pUnsignedInt2 + 1;\n      do {\n        tempUnsignedInt2 = *unsignedInts1;\n        tempUnsignedInt3 = unsignedInts1[1];\n        tempUnsignedInt5 = tempUnsignedInt2 + 0xfefefeff & ~tempUnsignedInt2 & 0x80808080;\n        if (tempUnsignedInt2 != tempUnsignedInt1 || tempUnsignedInt5 != 0) goto LAB_0008258e;\n        tempUnsignedInt4 = *pUnsignedInt1;\n        tempUnsignedInt1 = pUnsignedInt1[1];\n        tempUnsignedInt5 = tempUnsignedInt3 + 0xfefefeff & ~tempUnsignedInt3 & 0x80808080;\n        unsignedInts1 = unsignedInts1 + 2;\n        pUnsignedInt1 = pUnsignedInt1 + 2;\n      } while (tempUnsignedInt3 == tempUnsignedInt4 && tempUnsignedInt5 == 0);\n      tempUnsignedInt2 = tempUnsignedInt3 << 0x18 | (tempUnsignedInt3 >> 8 & 0xff) << 0x10 | (tempUnsignedInt3 >> 0x10 & 0xff) << 8 |\n              tempUnsignedInt3 >> 0x18;\n      tempUnsignedInt1 = tempUnsignedInt4 << 0x18 | (tempUnsignedInt4 >> 8 & 0xff) << 0x10 | (tempUnsignedInt4 >> 0x10 & 0xff) << 8 |\n              tempUnsignedInt4 >> 0x18;\n      goto LAB_0008259e;\n    }\n  }\n  do {\n    tempUnsignedInt1 = *unsignedInts1;\n    tempUnsignedInt2 = unsignedInts1[1];\n    tempUnsignedInt3 = *unsignedInts2;\n    tempUnsignedInt4 = unsignedInts2[1];\n    tempUnsignedInt5 = tempUnsignedInt1 + 0xfefefeff & ~tempUnsignedInt1 & 0x80808080;\n    if (tempUnsignedInt1 != tempUnsignedInt3 || tempUnsignedInt5 != 0) goto LAB_0008259a;\n    tempUnsignedInt5 = tempUnsignedInt2 + 0xfefefeff & ~tempUnsignedInt2 & 0x80808080;\n    unsignedInts1 = unsignedInts1 + 2;\n    unsignedInts2 = unsignedInts2 + 2;\n  } while (tempUnsignedInt2 == tempUnsignedInt4 && tempUnsignedInt5 == 0);\n  tempUnsignedInt2 = tempUnsignedInt2 << 0x18 | (tempUnsignedInt2 >> 8 & 0xff) << 0x10 | (tempUnsignedInt2 >> 0x10 & 0xff) << 8 | tempUnsignedInt2 >> 0x18;\n  tempUnsignedInt1 = tempUnsignedInt4 << 0x18 | (tempUnsignedInt4 >> 8 & 0xff) << 0x10 | (tempUnsignedInt4 >> 0x10 & 0xff) << 8 | tempUnsignedInt4 >> 0x18;\nLAB_0008259e:\n  tempUnsignedInt3 = tempUnsignedInt5 << 0x18 | (tempUnsignedInt5 >> 8 & 0xff) << 0x10 | (tempUnsignedInt5 >> 0x10 & 0xff) << 8 | tempUnsignedInt5 >> 0x18;\n  if (tempUnsignedInt3 != 0) {\n    tempUnsignedInt3 = 0x18 - LZCOUNT(tempUnsignedInt3);\n    tempUnsignedInt2 = tempUnsignedInt2 >> (tempUnsignedInt3 & 0xff);\n    tempUnsignedInt1 = tempUnsignedInt1 >> (tempUnsignedInt3 & 0xff);\n  }\n  result = 1;\n  if (tempUnsignedInt2 <= tempUnsignedInt1) {\n    result = -(uint)(tempUnsignedInt2 < tempUnsignedInt1);\n  }\n  return result;\nLAB_0008258e:\n  tempUnsignedInt2 = tempUnsignedInt2 << 0x18 | (tempUnsignedInt2 >> 8 & 0xff) << 0x10 | (tempUnsignedInt2 >> 0x10 & 0xff) << 8 | tempUnsignedInt2 >> 0x18;\n  tempUnsignedInt1 = tempUnsignedInt1 << 0x18 | (tempUnsignedInt1 >> 8 & 0xff) << 0x10 | (tempUnsignedInt1 >> 0x10 & 0xff) << 8 | tempUnsignedInt1 >> 0x18;\n  goto LAB_0008259e;\n}\n\n",
            "renaming": {
                "FUN_00082390": "compare_unsigned_integers_00082390",
                "param_1": "unsignedInts1",
                "param_2": "unsignedInts2",
                "puVar1": "pUnsignedInt1",
                "iVar2": "result",
                "puVar3": "pUnsignedInt2",
                "puVar4": "pTempUnsignedInt",
                "uVar5": "tempUnsignedInt1",
                "uVar6": "tempUnsignedInt2",
                "uVar7": "tempUnsignedInt3",
                "uVar8": "tempUnsignedInt4",
                "uVar9": "tempUnsignedInt5"
            },
            "calling": [
                "FUN_000815b8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000825cc": {
            "entrypoint": "0x000825cc",
            "current_name": "copy_string_with_alignment_000825cc",
            "code": "\nvoid copyStringWithAlignment_000825cc(uint *dest,uint *src)\n\n{\n  char currentChar;\n  ushort currentShort;\n  uint *nextPtr;\n  uint *nextPtrAligned;\n  uint currentWord;\n  uint tempWord;\n  uint *currentPtr;\n  bool isLastByteNull;\n  \n  if ((((uint)dest ^ (uint)src) & 3) != 0) {\n    do {\n      currentChar = *(char *)src;\n      *(char *)dest = currentChar;\n      src = (uint *)((int)src + 1);\n      dest = (uint *)((int)dest + 1);\n    } while (currentChar != '\\0');\n    return;\n  }\n  if (((uint)src & 3) != 0) {\n    nextPtrAligned = src;\n    if (((uint)src & 1) != 0) {\n      nextPtrAligned = (uint *)((int)src + 1);\n      currentChar = *(char *)src;\n      *(char *)dest = currentChar;\n      dest = (uint *)((int)dest + 1);\n      if (currentChar == '\\0') {\n        return;\n      }\n    }\n    src = nextPtrAligned;\n    if (((uint)nextPtrAligned & 2) != 0) {\n      src = (uint *)((int)nextPtrAligned + 2);\n      currentShort = *(ushort *)nextPtrAligned;\n      isLastByteNull = (currentShort & 0xff) == 0;\n      if (isLastByteNull) {\n        *(char *)dest = (char)currentShort;\n      }\n      else {\n        *(ushort *)dest = currentShort;\n        isLastByteNull = (currentShort & 0xff00) == 0;\n        dest = (uint *)((int)dest + 2);\n      }\n      if (isLastByteNull) {\n        return;\n      }\n    }\n  }\n  currentWord = *src;\n  nextPtrAligned = src + 1;\n  currentPtr = dest;\n  if (((uint)src & 4) != 0) {\n    if ((currentWord + 0xfefefeff & ~currentWord & 0x80808080) != 0) goto LAB_00082630;\n    currentPtr = dest + 1;\n    *dest = currentWord;\n    nextPtrAligned = src + 2;\n    currentWord = src[1];\n  }\n  while( true ) {\n    nextPtr = nextPtrAligned + 1;\n    tempWord = *nextPtrAligned;\n    dest = currentPtr;\n    if ((currentWord + 0xfefefeff & ~currentWord & 0x80808080) != 0) break;\n    dest = currentPtr + 1;\n    *currentPtr = currentWord;\n    currentWord = tempWord;\n    if ((tempWord + 0xfefefeff & ~tempWord & 0x80808080) != 0) break;\n    nextPtrAligned = nextPtrAligned + 2;\n    currentWord = *nextPtr;\n    currentPtr = currentPtr + 2;\n    *dest = tempWord;\n  }\nLAB_00082630:\n  do {\n    *(char *)dest = (char)currentWord;\n    tempWord = currentWord & 0xff;\n    currentWord = currentWord >> 8 | currentWord << 0x18;\n    dest = (uint *)((int)dest + 1);\n  } while (tempWord != 0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000825cc": "copy_string_with_alignment_000825cc",
                "param_1": "dest",
                "param_2": "src",
                "cVar1": "currentChar",
                "uVar2": "currentShort",
                "puVar3": "nextPtr",
                "puVar4": "nextPtrAligned",
                "uVar5": "currentWord",
                "uVar6": "tempWord",
                "puVar7": "currentPtr",
                "bVar8": "isLastByteNull"
            },
            "calling": [
                "FUN_0008151c",
                "FUN_000814d0",
                "FUN_00081570"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082688": {
            "entrypoint": "0x00082688",
            "current_name": "count_leading_zeros_00082688",
            "code": "\nint countLeadingZeros_00082688(uint input)\n\n{\n  int leadingZeros;\n  uint *alignedPointer;\n  uint value;\n  bool isZero;\n  \n  alignedPointer = (uint *)(input & 0xfffffffc);\n  leadingZeros = -(input & 3);\n  value = *alignedPointer;\n  if ((input & 3) != 0) {\n    value = value | 0xffffffffU >> ((leadingZeros + 4U & 0x1f) << 3);\n  }\n  while (alignedPointer = alignedPointer + 1, (value + 0xfefefeff & ~value & 0x80808080) == 0) {\n    leadingZeros = leadingZeros + 4;\n    value = *alignedPointer;\n  }\n  isZero = (value & 0xff) == 0;\n  if (!isZero) {\n    leadingZeros = leadingZeros + 1;\n    isZero = (value & 0xff00) == 0;\n  }\n  if (!isZero) {\n    leadingZeros = leadingZeros + 1;\n    isZero = (value & 0xff0000) == 0;\n  }\n  if (!isZero) {\n    leadingZeros = leadingZeros + 1;\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_00082688": "count_leading_zeros_00082688",
                "param_1": "input",
                "iVar1": "leadingZeros",
                "puVar2": "alignedPointer",
                "uVar3": "value",
                "bVar4": "isZero"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_000814f6",
                "FUN_000810a6"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082824": {
            "entrypoint": "0x00082824",
            "current_name": "process_data_00082824",
            "code": "\nint processData_00082824(undefined4 value,int num,int **data)\n\n{\n  int *currentData;\n  int result;\n  int *remainingData;\n  uint counter;\n  undefined4 *ptr;\n  uint value2;\n  uint shiftedValue;\n  \n  if (-1 < *(int *)(num + 100) << 0x12) {\n    result = FUN_00083ca8();\n    data[2] = (int *)0x0;\n    data[1] = (int *)0x0;\n    return result;\n  }\n  remainingData = data[2];\n  currentData = *data;\n  while (remainingData != (int *)0x0) {\n    value2 = currentData[1];\n    shiftedValue = value2 >> 2;\n    if (shiftedValue != 0) {\n      ptr = (undefined4 *)(*currentData + -4);\n      counter = 0;\n      do {\n        ptr = ptr + 1;\n        result = FUN_000839b4(value,*ptr,num);\n        counter = counter + 1;\n        if (result == -1) goto LAB_00082864;\n      } while (shiftedValue != counter);\n      remainingData = data[2];\n    }\n    remainingData = (int *)((int)remainingData - (value2 & 0xfffffffc));\n    data[2] = remainingData;\n    currentData = currentData + 2;\n  }\n  result = 0;\nLAB_00082864:\n  data[2] = (int *)0x0;\n  data[1] = (int *)0x0;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082824": "process_data_00082824",
                "param_1": "value",
                "param_2": "num",
                "param_3": "data",
                "piVar1": "currentData",
                "iVar2": "result",
                "piVar3": "remainingData",
                "uVar4": "counter",
                "puVar5": "ptr",
                "uVar6": "value2",
                "uVar7": "shiftedValue"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_00083ca8",
                "FUN_000839b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008289c": {
            "entrypoint": "0x0008289c",
            "current_name": "parse_format_string_0008289c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint parseFormatString_0008289c(int ptrStruct,int ptrBuffer,int *******formatString,int **ptrArgs)\n\n{\n  bool formatSpec;\n  bool isNegative;\n  bool isSigned;\n  char signCharacter;\n  bool isZeroPadded;\n  int ********formatArgs;\n  int *tempPtrVar;\n  int loopCounter;\n  char tempCharVar;\n  int *******tempPtrVar;\n  uint tempVar;\n  int **tempPtrVar;\n  uint tempVar;\n  uint tempVar;\n  int tempVar;\n  int ********ptempPtrVar;\n  int tempVar;\n  int *******tempPtrVar;\n  int *tempPtrVar;\n  int *******pppppppiVar20;\n  uint uVar21;\n  int *tempPtrVar;\n  int *******tempPtrVar;\n  undefined4 tempVar;\n  int ********tempPtrVar;\n  bool isPointer;\n  longlong tempLongVar;\n  int *******totalArgsSize;\n  int *******baseArgsSize;\n  int **ptrArgs;\n  int resultSize;\n  char *tempStr;\n  char signChar;\n  undefined padChar;\n  undefined isHex;\n  int ********tempPtrVar;\n  int argCounter;\n  int *******argList;\n  undefined tempCharVar;\n  char tempCharVar;\n  undefined tempVar;\n  undefined tempBuffer [4];\n  int *******local_64 [16];\n  \n  if ((ptrStruct != 0) && (*(int *)(ptrStruct + 0x38) == 0)) {\n    FUN_00083888();\n  }\n  tempVar = (uint)*(ushort *)(ptrBuffer + 0xc);\n  if (-1 < (int)((uint)*(ushort *)(ptrBuffer + 0xc) << 0x12)) {\n    tempVar = tempVar | 0x2000;\n    *(short *)(ptrBuffer + 0xc) = (short)tempVar;\n    *(uint *)(ptrBuffer + 100) = *(uint *)(ptrBuffer + 100) & 0xffffdfff;\n  }\n  if (((int)(tempVar << 0x1c) < 0) && (*(int *)(ptrBuffer + 0x10) != 0)) {\n    if ((tempVar & 0x1a) != 10) goto LAB_000828ee;\n  }\n  else {\n    loopCounter = FUN_0008356c(ptrStruct,ptrBuffer);\n    if (loopCounter != 0) {\n      return -1;\n    }\n    if ((*(ushort *)(ptrBuffer + 0xc) & 0x1a) != 10) goto LAB_000828ee;\n  }\n  if (-1 < *(short *)(ptrBuffer + 0xe)) {\n    loopCounter = FUN_000834f0(ptrStruct,ptrBuffer,formatString,ptrArgs);\n    return loopCounter;\n  }\nLAB_000828ee:\n  tempStr = (char *)0x0;\n  argList = (int *******)0x0;\n  argCounter = 0;\n  resultSize = 0;\n  formatArgs = (int ********)tempBuffer;\n  ptrArgs = ptrArgs;\n  tempPtrVar = (int ********)tempBuffer;\nLAB_00082902:\n  tempPtrVar = formatString;\n  if ((*(char *)formatString != '\\0') && (*(char *)formatString != '%')) {\n    do {\n      tempPtrVar = (int *******)((int)tempPtrVar + 1);\n      if (*(char *)tempPtrVar == '\\0') break;\n    } while (*(char *)tempPtrVar != '%');\n    pppppppiVar20 = (int *******)((int)tempPtrVar - (int)formatString);\n    if (pppppppiVar20 != (int *******)0x0) {\n      argCounter = argCounter + 1;\n      argList = (int *******)((int)argList + (int)pppppppiVar20);\n      *formatArgs = formatString;\n      formatArgs[1] = pppppppiVar20;\n      if (argCounter < 8) {\n        formatArgs = formatArgs + 2;\n      }\n      else {\n        if (argList == (int *******)0x0) {\n          resultSize = resultSize + (int)pppppppiVar20;\n          argCounter = 0;\n          formatArgs = (int ********)tempBuffer;\n          goto LAB_00082952;\n        }\n        loopCounter = FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar);\n        formatArgs = (int ********)tempBuffer;\n        if (loopCounter != 0) goto LAB_00083142;\n      }\n      resultSize = resultSize + (int)pppppppiVar20;\n    }\n  }\nLAB_00082952:\n  if (*(char *)tempPtrVar != '\\0') {\n    signChar = '\\0';\n    tempVar = (uint)*(byte *)((int)tempPtrVar + 1);\n    tempVar = 0;\n    isZeroPadded = false;\n    isNegative = false;\n    formatSpec = false;\n    isSigned = false;\n    isPointer = false;\n    pppppppiVar20 = (int *******)0x0;\n    baseArgsSize = (int *******)0xffffffff;\n    formatString = (int *******)((int)tempPtrVar + 1);\nLAB_00082976:\n    formatString = (int *******)((int)formatString + 1);\nLAB_0008297a:\n    switch(tempVar) {\n    case 0x20:\n      goto switchD_00082984_caseD_20;\n    default:\n      if (tempVar != 0) {\n        totalArgsSize = (int *******)0x1;\n        baseArgsSize = (int *******)0x1;\n        tempPtrVar = (int ********)&tempCharVar;\n        tempCharVar = (char)tempVar;\n        goto LAB_00082d76;\n      }\n      goto LAB_00083134;\n    case 0x23:\n      isSigned = true;\n      tempVar = (uint)*(byte *)formatString;\n      goto LAB_00082976;\n    case 0x2a:\n      pppppppiVar20 = (int *******)*ptrArgs;\n      ptrArgs = ptrArgs + 1;\n      if ((int)pppppppiVar20 < 0) {\n        pppppppiVar20 = (int *******)-(int)pppppppiVar20;\n        goto switchD_00082984_caseD_2d;\n      }\n      tempVar = (uint)*(byte *)formatString;\n      goto LAB_00082976;\n    case 0x2b:\n      tempVar = (uint)*(byte *)formatString;\n      signChar = '+';\n      goto LAB_00082976;\n    case 0x2d:\nswitchD_00082984_caseD_2d:\n      tempVar = tempVar | 4;\n      tempVar = (uint)*(byte *)formatString;\n      goto LAB_00082976;\n    case 0x2e:\n      tempVar = (uint)*(byte *)formatString;\n      tempPtrVar = (int *******)((int)formatString + 1);\n      if (tempVar == 0x2a) {\n        tempVar = (uint)*(byte *)((int)formatString + 1);\n        baseArgsSize = (int *******)*ptrArgs;\n        ptrArgs = ptrArgs + 1;\n        formatString = tempPtrVar;\n        if ((int)baseArgsSize < 0) {\n          baseArgsSize = (int *******)0xffffffff;\n        }\n        goto LAB_00082976;\n      }\n      tempVar = tempVar - 0x30;\n      if (tempVar < 10) {\n        uVar21 = 0;\n        do {\n          formatString = (int *******)((int)tempPtrVar + 1);\n          tempVar = (uint)*(byte *)tempPtrVar;\n          uVar21 = tempVar + uVar21 * 10;\n          tempVar = tempVar - 0x30;\n          tempPtrVar = formatString;\n        } while (tempVar < 10);\n        baseArgsSize = (int *******)(uVar21 | (int)uVar21 >> 0x1f);\n      }\n      else {\n        baseArgsSize = (int *******)0x0;\n        formatString = tempPtrVar;\n      }\n      goto LAB_0008297a;\n    case 0x30:\n      tempVar = tempVar | 0x80;\n      tempVar = (uint)*(byte *)formatString;\n      goto LAB_00082976;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_00082984_caseD_31;\n    case 0x44:\n      isNegative = true;\n      if (formatSpec == false) goto LAB_00082d8c;\nLAB_00082bfc:\n      ptrArgs = (int **)((int)ptrArgs + 7U & 0xfffffff8);\n      tempPtrVar = *ptrArgs;\n      tempPtrVar = ptrArgs[1];\n      ptrArgs = ptrArgs + 2;\n      goto LAB_00082c10;\n    case 0x4f:\n      isNegative = true;\n      if (formatSpec != false) goto LAB_00082aa6;\nLAB_00082c8e:\n      loopCounter = (uint)isNegative << 4;\n      tempVar = (uint)formatSpec << 5;\n      if ((isNegative == 0) && (tempVar = (uint)isPointer << 6, isPointer != 0)) {\n        tempPtrVar = (int *)(uint)*(ushort *)ptrArgs;\n        ptrArgs = ptrArgs + 1;\n        tempPtrVar = (int *)0x0;\n      }\n      else {\n        loopCounter = tempVar;\n        tempPtrVar = *ptrArgs;\n        ptrArgs = ptrArgs + 1;\n        tempPtrVar = (int *)0x0;\n      }\n      break;\n    case 0x55:\n      isNegative = true;\n      if (formatSpec != false) goto LAB_00082bc6;\nLAB_00082ce0:\n      if ((isNegative) || (isPointer == false)) {\n        loopCounter = 1;\n        tempPtrVar = *ptrArgs;\n        ptrArgs = ptrArgs + 1;\n        tempPtrVar = (int *)0x0;\n      }\n      else {\n        tempPtrVar = (int *)0x0;\n        tempPtrVar = (int *)(uint)*(ushort *)ptrArgs;\n        ptrArgs = ptrArgs + 1;\n        loopCounter = 1;\n      }\n      break;\n    case 0x58:\n      tempStr = \"0123456789ABCDEF\";\n      if (formatSpec == false) goto LAB_00082efa;\nLAB_00082d1a:\n      tempPtrVar = (int **)((int)ptrArgs + 7U & 0xfffffff8);\n      ptrArgs = tempPtrVar + 2;\n      tempPtrVar = *tempPtrVar;\n      tempPtrVar = tempPtrVar[1];\n      goto LAB_00082d2e;\n    case 99:\n      tempPtrVar = *ptrArgs;\n      ptrArgs = ptrArgs + 1;\n      totalArgsSize = (int *******)0x1;\n      tempCharVar = SUB41(tempPtrVar,0);\n      baseArgsSize = (int *******)0x1;\n      tempPtrVar = (int ********)&tempCharVar;\n      goto LAB_00082d76;\n    case 100:\n    case 0x69:\n      if (formatSpec != false) goto LAB_00082bfc;\nLAB_00082d8c:\n      if ((isNegative == false) && (isPointer != false)) {\n        tempPtrVar = (int *)(int)*(short *)ptrArgs;\n        ptrArgs = ptrArgs + 1;\n        tempPtrVar = (int *)((int)tempPtrVar >> 0x1f);\n      }\n      else {\n        tempPtrVar = *ptrArgs;\n        ptrArgs = ptrArgs + 1;\n        tempPtrVar = (int *)((int)tempPtrVar >> 0x1f);\n      }\nLAB_00082c10:\n      if ((int)tempPtrVar < 0) {\n        isPointer = tempPtrVar != (int *)0x0;\n        tempPtrVar = (int *)-(int)tempPtrVar;\n        tempPtrVar = (int *)(-(int)tempPtrVar - (uint)isPointer);\n        signChar = '-';\n        signCharacter = '-';\n        loopCounter = 1;\n        goto LAB_00082ace;\n      }\n      if (-1 < (int)baseArgsSize) {\n        tempVar = tempVar & 0xffffff7f;\n      }\n      isZeroPadded = false;\n      tempVar = (uint)tempPtrVar | (uint)tempPtrVar;\n      loopCounter = 1;\n      signCharacter = signChar;\n      goto joined_r0x00082adc;\n    case 0x68:\n      isPointer = true;\n      tempVar = (uint)*(byte *)formatString;\n      goto LAB_00082976;\n    case 0x6c:\n      tempVar = (uint)*(byte *)formatString;\n      if (tempVar == 0x6c) {\n        formatSpec = true;\n        tempVar = (uint)*(byte *)((int)formatString + 1);\n        formatString = (int *******)((int)formatString + 1);\n      }\n      else {\n        isNegative = true;\n      }\n      goto LAB_00082976;\n    case 0x6e:\n      if (formatSpec == false) {\n        if (isNegative == false) {\n          if (isPointer) {\n            tempPtrVar = *ptrArgs;\n            ptrArgs = ptrArgs + 1;\n            *(short *)tempPtrVar = (short)resultSize;\n          }\n          else {\n            tempPtrVar = *ptrArgs;\n            ptrArgs = ptrArgs + 1;\n            *tempPtrVar = resultSize;\n          }\n        }\n        else {\n          tempPtrVar = *ptrArgs;\n          ptrArgs = ptrArgs + 1;\n          *tempPtrVar = resultSize;\n        }\n      }\n      else {\n        tempPtrVar = *ptrArgs;\n        ptrArgs = ptrArgs + 1;\n        *tempPtrVar = resultSize;\n        tempPtrVar[1] = resultSize >> 0x1f;\n      }\n      goto LAB_00082902;\n    case 0x6f:\n      if (formatSpec == false) goto LAB_00082c8e;\nLAB_00082aa6:\n      tempPtrVar = (int **)((int)ptrArgs + 7U & 0xfffffff8);\n      ptrArgs = tempPtrVar + 2;\n      tempPtrVar = *tempPtrVar;\n      tempPtrVar = tempPtrVar[1];\n      loopCounter = 0;\n      break;\n    case 0x70:\n      tempPtrVar = *ptrArgs;\n      ptrArgs = ptrArgs + 1;\n      isHex = 0x78;\n      isZeroPadded = true;\n      tempPtrVar = (int *)0x0;\n      padChar = 0x30;\n      tempStr = \"0123456789abcdef\";\n      loopCounter = 2;\n      break;\n    case 0x71:\n      formatSpec = true;\n      tempVar = (uint)*(byte *)formatString;\n      goto LAB_00082976;\n    case 0x73:\n      tempPtrVar = (int ********)*ptrArgs;\n      signChar = '\\0';\n      ptrArgs = ptrArgs + 1;\n      if (tempPtrVar != (int ********)0x0) {\n        if ((int)baseArgsSize < 0) {\n          baseArgsSize = (int *******)FUN_00082688(tempPtrVar);\n          tempPtrVar = (int *******)0x0;\n          signCharacter = signChar;\n        }\n        else {\n          loopCounter = FUN_000840f8(tempPtrVar,0,baseArgsSize);\n          signCharacter = signChar;\n          if (loopCounter == 0) {\n            tempPtrVar = (int *******)0x0;\n          }\n          else {\n            tempPtrVar = (int *******)(loopCounter - (int)tempPtrVar);\n            if ((int)baseArgsSize <= (int)(int *******)(loopCounter - (int)tempPtrVar)) {\n              tempPtrVar = baseArgsSize;\n            }\n            tempPtrVar = (int *******)0x0;\n            baseArgsSize = tempPtrVar;\n          }\n        }\n        goto LAB_00082b04;\n      }\n      if ((int *******)0x5 < baseArgsSize) {\n        baseArgsSize = (int *******)0x6;\n      }\n      totalArgsSize = (int *******)((uint)baseArgsSize & ~((int)baseArgsSize >> 0x1f));\n      tempPtrVar = (int ********)&UNK_00085728;\nLAB_00082d76:\n      signChar = '\\0';\n      tempPtrVar = (int *******)0x0;\n      goto LAB_00082b1e;\n    case 0x75:\n      if (!formatSpec) goto LAB_00082ce0;\nLAB_00082bc6:\n      tempPtrVar = (int **)((int)ptrArgs + 7U & 0xfffffff8);\n      ptrArgs = tempPtrVar + 2;\n      tempPtrVar = *tempPtrVar;\n      tempPtrVar = tempPtrVar[1];\n      loopCounter = 1;\n      break;\n    case 0x78:\n      tempStr = \"0123456789abcdef\";\n      if (formatSpec != false) goto LAB_00082d1a;\nLAB_00082efa:\n      if ((isNegative == false) && (isPointer != false)) {\n        tempPtrVar = (int *)0x0;\n        tempPtrVar = (int *)(uint)*(ushort *)ptrArgs;\n        ptrArgs = ptrArgs + 1;\n      }\n      else {\n        tempPtrVar = *ptrArgs;\n        ptrArgs = ptrArgs + 1;\n        tempPtrVar = (int *)0x0;\n      }\nLAB_00082d2e:\n      if ((isSigned) && (((uint)tempPtrVar | (uint)tempPtrVar) != 0)) {\n        isZeroPadded = true;\n        padChar = 0x30;\n        loopCounter = 2;\n        isHex = (char)tempVar;\n      }\n      else {\n        loopCounter = 2;\n      }\n    }\n    signChar = '\\0';\n    signCharacter = '\\0';\nLAB_00082ace:\n    if (-1 < (int)baseArgsSize) {\n      tempVar = tempVar & 0xffffff7f;\n    }\n    tempVar = (uint)tempPtrVar | (uint)tempPtrVar;\njoined_r0x00082adc:\n    tempLongVar = CONCAT44(tempPtrVar,tempPtrVar);\n    tempPtrVar = baseArgsSize;\n    if ((tempVar == 0) && (baseArgsSize == (int *******)0x0)) {\n      tempPtrVar = (int ********)tempBuffer;\n      if ((loopCounter != 0) || (!isSigned)) goto LAB_00082b04;\n      tempPtrVar = (int ********)(&tempCharVar + 1);\n      tempVar = '0';\n      goto LAB_00082afe;\n    }\n    if (loopCounter == 1) {\n      if (tempPtrVar != (int *)0x0 || (int *)0x9 < tempPtrVar) {\n        ptempPtrVar = (int ********)(&tempCharVar + 1);\n        do {\n          tempPtrVar = ptempPtrVar;\n          tempVar = (undefined4)((ulonglong)tempLongVar >> 0x20);\n          tempCharVar = '\\n';\n          FUN_00084530((int)tempLongVar,tempVar,10,0);\n          *(char *)tempPtrVar = tempCharVar + '0';\n          tempLongVar = FUN_00084530((int)tempLongVar,tempVar,10,0);\n          ptempPtrVar = (int ********)((int)tempPtrVar + -1);\n        } while (tempLongVar != 0);\n        baseArgsSize = (int *******)((int)tempBuffer - (int)tempPtrVar);\n        goto LAB_00082b04;\n      }\n      tempVar = (char)tempPtrVar + '0';\n      tempPtrVar = (int ********)(&tempCharVar + 1);\n      goto LAB_00083282;\n    }\n    ptempPtrVar = (int ********)(&tempCharVar + 1);\n    if (loopCounter != 2) goto LAB_000830e2;\n    do {\n      tempPtrVar = ptempPtrVar;\n      tempVar = (uint)tempPtrVar & 0xf;\n      tempPtrVar = (int *)((uint)tempPtrVar >> 4 | (int)tempPtrVar << 0x1c);\n      tempPtrVar = (int *)((uint)tempPtrVar >> 4);\n      *(char *)tempPtrVar = tempStr[tempVar];\n      ptempPtrVar = (int ********)((int)tempPtrVar + -1);\n    } while (((uint)tempPtrVar | (uint)tempPtrVar) != 0);\n    baseArgsSize = (int *******)((int)tempBuffer - (int)tempPtrVar);\n    goto LAB_00082b04;\n  }\nLAB_00083134:\n  if (argList != (int *******)0x0) {\n    FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar);\n  }\nLAB_00083142:\n  if ((int)((uint)*(ushort *)(ptrBuffer + 0xc) << 0x19) < 0) {\n    return -1;\n  }\n  return resultSize;\nLAB_000830e2:\n  do {\n    tempPtrVar = ptempPtrVar;\n    tempPtrVar = (int *)((uint)tempPtrVar >> 3 | (int)tempPtrVar << 0x1d);\n    tempPtrVar = (int *)((uint)tempPtrVar >> 3);\n    loopCounter = ((uint)tempPtrVar & 7) + 0x30;\n    *(char *)tempPtrVar = (char)loopCounter;\n    ptempPtrVar = (int ********)((int)tempPtrVar + -1);\n    tempPtrVar = tempPtrVar;\n  } while (((uint)tempPtrVar | (uint)tempPtrVar) != 0);\n  if (isSigned) {\n    if (loopCounter == 0x30) {\nLAB_00082afe:\n      baseArgsSize = (int *******)((int)tempBuffer - (int)tempPtrVar);\n    }\n    else {\n      *(undefined *)((int)tempPtrVar + -1) = 0x30;\n      tempPtrVar = ptempPtrVar;\n      baseArgsSize = (int *******)((int)tempBuffer - (int)ptempPtrVar);\n    }\n  }\n  else {\nLAB_00083282:\n    baseArgsSize = (int *******)((int)tempBuffer - (int)tempPtrVar);\n  }\nLAB_00082b04:\n  totalArgsSize = baseArgsSize;\n  if ((int)baseArgsSize < (int)tempPtrVar) {\n    totalArgsSize = tempPtrVar;\n  }\n  if (signCharacter != '\\0') {\n    totalArgsSize = (int *******)((int)totalArgsSize + 1);\n  }\nLAB_00082b1e:\n  if (isZeroPadded) {\n    totalArgsSize = (int *******)((int)totalArgsSize + 2);\n  }\n  if ((tempVar == 0) &&\n     (tempPtrVar = (int *******)((int)pppppppiVar20 - (int)totalArgsSize), 0 < (int)tempPtrVar)) {\n    if ((int)tempPtrVar < 0x11) {\n      argCounter = argCounter + 1;\n    }\n    else {\n      do {\n        tempPtrVar = tempPtrVar;\n        loopCounter = argCounter + 1;\n        argList = argList + 4;\n        *formatArgs = (int *******)0x856f0;\n        formatArgs[1] = (int *******)0x10;\n        if (loopCounter < 8) {\n          tempVar = argCounter + 2;\n          formatArgs = formatArgs + 2;\n          argCounter = loopCounter;\n        }\n        else if (argList == (int *******)0x0) {\n          tempVar = 1;\n          formatArgs = (int ********)tempBuffer;\n          argCounter = 0;\n        }\n        else {\n          argCounter = loopCounter;\n          loopCounter = FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar);\n          if (loopCounter != 0) goto LAB_00083142;\n          tempVar = argCounter + 1;\n          formatArgs = (int ********)tempBuffer;\n        }\n        tempPtrVar = tempPtrVar + -4;\n      } while (0x10 < (int)tempPtrVar);\n      tempPtrVar = tempPtrVar + -4;\n      argCounter = tempVar;\n    }\n    argList = (int *******)((int)argList + (int)tempPtrVar);\n    *formatArgs = (int *******)0x856f0;\n    formatArgs[1] = tempPtrVar;\n    if (argCounter < 8) {\n      loopCounter = argCounter + 1;\n      formatArgs = formatArgs + 2;\n    }\n    else if (argList == (int *******)0x0) {\n      loopCounter = 1;\n      argCounter = 0;\n      formatArgs = (int ********)tempBuffer;\n    }\n    else {\n      loopCounter = FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar);\n      if (loopCounter != 0) goto LAB_00083142;\n      loopCounter = argCounter + 1;\n      formatArgs = (int ********)tempBuffer;\n    }\n  }\n  else {\n    loopCounter = argCounter + 1;\n  }\n  tempVar = loopCounter;\n  if (signChar != '\\0') {\n    argList = (int *******)((int)argList + 1);\n    tempVar = 1;\n    *formatArgs = (int *******)&signChar;\n    formatArgs[1] = (int *******)0x1;\n    argCounter = loopCounter;\n    if (loopCounter < 8) {\n      tempVar = loopCounter + 1;\n      formatArgs = formatArgs + 2;\n    }\n    else if (argList == (int *******)0x0) {\n      argCounter = 0;\n      formatArgs = (int ********)tempBuffer;\n    }\n    else {\n      loopCounter = FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar);\n      if (loopCounter != 0) goto LAB_00083142;\n      tempVar = argCounter + 1;\n      formatArgs = (int ********)tempBuffer;\n    }\n  }\n  loopCounter = tempVar;\n  tempVar = argCounter;\n  if (isZeroPadded) {\n    argList = (int *******)((int)argList + 2);\n    *formatArgs = (int *******)&padChar;\n    formatArgs[1] = (int *******)0x2;\n    if (tempVar < 8) {\n      loopCounter = tempVar + 1;\n      tempVar = tempVar;\n      formatArgs = formatArgs + 2;\n    }\n    else if (argList == (int *******)0x0) {\n      loopCounter = 1;\n      tempVar = 0;\n      formatArgs = (int ********)tempBuffer;\n    }\n    else {\n      argCounter = tempVar;\n      loopCounter = FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar);\n      if (loopCounter != 0) goto LAB_00083142;\n      loopCounter = argCounter + 1;\n      tempVar = argCounter;\n      formatArgs = (int ********)tempBuffer;\n    }\n  }\n  argCounter = tempVar;\n  if ((tempVar == 0x80) &&\n     (tempPtrVar = (int *******)((int)pppppppiVar20 - (int)totalArgsSize), 0 < (int)tempPtrVar)) {\n    if (0x10 < (int)tempPtrVar) {\n      do {\n        while( true ) {\n          tempPtrVar = tempPtrVar;\n          argCounter = tempVar + 1;\n          argList = argList + 4;\n          *formatArgs = (int *******)\"0000000000000000\";\n          formatArgs[1] = (int *******)0x10;\n          if (7 < argCounter) break;\n          loopCounter = tempVar + 2;\n          formatArgs = formatArgs + 2;\nLAB_000831f2:\n          tempVar = argCounter;\n          tempPtrVar = tempPtrVar + -4;\n          if ((int)(tempPtrVar + -4) < 0x11) goto LAB_00083218;\n        }\n        if (argList != (int *******)0x0) {\n          loopCounter = FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar);\n          if (loopCounter == 0) {\n            loopCounter = argCounter + 1;\n            formatArgs = (int ********)tempBuffer;\n            goto LAB_000831f2;\n          }\n          goto LAB_00083142;\n        }\n        loopCounter = 1;\n        tempVar = 0;\n        tempPtrVar = tempPtrVar + -4;\n        formatArgs = (int ********)tempBuffer;\n      } while (0x10 < (int)(tempPtrVar + -4));\nLAB_00083218:\n      tempPtrVar = tempPtrVar + -4;\n    }\n    argList = (int *******)((int)argList + (int)tempPtrVar);\n    *formatArgs = (int *******)\"0000000000000000\";\n    formatArgs[1] = tempPtrVar;\n    argCounter = loopCounter;\n    if (loopCounter < 8) {\n      loopCounter = loopCounter + 1;\n      formatArgs = formatArgs + 2;\n    }\n    else if (argList == (int *******)0x0) {\n      loopCounter = 1;\n      argCounter = 0;\n      formatArgs = (int ********)tempBuffer;\n    }\n    else {\n      loopCounter = FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar);\n      if (loopCounter != 0) goto LAB_00083142;\n      loopCounter = argCounter + 1;\n      formatArgs = (int ********)tempBuffer;\n    }\n  }\n  tempPtrVar = (int *******)((int)tempPtrVar - (int)baseArgsSize);\n  ptempPtrVar = (int ********)tempBuffer;\n  if ((int)tempPtrVar < 1) {\nLAB_0008302a:\n    argList = (int *******)((int)argList + (int)baseArgsSize);\n    *formatArgs = (int *******)tempPtrVar;\n    formatArgs[1] = baseArgsSize;\n    baseArgsSize = argList;\n    argCounter = loopCounter;\n    if (loopCounter < 8) goto LAB_000831be;\n    if (argList == (int *******)0x0) {\n      argCounter = 0;\n    }\n    else {\n      loopCounter = FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar);\n      if (loopCounter != 0) goto LAB_00083142;\n    }\n  }\n  else {\n    tempVar = argCounter;\n    if (0x10 < (int)tempPtrVar) {\n      do {\n        while( true ) {\n          tempPtrVar = tempPtrVar;\n          argCounter = tempVar + 1;\n          argList = argList + 4;\n          *formatArgs = (int *******)\"0000000000000000\";\n          formatArgs[1] = (int *******)0x10;\n          if (7 < argCounter) break;\n          loopCounter = tempVar + 2;\n          formatArgs = formatArgs + 2;\nLAB_00082fe6:\n          tempVar = argCounter;\n          tempPtrVar = tempPtrVar + -4;\n          if ((int)(tempPtrVar + -4) < 0x11) goto LAB_0008300e;\n        }\n        if (argList != (int *******)0x0) {\n          loopCounter = FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar);\n          if (loopCounter == 0) {\n            loopCounter = argCounter + 1;\n            formatArgs = (int ********)tempBuffer;\n            goto LAB_00082fe6;\n          }\n          goto LAB_00083142;\n        }\n        loopCounter = 1;\n        formatArgs = (int ********)tempBuffer;\n        tempVar = 0;\n        tempPtrVar = tempPtrVar + -4;\n      } while (0x10 < (int)(tempPtrVar + -4));\nLAB_0008300e:\n      tempPtrVar = tempPtrVar + -4;\n    }\n    argList = (int *******)((int)argList + (int)tempPtrVar);\n    *formatArgs = (int *******)\"0000000000000000\";\n    formatArgs[1] = tempPtrVar;\n    if (loopCounter < 8) {\n      loopCounter = loopCounter + 1;\n      formatArgs = formatArgs + 2;\n      goto LAB_0008302a;\n    }\n    if (argList != (int *******)0x0) {\n      argCounter = loopCounter;\n      loopCounter = FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar);\n      if (loopCounter != 0) goto LAB_00083142;\n      loopCounter = argCounter + 1;\n      formatArgs = (int ********)tempBuffer;\n      goto LAB_0008302a;\n    }\n    local_64[0] = baseArgsSize;\n    argCounter = 1;\n    formatArgs = (int ********)tempBuffer;\n    tempBuffer = (undefined  [4])tempPtrVar;\nLAB_000831be:\n    ptempPtrVar = formatArgs + 2;\n    argList = baseArgsSize;\n  }\n  if (((tempVar & 4) != 0) &&\n     (tempPtrVar = (int *******)((int)pppppppiVar20 - (int)totalArgsSize), 0 < (int)tempPtrVar)) {\n    loopCounter = argCounter;\n    if ((int)tempPtrVar < 0x11) {\n      tempVar = argCounter + 1;\n    }\n    else {\n      do {\n        while( true ) {\n          argCounter = loopCounter + 1;\n          argList = argList + 4;\n          *ptempPtrVar = (int *******)0x856f0;\n          ptempPtrVar[1] = (int *******)0x10;\n          if (7 < argCounter) break;\n          tempVar = loopCounter + 2;\n          ptempPtrVar = ptempPtrVar + 2;\nLAB_0008307a:\n          tempPtrVar = tempPtrVar + -4;\n          loopCounter = argCounter;\n          if ((int)tempPtrVar < 0x11) goto LAB_000830a2;\n        }\n        if (argList != (int *******)0x0) {\n          loopCounter = FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar);\n          if (loopCounter == 0) {\n            tempVar = argCounter + 1;\n            ptempPtrVar = (int ********)tempBuffer;\n            goto LAB_0008307a;\n          }\n          goto LAB_00083142;\n        }\n        tempPtrVar = tempPtrVar + -4;\n        tempVar = 1;\n        loopCounter = 0;\n        ptempPtrVar = (int ********)tempBuffer;\n      } while (0x10 < (int)tempPtrVar);\n    }\nLAB_000830a2:\n    argList = (int *******)((int)argList + (int)tempPtrVar);\n    *ptempPtrVar = (int *******)0x856f0;\n    ptempPtrVar[1] = tempPtrVar;\n    argCounter = tempVar;\n    if (7 < tempVar) {\n      if (argList == (int *******)0x0) {\n        if ((int)totalArgsSize < (int)pppppppiVar20) {\n          totalArgsSize = pppppppiVar20;\n        }\n        resultSize = resultSize + (int)totalArgsSize;\n        goto LAB_00083186;\n      }\n      loopCounter = FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar);\n      if (loopCounter != 0) goto LAB_00083142;\n    }\n  }\n  if ((int)totalArgsSize < (int)pppppppiVar20) {\n    totalArgsSize = pppppppiVar20;\n  }\n  resultSize = resultSize + (int)totalArgsSize;\n  if ((argList != (int *******)0x0) &&\n     (loopCounter = FUN_00082824(ptrStruct,ptrBuffer,&tempPtrVar), loopCounter != 0)) goto LAB_00083142;\nLAB_00083186:\n  argCounter = 0;\n  formatArgs = (int ********)tempBuffer;\n  goto LAB_00082902;\nswitchD_00082984_caseD_31:\n  tempVar = tempVar - 0x30;\n  pppppppiVar20 = (int *******)0x0;\n  tempPtrVar = formatString;\n  do {\n    formatString = (int *******)((int)tempPtrVar + 1);\n    tempVar = (uint)*(byte *)tempPtrVar;\n    pppppppiVar20 = (int *******)(tempVar + (int)pppppppiVar20 * 10);\n    tempVar = tempVar - 0x30;\n    tempPtrVar = formatString;\n  } while (tempVar < 10);\n  goto LAB_0008297a;\nswitchD_00082984_caseD_20:\n  tempVar = (uint)*(byte *)formatString;\n  if (signChar == '\\0') {\n    signChar = ' ';\n  }\n  goto LAB_00082976;\n}\n\n",
            "renaming": {
                "FUN_0008289c": "parse_format_string_0008289c",
                "param_1": "ptrStruct",
                "param_2": "ptrBuffer",
                "param_3": "formatString",
                "param_4": "ptrArgs",
                "bVar1": "formatSpec",
                "bVar2": "isNegative",
                "bVar3": "isSigned",
                "cVar4": "signCharacter",
                "bVar5": "isZeroPadded",
                "ppppppppiVar6": "formatArgs",
                "piVar7": "tempPtrVar",
                "iVar8": "loopCounter",
                "cVar9": "tempCharVar",
                "pppppppiVar10": "tempPtrVar",
                "uVar11": "tempVar",
                "ppiVar12": "tempPtrVar",
                "uVar13": "tempVar",
                "uVar14": "tempVar",
                "iVar15": "tempVar",
                "pppppppiVar16": "tempPtrVar",
                "iVar17": "tempVar",
                "pppppppiVar18": "tempPtrVar",
                "piVar19": "tempPtrVar",
                "piVar22": "tempPtrVar",
                "pppppppiVar23": "tempPtrVar",
                "uVar24": "tempVar",
                "ppppppppiVar25": "tempPtrVar",
                "bVar26": "isPointer",
                "lVar27": "tempLongVar",
                "local_dc": "totalArgsSize",
                "local_d4": "baseArgsSize",
                "local_c8": "ptrArgs",
                "local_c4": "resultSize",
                "local_c0": "tempStr",
                "local_a1": "signChar",
                "local_a0": "padChar",
                "local_9f": "isHex",
                "local_9c": "tempPtrVar",
                "local_98": "argCounter",
                "local_94": "argList",
                "local_90": "tempCharVar",
                "cStack_6a": "tempCharVar",
                "local_69": "tempVar",
                "local_68": "tempBuffer"
            },
            "calling": [
                "FUN_000834f0",
                "FUN_00081750",
                "FUN_000817c8"
            ],
            "called": [
                "FUN_000834f0",
                "FUN_00082824",
                "FUN_0008356c",
                "FUN_000840f8",
                "FUN_00084530",
                "FUN_00082688",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000834f0": {
            "entrypoint": "0x000834f0",
            "current_name": "extract_data_000834f0",
            "code": "\nint extractData_000834f0(undefined4 input,int data)\n\n{\n  int result;\n  int checkResult;\n  undefined *buffer [2];\n  undefined4 bufferSize;\n  ushort flag;\n  undefined2 value;\n  undefined *outputBuffer;\n  undefined4 outputSize;\n  undefined4 count;\n  undefined4 dataSize;\n  undefined4 additionalData;\n  undefined4 temporary;\n  undefined stackBuffer [1024];\n  \n  temporary = *(undefined4 *)(data + 100);\n  dataSize = *(undefined4 *)(data + 0x1c);\n  value = *(undefined2 *)(data + 0xe);\n  additionalData = *(undefined4 *)(data + 0x24);\n  buffer[0] = stackBuffer;\n  flag = *(ushort *)(data + 0xc) & 0xfffd;\n  bufferSize = 0x400;\n  outputSize = 0x400;\n  count = 0;\n  outputBuffer = buffer[0];\n  result = FUN_0008289c(input,buffer);\n  if ((-1 < result) && (checkResult = FUN_00083850(input,buffer), checkResult != 0)) {\n    result = -1;\n  }\n  if ((int)((uint)flag << 0x19) < 0) {\n    *(ushort *)(data + 0xc) = *(ushort *)(data + 0xc) | 0x40;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000834f0": "extract_data_000834f0",
                "param_1": "input",
                "param_2": "data",
                "iVar1": "result",
                "iVar2": "checkResult",
                "local_488": "buffer",
                "local_480": "bufferSize",
                "local_47c": "flag",
                "local_47a": "value",
                "local_478": "outputBuffer",
                "local_474": "outputSize",
                "local_470": "count",
                "local_46c": "dataSize",
                "local_464": "additionalData",
                "local_424": "temporary",
                "auStack_420": "stackBuffer"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_0008289c",
                "FUN_00083850"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008356c": {
            "entrypoint": "0x0008356c",
            "current_name": "check_and_update_data_0008356c",
            "code": "\nundefined4 check_and_update_data_0008356c(undefined4 *result,int *data)\n\n{\n  int value_1;\n  int value_2;\n  uint ushort_value;\n  ushort temp_ushort;\n  \n  if ((Elf32_Rel_ARRAY_20070000[140].r_offset != 0) &&\n     (*(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x38) == 0)) {\n    FUN_00083888();\n  }\n  temp_ushort = *(ushort *)(data + 3);\n  ushort_value = (uint)temp_ushort;\n  if ((int)(ushort_value << 0x1c) < 0) {\n    value_2 = data[4];\n  }\n  else {\n    if (-1 < (int)(ushort_value << 0x1b)) {\n      *result = 9;\n      *(ushort *)(data + 3) = temp_ushort | 0x40;\n      return 0xffffffff;\n    }\n    if ((int)(ushort_value << 0x1d) < 0) {\n      if ((int *)data[0xc] != (int *)0x0) {\n        if ((int *)data[0xc] != data + 0x10) {\n          FUN_00083b10(result);\n          temp_ushort = *(ushort *)(data + 3);\n        }\n        data[0xc] = 0;\n      }\n      value_2 = data[4];\n      temp_ushort = temp_ushort & 0xffdb;\n      *data = value_2;\n      data[1] = 0;\n    }\n    else {\n      value_2 = data[4];\n    }\n    *(ushort *)(data + 3) = temp_ushort | 8;\n    ushort_value = (uint)(temp_ushort | 8);\n  }\n  if ((value_2 == 0) && ((ushort_value & 0x280) != 0x200)) {\n    FUN_00084018(result,data);\n    ushort_value = (uint)*(ushort *)(data + 3);\n    value_2 = data[4];\n  }\n  if ((ushort_value & 1) == 0) {\n    value_1 = 0;\n    if (-1 < (int)(ushort_value << 0x1e)) {\n      value_1 = data[5];\n    }\n    data[2] = value_1;\n  }\n  else {\n    data[6] = -data[5];\n    data[2] = 0;\n  }\n  if ((value_2 == 0) && ((int)((uint)*(ushort *)(data + 3) << 0x18) < 0)) {\n    *(ushort *)(data + 3) = *(ushort *)(data + 3) | 0x40;\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0008356c": "check_and_update_data_0008356c",
                "param_1": "result",
                "param_2": "data",
                "iVar1": "value_1",
                "iVar2": "value_2",
                "uVar3": "ushort_value",
                "uVar4": "temp_ushort"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_000842a4",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00083b10",
                "FUN_00084018",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000836d8": {
            "entrypoint": "0x000836d8",
            "current_name": "FUNC_000836d8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00083698) */\n/* WARNING: Removing unreachable block (ram,0x00083630) */\n/* WARNING: Removing unreachable block (ram,0x000836c4) */\n/* WARNING: Removing unreachable block (ram,0x00083642) */\n/* WARNING: Removing unreachable block (ram,0x00083648) */\n/* WARNING: Removing unreachable block (ram,0x00083654) */\n/* WARNING: Removing unreachable block (ram,0x0008366e) */\n/* WARNING: Removing unreachable block (ram,0x0008364c) */\n/* WARNING: Removing unreachable block (ram,0x00083686) */\n/* WARNING: Removing unreachable block (ram,0x000836b8) */\n/* WARNING: Removing unreachable block (ram,0x00083688) */\n\nvoid FUNC_000836d8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000836d8": "FUNC_000836d8"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000836ec": {
            "entrypoint": "0x000836ec",
            "current_name": "initialize_function_000836ec",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00083698) */\n/* WARNING: Removing unreachable block (ram,0x000836b8) */\n\nvoid initializeFunction_000836ec(void)\n\n{\n  dword *pointer1;\n  dword result;\n  int index;\n  code *jumpTable;\n  \n  FUN_000841e4(6);\n  jumpTable = (code *)0x836fb;\n  result = FUN_00080eec(1);\n  if (Elf32_Rel_ARRAY_20070000[48].r_offset == 0) {\n    Elf32_Rel_ARRAY_20070000[48].r_offset = 0x20070184;\n  }\n  index = *(int *)(Elf32_Rel_ARRAY_20070000[48].r_offset + 4);\n  pointer1 = (dword *)Elf32_Rel_ARRAY_20070000[48].r_offset;\n  if (0x1f < index) {\n    pointer1 = (dword *)FUN_000817f0(400);\n    if (pointer1 == (dword *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x00083652. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*jumpTable)(0xffffffff);\n      return;\n    }\n    *pointer1 = Elf32_Rel_ARRAY_20070000[48].r_offset;\n    pointer1[1] = 0;\n    index = 0;\n    Elf32_Rel_ARRAY_20070000[48].r_offset = (dword)pointer1;\n    pointer1[0x62] = 0;\n    pointer1[99] = 0;\n  }\n  pointer1[1] = index + 1;\n  pointer1[index + 2] = result;\n                    /* WARNING: Could not recover jumptable at 0x00083696. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000836ec": "initialize_function_000836ec",
                "pdVar1": "pointer1",
                "dVar2": "result",
                "iVar3": "index",
                "UNRECOVERED_JUMPTABLE_00": "jumpTable"
            },
            "calling": [
                "FUN_000816f8"
            ],
            "called": [
                "FUN_000841e4",
                "FUN_00080eec",
                "FUN_000817f0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083850": {
            "entrypoint": "0x00083850",
            "current_name": "process_data_00083850",
            "code": "\nundefined4 processData_00083850(int *dataBuffer,int *infoBuffer)\n\n{\n  int *tempVar1;\n  int tempVar2;\n  ushort tempVar3;\n  uint tempVar4;\n  int tempVar5;\n  code *functionPtr;\n  undefined4 returnValue;\n  int tempVar7;\n  \n  if ((dataBuffer != (int *)0x0) && (dataBuffer[0xe] == 0)) {\n    FUN_00083888();\n  }\n  if (*(short *)(infoBuffer + 3) == 0) {\n    return 0;\n  }\n  tempVar3 = *(ushort *)(infoBuffer + 3);\n  if ((int)((uint)tempVar3 << 0x1c) < 0) {\n    tempVar7 = infoBuffer[4];\n    if (tempVar7 == 0) {\n      return 0;\n    }\n    tempVar2 = *infoBuffer;\n    if ((tempVar3 & 3) == 0) {\n      tempVar5 = infoBuffer[5];\n    }\n    else {\n      tempVar5 = 0;\n    }\n    *infoBuffer = tempVar7;\n    tempVar2 = tempVar2 - tempVar7;\n    infoBuffer[2] = tempVar5;\n    do {\n      if (tempVar2 < 1) {\n        return 0;\n      }\n      tempVar5 = (*(code *)infoBuffer[9])(dataBuffer,infoBuffer[7],tempVar7,tempVar2,returnValue);\n      tempVar2 = tempVar2 - tempVar5;\n      tempVar7 = tempVar7 + tempVar5;\n    } while (0 < tempVar5);\nLAB_000837c8:\n    *(ushort *)(infoBuffer + 3) = *(ushort *)(infoBuffer + 3) | 0x40;\n    return 0xffffffff;\n  }\n  *(ushort *)(infoBuffer + 3) = tempVar3 | 0x800;\n  if ((infoBuffer[1] < 1) && (infoBuffer[0xf] < 1)) {\n    return 0;\n  }\n  functionPtr = (code *)infoBuffer[10];\n  if (functionPtr == (code *)0x0) {\n    return 0;\n  }\n  tempVar4 = (uint)(tempVar3 | 0x800);\n  tempVar7 = *dataBuffer;\n  *dataBuffer = 0;\n  if ((tempVar3 & 0x1000) == 0) {\n    tempVar2 = (*functionPtr)(dataBuffer,infoBuffer[7],tempVar4 & 0x1000,1);\n    if ((tempVar2 == -1) && (tempVar5 = *dataBuffer, tempVar5 != 0)) {\n      if ((tempVar5 == 0x1d) || (tempVar5 == 0x16)) {\n        *dataBuffer = tempVar7;\n        return 0;\n      }\n      goto LAB_000837c8;\n    }\n    tempVar4 = (uint)*(ushort *)(infoBuffer + 3);\n    functionPtr = (code *)infoBuffer[10];\n  }\n  else {\n    tempVar2 = infoBuffer[0x14];\n  }\n  if (((int)(tempVar4 << 0x1d) < 0) && (tempVar2 = tempVar2 - infoBuffer[1], infoBuffer[0xc] != 0)) {\n    tempVar2 = tempVar2 - infoBuffer[0xf];\n  }\n  tempVar2 = (*functionPtr)(dataBuffer,infoBuffer[7],tempVar2,0);\n  if (tempVar2 == -1) {\n    tempVar5 = *dataBuffer;\n    if (tempVar5 != 0) {\n      if ((tempVar5 != 0x1d) && (tempVar5 != 0x16)) {\n        *(ushort *)(infoBuffer + 3) = *(ushort *)(infoBuffer + 3) | 0x40;\n        return 0xffffffff;\n      }\n      *(ushort *)(infoBuffer + 3) = *(ushort *)(infoBuffer + 3) & 0xf7ff;\n      *infoBuffer = infoBuffer[4];\n      infoBuffer[1] = 0;\n      goto LAB_00083774;\n    }\n    tempVar3 = *(ushort *)(infoBuffer + 3) & 0xf7ff;\n    infoBuffer[1] = 0;\n    *(ushort *)(infoBuffer + 3) = tempVar3;\n    *infoBuffer = infoBuffer[4];\n  }\n  else {\n    tempVar3 = *(ushort *)(infoBuffer + 3) & 0xf7ff;\n    *infoBuffer = infoBuffer[4];\n    *(ushort *)(infoBuffer + 3) = tempVar3;\n    infoBuffer[1] = 0;\n  }\n  if ((int)((uint)tempVar3 << 0x13) < 0) {\n    infoBuffer[0x14] = tempVar2;\n  }\nLAB_00083774:\n  tempVar1 = (int *)infoBuffer[0xc];\n  *dataBuffer = tempVar7;\n  if (tempVar1 == (int *)0x0) {\n    return 0;\n  }\n  if (tempVar1 != infoBuffer + 0x10) {\n    FUN_00083b10(dataBuffer);\n  }\n  infoBuffer[0xc] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083850": "process_data_00083850",
                "param_1": "dataBuffer",
                "param_2": "infoBuffer",
                "piVar1": "tempVar1",
                "iVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "iVar5": "tempVar5",
                "pcVar6": "functionPtr",
                "unaff_r4": "returnValue",
                "iVar7": "tempVar7"
            },
            "calling": [
                "FUN_000834f0",
                "FUN_00084484",
                "FUN_000842a4",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00083b10",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083888": {
            "entrypoint": "0x00083888",
            "current_name": "initialize_data_structures_00083888",
            "code": "\nvoid initializeDataStructures_00083888(int dataStructures)\n\n{\n  undefined4 *structure1;\n  undefined4 *structure2;\n  \n  if (*(int *)(dataStructures + 0x38) == 0) {\n    structure1 = *(undefined4 **)(dataStructures + 4);\n    *(undefined **)(dataStructures + 0x3c) = &LAB_0008387c_1;\n    *(undefined4 *)(dataStructures + 0x2e4) = 3;\n    *(int *)(dataStructures + 0x2e8) = dataStructures + 0x2ec;\n    *(undefined4 *)(dataStructures + 0x2e0) = 0;\n    *(undefined2 *)(structure1 + 3) = 4;\n    *structure1 = 0;\n    structure1[1] = 0;\n    structure1[2] = 0;\n    structure1[0x19] = 0;\n    *(undefined2 *)((int)structure1 + 0xe) = 0;\n    structure1[4] = 0;\n    structure1[5] = 0;\n    structure1[6] = 0;\n    FUN_00081f00(structure1 + 0x17,0,8);\n    structure2 = *(undefined4 **)(dataStructures + 8);\n    structure1[7] = structure1;\n    structure1[8] = 0x84221;\n    structure1[9] = 0x84245;\n    structure1[10] = 0x8427d;\n    structure1[0xb] = &LAB_0008429c_1;\n    *(undefined2 *)((int)structure2 + 0xe) = 1;\n    *(undefined2 *)(structure2 + 3) = 9;\n    *structure2 = 0;\n    structure2[1] = 0;\n    structure2[2] = 0;\n    structure2[0x19] = 0;\n    structure2[4] = 0;\n    structure2[5] = 0;\n    structure2[6] = 0;\n    FUN_00081f00(structure2 + 0x17,0,8);\n    structure1 = *(undefined4 **)(dataStructures + 0xc);\n    structure2[7] = structure2;\n    structure2[8] = 0x84221;\n    structure2[9] = 0x84245;\n    structure2[10] = 0x8427d;\n    structure2[0xb] = &LAB_0008429c_1;\n    *(undefined2 *)(structure1 + 3) = 0x12;\n    *(undefined2 *)((int)structure1 + 0xe) = 2;\n    *structure1 = 0;\n    structure1[1] = 0;\n    structure1[2] = 0;\n    structure1[0x19] = 0;\n    structure1[4] = 0;\n    structure1[5] = 0;\n    structure1[6] = 0;\n    FUN_00081f00(structure1 + 0x17,0,8);\n    structure1[7] = structure1;\n    structure1[8] = 0x84221;\n    structure1[9] = 0x84245;\n    structure1[10] = 0x8427d;\n    structure1[0xb] = &LAB_0008429c_1;\n    *(undefined4 *)(dataStructures + 0x38) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083888": "initialize_data_structures_00083888",
                "param_1": "dataStructures",
                "puVar1": "structure1",
                "puVar2": "structure2"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_00084484",
                "FUN_000842a4"
            ],
            "called": [
                "FUN_00081f00"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008397c": {
            "entrypoint": "0x0008397c",
            "current_name": "FUNC_0008397c",
            "code": "\nvoid FUNC_0008397c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008397c": "FUNC_0008397c"
            },
            "calling": [
                "FUN_00084484"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083980": {
            "entrypoint": "0x00083980",
            "current_name": "FUNC_00083980",
            "code": "\nvoid FUNC_00083980(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083980": "FUNC_00083980"
            },
            "calling": [
                "FUN_00084484"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000839b4": {
            "entrypoint": "0x000839b4",
            "current_name": "convert_and_print_000839b4",
            "code": "\nuint convertAndPrint_000839b4(undefined4 inputCount,uint bufferSize,byte **dataArray)\n\n{\n  int result;\n  uint isNewLineNeeded;\n  uint convertedByte;\n  byte *currentByte;\n  uint counter;\n  byte convertedValue;\n  byte conversionBuffer [3];\n  \n  if (-1 < (int)((uint)*(ushort *)(dataArray + 3) << 0x12)) {\n    *(ushort *)(dataArray + 3) = *(ushort *)(dataArray + 3) | 0x2000;\n    dataArray[0x19] = (byte *)((uint)dataArray[0x19] | 0x2000);\n  }\n  result = FUN_0008400c();\n  if ((result == 1) && (bufferSize - 1 < 0xff)) {\n    convertedByte = bufferSize & 0xff;\n    convertedValue = (byte)convertedByte;\n    isNewLineNeeded = 1;\n  }\n  else {\n    isNewLineNeeded = FUN_0008434c(inputCount,&convertedValue,bufferSize,dataArray + 0x17);\n    if (isNewLineNeeded == 0xffffffff) {\n      *(ushort *)(dataArray + 3) = *(ushort *)(dataArray + 3) | 0x40;\n      return 0xffffffff;\n    }\n    if (isNewLineNeeded == 0) {\n      return bufferSize;\n    }\n    convertedByte = (uint)convertedValue;\n  }\n  counter = 0;\n  do {\n    currentByte = dataArray[2] + -1;\n    dataArray[2] = currentByte;\n    if ((int)currentByte < 0) {\n      if ((int)dataArray[6] <= (int)currentByte) {\n        **dataArray = (byte)convertedByte;\n        currentByte = *dataArray;\n        convertedByte = (uint)*currentByte;\n        if (convertedByte != 10) goto LAB_00083a04;\n      }\n      result = FUN_000842a4(inputCount,convertedByte,dataArray);\n      if (result == -1) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      **dataArray = (byte)convertedByte;\n      currentByte = *dataArray;\nLAB_00083a04:\n      *dataArray = currentByte + 1;\n    }\n    if (isNewLineNeeded <= counter + 1) {\n      return bufferSize;\n    }\n    convertedByte = (uint)conversionBuffer[counter];\n    counter = counter + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000839b4": "convert_and_print_000839b4",
                "param_1": "inputCount",
                "param_2": "bufferSize",
                "param_3": "dataArray",
                "iVar1": "result",
                "uVar2": "isNewLineNeeded",
                "uVar3": "convertedByte",
                "pbVar4": "currentByte",
                "uVar5": "counter",
                "local_1c": "convertedValue",
                "abStack_1b": "conversionBuffer"
            },
            "calling": [
                "FUN_00082824"
            ],
            "called": [
                "FUN_0008434c",
                "FUN_0008400c",
                "FUN_000842a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083a74": {
            "entrypoint": "0x00083a74",
            "current_name": "optimize_function_00083a74",
            "code": "\nundefined4 optimize_function_00083a74(undefined4 input_value,int offset)\n\n{\n  int result;\n  uint rel_offset;\n  int new_offset;\n  \n  FUNC_00081f94();\n  rel_offset = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n  new_offset = ((rel_offset - offset) + 0xfef & 0xfffff000) - 0x1000;\n  if (0xfff < new_offset) {\n    result = FUN_0008236c(input_value,0);\n    if (result == Elf32_Rel_ARRAY_20070000[141].r_info + rel_offset) {\n      result = FUN_0008236c(input_value,-new_offset);\n      if (result != -1) {\n        DAT_2007121c = DAT_2007121c - new_offset;\n        *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = rel_offset - new_offset | 1;\n        FUNC_00081f98(input_value);\n        return 1;\n      }\n      new_offset = FUN_0008236c(input_value,0);\n      if (0xf < (int)(new_offset - Elf32_Rel_ARRAY_20070000[141].r_info)) {\n        DAT_2007121c = new_offset - Elf32_Rel_ARRAY_20070000[270].r_offset;\n        *(dword *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) =\n             new_offset - Elf32_Rel_ARRAY_20070000[141].r_info | 1;\n      }\n    }\n  }\n  FUNC_00081f98(input_value);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083a74": "optimize_function_00083a74",
                "param_1": "input_value",
                "param_2": "offset",
                "iVar1": "result",
                "uVar2": "rel_offset",
                "iVar3": "new_offset"
            },
            "calling": [
                "FUN_00083b10"
            ],
            "called": [
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_0008236c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083b10": {
            "entrypoint": "0x00083b10",
            "current_name": "process_relocation_00083b10",
            "code": "\nvoid processRelocation_00083b10(undefined4 param1,int param2)\n\n{\n  int prevOffset;\n  bool isFirstRelocation;\n  uint relativeOffset;\n  dword currentOffset;\n  int nextOffset;\n  uint nextOffsetAligned;\n  dword previousOffset;\n  uint size;\n  dword nextOffsetAfterRelocation;\n  \n  if (param2 == 0) {\n    return;\n  }\n  FUNC_00081f94();\n  relativeOffset = *(uint *)(param2 + -4);\n  previousOffset = param2 - 8;\n  nextOffsetAligned = relativeOffset & 0xfffffffe;\n  currentOffset = previousOffset + nextOffsetAligned;\n  size = *(uint *)(currentOffset + 4) & 0xfffffffc;\n  if (Elf32_Rel_ARRAY_20070000[141].r_info == currentOffset) {\n    size = size + nextOffsetAligned;\n    if (-1 < (int)(relativeOffset << 0x1f)) {\n      previousOffset = previousOffset - *(int *)(param2 + -8);\n      nextOffset = *(int *)(previousOffset + 0xc);\n      prevOffset = *(int *)(previousOffset + 8);\n      size = size + *(int *)(param2 + -8);\n      *(int *)(prevOffset + 0xc) = nextOffset;\n      *(int *)(nextOffset + 8) = prevOffset;\n    }\n    currentOffset = Elf32_Rel_ARRAY_20070000[269].r_info;\n    *(uint *)(previousOffset + 4) = size | 1;\n    Elf32_Rel_ARRAY_20070000[141].r_info = previousOffset;\n    if (currentOffset <= size) {\n      FUN_00083a74(param1,DAT_20071218);\n    }\n  }\n  else {\n    *(uint *)(currentOffset + 4) = size;\n    if ((relativeOffset & 1) == 0) {\n      previousOffset = previousOffset - *(int *)(param2 + -8);\n      prevOffset = *(int *)(previousOffset + 8);\n      nextOffsetAligned = nextOffsetAligned + *(int *)(param2 + -8);\n      if (prevOffset == 0x2007046c) {\n        isFirstRelocation = true;\n      }\n      else {\n        nextOffset = *(int *)(previousOffset + 0xc);\n        *(int *)(prevOffset + 0xc) = nextOffset;\n        *(int *)(nextOffset + 8) = prevOffset;\n        isFirstRelocation = false;\n      }\n    }\n    else {\n      isFirstRelocation = false;\n    }\n    if (-1 < *(int *)(currentOffset + size + 4) << 0x1f) {\n      nextOffsetAligned = nextOffsetAligned + size;\n      prevOffset = *(int *)(currentOffset + 8);\n      if ((!isFirstRelocation) && (prevOffset == 0x2007046c)) {\n        Elf32_Rel_ARRAY_20070000[142].r_info = previousOffset;\n        Elf32_Rel_ARRAY_20070000[143].r_offset = previousOffset;\n        *(undefined4 *)(previousOffset + 0xc) = 0x2007046c;\n        *(undefined4 *)(previousOffset + 8) = 0x2007046c;\n        *(uint *)(previousOffset + 4) = nextOffsetAligned | 1;\n        *(uint *)(previousOffset + nextOffsetAligned) = nextOffsetAligned;\n        goto LAB_00083ba4;\n      }\n      nextOffset = *(int *)(currentOffset + 0xc);\n      *(int *)(prevOffset + 0xc) = nextOffset;\n      *(int *)(nextOffset + 8) = prevOffset;\n    }\n    *(uint *)(previousOffset + 4) = nextOffsetAligned | 1;\n    *(uint *)(previousOffset + nextOffsetAligned) = nextOffsetAligned;\n    if (!isFirstRelocation) {\n      if (nextOffsetAligned < 0x200) {\n        relativeOffset = nextOffsetAligned & 0xfffffff8;\n        prevOffset = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + relativeOffset);\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << ((int)(nextOffsetAligned >> 3) >> 2 & 0xffU);\n        *(int *)(previousOffset + 8) = prevOffset;\n        *(uint *)(previousOffset + 0xc) = relativeOffset + 0x20070464;\n        *(dword *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + relativeOffset) = previousOffset;\n        *(dword *)(prevOffset + 0xc) = previousOffset;\n        FUNC_00081f98(param1);\n        return;\n      }\n      relativeOffset = nextOffsetAligned >> 9;\n      if (relativeOffset < 5) {\n        prevOffset = (nextOffsetAligned >> 6) + 0x38;\n        nextOffset = prevOffset * 2;\n      }\n      else if (relativeOffset < 0x15) {\n        prevOffset = relativeOffset + 0x5b;\n        nextOffset = prevOffset * 2;\n      }\n      else if (relativeOffset < 0x55) {\n        prevOffset = (nextOffsetAligned >> 0xc) + 0x6e;\n        nextOffset = prevOffset * 2;\n      }\n      else if (relativeOffset < 0x155) {\n        prevOffset = (nextOffsetAligned >> 0xf) + 0x77;\n        nextOffset = prevOffset * 2;\n      }\n      else if (relativeOffset < 0x555) {\n        prevOffset = (nextOffsetAligned >> 0x12) + 0x7c;\n        nextOffset = prevOffset * 2;\n      }\n      else {\n        nextOffset = 0xfc;\n        prevOffset = 0x7e;\n      }\n      nextOffsetAfterRelocation = nextOffset * 4 + 0x20070464;\n      currentOffset = (&Elf32_Rel_ARRAY_20070000[0x8d].r_info)[nextOffset];\n      if (currentOffset == nextOffsetAfterRelocation) {\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << (prevOffset >> 2 & 0xffU);\n        nextOffsetAfterRelocation = currentOffset;\n      }\n      else {\n        do {\n          if ((*(uint *)(currentOffset + 4) & 0xfffffffc) <= nextOffsetAligned) break;\n          currentOffset = *(dword *)(currentOffset + 8);\n        } while (nextOffsetAfterRelocation != currentOffset);\n        nextOffsetAfterRelocation = *(dword *)(currentOffset + 0xc);\n      }\n      *(dword *)(previousOffset + 0xc) = nextOffsetAfterRelocation;\n      *(dword *)(previousOffset + 8) = currentOffset;\n      *(dword *)(nextOffsetAfterRelocation + 8) = previousOffset;\n      *(dword *)(currentOffset + 0xc) = previousOffset;\n    }\n  }\nLAB_00083ba4:\n  FUNC_00081f98(param1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083b10": "process_relocation_00083b10",
                "param_1": "param1",
                "param_2": "param2",
                "iVar1": "prevOffset",
                "bVar2": "isFirstRelocation",
                "uVar3": "relativeOffset",
                "dVar4": "currentOffset",
                "iVar5": "nextOffset",
                "uVar6": "nextOffsetAligned",
                "dVar7": "previousOffset",
                "uVar8": "size",
                "dVar9": "nextOffsetAfterRelocation"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00081800",
                "FUN_00081810",
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_00084484",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_00083a74"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083ca8": {
            "entrypoint": "0x00083ca8",
            "current_name": "parse_packet_00083ca8",
            "code": "\nundefined4 parsePacket_00083ca8(undefined4 *outBuffer,uint *inBuffer,uint **packetInfo)\n\n{\n  int result;\n  uint dataFlag;\n  uint temp;\n  ushort packetFlags;\n  uint tempValue;\n  uint *ptr1;\n  uint *ptr2;\n  uint size;\n  uint tempSize;\n  uint temp2;\n  uint temp3;\n  uint tempFlag;\n  \n  if (packetInfo[2] != (uint *)0x0) {\n    packetFlags = *(ushort *)(inBuffer + 3);\n    tempValue = (uint)packetFlags;\n    if (((int)(tempValue << 0x1c) < 0) && (inBuffer[4] != 0)) {\n      ptr2 = *packetInfo;\n    }\n    else {\n      result = FUN_0008356c(outBuffer,inBuffer);\n      if (result != 0) {\n        return 0xffffffff;\n      }\n      packetFlags = *(ushort *)(inBuffer + 3);\n      tempValue = (uint)packetFlags;\n      ptr2 = *packetInfo;\n    }\n    if ((packetFlags & 2) == 0) {\n      dataFlag = tempValue & 2;\n      temp2 = dataFlag;\n      size = dataFlag;\n      tempFlag = dataFlag;\n      if ((tempValue & 1) == 0) {\n        dataFlag = 0;\n        temp2 = 0;\n        while( true ) {\n          while (dataFlag == 0) {\n            temp2 = *ptr2;\n            ptr1 = ptr2 + 1;\n            ptr2 = ptr2 + 2;\n            dataFlag = *ptr1;\n          }\n          size = inBuffer[2];\n          if ((int)(tempValue << 0x16) < 0) {\n            if (dataFlag < size) {\n              tempValue = *inBuffer;\n              size = dataFlag;\n            }\n            else if ((tempValue & 0x480) == 0) {\n              tempValue = *inBuffer;\n            }\n            else {\n              result = *inBuffer - inBuffer[4];\n              size = result + 1 + dataFlag;\n              tempSize = (int)(inBuffer[5] * 3) / 2;\n              if (size <= tempSize) {\n                size = tempSize;\n              }\n              if ((int)(tempValue << 0x15) < 0) {\n                tempSize = FUN_00081810(outBuffer,size);\n                if (tempSize == 0) {\n                  *outBuffer = 0xc;\n                  packetFlags = *(ushort *)(inBuffer + 3);\n                  goto LAB_00083da4;\n                }\n                FUN_00081d48(tempSize,inBuffer[4],result);\n                *(ushort *)(inBuffer + 3) = *(ushort *)(inBuffer + 3) & 0xfb7f | 0x80;\n              }\n              else {\n                tempSize = FUN_00081fac(outBuffer);\n                if (tempSize == 0) {\n                  FUN_00083b10(outBuffer,inBuffer[4]);\n                  packetFlags = *(ushort *)(inBuffer + 3) & 0xff7f;\n                  *outBuffer = 0xc;\n                  goto LAB_00083da4;\n                }\n              }\n              tempValue = tempSize + result;\n              inBuffer[4] = tempSize;\n              inBuffer[5] = size;\n              *inBuffer = tempValue;\n              inBuffer[2] = size - result;\n              size = dataFlag;\n            }\n            FUN_00081e34(tempValue,temp2,size);\n            inBuffer[2] = inBuffer[2] - size;\n            *inBuffer = *inBuffer + size;\n            size = dataFlag;\n          }\n          else if ((inBuffer[4] < *inBuffer) || (tempValue = inBuffer[5], dataFlag < tempValue)) {\n            if (dataFlag < size) {\n              size = dataFlag;\n            }\n            FUN_00081e34(*inBuffer,temp2,size);\n            tempValue = inBuffer[2];\n            inBuffer[2] = tempValue - size;\n            *inBuffer = *inBuffer + size;\n            if ((tempValue - size == 0) && (result = FUN_00083850(outBuffer,inBuffer), result != 0))\n            goto LAB_00083da2;\n          }\n          else {\n            size = 0x7fffffff;\n            if (dataFlag < 0x7fffffff) {\n              size = dataFlag;\n            }\n            size = (*(code *)inBuffer[9])(outBuffer,inBuffer[7],temp2,(size / tempValue) * tempValue);\n            if ((int)size < 1) goto LAB_00083da2;\n          }\n          ptr1 = packetInfo[2];\n          temp2 = temp2 + size;\n          dataFlag = dataFlag - size;\n          packetInfo[2] = (uint *)((int)ptr1 - size);\n          if ((uint *)((int)ptr1 - size) == (uint *)0x0) break;\n          tempValue = (uint)*(ushort *)(inBuffer + 3);\n        }\n      }\n      else {\n        do {\n          while (dataFlag == 0) {\n            size = *ptr2;\n            dataFlag = ptr2[1];\n            tempFlag = 0;\n            ptr2 = ptr2 + 2;\n          }\n          if (tempFlag == 0) {\n            result = FUN_000840f8(size,10,dataFlag);\n            if (result == 0) {\n              temp2 = dataFlag + 1;\n              tempFlag = 1;\n            }\n            else {\n              temp2 = (result + 1) - size;\n              tempFlag = 1;\n            }\n          }\n          tempSize = *inBuffer;\n          tempValue = temp2;\n          if (dataFlag <= temp2) {\n            tempValue = dataFlag;\n          }\n          temp = inBuffer[5];\n          if ((inBuffer[4] < tempSize) && (temp3 = inBuffer[2] + temp, (int)temp3 < (int)tempValue)) {\n            FUN_00081e34(tempSize,size,temp3);\n            *inBuffer = *inBuffer + temp3;\n            result = FUN_00083850(outBuffer,inBuffer);\n            if (result != 0) goto LAB_00083da2;\n          }\n          else if ((int)tempValue < (int)temp) {\n            FUN_00081e34(tempSize,size,tempValue);\n            inBuffer[2] = inBuffer[2] - tempValue;\n            *inBuffer = tempValue + *inBuffer;\n            temp3 = tempValue;\n          }\n          else {\n            temp3 = (*(code *)inBuffer[9])(outBuffer,inBuffer[7],size,temp);\n            if ((int)temp3 < 1) goto LAB_00083da2;\n          }\n          temp2 = temp2 - temp3;\n          if (temp2 == 0) {\n            result = FUN_00083850(outBuffer,inBuffer);\n            if (result != 0) goto LAB_00083da2;\n            tempFlag = 0;\n          }\n          ptr1 = packetInfo[2];\n          size = size + temp3;\n          dataFlag = dataFlag - temp3;\n          packetInfo[2] = (uint *)((int)ptr1 - temp3);\n        } while ((uint *)((int)ptr1 - temp3) != (uint *)0x0);\n      }\n    }\n    else {\n      dataFlag = 0;\n      tempValue = 0;\n      do {\n        while( true ) {\n          temp2 = tempValue;\n          if (0x7ffffbff < tempValue) {\n            temp2 = 0x7ffffc00;\n          }\n          if (tempValue != 0) break;\n          dataFlag = *ptr2;\n          tempValue = ptr2[1];\n          ptr2 = ptr2 + 2;\n        }\n        result = (*(code *)inBuffer[9])(outBuffer,inBuffer[7],dataFlag,temp2);\n        if (result < 1) {\nLAB_00083da2:\n          packetFlags = *(ushort *)(inBuffer + 3);\nLAB_00083da4:\n          *(ushort *)(inBuffer + 3) = packetFlags | 0x40;\n          return 0xffffffff;\n        }\n        ptr1 = packetInfo[2];\n        dataFlag = dataFlag + result;\n        tempValue = tempValue - result;\n        packetInfo[2] = (uint *)((int)ptr1 - result);\n      } while ((uint *)((int)ptr1 - result) != (uint *)0x0);\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083ca8": "parse_packet_00083ca8",
                "param_1": "outBuffer",
                "param_2": "inBuffer",
                "param_3": "packetInfo",
                "iVar1": "result",
                "uVar2": "dataFlag",
                "uVar3": "temp",
                "uVar4": "packetFlags",
                "uVar5": "tempValue",
                "puVar6": "ptr1",
                "puVar7": "ptr2",
                "uVar8": "size",
                "uVar9": "tempSize",
                "uVar10": "temp2",
                "uVar11": "temp3",
                "local_2c": "tempFlag"
            },
            "calling": [
                "FUN_00082824"
            ],
            "called": [
                "FUN_00081d48",
                "FUN_00081fac",
                "FUN_00083b10",
                "FUN_00081810",
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_000840f8",
                "FUN_00081e34"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084004": {
            "entrypoint": "0x00084004",
            "current_name": "get_memory_address_00084004",
            "code": "\nuintptr_t getMemoryAddress_00084004(void)\n\n{\n  return 0x20070878;\n}\n\n",
            "renaming": {
                "FUN_00084004": "get_memory_address_00084004",
                "undefined4": "uintptr_t"
            },
            "calling": [
                "FUN_0008434c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008400c": {
            "entrypoint": "0x0008400c",
            "current_name": "get_rel_array_offset_0008400c",
            "code": "\ndword get_Rel_Array_Offset_0008400c(void)\n\n{\n  return relArray[275].r_offset;\n}\n\n",
            "renaming": {
                "FUN_0008400c": "get_rel_array_offset_0008400c",
                "Elf32_Rel_ARRAY_20070000": "relArray"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084018": {
            "entrypoint": "0x00084018",
            "current_name": "process_data_00084018",
            "code": "\nvoid processData_00084018(int data,int *array)\n\n{\n  ushort var1;\n  int result;\n  int status;\n  uint var2;\n  bool flag;\n  undefined tempBuffer [4];\n  uint localVar;\n  \n  var1 = *(ushort *)(array + 3);\n  var2 = (uint)var1;\n  if ((int)(var2 << 0x1e) < 0) {\n    *array = (int)array + 0x43;\n    array[4] = (int)array + 0x43;\n    array[5] = 1;\n    return;\n  }\n  if (-1 < *(short *)((int)array + 0xe)) {\n    result = FUN_00084494(data,(int)*(short *)((int)array + 0xe),tempBuffer);\n    if (-1 < result) {\n      flag = (localVar & 0xf000) == 0x2000;\n      if (((localVar & 0xf000) == 0x8000) && (array[10] == 0x8427d)) {\n        result = 0x400;\n        *(ushort *)(array + 3) = *(ushort *)(array + 3) | 0x400;\n        array[0x13] = 0x400;\n      }\n      else {\n        result = 0x400;\n        *(ushort *)(array + 3) = *(ushort *)(array + 3) | 0x800;\n      }\n      goto LAB_00084074;\n    }\n    var1 = *(ushort *)(array + 3);\n    var2 = (uint)var1;\n  }\n  *(ushort *)(array + 3) = var1 | 0x800;\n  if ((var2 & 0x80) == 0) {\n    result = 0x400;\n  }\n  else {\n    result = 0x40;\n  }\n  flag = false;\nLAB_00084074:\n  status = FUN_00081810(data,result);\n  var1 = *(ushort *)(array + 3);\n  if (status == 0) {\n    if (-1 < (int)((uint)var1 << 0x16)) {\n      *(ushort *)(array + 3) = var1 | 2;\n      *array = (int)array + 0x43;\n      array[4] = (int)array + 0x43;\n      array[5] = 1;\n    }\n  }\n  else {\n    *(undefined **)(data + 0x3c) = &label;\n    *(ushort *)(array + 3) = var1 | 0x80;\n    *array = status;\n    array[4] = status;\n    array[5] = result;\n    if ((flag) && (result = FUN_000844bc(data,(int)*(short *)((int)array + 0xe)), result != 0))\n    {\n      *(ushort *)(array + 3) = *(ushort *)(array + 3) | 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084018": "process_data_00084018",
                "param_1": "data",
                "param_2": "array",
                "uVar1": "var1",
                "iVar2": "result",
                "iVar3": "status",
                "uVar4": "var2",
                "bVar5": "flag",
                "auStack_54": "tempBuffer",
                "local_50": "localVar",
                "LAB_0008387c_1": "label"
            },
            "calling": [
                "FUN_0008356c"
            ],
            "called": [
                "FUN_00081810",
                "FUN_00084494",
                "FUN_000844bc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000840f8": {
            "entrypoint": "0x000840f8",
            "current_name": "search_and_compare_000840f8",
            "code": "\nuint * searchAndCompare_000840f8(uint *data,char target,uint length)\n\n{\n  uint tmp1;\n  int index;\n  uint *ptr;\n  bool found;\n  \n  if (((uint)data & 3) == 0) {\nLAB_00084128:\n    if (3 < length) {\n      ptr = data;\n      do {\n        tmp1 = *ptr ^ CONCAT22(CONCAT11(target,target),CONCAT11(target,target));\n        data = ptr;\n        if ((tmp1 + 0xfefefeff & ~tmp1 & 0x80808080) != 0) break;\n        length = length - 4;\n        data = ptr + 1;\n        ptr = ptr + 1;\n      } while (3 < length);\n    }\n    if (length == 0) {\n      data = (uint *)0x0;\n    }\n    else if (*(char *)data != target) {\n      index = 0;\n      do {\n        data = (uint *)((int)data + 1);\n        found = index == length - 1;\n        index = index + 1;\n        if (found) goto LAB_00084150;\n      } while (*(char *)data != target);\n    }\n  }\n  else if (length == 0) {\nLAB_00084150:\n    data = (uint *)0x0;\n  }\n  else if (*(char *)data != target) {\n    ptr = (uint *)((int)data + 1);\n    length = length - 1;\n    do {\n      data = ptr;\n      if (((uint)data & 3) == 0) goto LAB_00084128;\n      if (length == 0) goto LAB_00084150;\n      ptr = (uint *)((int)data + 1);\n      length = length - 1;\n    } while (*(char *)data != target);\n  }\n  return data;\n}\n\n",
            "renaming": {
                "FUN_000840f8": "search_and_compare_000840f8",
                "param_1": "data",
                "param_2": "target",
                "param_3": "length",
                "uVar1": "tmp1",
                "iVar2": "index",
                "puVar3": "ptr",
                "bVar4": "found"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_00083ca8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000841e4": {
            "entrypoint": "0x000841e4",
            "current_name": "process_parameter_000841e4",
            "code": "\nint processParameter_000841e4(uint param)\n\n{\n  dword offset;\n  undefined4 result;\n  int value;\n  code *functionPtr;\n  undefined4 value1;\n  undefined4 value2;\n  undefined4 returnAddr;\n  undefined4 constantValue;\n  \n  offset = Elf32_Rel_ARRAY_20070000[140].r_offset;\n  constantValue = 0x20070460;\n  if (0x1f < param) {\n    *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x16;\n    return -1;\n  }\n  value = *(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x2dc);\n  if ((value == 0) || (functionPtr = *(code **)(value + param * 4), functionPtr == (code *)0x0)) {\n    result = thunk_FUN_00080efe(Elf32_Rel_ARRAY_20070000[140].r_offset);\n    DAT_20071244 = 0;\n    value = FUNC_00080efc(result,param,param,0,constantValue,value1,value2,returnAddr);\n    if ((value == -1) && (DAT_20071244 != 0)) {\n      *(int *)offset = DAT_20071244;\n      return -1;\n    }\n    return value;\n  }\n  if (functionPtr == (code *)0x1) {\n    return 0;\n  }\n  if (functionPtr != (code *)0xffffffff) {\n    *(undefined4 *)(value + param * 4) = 0;\n    (*functionPtr)(param);\n    return 0;\n  }\n  *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x16;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000841e4": "process_parameter_000841e4",
                "param_1": "param",
                "dVar1": "offset",
                "uVar2": "result",
                "iVar3": "value",
                "pcVar4": "functionPtr",
                "unaff_r4": "value1",
                "unaff_r5": "value2",
                "in_lr": "returnAddr",
                "uVar5": "constantValue"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_00080efc",
                "thunk_FUN_00080efe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_00080efe": {
            "entrypoint": "0x0008421c",
            "current_name": "get_error_code_thunk_00080efe",
            "code": "\nundefined4 get_error_code_thunk_00080efe(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "thunk_FUN_00080efe": "get_error_code_thunk_00080efe"
            },
            "calling": [
                "FUN_000841e4"
            ],
            "called": [
                "FUN_00080efe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084220": {
            "entrypoint": "0x00084220",
            "current_name": "update_value_and_mask_bits_00084220",
            "code": "\nvoid updateValueAndMaskBits_00084220(undefined4 valuePtr,int dataPtr)\n\n{\n  int result;\n  \n  result = FUN_00084508(valuePtr,(int)*(short *)(dataPtr + 0xe));\n  if (-1 < result) {\n    *(int *)(dataPtr + 0x50) = *(int *)(dataPtr + 0x50) + result;\n    return;\n  }\n  *(ushort *)(dataPtr + 0xc) = *(ushort *)(dataPtr + 0xc) & 0xefff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084220": "update_value_and_mask_bits_00084220",
                "param_1": "valuePtr",
                "param_2": "dataPtr",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "FUN_00084508"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084244": {
            "entrypoint": "0x00084244",
            "current_name": "process_data_00084244",
            "code": "\nvoid processData_00084244(int *outputBuffer,int inputBuffer,undefined4 paramA,undefined4 paramB)\n\n{\n  int returnValue;\n  ushort ushortValue;\n  undefined4 unusedParam1;\n  undefined4 unusedParam2;\n  undefined4 unusedParam3;\n  undefined4 unusedParam4;\n  \n  ushortValue = *(ushort *)(inputBuffer + 0xc);\n  if ((int)((uint)ushortValue << 0x17) < 0) {\n    FUN_000844e0(outputBuffer,(int)*(short *)(inputBuffer + 0xe),0,2);\n    ushortValue = *(ushort *)(inputBuffer + 0xc);\n  }\n  *(ushort *)(inputBuffer + 0xc) = ushortValue & 0xefff;\n  DAT_20071244 = 0;\n  returnValue = FUN_00080ec8((int)*(short *)(inputBuffer + 0xe),paramA,paramB,paramB,unusedParam1,unusedParam2,\n                       unusedParam3,unusedParam4);\n  if ((returnValue == -1) && (DAT_20071244 != 0)) {\n    *outputBuffer = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084244": "process_data_00084244",
                "param_1": "outputBuffer",
                "param_2": "inputBuffer",
                "param_3": "paramA",
                "param_4": "paramB",
                "iVar1": "returnValue",
                "uVar2": "ushortValue",
                "unaff_r4": "unusedParam1",
                "unaff_r5": "unusedParam2",
                "unaff_r6": "unusedParam3",
                "in_lr": "unusedParam4"
            },
            "calling": [],
            "called": [
                "FUN_00080ec8",
                "FUN_000844e0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008427c": {
            "entrypoint": "0x0008427c",
            "current_name": "update_status_0008427c",
            "code": "\nvoid updateStatus_0008427c(undefined4 param,int data)\n\n{\n  int result;\n  ushort status;\n  \n  result = FUN_000844e0(param,(int)*(short *)(data + 0xe));\n  if (result == -1) {\n    status = *(ushort *)(data + 0xc) & 0xefff;\n  }\n  else {\n    status = *(ushort *)(data + 0xc) | 0x1000;\n  }\n  if (result != -1) {\n    *(int *)(data + 0x50) = result;\n  }\n  *(ushort *)(data + 0xc) = status;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008427c": "update_status_0008427c",
                "param_1": "param",
                "param_2": "data",
                "iVar1": "result",
                "uVar2": "status"
            },
            "calling": [],
            "called": [
                "FUN_000844e0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000842a4": {
            "entrypoint": "0x000842a4",
            "current_name": "decode_and_process_data_000842a4",
            "code": "\nuint decode_and_process_data_000842a4(int input,uint flags,undefined4 *data,undefined4 size)\n\n{\n  ushort header;\n  uint header_as_uint;\n  undefined *buffer;\n  int offset;\n  \n  if ((input != 0) && (*(int *)(input + 0x38) == 0)) {\n    FUN_00083888();\n  }\n  header = *(ushort *)(data + 3);\n  header_as_uint = (uint)header;\n  data[2] = data[6];\n  if ((-1 < (int)(header_as_uint << 0x1c)) || (offset = data[4], offset == 0)) {\n    offset = FUN_0008356c(input,data,header,header_as_uint,size);\n    if (offset != 0) {\n      return 0xffffffff;\n    }\n    header = *(ushort *)(data + 3);\n    offset = data[4];\n    header_as_uint = (uint)header;\n  }\n  flags = flags & 0xff;\n  if ((int)(header_as_uint << 0x12) < 0) {\n    buffer = (undefined *)*data;\n    offset = (int)buffer - offset;\n    if (offset < (int)data[5]) {\nLAB_000842d6:\n      offset = offset + 1;\n      goto LAB_000842d8;\n    }\n  }\n  else {\n    data[0x19] = data[0x19] & 0xffffdfff;\n    buffer = (undefined *)*data;\n    *(ushort *)(data + 3) = header | 0x2000;\n    offset = (int)buffer - offset;\n    if (offset < (int)data[5]) goto LAB_000842d6;\n  }\n  offset = FUN_00083850(input,data);\n  if (offset != 0) {\n    return 0xffffffff;\n  }\n  buffer = (undefined *)*data;\n  offset = 1;\nLAB_000842d8:\n  data[2] = data[2] + -1;\n  *data = buffer + 1;\n  *buffer = (char)flags;\n  if (((data[5] == offset) ||\n      (((int)((uint)*(ushort *)(data + 3) << 0x1f) < 0 && (flags == 10)))) &&\n     (offset = FUN_00083850(input,data), offset != 0)) {\n    return 0xffffffff;\n  }\n  return flags;\n}\n\n",
            "renaming": {
                "FUN_000842a4": "decode_and_process_data_000842a4",
                "param_1": "input",
                "param_2": "flags",
                "param_3": "data",
                "param_4": "size",
                "uVar1": "header",
                "uVar2": "header_as_uint",
                "puVar3": "buffer",
                "iVar4": "offset"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008434c": {
            "entrypoint": "0x0008434c",
            "current_name": "execute_relocation_function_0008434c",
            "code": "\nvoid executeRelocationFunction_0008434c(undefined4 *result,int size,undefined4 arg1,undefined4 *status)\n\n{\n  dword relocationInfo;\n  undefined4 dynamicValue;\n  int returnValue;\n  undefined localBuffer [12];\n  \n  relocationInfo = Elf32_Rel_ARRAY_20070000[275].r_info;\n  if (size == 0) {\n    dynamicValue = FUN_00084004();\n    returnValue = (*(code *)relocationInfo)(result,localBuffer,0,dynamicValue,status);\n  }\n  else {\n    dynamicValue = FUN_00084004();\n    returnValue = (*(code *)relocationInfo)(result,size,arg1,dynamicValue,status);\n  }\n  if (returnValue == -1) {\n    *status = 0;\n    *result = 0x8a;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008434c": "execute_relocation_function_0008434c",
                "param_1": "result",
                "param_2": "size",
                "param_3": "arg1",
                "param_4": "status",
                "dVar1": "relocationInfo",
                "uVar2": "dynamicValue",
                "iVar3": "returnValue",
                "auStack_24": "localBuffer"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [
                "FUN_0008439c",
                "FUN_00084004"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008439c": {
            "entrypoint": "0x0008439c",
            "current_name": "write_byte_to_memory_0008439c",
            "code": "\nundefined4 write_byte_to_memory_0008439c(undefined4 *output_ptr,undefined *data_ptr,uint value)\n\n{\n  if (data_ptr == (undefined *)0x0) {\n    return 0;\n  }\n  if (value < 0x100) {\n    *data_ptr = (char)value;\n    return 1;\n  }\n  *output_ptr = 0x8a;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0008439c": "write_byte_to_memory_0008439c",
                "param_1": "output_ptr",
                "param_2": "data_ptr",
                "param_3": "value"
            },
            "calling": [
                "FUN_0008434c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084484": {
            "entrypoint": "0x00084484",
            "current_name": "perform_action_00084484",
            "code": "\nundefined4 performAction_00084484(int inputParam)\n\n{\n  dword offset;\n  undefined4 returnValue;\n  int result;\n  \n  offset = Elf32_Rel_ARRAY_20070000[140].r_offset;\n  if (inputParam != 0) {\n    if ((Elf32_Rel_ARRAY_20070000[140].r_offset != 0) &&\n       (*(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x38) == 0)) {\n      FUN_00083888();\n    }\n    if (*(short *)(inputParam + 0xc) != 0) {\n      returnValue = FUN_00083850(offset,inputParam);\n      if ((*(code **)(inputParam + 0x2c) != (code *)0x0) &&\n         (result = (**(code **)(inputParam + 0x2c))(offset,*(undefined4 *)(inputParam + 0x1c)), result < 0))\n      {\n        returnValue = 0xffffffff;\n      }\n      if ((int)((uint)*(ushort *)(inputParam + 0xc) << 0x18) < 0) {\n        FUN_00083b10(offset,*(undefined4 *)(inputParam + 0x10));\n      }\n      if (*(int *)(inputParam + 0x30) != 0) {\n        if (*(int *)(inputParam + 0x30) != inputParam + 0x40) {\n          FUN_00083b10(offset);\n        }\n        *(undefined4 *)(inputParam + 0x30) = 0;\n      }\n      if (*(int *)(inputParam + 0x44) != 0) {\n        FUN_00083b10(offset);\n        *(undefined4 *)(inputParam + 0x44) = 0;\n      }\n      FUNC_0008397c();\n      *(undefined2 *)(inputParam + 0xc) = 0;\n      FUNC_00083980();\n      return returnValue;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00084484": "perform_action_00084484",
                "param_1": "inputParam",
                "dVar1": "offset",
                "uVar2": "returnValue",
                "iVar3": "result"
            },
            "calling": [],
            "called": [
                "FUN_00083b10",
                "FUN_00083850",
                "FUN_00083980",
                "FUN_0008397c",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084494": {
            "entrypoint": "0x00084494",
            "current_name": "initialize_and_check_data_00084494",
            "code": "\nvoid initializeAndCheckData_00084494(int *result,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  int returnValue;\n  \n  DAT_20071244 = 0;\n  returnValue = FUN_00080eb0(arg1,arg2,arg2,0,arg3);\n  if ((returnValue == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084494": "initialize_and_check_data_00084494",
                "param_1": "result",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "iVar1": "returnValue"
            },
            "calling": [
                "FUN_00084018"
            ],
            "called": [
                "FUN_00080eb0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844bc": {
            "entrypoint": "0x000844bc",
            "current_name": "check_and_update_value_000844bc",
            "code": "\nvoid checkAndUpdateValue_000844bc(int *result,undefined4 inputValue)\n\n{\n  int status;\n  \n  DAT_20071244 = 0;\n  status = FUN_00080eba(inputValue);\n  if ((status == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844bc": "check_and_update_value_000844bc",
                "param_1": "result",
                "param_2": "inputValue",
                "iVar1": "status"
            },
            "calling": [
                "FUN_00084018"
            ],
            "called": [
                "FUN_00080eba"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844e0": {
            "entrypoint": "0x000844e0",
            "current_name": "check_and_assign_value_000844e0",
            "code": "\nvoid checkAndAssignValue_000844e0(int *result,undefined4 input1,undefined4 input2,undefined4 input3)\n\n{\n  int returnValue;\n  \n  DAT_20071244 = 0;\n  returnValue = FUN_00080ebe(input1,input2,input3);\n  if ((returnValue == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844e0": "check_and_assign_value_000844e0",
                "param_1": "result",
                "param_2": "input1",
                "param_3": "input2",
                "param_4": "input3",
                "iVar1": "returnValue"
            },
            "calling": [
                "FUN_0008427c",
                "FUN_00084244"
            ],
            "called": [
                "FUN_00080ebe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084508": {
            "entrypoint": "0x00084508",
            "current_name": "validate_and_assign_value_00084508",
            "code": "\nvoid validate_and_assign_value_00084508(int *result_ptr,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int result;\n  \n  DAT_20071244 = 0;\n  result = FUN_00080ec2(param_2,param_3,param_4);\n  if ((result == -1) && (DAT_20071244 != 0)) {\n    *result_ptr = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084508": "validate_and_assign_value_00084508",
                "param_1": "result_ptr",
                "iVar1": "result"
            },
            "calling": [
                "FUN_00084220"
            ],
            "called": [
                "FUN_00080ec2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084530": {
            "entrypoint": "0x00084530",
            "current_name": "check_conditions_and_return_value_00084530",
            "code": "\nint checkConditionsAndReturnValue_00084530(int value1,int value2,int value3,int value4)\n\n{\n  int result;\n  \n  if ((value4 == 0) && (value3 == 0)) {\n    if (value2 != 0 || value1 != 0) {\n      value1 = -1;\n    }\n    return value1;\n  }\n  result = FUN_0008458c();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00084530": "check_conditions_and_return_value_00084530",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "iVar1": "result"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_0008458c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008455c": {
            "entrypoint": "0x0008455c",
            "current_name": "subtract_integers_0008455c",
            "code": "\nvoid subtract_integers_0008455c(uint input_value1,int input_value2,undefined4 input_value3,undefined4 input_value4,int *output_values)\n\n{\n  uint result1;\n  longlong result2;\n  \n  result2 = FUN_000845c0();\n  result2 = result2 * CONCAT44(input_value4,input_value3);\n  result1 = (uint)result2;\n  *output_values = input_value1 - result1;\n  output_values[1] = (input_value2 - (int)((ulonglong)result2 >> 0x20)) - (uint)(input_value1 < result1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008455c": "subtract_integers_0008455c",
                "param_1": "input_value1",
                "param_2": "input_value2",
                "param_3": "input_value3",
                "param_4": "input_value4",
                "param_5": "output_values",
                "uVar1": "result1",
                "lVar2": "result2"
            },
            "calling": [],
            "called": [
                "FUN_000845c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008458c": {
            "entrypoint": "0x0008458c",
            "current_name": "subtract_param_from_input_0008458c",
            "code": "\nvoid subtract_param_from_input_0008458c(uint input_value,int param_integer,undefined4 param_3_value,undefined4 param_4_value,int *output_array)\n\n{\n  uint result_uint;\n  longlong result_longlong;\n  \n  result_longlong = FUN_00084860();\n  result_longlong = result_longlong * CONCAT44(param_4_value,param_3_value);\n  result_uint = (uint)result_longlong;\n  *output_array = input_value - result_uint;\n  output_array[1] = (param_integer - (int)((ulonglong)result_longlong >> 0x20)) - (uint)(input_value < result_uint);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008458c": "subtract_param_from_input_0008458c",
                "param_1": "input_value",
                "param_2": "param_integer",
                "param_3": "param_3_value",
                "param_4": "param_4_value",
                "param_5": "output_array",
                "uVar1": "result_uint",
                "lVar2": "result_longlong"
            },
            "calling": [
                "FUN_00084530"
            ],
            "called": [
                "FUN_00084860"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000845c0": {
            "entrypoint": "0x000845c0",
            "current_name": "divide_with_remainder_000845c0",
            "code": "\nundefined8 divideWithRemainder_000845c0(uint dividend,uint dividendHigh,uint divisor,uint divisorHigh)\n\n{\n  longlong result;\n  uint quotientLow;\n  uint quotientHigh;\n  uint remainder;\n  uint temp;\n  int shiftCount;\n  uint temp1;\n  uint temp2;\n  uint isDividendNegative;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  bool carryFlag;\n  \n  if ((int)dividendHigh < 0) {\n    carryFlag = dividend != 0;\n    dividend = -dividend;\n    dividendHigh = -dividendHigh - (uint)carryFlag;\n    isDividendNegative = 0xffffffff;\n  }\n  else {\n    isDividendNegative = 0;\n  }\n  if ((int)divisorHigh < 0) {\n    isDividendNegative = ~isDividendNegative;\n    carryFlag = divisor != 0;\n    divisor = -divisor;\n    divisorHigh = -divisorHigh - (uint)carryFlag;\n  }\n  if (divisorHigh == 0) {\n    if (dividendHigh < divisor) {\n      shiftCount = LZCOUNT(divisor);\n      if (shiftCount != 0) {\n        quotientHigh = dividend >> (0x20U - shiftCount & 0xff);\n        divisor = divisor << shiftCount;\n        dividend = dividend << shiftCount;\n        dividendHigh = dividendHigh << shiftCount | quotientHigh;\n      }\n      quotientLow = divisor >> 0x10;\n      remainder = dividendHigh / quotientLow;\n      temp1 = (divisor & 0xffff) * remainder;\n      temp3 = dividend >> 0x10 | (dividendHigh - quotientLow * remainder) * 0x10000;\n      quotientHigh = remainder;\n      if (temp3 <= temp1 && temp1 - temp3 != 0) {\n        carryFlag = CARRY4(temp3,divisor);\n        temp3 = temp3 + divisor;\n        quotientHigh = remainder - 1;\n        if ((carryFlag == false) && (temp3 <= temp1 && temp1 - temp3 != 0)) {\n          quotientHigh = remainder - 2;\n          temp3 = temp3 + divisor;\n        }\n      }\n      temp2 = (temp3 - temp1) / quotientLow;\n      remainder = (divisor & 0xffff) * temp2;\n      temp1 = dividend & 0xffff | ((temp3 - temp1) - quotientLow * temp2) * 0x10000;\n      quotientLow = temp2;\n      if (temp1 <= remainder && remainder - temp1 != 0) {\n        quotientLow = temp2 - 1;\n        if ((CARRY4(temp1,divisor) == false) &&\n           (temp1 + divisor <= remainder && remainder - (temp1 + divisor) != 0)) {\n          quotientLow = temp2 - 2;\n        }\n      }\n      quotientLow = quotientLow | quotientHigh << 0x10;\n      quotientHigh = 0;\n    }\n    else {\n      if (divisor == 0) {\n        divisor = 1 / 0;\n      }\n      shiftCount = LZCOUNT(divisor);\n      if (shiftCount == 0) {\n        dividendHigh = dividendHigh - divisor;\n        remainder = divisor >> 0x10;\n        temp5 = divisor & 0xffff;\n        quotientHigh = 1;\n      }\n      else {\n        divisor = divisor << shiftCount;\n        quotientHigh = dividendHigh >> (0x20U - shiftCount & 0xff);\n        remainder = divisor >> 0x10;\n        temp3 = quotientHigh / remainder;\n        temp5 = divisor & 0xffff;\n        temp1 = temp5 * temp3;\n        temp2 = dividend >> (0x20U - shiftCount & 0xff) | dividendHigh << shiftCount;\n        quotientHigh = temp2 >> 0x10 | (quotientHigh - remainder * temp3) * 0x10000;\n        dividend = dividend << shiftCount;\n        quotientLow = temp3;\n        if (quotientHigh <= temp1 && temp1 - quotientHigh != 0) {\n          carryFlag = CARRY4(quotientHigh,divisor);\n          quotientHigh = quotientHigh + divisor;\n          quotientLow = temp3 - 1;\n          if ((carryFlag == false) && (quotientHigh <= temp1 && temp1 - quotientHigh != 0)) {\n            quotientLow = temp3 - 2;\n            quotientHigh = quotientHigh + divisor;\n          }\n        }\n        temp = (quotientHigh - temp1) / remainder;\n        temp3 = temp5 * temp;\n        dividendHigh = temp2 & 0xffff | ((quotientHigh - temp1) - remainder * temp) * 0x10000;\n        quotientHigh = temp;\n        if (dividendHigh <= temp3 && temp3 - dividendHigh != 0) {\n          carryFlag = CARRY4(dividendHigh,divisor);\n          dividendHigh = dividendHigh + divisor;\n          quotientHigh = temp - 1;\n          if ((carryFlag == false) && (dividendHigh <= temp3 && temp3 - dividendHigh != 0)) {\n            quotientHigh = temp - 2;\n            dividendHigh = dividendHigh + divisor;\n          }\n        }\n        dividendHigh = dividendHigh - temp3;\n        quotientHigh = quotientHigh | quotientLow << 0x10;\n      }\n      quotientLow = dividendHigh / remainder;\n      temp3 = temp5 * quotientLow;\n      temp2 = dividend >> 0x10 | (dividendHigh - remainder * quotientLow) * 0x10000;\n      temp1 = quotientLow;\n      if (temp2 <= temp3 && temp3 - temp2 != 0) {\n        carryFlag = CARRY4(temp2,divisor);\n        temp2 = temp2 + divisor;\n        temp1 = quotientLow - 1;\n        if ((carryFlag == false) && (temp2 <= temp3 && temp3 - temp2 != 0)) {\n          temp1 = quotientLow - 2;\n          temp2 = temp2 + divisor;\n        }\n      }\n      temp = (temp2 - temp3) / remainder;\n      temp5 = temp5 * temp;\n      remainder = dividend & 0xffff | ((temp2 - temp3) - remainder * temp) * 0x10000;\n      quotientLow = temp;\n      if (remainder <= temp5 && temp5 - remainder != 0) {\n        quotientLow = temp - 1;\n        if ((CARRY4(remainder,divisor) == false) &&\n           (remainder + divisor <= temp5 && temp5 - (remainder + divisor) != 0)) {\n          quotientLow = temp - 2;\n        }\n      }\n      quotientLow = quotientLow | temp1 << 0x10;\n    }\n  }\n  else if (dividendHigh < divisorHigh) {\n    quotientHigh = 0;\n    quotientLow = 0;\n  }\n  else {\n    shiftCount = LZCOUNT(divisorHigh);\n    if (shiftCount == 0) {\n      if ((divisorHigh < dividendHigh) || (divisor <= dividend)) {\n        quotientHigh = 0;\n        quotientLow = 1;\n      }\n      else {\n        quotientLow = 0;\n        quotientHigh = 0;\n      }\n    }\n    else {\n      quotientHigh = 0x20 - shiftCount;\n      remainder = dividendHigh >> (quotientHigh & 0xff);\n      temp5 = divisor >> (quotientHigh & 0xff) | divisorHigh << shiftCount;\n      temp3 = temp5 >> 0x10;\n      quotientLow = remainder / temp3;\n      temp2 = (temp5 & 0xffff) * quotientLow;\n      temp1 = dividendHigh << shiftCount | dividend >> (quotientHigh & 0xff);\n      remainder = temp1 >> 0x10 | (remainder - temp3 * quotientLow) * 0x10000;\n      quotientHigh = quotientLow;\n      if (remainder <= temp2 && temp2 - remainder != 0) {\n        carryFlag = CARRY4(remainder,temp5);\n        remainder = remainder + temp5;\n        quotientHigh = quotientLow - 1;\n        if ((carryFlag == false) && (remainder <= temp2 && temp2 - remainder != 0)) {\n          quotientHigh = quotientLow - 2;\n          remainder = remainder + temp5;\n        }\n      }\n      temp = (remainder - temp2) / temp3;\n      temp4 = (temp5 & 0xffff) * temp;\n      remainder = temp1 & 0xffff | ((remainder - temp2) - temp3 * temp) * 0x10000;\n      quotientLow = temp;\n      if (remainder <= temp4 && temp4 - remainder != 0) {\n        carryFlag = CARRY4(remainder,temp5);\n        remainder = remainder + temp5;\n        quotientLow = temp - 1;\n        if ((carryFlag == false) && (remainder <= temp4 && temp4 - remainder != 0)) {\n          quotientLow = temp - 2;\n          remainder = remainder + temp5;\n        }\n      }\n      quotientLow = quotientLow | quotientHigh << 0x10;\n      result = (ulonglong)quotientLow * (ulonglong)(divisor << shiftCount);\n      temp1 = (uint)((ulonglong)result >> 0x20);\n      quotientHigh = 0;\n      if ((remainder - temp4 < temp1) ||\n         ((remainder - temp4 == temp1 && (dividend << shiftCount < (uint)result)))) {\n        quotientLow = quotientLow - 1;\n        quotientHigh = 0;\n      }\n    }\n  }\n  if (isDividendNegative != 0) {\n    carryFlag = quotientLow != 0;\n    quotientLow = -quotientLow;\n    quotientHigh = -quotientHigh - (uint)carryFlag;\n  }\n  return CONCAT44(quotientHigh,quotientLow);\n}\n\n",
            "renaming": {
                "FUN_000845c0": "divide_with_remainder_000845c0",
                "param_1": "dividend",
                "param_2": "dividendHigh",
                "param_3": "divisor",
                "param_4": "divisorHigh",
                "lVar1": "result",
                "uVar2": "quotientLow",
                "uVar3": "quotientHigh",
                "uVar4": "remainder",
                "uVar5": "temp",
                "iVar6": "shiftCount",
                "uVar7": "temp1",
                "uVar8": "temp2",
                "uVar9": "isDividendNegative",
                "uVar10": "temp3",
                "uVar11": "temp4",
                "uVar12": "temp5",
                "bVar13": "carryFlag"
            },
            "calling": [
                "FUN_0008455c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084860": {
            "entrypoint": "0x00084860",
            "current_name": "calculate_quotient_remainder_00084860",
            "code": "\nulonglong calculateQuotientRemainder_00084860(uint dividend,uint divisor,uint quotient,uint remainder)\n\n{\n  longlong product;\n  uint q1;\n  uint uVar3;\n  uint q2;\n  uint uVar5;\n  uint q3;\n  uint uVar7;\n  uint quotient1;\n  uint quotient2;\n  int shiftAmount;\n  bool carryFlag;\n  \n  if (remainder == 0) {\n    if (quotient <= divisor) {\n      if (quotient == 0) {\n        quotient = 1 / 0;\n      }\n      shiftAmount = LZCOUNT(quotient);\n      if (shiftAmount == 0) {\n        divisor = divisor - quotient;\n        uVar3 = quotient >> 0x10;\n        uVar5 = quotient & 0xffff;\n        q1 = 1;\n      }\n      else {\n        quotient = quotient << shiftAmount;\n        quotient1 = divisor >> (0x20U - shiftAmount & 0xff);\n        uVar3 = quotient >> 0x10;\n        quotient2 = quotient1 / uVar3;\n        uVar5 = quotient & 0xffff;\n        q1 = uVar5 * quotient2;\n        q3 = dividend >> (0x20U - shiftAmount & 0xff) | divisor << shiftAmount;\n        q2 = q3 >> 0x10 | (quotient1 - uVar3 * quotient2) * 0x10000;\n        dividend = dividend << shiftAmount;\n        quotient1 = quotient2;\n        if (q2 <= q1 && q1 - q2 != 0) {\n          carryFlag = CARRY4(q2,quotient);\n          q2 = q2 + quotient;\n          quotient1 = quotient2 - 1;\n          if ((carryFlag == false) && (q2 <= q1 && q1 - q2 != 0)) {\n            quotient1 = quotient2 - 2;\n            q2 = q2 + quotient;\n          }\n        }\n        uVar7 = (q2 - q1) / uVar3;\n        quotient2 = uVar5 * uVar7;\n        divisor = q3 & 0xffff | ((q2 - q1) - uVar3 * uVar7) * 0x10000;\n        q1 = uVar7;\n        if (divisor <= quotient2 && quotient2 - divisor != 0) {\n          carryFlag = CARRY4(divisor,quotient);\n          divisor = divisor + quotient;\n          q1 = uVar7 - 1;\n          if ((carryFlag == false) && (divisor <= quotient2 && quotient2 - divisor != 0)) {\n            q1 = uVar7 - 2;\n            divisor = divisor + quotient;\n          }\n        }\n        divisor = divisor - quotient2;\n        q1 = q1 | quotient1 << 0x10;\n      }\n      quotient2 = divisor / uVar3;\n      q2 = uVar5 * quotient2;\n      q3 = dividend >> 0x10 | (divisor - uVar3 * quotient2) * 0x10000;\n      quotient1 = quotient2;\n      if (q3 <= q2 && q2 - q3 != 0) {\n        carryFlag = CARRY4(q3,quotient);\n        q3 = q3 + quotient;\n        quotient1 = quotient2 - 1;\n        if ((carryFlag == false) && (q3 <= q2 && q2 - q3 != 0)) {\n          quotient1 = quotient2 - 2;\n          q3 = q3 + quotient;\n        }\n      }\n      quotient2 = (q3 - q2) / uVar3;\n      uVar5 = uVar5 * quotient2;\n      q3 = dividend & 0xffff | ((q3 - q2) - uVar3 * quotient2) * 0x10000;\n      uVar3 = quotient2;\n      if (q3 <= uVar5 && uVar5 - q3 != 0) {\n        uVar3 = quotient2 - 1;\n        if ((CARRY4(q3,quotient) == false) &&\n           (q3 + quotient <= uVar5 && uVar5 - (q3 + quotient) != 0)) {\n          uVar3 = quotient2 - 2;\n        }\n      }\n      return CONCAT44(q1,uVar3 | quotient1 << 0x10);\n    }\n    shiftAmount = LZCOUNT(quotient);\n    if (shiftAmount != 0) {\n      quotient1 = dividend >> (0x20U - shiftAmount & 0xff);\n      quotient = quotient << shiftAmount;\n      dividend = dividend << shiftAmount;\n      divisor = quotient1 | divisor << shiftAmount;\n    }\n    q1 = quotient >> 0x10;\n    uVar3 = divisor / q1;\n    uVar5 = (quotient & 0xffff) * uVar3;\n    quotient2 = dividend >> 0x10 | (divisor - q1 * uVar3) * 0x10000;\n    quotient1 = uVar3;\n    if (quotient2 <= uVar5 && uVar5 - quotient2 != 0) {\n      carryFlag = CARRY4(quotient2,quotient);\n      quotient2 = quotient2 + quotient;\n      quotient1 = uVar3 - 1;\n      if ((carryFlag == false) && (quotient2 <= uVar5 && uVar5 - quotient2 != 0)) {\n        quotient1 = uVar3 - 2;\n        quotient2 = quotient2 + quotient;\n      }\n    }\n    q3 = (quotient2 - uVar5) / q1;\n    uVar3 = (quotient & 0xffff) * q3;\n    uVar5 = dividend & 0xffff | ((quotient2 - uVar5) - q1 * q3) * 0x10000;\n    q1 = q3;\n    if (uVar5 <= uVar3 && uVar3 - uVar5 != 0) {\n      q1 = q3 - 1;\n      if ((CARRY4(uVar5,quotient) == false) &&\n         (uVar5 + quotient <= uVar3 && uVar3 - (uVar5 + quotient) != 0)) {\n        q1 = q3 - 2;\n      }\n    }\n    q1 = q1 | quotient1 << 0x10;\n  }\n  else {\n    if (divisor < remainder) {\n      return 0;\n    }\n    shiftAmount = LZCOUNT(remainder);\n    if (shiftAmount == 0) {\n      if ((remainder < divisor) || (quotient <= dividend)) {\n        return 1;\n      }\n      q1 = 0;\n    }\n    else {\n      q1 = 0x20 - shiftAmount;\n      quotient1 = divisor >> (q1 & 0xff);\n      uVar3 = remainder << shiftAmount | quotient >> (q1 & 0xff);\n      uVar5 = uVar3 >> 0x10;\n      q2 = quotient1 / uVar5;\n      quotient2 = (uVar3 & 0xffff) * q2;\n      q3 = dividend >> (q1 & 0xff) | divisor << shiftAmount;\n      q1 = q3 >> 0x10 | (quotient1 - uVar5 * q2) * 0x10000;\n      quotient1 = q2;\n      if (q1 <= quotient2 && quotient2 - q1 != 0) {\n        carryFlag = CARRY4(q1,uVar3);\n        q1 = q1 + uVar3;\n        quotient1 = q2 - 1;\n        if ((carryFlag == false) && (q1 <= quotient2 && quotient2 - q1 != 0)) {\n          quotient1 = q2 - 2;\n          q1 = q1 + uVar3;\n        }\n      }\n      q2 = (q1 - quotient2) / uVar5;\n      uVar7 = (uVar3 & 0xffff) * q2;\n      uVar5 = q3 & 0xffff | ((q1 - quotient2) - uVar5 * q2) * 0x10000;\n      q1 = q2;\n      if (uVar5 <= uVar7 && uVar7 - uVar5 != 0) {\n        carryFlag = CARRY4(uVar5,uVar3);\n        uVar5 = uVar5 + uVar3;\n        q1 = q2 - 1;\n        if ((carryFlag == false) && (uVar5 <= uVar7 && uVar7 - uVar5 != 0)) {\n          q1 = q2 - 2;\n          uVar5 = uVar5 + uVar3;\n        }\n      }\n      q1 = q1 | quotient1 << 0x10;\n      product = (ulonglong)q1 * (ulonglong)(quotient << shiftAmount);\n      quotient1 = (uint)((ulonglong)product >> 0x20);\n      if ((uVar5 - uVar7 < quotient1) || ((uVar5 - uVar7 == quotient1 && (dividend << shiftAmount < (uint)product)))\n         ) {\n        q1 = q1 - 1;\n      }\n    }\n  }\n  return (ulonglong)q1;\n}\n\n",
            "renaming": {
                "FUN_00084860": "calculate_quotient_remainder_00084860",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "lVar1": "product",
                "uVar2": "q1",
                "uVar4": "q2",
                "uVar6": "q3",
                "uVar8": "quotient1",
                "uVar9": "quotient2",
                "iVar10": "shiftAmount",
                "bVar11": "carryFlag"
            },
            "calling": [
                "FUN_0008458c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00085844": {
            "entrypoint": "0x00085844",
            "current_name": "FUNC_00085844",
            "code": "\nvoid FUNC_00085844(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085844": "FUNC_00085844"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 120714,
    "layers": [
        [
            "FUN_000800f4",
            "FUN_00080164",
            "FUN_000801e0",
            "FUN_00080250",
            "FUN_000803fc",
            "FUN_0008044c",
            "FUN_000805a8",
            "FUN_000806a0",
            "FUN_000806f8",
            "FUN_00080774",
            "FUN_0008089c",
            "FUN_00080970",
            "FUN_000809be",
            "FUN_000809e4",
            "FUN_00080a0a",
            "FUN_00080a30",
            "FUN_00080a94",
            "FUN_00080aa8",
            "FUN_00080b2c",
            "FUN_00080b90",
            "FUN_00080b98",
            "FUN_00080c98",
            "FUN_00080d30",
            "FUN_00080d3e",
            "FUN_00080d58",
            "FUN_00080d62",
            "FUN_00080d6a",
            "FUN_00080e80",
            "FUN_00080e88",
            "FUN_00080eaa",
            "FUN_00080eb0",
            "FUN_00080eba",
            "FUN_00080ebe",
            "FUN_00080ec2",
            "FUN_00080ec8",
            "FUN_00080eec",
            "FUN_00080efe",
            "thunk_FUN_000816d8",
            "FUN_00080f0c",
            "FUN_00081014",
            "FUN_000810a6",
            "FUN_000810c4",
            "FUN_000810cc",
            "FUN_000810d8",
            "FUN_000810e8",
            "FUN_000810fc",
            "FUN_0008113a",
            "thunk_FUN_0008113a",
            "FUN_0008117a",
            "FUN_00081190",
            "FUN_000811b0",
            "FUN_000811ca",
            "FUN_000811e8",
            "FUN_00081214",
            "FUN_00081248",
            "FUN_00081276",
            "FUN_000812b8",
            "FUN_00081348",
            "FUN_000813dc",
            "FUN_00081438",
            "FUN_0008145c",
            "FUN_00081472",
            "FUN_00081480",
            "FUN_00081496",
            "FUN_000814ae",
            "FUN_000814d0",
            "FUN_000814f6",
            "FUN_0008151c",
            "FUN_00081560",
            "FUN_00081570",
            "FUN_0008159e",
            "FUN_000815b8",
            "FUN_000815de",
            "FUN_000815ec",
            "FUN_00081618",
            "FUN_00081624",
            "FUN_00081684",
            "FUN_000816d8",
            "FUN_000816ec",
            "FUN_000816f8",
            "FUN_00081750",
            "FUN_00081778",
            "FUN_000817c8",
            "FUN_000817f0",
            "FUN_00081800",
            "FUN_00081810",
            "FUN_00081d48",
            "FUN_00081e34",
            "FUN_00081f00",
            "FUN_00081f9c",
            "FUN_00081fac",
            "FUN_0008236c",
            "FUN_00082390",
            "FUN_000825cc",
            "FUN_00082688",
            "FUN_00082824",
            "FUN_0008289c",
            "FUN_000834f0",
            "FUN_0008356c",
            "FUN_000836ec",
            "FUN_00083850",
            "FUN_00083888",
            "FUN_000839b4",
            "FUN_00083a74",
            "FUN_00083b10",
            "FUN_00083ca8",
            "FUN_00084004",
            "FUN_0008400c",
            "FUN_00084018",
            "FUN_000840f8",
            "FUN_000841e4",
            "thunk_FUN_00080efe",
            "FUN_00084220",
            "FUN_00084244",
            "FUN_0008427c",
            "FUN_000842a4",
            "FUN_0008434c",
            "FUN_0008439c",
            "FUN_00084484",
            "FUN_00084494",
            "FUN_000844bc",
            "FUN_000844e0",
            "FUN_00084508",
            "FUN_00084530",
            "FUN_0008455c",
            "FUN_0008458c",
            "FUN_000845c0",
            "FUN_00084860"
        ]
    ],
    "locked_functions": []
}