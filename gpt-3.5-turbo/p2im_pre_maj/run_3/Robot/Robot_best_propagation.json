{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeFlag_08000110(undefined4 input)\n\n{\n  if ((char)DAT_200009c8 == '\\0') {\n    DAT_200009c8._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_flag_08000110",
                "param_1": "input"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "combine_integers_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 combineIntegers_08000134(undefined4 firstInteger,undefined4 secondInteger)\n\n{\n  return combineIntegers_08000134WithConcatenation(secondInteger,firstInteger);\n}\n\n",
            "renaming": {
                "FUN_08000134": "combine_integers_08000134",
                "param_1": "firstInteger",
                "param_2": "secondInteger",
                "CONCAT44": "combineIntegersWithConcatenation"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000158": {
            "entrypoint": "0x08000158",
            "current_name": "calculate_unary_operation_08000158",
            "code": "\nulonglong calculate_unary_operation_08000158(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  int value_1;\n  byte bit_1;\n  uint value_2;\n  uint value_3;\n  uint value_4;\n  uint result_1;\n  uint result_2;\n  int result_3;\n  uint auxiliary_1;\n  uint auxiliary_2;\n  uint auxiliary_3;\n  uint auxiliary_4;\n  bool flag_1;\n  bool flag_2;\n  bool flag_3;\n  \n  result_1 = input_4 ^ 0x80000000;\n  auxiliary_1 = input_2 << 1;\n  input_4 = input_4 << 1;\n  flag_1 = ((input_2 ^ result_1) & 0x7fffffff) == 0;\n  flag_2 = flag_1 && input_1 == input_3;\n  if (!flag_1 || input_1 != input_3) {\n    flag_2 = (auxiliary_1 | input_1) == 0;\n  }\n  if (!flag_2) {\n    flag_2 = (input_4 | input_3) == 0;\n  }\n  result_3 = (int)auxiliary_1 >> 0x15;\n  if (!flag_2) {\n    flag_2 = result_3 == -1;\n  }\n  value_1 = (int)input_4 >> 0x15;\n  if (!flag_2) {\n    flag_2 = value_1 == -1;\n  }\n  if (flag_2) {\n    if (result_3 == -1 || value_1 == -1) {\n      auxiliary_1 = result_1;\n      auxiliary_3 = input_3;\n      if (result_3 == -1) {\n        auxiliary_1 = input_2;\n        auxiliary_3 = input_1;\n      }\n      if (result_3 != -1 || value_1 != -1) {\n        input_3 = auxiliary_3;\n        result_1 = auxiliary_1;\n      }\n      flag_2 = (auxiliary_3 | auxiliary_1 << 0xc) == 0;\n      if (flag_2) {\n        flag_2 = (input_3 | result_1 << 0xc) == 0;\n      }\n      if (flag_2) {\n        flag_2 = auxiliary_1 == result_1;\n      }\n      if (!flag_2) {\n        auxiliary_1 = auxiliary_1 | 0x80000;\n      }\n      return CONCAT44(auxiliary_1,auxiliary_3);\n    }\n    if (((input_2 ^ result_1) & 0x7fffffff) != 0 || input_1 != input_3) {\n      if ((auxiliary_1 | input_1) == 0) {\n        input_1 = input_3;\n        input_2 = result_1;\n      }\n      return CONCAT44(input_2,input_1);\n    }\n    if (input_2 != result_1) {\n      return 0;\n    }\n    if (auxiliary_1 >> 0x15 == 0) {\n      flag_2 = (input_1 & 0x80000000) != 0;\n      result_1 = input_2 * 2 + (uint)flag_2;\n      if (CARRY4(input_2,input_2) || CARRY4(input_2 * 2,(uint)flag_2)) {\n        result_1 = result_1 | 0x80000000;\n      }\n      return CONCAT44(result_1,input_1 << 1);\n    }\n    if (auxiliary_1 < 0xffc00000) {\n      return CONCAT44(input_2 + 0x100000,input_1);\n    }\n    input_2 = input_2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input_2 | 0x7ff00000) << 0x20;\n  }\n  auxiliary_1 = auxiliary_1 >> 0x15;\n  input_4 = input_4 >> 0x15;\n  auxiliary_3 = input_4 - auxiliary_1;\n  flag_2 = auxiliary_3 != 0;\n  if (input_4 < auxiliary_1) {\n    auxiliary_3 = -auxiliary_3;\n  }\n  auxiliary_2 = input_1;\n  result_2 = input_2;\n  if (flag_2 && auxiliary_1 <= input_4) {\n    auxiliary_1 = auxiliary_1 + auxiliary_3;\n    auxiliary_2 = input_3;\n    result_2 = result_1;\n    input_3 = input_1;\n    result_1 = input_2;\n  }\n  if (0x36 < auxiliary_3) {\n    return CONCAT44(result_2,auxiliary_2);\n  }\n  value_3 = result_2 & 0xfffff | 0x100000;\n  if ((result_2 & 0x80000000) != 0) {\n    flag_2 = auxiliary_2 != 0;\n    auxiliary_2 = -auxiliary_2;\n    value_3 = -value_3 - (uint)flag_2;\n  }\n  result_2 = result_1 & 0xfffff | 0x100000;\n  if ((result_1 & 0x80000000) != 0) {\n    flag_2 = input_3 != 0;\n    input_3 = -input_3;\n    result_2 = -result_2 - (uint)flag_2;\n  }\n  if (auxiliary_1 == auxiliary_3) {\n    result_2 = result_2 ^ 0x100000;\n    if (auxiliary_1 == 0) {\n      value_3 = value_3 ^ 0x100000;\n      auxiliary_1 = 1;\n    }\n    else {\n      auxiliary_3 = auxiliary_3 - 1;\n    }\n  }\n  result_1 = -auxiliary_3 + 0x20;\n  if ((int)auxiliary_3 < 0x21) {\n    auxiliary_4 = input_3 << (result_1 & 0xff);\n    input_3 = input_3 >> (auxiliary_3 & 0xff);\n    value_2 = auxiliary_2 + input_3;\n    value_4 = result_2 << (result_1 & 0xff);\n    result_1 = value_2 + value_4;\n    value_3 = value_3 + CARRY4(auxiliary_2,input_3) + ((int)result_2 >> (auxiliary_3 & 0xff)) +\n            (uint)CARRY4(value_2,value_4);\n  }\n  else {\n    auxiliary_4 = result_2 << (-auxiliary_3 + 0x40 & 0xff);\n    if (input_3 != 0) {\n      auxiliary_4 = auxiliary_4 | 2;\n    }\n    result_2 = (int)result_2 >> (auxiliary_3 - 0x20 & 0xff);\n    result_1 = auxiliary_2 + result_2;\n    value_3 = value_3 + ((int)result_2 >> 0x1f) + (uint)CARRY4(auxiliary_2,result_2);\n  }\n  input_2 = value_3 & 0x80000000;\n  auxiliary_3 = value_3;\n  if ((int)value_3 < 0) {\n    flag_2 = auxiliary_4 == 0;\n    auxiliary_4 = -auxiliary_4;\n    auxiliary_3 = -result_1;\n    result_1 = -(uint)!flag_2 - result_1;\n    auxiliary_3 = -(uint)(flag_2 <= auxiliary_3) - value_3;\n  }\n  if (0xfffff < auxiliary_3) {\n    auxiliary_2 = auxiliary_1 - 1;\n    if (0x1fffff < auxiliary_3) {\n      auxiliary_2 = auxiliary_3 & 1;\n      auxiliary_3 = auxiliary_3 >> 1;\n      bit_1 = (byte)result_1;\n      result_1 = (uint)(auxiliary_2 != 0) << 0x1f | result_1 >> 1;\n      auxiliary_4 = (uint)(bit_1 & 1) << 0x1f | auxiliary_4 >> 1;\n      auxiliary_2 = auxiliary_1;\n      if (0xffbfffff < auxiliary_1 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    flag_2 = 0x7fffffff < auxiliary_4;\n    if (auxiliary_4 == 0x80000000) {\n      flag_2 = (result_1 & 1) != 0;\n    }\n    return CONCAT44(auxiliary_3 + auxiliary_2 * 0x100000 + (uint)CARRY4(result_1,(uint)flag_2) | input_2,\n                    result_1 + flag_2);\n  }\n  flag_1 = (auxiliary_4 & 0x80000000) != 0;\n  auxiliary_4 = auxiliary_4 << 1;\n  auxiliary_2 = result_1 * 2;\n  flag_2 = CARRY4(result_1,result_1);\n  result_1 = result_1 * 2 + (uint)flag_1;\n  auxiliary_3 = auxiliary_3 * 2 + (uint)(flag_2 || CARRY4(auxiliary_2,(uint)flag_1));\n  auxiliary_2 = auxiliary_1 - 2;\n  if ((auxiliary_3 & 0x100000) != 0) goto LAB_08000268;\n  result_2 = result_1;\n  auxiliary_1 = auxiliary_3;\n  if (auxiliary_3 == 0) {\n    result_2 = 0;\n    auxiliary_1 = result_1;\n  }\n  result_3 = LZCOUNT(auxiliary_1);\n  if (auxiliary_3 == 0) {\n    result_3 = result_3 + 0x20;\n  }\n  auxiliary_3 = result_3 - 0xb;\n  flag_3 = SBORROW4(auxiliary_3,0x20);\n  result_1 = result_3 - 0x2b;\n  flag_2 = (int)result_1 < 0;\n  flag_1 = result_1 == 0;\n  if ((int)auxiliary_3 < 0x20) {\n    flag_3 = SCARRY4(result_1,0xc);\n    result_3 = result_3 + -0x1f;\n    flag_2 = result_3 < 0;\n    flag_1 = result_3 == 0;\n    result_1 = auxiliary_3;\n    if (!flag_1 && flag_2 == flag_3) {\n      result_2 = auxiliary_1 << (auxiliary_3 & 0xff);\n      auxiliary_1 = auxiliary_1 >> (0xcU - result_3 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (flag_1 || flag_2 != flag_3) {\n    auxiliary_4 = 0x20 - result_1;\n  }\n  auxiliary_1 = auxiliary_1 << (result_1 & 0xff);\n  if (flag_1 || flag_2 != flag_3) {\n    auxiliary_1 = auxiliary_1 | result_2 >> (auxiliary_4 & 0xff);\n  }\n  if (flag_1 || flag_2 != flag_3) {\n    result_2 = result_2 << (result_1 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)auxiliary_3 <= (int)auxiliary_2) {\n    return CONCAT44(auxiliary_1 + (auxiliary_2 - auxiliary_3) * 0x100000 | input_2,result_2);\n  }\n  result_1 = ~(auxiliary_2 - auxiliary_3);\n  if ((int)result_1 < 0x1f) {\n    result_3 = result_1 - 0x13;\n    if (result_3 != 0 && result_3 < 0 == SCARRY4(result_1 - 0x1f,0xc)) {\n      return CONCAT44(value_3,result_2 >> (0x20 - (0xcU - result_3) & 0xff) | auxiliary_1 << (0xcU - result_3 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    result_1 = result_1 + 1;\n    return CONCAT44(input_2 | auxiliary_1 >> (result_1 & 0xff),\n                    result_2 >> (result_1 & 0xff) | auxiliary_1 << (0x20 - result_1 & 0xff));\n  }\n  return CONCAT44(value_3,auxiliary_1 >> (result_1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000158": "calculate_unary_operation_08000158",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "value_1",
                "bVar2": "bit_1",
                "uVar3": "value_2",
                "uVar4": "value_3",
                "uVar5": "value_4",
                "uVar6": "result_1",
                "uVar7": "result_2",
                "iVar8": "result_3",
                "uVar9": "auxiliary_1",
                "uVar10": "auxiliary_2",
                "uVar11": "auxiliary_3",
                "uVar12": "auxiliary_4",
                "bVar13": "flag_1",
                "bVar14": "flag_2",
                "bVar15": "flag_3"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800015c": {
            "entrypoint": "0x0800015c",
            "current_name": "calculate_0800015c",
            "code": "\nulonglong calculate_0800015c(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shift1;\n  byte carry;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shift2;\n  uint shifted_input2;\n  uint result1;\n  uint shifted_input4;\n  uint difference;\n  uint result2;\n  uint result3;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  shifted_input2 = input2 << 1;\n  shifted_input4 = input4 << 1;\n  condition1 = ((input2 ^ input4) & 0x7fffffff) == 0;\n  condition2 = condition1 && input1 == input3;\n  if (!condition1 || input1 != input3) {\n    condition2 = (shifted_input2 | input1) == 0;\n  }\n  if (!condition2) {\n    condition2 = (shifted_input4 | input3) == 0;\n  }\n  shift2 = (int)shifted_input2 >> 0x15;\n  if (!condition2) {\n    condition2 = shift2 == -1;\n  }\n  shift1 = (int)shifted_input4 >> 0x15;\n  if (!condition2) {\n    condition2 = shift1 == -1;\n  }\n  if (condition2) {\n    if (shift2 == -1 || shift1 == -1) {\n      shifted_input4 = input4;\n      shifted_input2 = input3;\n      if (shift2 == -1) {\n        shifted_input4 = input2;\n        shifted_input2 = input1;\n      }\n      if (shift2 != -1 || shift1 != -1) {\n        input3 = shifted_input2;\n        input4 = shifted_input4;\n      }\n      condition2 = (shifted_input2 | shifted_input4 << 0xc) == 0;\n      if (condition2) {\n        condition2 = (input3 | input4 << 0xc) == 0;\n      }\n      if (condition2) {\n        condition2 = shifted_input4 == input4;\n      }\n      if (!condition2) {\n        shifted_input4 = shifted_input4 | 0x80000;\n      }\n      return CONCAT44(shifted_input4,shifted_input2);\n    }\n    if (((input2 ^ input4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((shifted_input2 | input1) == 0) {\n        input1 = input3;\n        input2 = input4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != input4) {\n      return 0;\n    }\n    if (shifted_input2 >> 0x15 == 0) {\n      condition2 = (input1 & 0x80000000) != 0;\n      shifted_input4 = input2 * 2 + (uint)condition2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)condition2)) {\n        shifted_input4 = shifted_input4 | 0x80000000;\n      }\n      return CONCAT44(shifted_input4,input1 << 1);\n    }\n    if (shifted_input2 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  shifted_input2 = shifted_input2 >> 0x15;\n  shifted_input4 = shifted_input4 >> 0x15;\n  difference = shifted_input4 - shifted_input2;\n  condition2 = difference != 0;\n  if (shifted_input4 < shifted_input2) {\n    difference = -difference;\n  }\n  result1 = input1;\n  temp3 = input2;\n  if (condition2 && shifted_input2 <= shifted_input4) {\n    shifted_input2 = shifted_input2 + difference;\n    result1 = input3;\n    temp3 = input4;\n    input3 = input1;\n    input4 = input2;\n  }\n  if (0x36 < difference) {\n    return CONCAT44(temp3,result1);\n  }\n  shifted_input4 = temp3 & 0xfffff | 0x100000;\n  if ((temp3 & 0x80000000) != 0) {\n    condition2 = result1 != 0;\n    result1 = -result1;\n    shifted_input4 = -shifted_input4 - (uint)condition2;\n  }\n  temp3 = input4 & 0xfffff | 0x100000;\n  if ((input4 & 0x80000000) != 0) {\n    condition2 = input3 != 0;\n    input3 = -input3;\n    temp3 = -temp3 - (uint)condition2;\n  }\n  if (shifted_input2 == difference) {\n    temp3 = temp3 ^ 0x100000;\n    if (shifted_input2 == 0) {\n      shifted_input4 = shifted_input4 ^ 0x100000;\n      shifted_input2 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  result3 = -difference + 0x20;\n  if ((int)difference < 0x21) {\n    result2 = input3 << (result3 & 0xff);\n    input3 = input3 >> (difference & 0xff);\n    temp1 = result1 + input3;\n    temp2 = temp3 << (result3 & 0xff);\n    result3 = temp1 + temp2;\n    shifted_input4 = shifted_input4 + CARRY4(result1,input3) + ((int)temp3 >> (difference & 0xff)) +\n            (uint)CARRY4(temp1,temp2);\n  }\n  else {\n    result2 = temp3 << (-difference + 0x40 & 0xff);\n    if (input3 != 0) {\n      result2 = result2 | 2;\n    }\n    temp3 = (int)temp3 >> (difference - 0x20 & 0xff);\n    result3 = result1 + temp3;\n    shifted_input4 = shifted_input4 + ((int)temp3 >> 0x1f) + (uint)CARRY4(result1,temp3);\n  }\n  input2 = shifted_input4 & 0x80000000;\n  difference = shifted_input4;\n  if ((int)shifted_input4 < 0) {\n    condition2 = result2 == 0;\n    result2 = -result2;\n    difference = -result3;\n    result3 = -(uint)!condition2 - result3;\n    difference = -(uint)(condition2 <= difference) - shifted_input4;\n  }\n  if (0xfffff < difference) {\n    result1 = shifted_input2 - 1;\n    if (0x1fffff < difference) {\n      shifted_input4 = difference & 1;\n      difference = difference >> 1;\n      carry = (byte)result3;\n      result3 = (uint)(shifted_input4 != 0) << 0x1f | result3 >> 1;\n      result2 = (uint)(carry & 1) << 0x1f | result2 >> 1;\n      result1 = shifted_input2;\n      if (0xffbfffff < shifted_input2 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    condition2 = 0x7fffffff < result2;\n    if (result2 == 0x80000000) {\n      condition2 = (result3 & 1) != 0;\n    }\n    return CONCAT44(difference + result1 * 0x100000 + (uint)CARRY4(result3,(uint)condition2) | input2,\n                    result3 + condition2);\n  }\n  condition1 = (result2 & 0x80000000) != 0;\n  result2 = result2 << 1;\n  result1 = result3 * 2;\n  condition2 = CARRY4(result3,result3);\n  result3 = result3 * 2 + (uint)condition1;\n  difference = difference * 2 + (uint)(condition2 || CARRY4(result1,(uint)condition1));\n  result1 = shifted_input2 - 2;\n  if ((difference & 0x100000) != 0) goto LAB_08000268;\n  temp3 = result3;\n  shifted_input2 = difference;\n  if (difference == 0) {\n    temp3 = 0;\n    shifted_input2 = result3;\n  }\n  shift2 = LZCOUNT(shifted_input2);\n  if (difference == 0) {\n    shift2 = shift2 + 0x20;\n  }\n  result3 = shift2 - 0xb;\n  condition3 = SBORROW4(result3,0x20);\n  difference = shift2 - 0x2b;\n  condition2 = (int)difference < 0;\n  condition1 = difference == 0;\n  if ((int)result3 < 0x20) {\n    condition3 = SCARRY4(difference,0xc);\n    shift2 = shift2 + -0x1f;\n    condition2 = shift2 < 0;\n    condition1 = shift2 == 0;\n    difference = result3;\n    if (!condition1 && condition2 == condition3) {\n      temp3 = shifted_input2 << (result3 & 0xff);\n      shifted_input2 = shifted_input2 >> (0xcU - shift2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (condition1 || condition2 != condition3) {\n    result2 = 0x20 - difference;\n  }\n  shifted_input2 = shifted_input2 << (difference & 0xff);\n  if (condition1 || condition2 != condition3) {\n    shifted_input2 = shifted_input2 | temp3 >> (result2 & 0xff);\n  }\n  if (condition1 || condition2 != condition3) {\n    temp3 = temp3 << (difference & 0xff);\n  }\nLAB_080002e0:\n  if ((int)result3 <= (int)result1) {\n    return CONCAT44(shifted_input2 + (result1 - result3) * 0x100000 | input2,temp3);\n  }\n  difference = ~(result1 - result3);\n  if ((int)difference < 0x1f) {\n    shift2 = difference - 0x13;\n    if (shift2 != 0 && shift2 < 0 == SCARRY4(difference - 0x1f,0xc)) {\n      return CONCAT44(shifted_input4,temp3 >> (0x20 - (0xcU - shift2) & 0xff) | shifted_input2 << (0xcU - shift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    difference = difference + 1;\n    return CONCAT44(input2 | shifted_input2 >> (difference & 0xff),\n                    temp3 >> (difference & 0xff) | shifted_input2 << (0x20 - difference & 0xff));\n  }\n  return CONCAT44(shifted_input4,shifted_input2 >> (difference - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800015c": "calculate_0800015c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shift1",
                "bVar2": "carry",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "iVar6": "shift2",
                "uVar7": "shifted_input2",
                "uVar8": "result1",
                "uVar9": "shifted_input4",
                "uVar10": "difference",
                "uVar11": "result2",
                "uVar12": "result3",
                "bVar13": "condition1",
                "bVar14": "condition2",
                "bVar15": "condition3"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003d4": {
            "entrypoint": "0x080003d4",
            "current_name": "reverse_bits_080003d4",
            "code": "\nulonglong reverse_bits_080003d4(uint input_number)\n\n{\n  uint result_high;\n  uint result_low;\n  int num_bits;\n  uint shift_amount;\n  uint remaining_bits;\n  bool is_negative;\n  bool is_zero;\n  bool overflow_flag;\n  \n  if (input_number == 0) {\n    return 0;\n  }\n  result_high = 0;\n  num_bits = LZCOUNT(input_number);\n  shift_amount = num_bits + 0x15;\n  overflow_flag = SBORROW4(shift_amount,0x20);\n  result_low = num_bits - 0xb;\n  is_negative = (int)result_low < 0;\n  is_zero = result_low == 0;\n  if (shift_amount < 0x20) {\n    overflow_flag = SCARRY4(result_low,0xc);\n    is_negative = false;\n    is_zero = num_bits + 1 == 0;\n    result_low = shift_amount;\n    if (!is_zero && overflow_flag == false) {\n      result_high = input_number << shift_amount;\n      input_number = input_number >> (0xcU - (num_bits + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_zero || is_negative != overflow_flag) {\n    remaining_bits = 0x20 - result_low;\n  }\n  input_number = input_number << (result_low & 0xff);\n  if (is_zero || is_negative != overflow_flag) {\n    input_number = input_number | 0U >> (remaining_bits & 0xff);\n  }\n  if (is_zero || is_negative != overflow_flag) {\n    result_high = 0 << (result_low & 0xff);\n  }\nLAB_080002e0:\n  if (shift_amount < 0x433) {\n    return CONCAT44(input_number + (0x432 - shift_amount) * 0x100000,result_high);\n  }\n  result_low = ~(0x432 - shift_amount);\n  if (0x1e < (int)result_low) {\n    return (ulonglong)(input_number >> (result_low - 0x1f & 0xff));\n  }\n  num_bits = result_low - 0x13;\n  if (num_bits == 0 || num_bits < 0 != SCARRY4(result_low - 0x1f,0xc)) {\n    result_low = result_low + 1;\n    return CONCAT44(input_number >> (result_low & 0xff),\n                    result_high >> (result_low & 0xff) | input_number << (0x20 - result_low & 0xff));\n  }\n  return (ulonglong)(result_high >> (0x20 - (0xcU - num_bits) & 0xff) | input_number << (0xcU - num_bits & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003d4": "reverse_bits_080003d4",
                "param_1": "input_number",
                "uVar1": "result_high",
                "uVar2": "result_low",
                "iVar3": "num_bits",
                "uVar4": "shift_amount",
                "in_r12": "remaining_bits",
                "bVar5": "is_negative",
                "bVar6": "is_zero",
                "bVar7": "overflow_flag"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003f4": {
            "entrypoint": "0x080003f4",
            "current_name": "bitwise_shift_080003f4",
            "code": "\nulonglong bitwise_shift_080003f4(uint value)\n\n{\n  uint shift_count;\n  uint abs_value;\n  uint adjusted_shift_count;\n  int leading_zeroes;\n  uint final_shift_count;\n  uint is_negative;\n  uint remaining_bits;\n  bool is_negative_overflow;\n  bool is_zero;\n  bool is_overflowing;\n  \n  if (value == 0) {\n    return 0;\n  }\n  is_negative = value & 0x80000000;\n  abs_value = value;\n  if ((int)is_negative < 0) {\n    abs_value = -value;\n  }\n  shift_count = 0;\n  leading_zeroes = LZCOUNT(abs_value);\n  final_shift_count = leading_zeroes + 0x15;\n  is_overflowing = SBORROW4(final_shift_count,0x20);\n  adjusted_shift_count = leading_zeroes - 0xb;\n  is_negative_overflow = (int)adjusted_shift_count < 0;\n  is_zero = adjusted_shift_count == 0;\n  if (final_shift_count < 0x20) {\n    is_overflowing = SCARRY4(adjusted_shift_count,0xc);\n    is_negative_overflow = false;\n    is_zero = leading_zeroes + 1 == 0;\n    adjusted_shift_count = final_shift_count;\n    if (!is_zero && is_overflowing == false) {\n      shift_count = abs_value << final_shift_count;\n      abs_value = abs_value >> (0xcU - (leading_zeroes + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_zero || is_negative_overflow != is_overflowing) {\n    remaining_bits = 0x20 - adjusted_shift_count;\n  }\n  abs_value = abs_value << (adjusted_shift_count & 0xff);\n  if (is_zero || is_negative_overflow != is_overflowing) {\n    abs_value = abs_value | 0U >> (remaining_bits & 0xff);\n  }\n  if (is_zero || is_negative_overflow != is_overflowing) {\n    shift_count = 0 << (adjusted_shift_count & 0xff);\n  }\nLAB_080002e0:\n  if (final_shift_count < 0x433) {\n    return CONCAT44(abs_value + (0x432 - final_shift_count) * 0x100000 | is_negative,shift_count);\n  }\n  adjusted_shift_count = ~(0x432 - final_shift_count);\n  if (0x1e < (int)adjusted_shift_count) {\n    return CONCAT44(value,abs_value >> (adjusted_shift_count - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeroes = adjusted_shift_count - 0x13;\n  if (leading_zeroes == 0 || leading_zeroes < 0 != SCARRY4(adjusted_shift_count - 0x1f,0xc)) {\n    adjusted_shift_count = adjusted_shift_count + 1;\n    return CONCAT44(is_negative | abs_value >> (adjusted_shift_count & 0xff),\n                    shift_count >> (adjusted_shift_count & 0xff) | abs_value << (0x20 - adjusted_shift_count & 0xff));\n  }\n  return CONCAT44(value,shift_count >> (0x20 - (0xcU - leading_zeroes) & 0xff) | abs_value << (0xcU - leading_zeroes & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080003f4": "bitwise_shift_080003f4",
                "param_1": "value",
                "uVar1": "shift_count",
                "uVar2": "abs_value",
                "uVar3": "adjusted_shift_count",
                "iVar4": "leading_zeroes",
                "uVar5": "final_shift_count",
                "uVar6": "is_negative",
                "in_r12": "remaining_bits",
                "bVar7": "is_negative_overflow",
                "bVar8": "is_zero",
                "bVar9": "is_overflowing"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000418": {
            "entrypoint": "0x08000418",
            "current_name": "reverse_bits_08000418",
            "code": "\nulonglong reverseBits_08000418(uint input,undefined4 unused1,undefined4 unused2,uint unused3)\n\n{\n  uint signBit;\n  uint var1;\n  uint resultUpper;\n  uint var2;\n  uint shiftedInput;\n  int count;\n  uint shiftAmount;\n  uint unused4;\n  bool isNegative;\n  bool isZeroOrFF;\n  bool isNegativeShift;\n  \n  shiftedInput = input << 1;\n  isZeroOrFF = shiftedInput == 0;\n  signBit = (uint)((input & 0x80000000) != 0) << 0x1f;\n  var2 = (uint)((int)shiftedInput >> 3) >> 1;\n  resultUpper = signBit | var2;\n  input = input << 0x1d;\n  if (!isZeroOrFF) {\n    unused3 = shiftedInput & 0xff000000;\n    isZeroOrFF = unused3 == 0;\n  }\n  if (!isZeroOrFF) {\n    isZeroOrFF = unused3 == 0xff000000;\n  }\n  if (!isZeroOrFF) {\n    return CONCAT44(resultUpper,input) ^ 0x3800000000000000;\n  }\n  if ((shiftedInput & 0xffffff) == 0) {\n    return CONCAT44(resultUpper,input);\n  }\n  if (unused3 == 0xff000000) {\n    return CONCAT44(resultUpper,input) | 0x8000000000000;\n  }\n  var1 = input;\n  shiftedInput = var2;\n  if (var2 == 0) {\n    var1 = 0;\n    shiftedInput = input;\n  }\n  count = LZCOUNT(shiftedInput);\n  if (var2 == 0) {\n    count = count + 0x20;\n  }\n  shiftAmount = count - 0xb;\n  isNegativeShift = SBORROW4(shiftAmount,0x20);\n  var2 = count - 0x2b;\n  isZeroOrFF = (int)var2 < 0;\n  isNegative = var2 == 0;\n  if ((int)shiftAmount < 0x20) {\n    isNegativeShift = SCARRY4(var2,0xc);\n    count = count + -0x1f;\n    isZeroOrFF = count < 0;\n    isNegative = count == 0;\n    var2 = shiftAmount;\n    if (!isNegative && isZeroOrFF == isNegativeShift) {\n      var1 = shiftedInput << (shiftAmount & 0xff);\n      shiftedInput = shiftedInput >> (0xcU - count & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isNegative || isZeroOrFF != isNegativeShift) {\n    unused4 = 0x20 - var2;\n  }\n  shiftedInput = shiftedInput << (var2 & 0xff);\n  if (isNegative || isZeroOrFF != isNegativeShift) {\n    shiftedInput = shiftedInput | var1 >> (unused4 & 0xff);\n  }\n  if (isNegative || isZeroOrFF != isNegativeShift) {\n    var1 = var1 << (var2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shiftAmount < 0x381) {\n    return CONCAT44(shiftedInput + (0x380 - shiftAmount) * 0x100000 | signBit,var1);\n  }\n  var2 = ~(0x380 - shiftAmount);\n  if (0x1e < (int)var2) {\n    return CONCAT44(resultUpper,shiftedInput >> (var2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  count = var2 - 0x13;\n  if (count == 0 || count < 0 != SCARRY4(var2 - 0x1f,0xc)) {\n    var2 = var2 + 1;\n    return CONCAT44(signBit | shiftedInput >> (var2 & 0xff),\n                    var1 >> (var2 & 0xff) | shiftedInput << (0x20 - var2 & 0xff));\n  }\n  return CONCAT44(resultUpper,var1 >> (0x20 - (0xcU - count) & 0xff) | shiftedInput << (0xcU - count & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000418": "reverse_bits_08000418",
                "param_1": "input",
                "param_2": "unused1",
                "param_3": "unused2",
                "param_4": "unused3",
                "uVar1": "signBit",
                "uVar2": "var1",
                "uVar3": "resultUpper",
                "uVar4": "var2",
                "uVar5": "shiftedInput",
                "iVar6": "count",
                "uVar7": "shiftAmount",
                "in_r12": "unused4",
                "bVar8": "isNegative",
                "bVar9": "isZeroOrFF",
                "bVar10": "isNegativeShift"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004c8": {
            "entrypoint": "0x080004c8",
            "current_name": "calculate_shifted_values_080004c8",
            "code": "\nulonglong calculate_shifted_values_080004c8(undefined4 input_param_1,uint input_param_2,uint input_param_3,uint input_param_4)\n\n{\n  ulonglong result;\n  longlong temp_result;\n  uint shifted_value_1;\n  uint shifted_value_2;\n  int sum;\n  uint subtracted_value;\n  uint shifted_value_3;\n  uint shifted_value_4;\n  uint shifted_value_5;\n  bool is_zero;\n  bool is_negative;\n  bool is_subtracted;\n  ulonglong combined_values;\n  \n  combined_values = CONCAT44(input_param_2,input_param_1);\n  shifted_value_4 = 0x7ff;\n  shifted_value_2 = input_param_2 >> 0x14 & 0x7ff;\n  is_zero = shifted_value_2 == 0;\n  if (!is_zero) {\n    shifted_value_3 = input_param_4 >> 0x14 & 0x7ff;\n    is_zero = shifted_value_3 == 0;\n  }\n  if (!is_zero) {\n    is_zero = shifted_value_2 == 0x7ff;\n  }\n  if (!is_zero) {\n    is_zero = shifted_value_3 == 0x7ff;\n  }\n  if (is_zero) {\n    combined_values = calculate_shifted_and_080006a4();\n  }\n  shifted_value_1 = (uint)(combined_values >> 0x20);\n  sum = shifted_value_2 + shifted_value_3;\n  shifted_value_2 = shifted_value_1 ^ input_param_4;\n  shifted_value_1 = shifted_value_1 & ~(shifted_value_4 << 0x15);\n  input_param_4 = input_param_4 & ~(shifted_value_4 << 0x15);\n  is_zero = ((uint)combined_values | shifted_value_1 << 0xc) == 0;\n  if (!is_zero) {\n    is_zero = (input_param_3 | input_param_4 << 0xc) == 0;\n  }\n  shifted_value_1 = shifted_value_1 | 0x100000;\n  input_param_4 = input_param_4 | 0x100000;\n  if (is_zero) {\n    input_param_3 = (uint)combined_values | input_param_3;\n    input_param_4 = (shifted_value_2 & 0x80000000 | shifted_value_1) ^ input_param_4;\n    shifted_value_2 = shifted_value_4 >> 1;\n    is_subtracted = SBORROW4(sum,shifted_value_2);\n    subtracted_value = sum - shifted_value_2;\n    is_zero = subtracted_value == 0;\n    shifted_value_1 = subtracted_value;\n    if (!is_zero && (int)shifted_value_2 <= sum) {\n      is_subtracted = SBORROW4(shifted_value_4,subtracted_value);\n      shifted_value_1 = shifted_value_4 - subtracted_value;\n      is_zero = shifted_value_4 == subtracted_value;\n    }\n    if (!is_zero && (int)shifted_value_1 < 0 == is_subtracted) {\n      input_param_4 = input_param_4 | subtracted_value * 0x100000;\n    }\n    if (!is_zero && (int)shifted_value_1 < 0 == is_subtracted) {\n      return CONCAT44(input_param_4,input_param_3);\n    }\n    input_param_4 = input_param_4 | 0x100000;\n    shifted_value_4 = 0;\n    is_subtracted = SBORROW4(subtracted_value,1);\n    subtracted_value = subtracted_value - 1;\n    is_zero = subtracted_value == 0;\n    shifted_value_2 = subtracted_value;\n  }\n  else {\n    result = (combined_values & 0xffffffff) * (ulonglong)input_param_3;\n    combined_values = (combined_values & 0xffffffff) * (ulonglong)input_param_4 +\n             (ulonglong)shifted_value_1 * (ulonglong)input_param_3 + (result >> 0x20);\n    shifted_value_5 = (uint)combined_values;\n    temp_result = (ulonglong)shifted_value_1 * (ulonglong)input_param_4 + (combined_values >> 0x20);\n    shifted_value_4 = (uint)temp_result;\n    shifted_value_1 = (uint)((ulonglong)temp_result >> 0x20);\n    if ((int)result != 0) {\n      shifted_value_5 = shifted_value_5 | 1;\n    }\n    subtracted_value = (sum + -0x3ff) - (uint)(shifted_value_1 < 0x200);\n    if (shifted_value_1 < 0x200) {\n      is_zero = (shifted_value_5 & 0x80000000) != 0;\n      shifted_value_5 = shifted_value_5 << 1;\n      temp_result = CONCAT44(shifted_value_1 * 2 + (uint)(CARRY4(shifted_value_4,shifted_value_4) || CARRY4(shifted_value_4 * 2,(uint)is_zero)),\n                       shifted_value_4 * 2 + (uint)is_zero);\n    }\n    input_param_4 = shifted_value_2 & 0x80000000 | (int)((ulonglong)temp_result >> 0x20) << 0xb | (uint)temp_result >> 0x15;\n    input_param_3 = (uint)temp_result << 0xb | shifted_value_5 >> 0x15;\n    shifted_value_4 = shifted_value_5 * 0x800;\n    is_negative = 0xfc < subtracted_value;\n    is_subtracted = SBORROW4(subtracted_value,0xfd);\n    shifted_value_1 = subtracted_value - 0xfd;\n    is_zero = shifted_value_1 == 0;\n    shifted_value_2 = shifted_value_1;\n    if (is_negative && !is_zero) {\n      is_negative = 0x6ff < shifted_value_1;\n      is_subtracted = SBORROW4(shifted_value_1,0x700);\n      shifted_value_2 = subtracted_value - 0x7fd;\n      is_zero = shifted_value_1 == 0x700;\n    }\n    if (!is_negative || is_zero) {\n      is_zero = 0x7fffffff < shifted_value_4;\n      if (shifted_value_4 == 0x80000000) {\n        is_zero = (shifted_value_5 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input_param_4 + subtracted_value * 0x100000 + (uint)CARRY4(input_param_3,(uint)is_zero),input_param_3 + is_zero\n                     );\n    }\n  }\n  if (!is_zero && (int)shifted_value_2 < 0 == is_subtracted) {\n    return (ulonglong)(input_param_4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  is_negative = SCARRY4(subtracted_value,0x36);\n  is_zero = (int)(subtracted_value + 0x36) < 0;\n  is_subtracted = subtracted_value == 0xffffffca;\n  if (is_subtracted || is_zero != is_negative) {\n    input_param_3 = 0;\n  }\n  if (is_subtracted || is_zero != is_negative) {\n    input_param_4 = input_param_4 & 0x80000000;\n  }\n  if (is_subtracted || is_zero != is_negative) {\n    return CONCAT44(input_param_4,input_param_3);\n  }\n  shifted_value_2 = -subtracted_value;\n  shifted_value_1 = shifted_value_2 - 0x20;\n  if (0x1f < (int)shifted_value_2) {\n    subtracted_value = input_param_3 >> (shifted_value_1 & 0xff) | input_param_4 << (0x20 - shifted_value_1 & 0xff);\n    shifted_value_2 = (input_param_4 >> (shifted_value_1 & 0xff) & ~((input_param_4 & 0x80000000) >> (shifted_value_1 & 0xff))) -\n            ((int)subtracted_value >> 0x1f);\n    if ((shifted_value_4 | input_param_3 << (0x20 - shifted_value_1 & 0xff) | subtracted_value << 1) == 0) {\n      shifted_value_2 = shifted_value_2 & ~(subtracted_value >> 0x1f);\n    }\n    return CONCAT44(input_param_4,shifted_value_2) & 0x80000000ffffffff;\n  }\n  sum = shifted_value_2 - 0x14;\n  if (sum == 0 || sum < 0 != SCARRY4(shifted_value_1,0xc)) {\n    shifted_value_5 = input_param_3 << (subtracted_value + 0x20 & 0xff);\n    shifted_value_1 = input_param_3 >> (shifted_value_2 & 0xff) | input_param_4 << (subtracted_value + 0x20 & 0xff);\n    subtracted_value = shifted_value_1 + -((int)shifted_value_5 >> 0x1f);\n    if ((shifted_value_4 | shifted_value_5 << 1) == 0) {\n      subtracted_value = subtracted_value & ~(shifted_value_5 >> 0x1f);\n    }\n    return CONCAT44((input_param_4 & 0x80000000) +\n                    ((input_param_4 & 0x7fffffff) >> (shifted_value_2 & 0xff)) +\n                    (uint)CARRY4(shifted_value_1,-((int)shifted_value_5 >> 0x1f)),subtracted_value);\n  }\n  shifted_value_2 = 0xc - sum;\n  subtracted_value = input_param_3 << (shifted_value_2 & 0xff);\n  shifted_value_2 = input_param_3 >> (0x20 - shifted_value_2 & 0xff) | input_param_4 << (shifted_value_2 & 0xff);\n  shifted_value_1 = shifted_value_2 + -((int)subtracted_value >> 0x1f);\n  if ((shifted_value_4 | subtracted_value << 1) == 0) {\n    shifted_value_1 = shifted_value_1 & ~(subtracted_value >> 0x1f);\n  }\n  return CONCAT44((input_param_4 & 0x80000000) + (uint)CARRY4(shifted_value_2,-((int)subtracted_value >> 0x1f)),shifted_value_1);\n}\n\n",
            "renaming": {
                "FUN_080004c8": "calculate_shifted_values_080004c8",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "input_param_3",
                "param_4": "input_param_4",
                "uVar1": "result",
                "lVar2": "temp_result",
                "uVar3": "shifted_value_1",
                "uVar4": "shifted_value_2",
                "iVar5": "sum",
                "uVar6": "subtracted_value",
                "unaff_r5": "shifted_value_3",
                "uVar7": "shifted_value_4",
                "uVar8": "shifted_value_5",
                "bVar9": "is_zero",
                "bVar10": "is_negative",
                "bVar11": "is_subtracted",
                "uVar12": "combined_values"
            },
            "calling": [
                "frexp",
                "atan",
                "_dtoa_r",
                "mpu6050_calc_pitch",
                "_svfprintf_r",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [
                "FUN_080006a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006a4": {
            "entrypoint": "0x080006a4",
            "current_name": "calculate_shifted_and_080006a4",
            "code": "\nulonglong calculate_shifted_and_080006a4(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  uint temp_4;\n  uint temp_5;\n  bool is_zero;\n  \n  temp_3 = temp_5 & input_4 >> 0x14;\n  if (temp_2 != temp_5 && temp_3 != temp_5) {\n    is_zero = (input_1 | input_2 << 1) == 0;\n    if (!is_zero) {\n      is_zero = (input_3 | input_4 << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n    }\n    if (temp_2 == 0) {\n      temp_4 = input_2 & 0x80000000;\n      do {\n        temp_1 = input_1 & 0x80000000;\n        input_1 = input_1 << 1;\n        input_2 = input_2 * 2 + (uint)(temp_1 != 0);\n      } while ((input_2 & 0x100000) == 0);\n      input_2 = input_2 | temp_4;\n      if (temp_3 != 0) {\n        return CONCAT44(input_2,input_1);\n      }\n    }\n    do {\n      temp_3 = input_3 & 0x80000000;\n      input_3 = input_3 << 1;\n      input_4 = input_4 * 2 + (uint)(temp_3 != 0);\n    } while ((input_4 & 0x100000) == 0);\n    return CONCAT44(input_2,input_1);\n  }\n  is_zero = (input_1 | input_2 << 1) == 0;\n  if (is_zero) {\n    input_2 = input_4;\n    input_1 = input_3;\n  }\n  if (!is_zero) {\n    is_zero = (input_3 | input_4 << 1) == 0;\n  }\n  temp_4 = input_2;\n  if (((!is_zero) && ((temp_2 != temp_5 || ((input_1 | input_2 << 0xc) == 0)))) &&\n     ((temp_3 != temp_5 || (input_1 = input_3, temp_4 = input_4, (input_3 | input_4 << 0xc) == 0)))) {\n    return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(temp_4,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006a4": "calculate_shifted_and_080006a4",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "temp_1",
                "unaff_r4": "temp_2",
                "uVar2": "temp_3",
                "uVar3": "temp_4",
                "in_r12": "temp_5",
                "bVar4": "is_zero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800071c": {
            "entrypoint": "0x0800071c",
            "current_name": "decode_float_0800071c",
            "code": "\nulonglong decode_float_0800071c(undefined4 param1,uint param2,uint param3,uint param4)\n\n{\n  uint result1;\n  uint result2;\n  uint result3;\n  uint result4;\n  uint result5;\n  uint result6;\n  uint result7;\n  int result8;\n  uint result9;\n  uint result10;\n  uint result11;\n  uint result12;\n  uint result13;\n  uint result14;\n  bool isTrue1;\n  bool isTrue2;\n  bool isTrue3;\n  undefined8 result17;\n  \n  result17 = CONCAT44(param2,param1);\n  result14 = 0x7ff;\n  result7 = param2 >> 0x14 & 0x7ff;\n  isTrue1 = result7 == 0;\n  if (!isTrue1) {\n    result10 = param4 >> 0x14 & 0x7ff;\n    isTrue1 = result10 == 0;\n  }\n  if (!isTrue1) {\n    isTrue1 = result7 == 0x7ff;\n  }\n  if (!isTrue1) {\n    isTrue1 = result10 == 0x7ff;\n  }\n  if (isTrue1) {\n    result17 = decode_float_0800071c_0800088a();\n  }\n  result9 = (uint)((ulonglong)result17 >> 0x20);\n  result12 = (uint)result17;\n  result8 = result7 - result10;\n  if ((param3 | param4 << 0xc) == 0) {\n    result7 = (result9 ^ param4) & 0x80000000 | result9 & 0xfffff;\n    isTrue3 = SCARRY4(result8,result14 >> 1);\n    result9 = result8 + (result14 >> 1);\n    isTrue1 = (int)result9 < 0;\n    isTrue2 = result9 == 0;\n    if (!isTrue2 && isTrue1 == isTrue3) {\n      isTrue3 = SBORROW4(result14,result9);\n      isTrue1 = (int)(result14 - result9) < 0;\n      isTrue2 = result14 == result9;\n    }\n    if (!isTrue2 && isTrue1 == isTrue3) {\n      result7 = result7 | result9 * 0x100000;\n    }\n    if (!isTrue2 && isTrue1 == isTrue3) {\n      return CONCAT44(result7,result12);\n    }\n    result7 = result7 | 0x100000;\n    result14 = 0;\n    isTrue2 = SBORROW4(result9,1);\n    result9 = result9 - 1;\n    isTrue1 = result9 == 0;\n    result3 = result9;\n  }\n  else {\n    result3 = (param4 << 0xc) >> 4 | 0x10000000 | param3 >> 0x18;\n    result14 = param3 << 8;\n    result11 = (result9 << 0xc) >> 4 | 0x10000000 | result12 >> 0x18;\n    result12 = result12 * 0x100;\n    result7 = (result9 ^ param4) & 0x80000000;\n    isTrue1 = result3 <= result11;\n    if (result11 == result3) {\n      isTrue1 = result14 <= result12;\n    }\n    result8 = result8 + (uint)isTrue1;\n    result9 = result8 + 0x3fd;\n    if (isTrue1 == false) {\n      result3 = result3 >> 1;\n      result14 = (uint)((param3 >> 0x18 & 1) != 0) << 0x1f | result14 >> 1;\n    }\n    result13 = result12 - result14;\n    result11 = (result11 - result3) - (uint)(result12 < result14);\n    result4 = result3 >> 1;\n    result1 = (uint)((result3 & 1) != 0) << 0x1f | result14 >> 1;\n    result12 = 0x100000;\n    result3 = 0x80000;\n    while( true ) {\n      isTrue1 = result1 <= result13;\n      if (result4 < result11 || result11 - result4 < (uint)isTrue1) {\n        result13 = result13 - result1;\n        result12 = result12 | result3;\n        result11 = (result11 - result4) - (uint)!isTrue1;\n      }\n      result5 = result4 >> 1;\n      result1 = (uint)((result4 & 1) != 0) << 0x1f | result1 >> 1;\n      isTrue2 = result1 <= result13;\n      isTrue1 = result11 - result5 < (uint)isTrue2;\n      result14 = result11;\n      if (result5 < result11 || isTrue1) {\n        result13 = result13 - result1;\n        result14 = (result11 - result5) - (uint)!isTrue2;\n      }\n      if (result5 < result11 || isTrue1) {\n        result12 = result12 | result3 >> 1;\n      }\n      result11 = result4 >> 2;\n      result2 = (uint)((result5 & 1) != 0) << 0x1f | result1 >> 1;\n      isTrue2 = result2 <= result13;\n      isTrue1 = result14 - result11 < (uint)isTrue2;\n      result5 = result14;\n      if (result11 < result14 || isTrue1) {\n        result13 = result13 - result2;\n        result5 = (result14 - result11) - (uint)!isTrue2;\n      }\n      if (result11 < result14 || isTrue1) {\n        result12 = result12 | result3 >> 2;\n      }\n      result6 = result4 >> 3;\n      result1 = (uint)((result11 & 1) != 0) << 0x1f | result2 >> 1;\n      isTrue2 = result1 <= result13;\n      isTrue1 = result5 - result6 < (uint)isTrue2;\n      result11 = result5;\n      if (result6 < result5 || isTrue1) {\n        result13 = result13 - result1;\n        result11 = (result5 - result6) - (uint)!isTrue2;\n      }\n      if (result6 < result5 || isTrue1) {\n        result12 = result12 | result3 >> 3;\n      }\n      result14 = result11 | result13;\n      if (result14 == 0) break;\n      result11 = result11 << 4 | result13 >> 0x1c;\n      result13 = result13 << 4;\n      result4 = result4 & 0xfffffff8 | result1 >> 0x1d;\n      result1 = (result2 >> 1) << 3;\n      result3 = result3 >> 4;\n      if (result3 == 0) {\n        result6 = result4;\n        if ((result7 & 0x100000) != 0) goto LAB_0800083a;\n        result7 = result7 | result12;\n        result12 = 0;\n        result3 = 0x80000000;\n      }\n    }\n    if ((result7 & 0x100000) == 0) {\n      result7 = result7 | result12;\n      result12 = 0;\n    }\nLAB_0800083a:\n    isTrue3 = 0xfc < result9;\n    isTrue2 = SBORROW4(result9,0xfd);\n    result4 = result8 + 0x300;\n    isTrue1 = result4 == 0;\n    result3 = result4;\n    if (isTrue3 && !isTrue1) {\n      isTrue3 = 0x6ff < result4;\n      isTrue2 = SBORROW4(result4,0x700);\n      result3 = result8 - 0x400;\n      isTrue1 = result4 == 0x700;\n    }\n    if (!isTrue3 || isTrue1) {\n      isTrue1 = result6 <= result11;\n      if (result11 == result6) {\n        isTrue1 = result1 <= result13;\n      }\n      if (result11 == result6 && result13 == result1) {\n        isTrue1 = (result12 & 1) != 0;\n      }\n      return CONCAT44(result7 + result9 * 0x100000 + (uint)CARRY4(result12,(uint)isTrue1),result12 + isTrue1);\n    }\n  }\n  if (!isTrue1 && (int)result3 < 0 == isTrue2) {\n    return (ulonglong)(result7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  isTrue3 = SCARRY4(result9,0x36);\n  isTrue1 = (int)(result9 + 0x36) < 0;\n  isTrue2 = result9 == 0xffffffca;\n  if (isTrue2 || isTrue1 != isTrue3) {\n    result12 = 0;\n  }\n  if (isTrue2 || isTrue1 != isTrue3) {\n    result7 = result7 & 0x80000000;\n  }\n  if (isTrue2 || isTrue1 != isTrue3) {\n    return CONCAT44(result7,result12);\n  }\n  result3 = -result9;\n  result11 = result3 - 0x20;\n  if (0x1f < (int)result3) {\n    result3 = result12 >> (result11 & 0xff) | result7 << (0x20 - result11 & 0xff);\n    result9 = (result7 >> (result11 & 0xff) & ~((result7 & 0x80000000) >> (result11 & 0xff))) -\n            ((int)result3 >> 0x1f);\n    if ((result14 | result12 << (0x20 - result11 & 0xff) | result3 << 1) == 0) {\n      result9 = result9 & ~(result3 >> 0x1f);\n    }\n    return CONCAT44(result7,result9) & 0x80000000ffffffff;\n  }\n  result8 = result3 - 0x14;\n  if (result8 != 0 && result8 < 0 == SCARRY4(result11,0xc)) {\n    result9 = 0xc - result8;\n    result3 = result12 << (result9 & 0xff);\n    result12 = result12 >> (0x20 - result9 & 0xff) | result7 << (result9 & 0xff);\n    result9 = result12 + -((int)result3 >> 0x1f);\n    if ((result14 | result3 << 1) == 0) {\n      result9 = result9 & ~(result3 >> 0x1f);\n    }\n    return CONCAT44((result7 & 0x80000000) + (uint)CARRY4(result12,-((int)result3 >> 0x1f)),result9);\n  }\n  result11 = result12 << (result9 + 0x20 & 0xff);\n  result12 = result12 >> (result3 & 0xff) | result7 << (result9 + 0x20 & 0xff);\n  result9 = result12 + -((int)result11 >> 0x1f);\n  if ((result14 | result11 << 1) == 0) {\n    result9 = result9 & ~(result11 >> 0x1f);\n  }\n  return CONCAT44((result7 & 0x80000000) +\n                  ((result7 & 0x7fffffff) >> (result3 & 0xff)) +\n                  (uint)CARRY4(result12,-((int)result11 >> 0x1f)),result9);\n}\n\n",
            "renaming": {
                "FUN_0800071c": "decode_float_0800071c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "result3",
                "uVar4": "result4",
                "uVar5": "result5",
                "uVar6": "result6",
                "uVar7": "result7",
                "iVar8": "result8",
                "uVar9": "result9",
                "unaff_r5": "result10",
                "uVar10": "result11",
                "uVar11": "result12",
                "uVar12": "result13",
                "uVar13": "result14",
                "bVar14": "isTrue1",
                "bVar15": "isTrue2",
                "bVar16": "isTrue3"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [
                "FUN_0800088a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800088a": {
            "entrypoint": "0x0800088a",
            "current_name": "decode_float_0800088a",
            "code": "\nulonglong decode_float_0800088a(uint input_u,uint input_v,uint input_x,uint input_y)\n\n{\n  uint bit_u;\n  uint bit_v;\n  uint bit_x;\n  uint bit_y;\n  uint input_flag;\n  bool check_flag;\n  \n  bit_x = input_flag & input_y >> 0x14;\n  bit_y = input_v;\n  if (bit_v != input_flag || bit_x != input_flag) {\n    if (bit_v == input_flag) {\n      if (((input_u | input_v << 0xc) == 0) && (input_u = input_x, bit_y = input_y, bit_x != input_flag)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((input_v ^ input_y) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bit_x == input_flag) {\n      input_u = input_x;\n      bit_y = input_y;\n      if ((input_x | input_y << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((input_v ^ input_y) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      check_flag = (input_u | input_v << 1) == 0;\n      if (!check_flag) {\n        check_flag = (input_x | input_y << 1) == 0;\n      }\n      if (!check_flag) {\n        if (bit_v == 0) {\n          bit_y = input_v & 0x80000000;\n          do {\n            bit_u = input_u & 0x80000000;\n            input_u = input_u << 1;\n            input_v = input_v * 2 + (uint)(bit_u != 0);\n          } while ((input_v & 0x100000) == 0);\n          input_v = input_v | bit_y;\n          if (bit_x != 0) {\n            return CONCAT44(input_v,input_u);\n          }\n        }\n        do {\n          bit_y = input_x & 0x80000000;\n          input_x = input_x << 1;\n          input_y = input_y * 2 + (uint)(bit_y != 0);\n        } while ((input_y & 0x100000) == 0);\n        return CONCAT44(input_v,input_u);\n      }\n      if ((input_u | input_v << 1) != 0) goto LAB_080006fc;\n      if ((input_x | input_y << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(bit_y,input_u) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800088a": "decode_float_0800088a",
                "param_1": "input_u",
                "param_2": "input_v",
                "param_3": "input_x",
                "param_4": "input_y",
                "uVar1": "bit_u",
                "unaff_r4": "bit_v",
                "uVar2": "bit_x",
                "uVar3": "bit_y",
                "in_r12": "input_flag",
                "bVar4": "check_flag"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_inputs_080008fc",
            "code": "\nuint check_inputs_080008fc(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint result;\n  bool isZero;\n  bool isGreaterEqualThanZero;\n  \n  if (((int)(input_2 << 1) >> 0x15 == -1 || (int)(input_4 << 1) >> 0x15 == -1) &&\n     ((((int)(input_2 << 1) >> 0x15 == -1 && ((input_1 | input_2 << 0xc) != 0)) ||\n      (((int)(input_4 << 1) >> 0x15 == -1 && ((input_3 | input_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (input_1 | input_2 << 1) == 0;\n  if (isZero) {\n    isZero = (input_3 | input_4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = input_2 == input_4;\n  }\n  if (isZero) {\n    isZero = input_1 == input_3;\n  }\n  if (!isZero) {\n    result = input_2 ^ input_4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = input_2 == input_4;\n    }\n    isGreaterEqualThanZero = -1 < (int)result && input_4 <= input_2;\n    if (isZero) {\n      isGreaterEqualThanZero = input_3 <= input_1;\n    }\n    input_4 = (int)input_4 >> 0x1f;\n    if (!isGreaterEqualThanZero) {\n      input_4 = ~input_4;\n    }\n    return input_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_inputs_080008fc",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isGreaterEqualThanZero"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000978": {
            "entrypoint": "0x08000978",
            "current_name": "compare_floating_point_08000978",
            "code": "\nvoid compareFloatingPoint_08000978(undefined4 resultFlag,undefined4 operand1,undefined4 operand2,undefined4 tolerance)\n\n{\n  __aeabi_cdcmpeq(operand2,tolerance,resultFlag,operand1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000978": "compare_floating_point_08000978",
                "param_1": "resultFlag",
                "param_2": "operand1",
                "param_3": "operand2",
                "param_4": "tolerance"
            },
            "calling": [
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000988": {
            "entrypoint": "0x08000988",
            "current_name": "convert_to_float_08000988",
            "code": "\nundefined4 convertToFloat_08000988(undefined4 input)\n\n{\n  convertToFloat_08000988Internal();\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000988": "convert_to_float_08000988",
                "param_1": "input",
                "__nedf2": "convertToFloatInternal"
            },
            "calling": [
                "__aeabi_dcmple",
                "__aeabi_dcmpeq",
                "__aeabi_dcmplt",
                "__aeabi_cdrcmple"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "is_cd_comparison_true_08000998",
            "code": "\nbool isCdComparisonTrue_08000998(void)\n\n{\n  char comparisonResult;\n  \n  __aeabi_cdcmpeq();\n  return comparisonResult != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000998": "is_cd_comparison_true_08000998",
                "in_ZR": "comparisonResult"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009ac": {
            "entrypoint": "0x080009ac",
            "current_name": "check_if_zero_080009ac",
            "code": "\nbool checkIfZero_080009ac(void)\n\n{\n  char inputCharacter;\n  \n  __aeabi_cdcmpeq();\n  return inputCharacter == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009ac": "check_if_zero_080009ac",
                "in_CY": "inputCharacter"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c0": {
            "entrypoint": "0x080009c0",
            "current_name": "check_equality_080009c0",
            "code": "\nbool check_equality_080009c0(void)\n\n{\n  undefined is_zero;\n  undefined is_carry;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)is_carry || (bool)is_zero;\n}\n\n",
            "renaming": {
                "FUN_080009c0": "check_equality_080009c0",
                "in_ZR": "is_zero",
                "in_CY": "is_carry"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009d4": {
            "entrypoint": "0x080009d4",
            "current_name": "is_comparison_true_080009d4",
            "code": "\nbool isComparisonTrue_080009d4(void)\n\n{\n  undefined isZeroFlagSet;\n  undefined isCarryFlagSet;\n  \n  __aeabi_cdrcmple();\n  return !(bool)isCarryFlagSet || (bool)isZeroFlagSet;\n}\n\n",
            "renaming": {
                "FUN_080009d4": "is_comparison_true_080009d4",
                "in_ZR": "isZeroFlagSet",
                "in_CY": "isCarryFlagSet"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009e8": {
            "entrypoint": "0x080009e8",
            "current_name": "is_null_string_080009e8",
            "code": "\nbool is_null_string_080009e8(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009e8": "is_null_string_080009e8",
                "in_CY": "input_character"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009fc": {
            "entrypoint": "0x080009fc",
            "current_name": "calculate_float_080009fc",
            "code": "\nuint calculateFloat_080009fc(uint input1,uint input2)\n\n{\n  uint result;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  bool isZero;\n  bool isLessThan;\n  \n  temp1 = input2 * 2;\n  isLessThan = temp1 < 0x70000000;\n  temp2 = temp1 + 0x90000000;\n  result = temp2;\n  if (!isLessThan) {\n    temp3 = temp1 + 0x8fe00000;\n    result = temp3;\n  }\n  isZero = result == 0;\n  if (!isLessThan && temp2 >= 0x200000) {\n    isZero = temp3 == 0x1fc00000;\n  }\n  if (((isLessThan || temp2 < 0x200000) || 0x1fc00000 < temp3) || isZero) {\n    if ((input2 & 0x40000000) != 0) {\n      if (((int)temp1 >> 0x15 == -1) && ((input1 | input2 << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return input2 & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(temp1 + 0x92e00000) < 0 != isCarry(temp2,0x2e00000)) {\n      return input2 & 0x80000000;\n    }\n    temp1 = 0x18 - (temp1 + 0x92e00000 >> 0x15);\n    result = input1 >> (temp1 & 0xff);\n    if (input1 << (0x20 - temp1 & 0xff) != 0) {\n      result = result | 1;\n    }\n    temp2 = input2 & 0x1fffff | 0x100000;\n    input1 = result | temp2 << (0x20 - temp1 & 0xff);\n    temp2 = (temp2 >> (temp1 & 0xff)) << 1;\n  }\n  result = (input2 & 0x80000000 | input1 >> 0x1d) + temp2 * 4 + (uint)(0x7fffffff < input1 * 8);\n  if (input1 * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080009fc": "calculate_float_080009fc",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "in_r12": "temp3",
                "bVar4": "isZero",
                "bVar5": "isLessThan",
                "SCARRY4": "isCarry"
            },
            "calling": [
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa4": {
            "entrypoint": "0x08000aa4",
            "current_name": "calculate_floating_point_value_08000aa4",
            "code": "\nuint calculateFloatingPointValue_08000aa4(uint input,uint epsilon,undefined4 param_3,uint param_4)\n\n{\n  int bitShiftValue1;\n  int bitShiftValue2;\n  uint temp1;\n  uint temp2;\n  uint result1;\n  uint result2;\n  uint difference;\n  bool isEqual;\n  \n  temp1 = epsilon ^ 0x80000000;\n  result1 = input << 1;\n  isEqual = result1 == 0;\n  if (!isEqual) {\n    param_4 = epsilon << 1;\n    isEqual = param_4 == 0;\n  }\n  if (!isEqual) {\n    isEqual = result1 == param_4;\n  }\n  bitShiftValue1 = (int)result1 >> 0x18;\n  if (!isEqual) {\n    isEqual = bitShiftValue1 == -1;\n  }\n  if (!isEqual) {\n    isEqual = (int)param_4 >> 0x18 == -1;\n  }\n  if (isEqual) {\n    bitShiftValue2 = (int)(epsilon << 1) >> 0x18;\n    if (bitShiftValue1 == -1 || bitShiftValue2 == -1) {\n      result1 = temp1;\n      if (bitShiftValue1 == -1) {\n        result1 = input;\n      }\n      if (bitShiftValue1 != -1 || bitShiftValue2 != -1) {\n        temp1 = result1;\n      }\n      isEqual = (result1 & 0x7fffff) == 0;\n      if (isEqual) {\n        isEqual = (temp1 & 0x7fffff) == 0;\n      }\n      if (isEqual) {\n        isEqual = result1 == temp1;\n      }\n      if (!isEqual) {\n        result1 = result1 | 0x400000;\n      }\n      return result1;\n    }\n    if (((input ^ temp1) & 0x7fffffff) != 0) {\n      if (result1 == 0) {\n        input = temp1;\n      }\n      return input;\n    }\n    if (input != temp1) {\n      return 0;\n    }\n    if ((result1 & 0xff000000) == 0) {\n      temp1 = input << 1;\n      if ((input & 0x80000000) != 0) {\n        temp1 = temp1 | 0x80000000;\n      }\n      return temp1;\n    }\n    if (result1 < 0xfe000000) {\n      return input + 0x800000;\n    }\n    input = input & 0x80000000;\nLAB_08000bde:\n    return input | 0x7f800000;\n  }\n  result1 = result1 >> 0x18;\n  param_4 = param_4 >> 0x18;\n  difference = param_4 - result1;\n  isEqual = difference != 0;\n  result2 = result1;\n  if (isEqual && result1 <= param_4) {\n    result2 = result1 + difference;\n  }\n  if (isEqual && result1 <= param_4) {\n    temp1 = temp1 ^ input;\n  }\n  if (isEqual && result1 <= param_4) {\n    input = input ^ temp1;\n  }\n  if (isEqual && result1 <= param_4) {\n    temp1 = temp1 ^ input;\n  }\n  if (param_4 < result1) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input;\n  }\n  result1 = input & 0xffffff | 0x800000;\n  if ((input & 0x80000000) != 0) {\n    result1 = -result1;\n  }\n  temp2 = temp1 & 0xffffff | 0x800000;\n  if ((temp1 & 0x80000000) != 0) {\n    temp2 = -temp2;\n  }\n  if (result2 == difference) {\n    temp2 = temp2 ^ 0x800000;\n    if (result2 == 0) {\n      result1 = result1 ^ 0x800000;\n      result2 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  result1 = result1 + ((int)temp2 >> (difference & 0xff));\n  temp2 = temp2 << (0x20 - difference & 0xff);\n  input = result1 & 0x80000000;\n  if ((int)result1 < 0) {\n    isEqual = temp2 != 0;\n    temp2 = -temp2;\n    result1 = -result1 - (uint)isEqual;\n  }\n  if (result1 < 0x800000) {\n    temp1 = temp2 & 0x80000000;\n    temp2 = temp2 << 1;\n    result1 = result1 * 2 + (uint)(temp1 != 0);\n    temp1 = result2 - 2;\n    if ((result1 & 0x800000) == 0) {\n      difference = LZCOUNT(result1) - 8;\n      result1 = result1 << (difference & 0xff);\n      if ((int)temp1 < (int)difference) {\n        result1 = result1 >> (-(temp1 - difference) & 0xff);\n      }\n      else {\n        result1 = result1 + (temp1 - difference) * 0x800000;\n      }\n      return result1 | input;\n    }\n  }\n  else {\n    temp1 = result2 - 1;\n    if (0xffffff < result1) {\n      temp1 = result1 & 1;\n      result1 = result1 >> 1;\n      temp2 = (uint)(temp1 != 0) << 0x1f | temp2 >> 1;\n      temp1 = result2;\n      if (0xfd < result2) goto LAB_08000bde;\n    }\n  }\n  result1 = result1 + temp1 * 0x800000 + (uint)(0x7fffffff < temp2);\n  if (temp2 == 0x80000000) {\n    result1 = result1 & 0xfffffffe;\n  }\n  return result1 | input;\n}\n\n",
            "renaming": {
                "FUN_08000aa4": "calculate_floating_point_value_08000aa4",
                "param_1": "input",
                "param_2": "epsilon",
                "iVar1": "bitShiftValue1",
                "iVar2": "bitShiftValue2",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "result1",
                "uVar6": "result2",
                "uVar7": "difference",
                "bVar8": "isEqual"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_floating_point_value_08000aa8",
            "code": "\nuint calculateFloatingPointValue_08000aa8(uint inputValue1,uint inputValue2,undefined4 undefinedValue,uint controlValue)\n\n{\n  int shiftedValue1;\n  int shiftedValue2;\n  uint absValue1;\n  uint result;\n  uint remainingShift;\n  uint absValueDiff;\n  bool comparisonResult;\n  \n  result = inputValue1 << 1;\n  comparisonResult = result == 0;\n  if (!comparisonResult) {\n    controlValue = inputValue2 << 1;\n    comparisonResult = controlValue == 0;\n  }\n  if (!comparisonResult) {\n    comparisonResult = result == controlValue;\n  }\n  shiftedValue1 = (int)result >> 0x18;\n  if (!comparisonResult) {\n    comparisonResult = shiftedValue1 == -1;\n  }\n  if (!comparisonResult) {\n    comparisonResult = (int)controlValue >> 0x18 == -1;\n  }\n  if (comparisonResult) {\n    shiftedValue2 = (int)(inputValue2 << 1) >> 0x18;\n    if (shiftedValue1 == -1 || shiftedValue2 == -1) {\n      result = inputValue2;\n      if (shiftedValue1 == -1) {\n        result = inputValue1;\n      }\n      if (shiftedValue1 != -1 || shiftedValue2 != -1) {\n        inputValue2 = result;\n      }\n      comparisonResult = (result & 0x7fffff) == 0;\n      if (comparisonResult) {\n        comparisonResult = (inputValue2 & 0x7fffff) == 0;\n      }\n      if (comparisonResult) {\n        comparisonResult = result == inputValue2;\n      }\n      if (!comparisonResult) {\n        result = result | 0x400000;\n      }\n      return result;\n    }\n    if (((inputValue1 ^ inputValue2) & 0x7fffffff) != 0) {\n      if (result == 0) {\n        inputValue1 = inputValue2;\n      }\n      return inputValue1;\n    }\n    if (inputValue1 != inputValue2) {\n      return 0;\n    }\n    if ((result & 0xff000000) == 0) {\n      result = inputValue1 << 1;\n      if ((inputValue1 & 0x80000000) != 0) {\n        result = result | 0x80000000;\n      }\n      return result;\n    }\n    if (result < 0xfe000000) {\n      return inputValue1 + 0x800000;\n    }\n    inputValue1 = inputValue1 & 0x80000000;\nLAB_08000bde:\n    return inputValue1 | 0x7f800000;\n  }\n  result = result >> 0x18;\n  controlValue = controlValue >> 0x18;\n  absValueDiff = controlValue - result;\n  comparisonResult = absValueDiff != 0;\n  remainingShift = result;\n  if (comparisonResult && result <= controlValue) {\n    remainingShift = result + absValueDiff;\n  }\n  if (comparisonResult && result <= controlValue) {\n    inputValue2 = inputValue2 ^ inputValue1;\n  }\n  if (comparisonResult && result <= controlValue) {\n    inputValue1 = inputValue1 ^ inputValue2;\n  }\n  if (comparisonResult && result <= controlValue) {\n    inputValue2 = inputValue2 ^ inputValue1;\n  }\n  if (controlValue < result) {\n    absValueDiff = -absValueDiff;\n  }\n  if (0x19 < absValueDiff) {\n    return inputValue1;\n  }\n  result = inputValue1 & 0xffffff | 0x800000;\n  if ((inputValue1 & 0x80000000) != 0) {\n    result = -result;\n  }\n  absValue1 = inputValue2 & 0xffffff | 0x800000;\n  if ((inputValue2 & 0x80000000) != 0) {\n    absValue1 = -absValue1;\n  }\n  if (remainingShift == absValueDiff) {\n    absValue1 = absValue1 ^ 0x800000;\n    if (remainingShift == 0) {\n      result = result ^ 0x800000;\n      remainingShift = 1;\n    }\n    else {\n      absValueDiff = absValueDiff - 1;\n    }\n  }\n  result = result + ((int)absValue1 >> (absValueDiff & 0xff));\n  absValue1 = absValue1 << (0x20 - absValueDiff & 0xff);\n  inputValue1 = result & 0x80000000;\n  if ((int)result < 0) {\n    comparisonResult = absValue1 != 0;\n    absValue1 = -absValue1;\n    result = -result - (uint)comparisonResult;\n  }\n  if (result < 0x800000) {\n    absValueDiff = absValue1 & 0x80000000;\n    absValue1 = absValue1 << 1;\n    result = result * 2 + (uint)(absValueDiff != 0);\n    absValueDiff = remainingShift - 2;\n    if ((result & 0x800000) == 0) {\n      remainingShift = LZCOUNT(result) - 8;\n      result = result << (remainingShift & 0xff);\n      if ((int)absValueDiff < (int)remainingShift) {\n        result = result >> (-(absValueDiff - remainingShift) & 0xff);\n      }\n      else {\n        result = result + (absValueDiff - remainingShift) * 0x800000;\n      }\n      return result | inputValue1;\n    }\n  }\n  else {\n    absValueDiff = remainingShift - 1;\n    if (0xffffff < result) {\n      absValueDiff = result & 1;\n      result = result >> 1;\n      absValue1 = (uint)(absValueDiff != 0) << 0x1f | absValue1 >> 1;\n      absValueDiff = remainingShift;\n      if (0xfd < remainingShift) goto LAB_08000bde;\n    }\n  }\n  result = result + absValueDiff * 0x800000 + (uint)(0x7fffffff < absValue1);\n  if (absValue1 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result | inputValue1;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_floating_point_value_08000aa8",
                "param_1": "inputValue1",
                "param_2": "inputValue2",
                "param_3": "undefinedValue",
                "param_4": "controlValue",
                "iVar1": "shiftedValue1",
                "iVar2": "shiftedValue2",
                "uVar3": "absValue1",
                "uVar4": "result",
                "uVar5": "remainingShift",
                "uVar6": "absValueDiff",
                "bVar7": "comparisonResult"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calibrate"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c08": {
            "entrypoint": "0x08000c08",
            "current_name": "calculate_threshold_08000c08",
            "code": "\nuint calculateThreshold_08000c08(uint inputValue)\n\n{\n  uint leadingZeros;\n  uint shiftValue;\n  int offsetValue;\n  uint comparisonValue;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeros = LZCOUNT(inputValue);\n  shiftValue = leadingZeros - 8;\n  offsetValue = shiftValue * -0x800000 + 0x4a800000;\n  if (7 < leadingZeros) {\n    comparisonValue = 0 << (shiftValue & 0xff);\n    leadingZeros = offsetValue + (inputValue << (shiftValue & 0xff)) +\n            (0U >> (0x20 - shiftValue & 0xff)) + (uint)(0x7fffffff < comparisonValue);\n    if (comparisonValue == 0x80000000) {\n      leadingZeros = leadingZeros & 0xfffffffe;\n    }\n    return leadingZeros;\n  }\n  shiftValue = inputValue << leadingZeros + 0x18;\n  leadingZeros = offsetValue + ((inputValue >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftValue >> 0x1f));\n  if ((shiftValue & 0x7fffffff) == 0) {\n    leadingZeros = leadingZeros & ~(shiftValue >> 0x1f);\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_08000c08": "calculate_threshold_08000c08",
                "param_1": "inputValue",
                "uVar1": "leadingZeros",
                "uVar2": "shiftValue",
                "iVar3": "offsetValue",
                "uVar4": "comparisonValue"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c10": {
            "entrypoint": "0x08000c10",
            "current_name": "reverse_and_modify_08000c10",
            "code": "\nuint reverseAndModify_08000c10(uint inputValue)\n\n{\n  uint leadingZeros;\n  uint shiftAmount;\n  uint flag;\n  int result;\n  \n  flag = inputValue & 0x80000000;\n  if ((int)flag < 0) {\n    inputValue = -inputValue;\n  }\n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeros = countLeadingZeros(inputValue);\n  shiftAmount = leadingZeros - 8;\n  result = ((flag | 0x4b000000) - 0x800000) + shiftAmount * -0x800000;\n  if (7 < leadingZeros) {\n    leadingZeros = 0 << (shiftAmount & 0xff);\n    flag = result + (inputValue << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < leadingZeros);\n    if (leadingZeros == 0x80000000) {\n      flag = flag & 0xfffffffe;\n    }\n    return flag;\n  }\n  shiftAmount = inputValue << leadingZeros + 0x18;\n  flag = result + ((inputValue >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    flag = flag & ~(shiftAmount >> 0x1f);\n  }\n  return flag;\n}\n\n",
            "renaming": {
                "FUN_08000c10": "reverse_and_modify_08000c10",
                "param_1": "inputValue",
                "uVar1": "leadingZeros",
                "uVar2": "shiftAmount",
                "uVar3": "flag",
                "iVar4": "result",
                "LZCOUNT": "countLeadingZeros"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_update",
                "mpu6050_calibrate"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cb8": {
            "entrypoint": "0x08000cb8",
            "current_name": "calculate_floating_point_08000cb8",
            "code": "\nuint calculateFloatingPoint_08000cb8(uint value1,uint value2,undefined4 someFlag,uint anotherFlag)\n\n{\n  longlong temp1;\n  uint result;\n  uint byte1;\n  int sum;\n  int diff;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  bool isTrue;\n  bool isOverflow;\n  \n  byte1 = value1 >> 0x17 & 0xff;\n  isTrue = byte1 == 0;\n  if (!isTrue) {\n    anotherFlag = value2 >> 0x17 & 0xff;\n    isTrue = anotherFlag == 0;\n  }\n  if (!isTrue) {\n    isTrue = byte1 == 0xff;\n  }\n  if (!isTrue) {\n    isTrue = anotherFlag == 0xff;\n  }\n  if (isTrue) {\n    anotherFlag = value2 >> 0x17 & 0xff;\n    if (byte1 == 0xff || anotherFlag == 0xff) {\n      isTrue = value1 == 0 || value1 == 0x80000000;\n      result = value2;\n      if (value1 != 0 && value1 != 0x80000000) {\n        isTrue = value2 == 0;\n        result = value1;\n      }\n      if (!isTrue) {\n        isTrue = value2 == 0x80000000;\n      }\n      temp4 = result;\n      if (((isTrue) || ((byte1 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((anotherFlag == 0xff && (temp4 = value2, (value2 & 0x7fffff) != 0)))) {\n        return temp4 | 0x7fc00000;\n      }\n      result = result ^ value2;\n      goto LAB_08000e08;\n    }\n    isTrue = (value1 & 0x7fffffff) == 0;\n    if (!isTrue) {\n      isTrue = (value2 & 0x7fffffff) == 0;\n    }\n    if (isTrue) {\n      return (value1 ^ value2) & 0x80000000;\n    }\n    isTrue = byte1 == 0;\n    result = value1 & 0x80000000;\n    while( true ) {\n      if (isTrue) {\n        value1 = value1 << 1;\n        isTrue = (value1 & 0x800000) == 0;\n      }\n      if (!isTrue) break;\n      byte1 = byte1 - 1;\n    }\n    value1 = value1 | result;\n    isTrue = anotherFlag == 0;\n    result = value2 & 0x80000000;\n    while( true ) {\n      if (isTrue) {\n        value2 = value2 << 1;\n        isTrue = (value2 & 0x800000) == 0;\n      }\n      if (!isTrue) break;\n      anotherFlag = anotherFlag - 1;\n    }\n    value2 = value2 | result;\n  }\n  sum = byte1 + anotherFlag;\n  temp4 = value1 ^ value2;\n  byte1 = value1 << 9;\n  isTrue = byte1 == 0;\n  if (!isTrue) {\n    value2 = value2 << 9;\n    isTrue = value2 == 0;\n  }\n  if (isTrue) {\n    if (byte1 == 0) {\n      value2 = value2 << 9;\n    }\n    result = temp4 & 0x80000000 | value1 & 0x7fffff | value2 >> 9;\n    isOverflow = SBORROW4(sum,0x7f);\n    diff = sum + -0x7f;\n    isTrue = diff == 0;\n    temp3 = diff;\n    if (!isTrue && 0x7e < sum) {\n      isOverflow = SBORROW4(0xff,diff);\n      temp3 = 0xff - diff;\n      isTrue = diff == 0xff;\n    }\n    if (!isTrue && temp3 < 0 == isOverflow) {\n      result = result | diff * 0x800000;\n    }\n    if (!isTrue && temp3 < 0 == isOverflow) {\n      return result;\n    }\n    result = result | 0x800000;\n    temp2 = 0;\n    isOverflow = SBORROW4(diff,1);\n    temp4 = sum - 0x80;\n    isTrue = temp4 == 0;\n    byte1 = temp4;\n  }\n  else {\n    temp1 = (ulonglong)(byte1 >> 5 | 0x8000000) * (ulonglong)(value2 >> 5 | 0x8000000);\n    temp2 = (uint)temp1;\n    result = (uint)((ulonglong)temp1 >> 0x20);\n    isTrue = result < 0x800000;\n    if (isTrue) {\n      result = result << 1;\n    }\n    if (isTrue) {\n      result = result | temp2 >> 0x1f;\n      temp2 = temp2 << 1;\n    }\n    result = temp4 & 0x80000000 | result;\n    temp4 = (sum + -0x7f) - (uint)isTrue;\n    isOverflow = SBORROW4(temp4,0xfd);\n    isTrue = temp4 == 0xfd;\n    byte1 = temp4 - 0xfd;\n    if (temp4 < 0xfe) {\n      result = result + temp4 * 0x800000 + (uint)(0x7fffffff < temp2);\n      if (temp2 == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isTrue || (int)byte1 < 0 != isOverflow) {\n    isTrue = (int)(temp4 + 0x19) < 0;\n    if (temp4 == 0xffffffe7 || isTrue != SCARRY4(temp4,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (temp4 != 0xffffffe7 && isTrue == SCARRY4(temp4,0x19)) {\n      byte1 = (result << 1) >> (-temp4 & 0xff);\n      temp4 = result << (temp4 + 0x20 & 0xff);\n      byte1 = ((uint)((result & 0x80000000) != 0) << 0x1f | byte1 >> 1) + (uint)((byte)byte1 & 1);\n      if ((temp2 | temp4 << 1) == 0) {\n        byte1 = byte1 & ~(temp4 >> 0x1f);\n      }\n      return byte1;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cb8": "calculate_floating_point_08000cb8",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "someFlag",
                "param_4": "anotherFlag",
                "lVar1": "temp1",
                "uVar2": "result",
                "uVar3": "byte1",
                "iVar4": "sum",
                "iVar5": "diff",
                "uVar6": "temp2",
                "iVar7": "temp3",
                "uVar8": "temp4",
                "bVar9": "isTrue",
                "bVar10": "isOverflow"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e20": {
            "entrypoint": "0x08000e20",
            "current_name": "float_to_uint_08000e20",
            "code": "\nuint floatToUint_08000e20(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  uint result1;\n  uint result2;\n  int diff;\n  uint sum;\n  int temp;\n  uint finalResult;\n  bool isZero;\n  bool isNegative;\n  bool overflow;\n  \n  result2 = input1 >> 0x17 & 0xff;\n  isZero = result2 == 0;\n  if (!isZero) {\n    input4 = input2 >> 0x17 & 0xff;\n    isZero = input4 == 0;\n  }\n  if (!isZero) {\n    isZero = result2 == 0xff;\n  }\n  if (!isZero) {\n    isZero = input4 == 0xff;\n  }\n  if (isZero) {\n    input4 = input2 >> 0x17 & 0xff;\n    finalResult = input1;\n    if (result2 == 0xff) {\n      if (((input1 & 0x7fffff) != 0) || (finalResult = input2, input4 == 0xff)) {\nLAB_08000e16:\n        return finalResult | 0x7fc00000;\n      }\n    }\n    else {\n      if (input4 == 0xff) {\n        finalResult = input2;\n        if ((input2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (input1 ^ input2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      isZero = (input1 & 0x7fffffff) == 0;\n      if (!isZero) {\n        isZero = (input2 & 0x7fffffff) == 0;\n      }\n      if (!isZero) {\n        isZero = result2 == 0;\n        finalResult = input1 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            input1 = input1 << 1;\n            isZero = (input1 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          result2 = result2 - 1;\n        }\n        input1 = input1 | finalResult;\n        isZero = input4 == 0;\n        finalResult = input2 & 0x80000000;\n        while( true ) {\n          if (isZero) {\n            input2 = input2 << 1;\n            isZero = (input2 & 0x800000) == 0;\n          }\n          if (!isZero) break;\n          input4 = input4 - 1;\n        }\n        input2 = input2 | finalResult;\n        goto LAB_08000e38;\n      }\n      if ((input1 & 0x7fffffff) == 0) {\n        if ((input2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    input1 = input1 ^ input2;\n  }\n  else {\nLAB_08000e38:\n    diff = result2 - input4;\n    if (input2 << 9 == 0) {\n      input1 = (input1 ^ input2) & 0x80000000 | input1 & 0x7fffff;\n      overflow = SCARRY4(diff,0x7f);\n      temp = diff + 0x7f;\n      isZero = temp < 0;\n      isNegative = temp == 0;\n      if (!isNegative && isZero == overflow) {\n        overflow = SBORROW4(0xff,temp);\n        isZero = 0xff - temp < 0;\n        isNegative = temp == 0xff;\n      }\n      if (!isNegative && isZero == overflow) {\n        input1 = input1 | temp * 0x800000;\n      }\n      if (!isNegative && isZero == overflow) {\n        return input1;\n      }\n      input1 = input1 | 0x800000;\n      result2 = 0;\n      isNegative = SBORROW4(temp,1);\n      sum = diff + 0x7e;\n      isZero = sum == 0;\n      finalResult = sum;\n    }\n    else {\n      result1 = (input2 << 9) >> 4 | 0x10000000;\n      result2 = (input1 << 9) >> 4 | 0x10000000;\n      input1 = (input1 ^ input2) & 0x80000000;\n      isZero = result1 <= result2;\n      if (!isZero) {\n        result2 = result2 << 1;\n      }\n      sum = diff + 0x7d + (uint)isZero;\n      finalResult = 0x800000;\n      do {\n        if (result1 <= result2) {\n          result2 = result2 - result1;\n          input1 = input1 | finalResult;\n        }\n        isZero = result1 >> 1 <= result2;\n        if (isZero) {\n          result2 = result2 - (result1 >> 1);\n        }\n        if (isZero) {\n          input1 = input1 | finalResult >> 1;\n        }\n        isZero = result1 >> 2 <= result2;\n        if (isZero) {\n          result2 = result2 - (result1 >> 2);\n        }\n        if (isZero) {\n          input1 = input1 | finalResult >> 2;\n        }\n        isZero = result1 >> 3 <= result2;\n        if (isZero) {\n          result2 = result2 - (result1 >> 3);\n        }\n        if (isZero) {\n          input1 = input1 | finalResult >> 3;\n        }\n        result2 = result2 * 0x10;\n        isZero = result2 == 0;\n        if (!isZero) {\n          finalResult = finalResult >> 4;\n          isZero = finalResult == 0;\n        }\n      } while (!isZero);\n      isNegative = SBORROW4(sum,0xfd);\n      isZero = sum == 0xfd;\n      finalResult = sum - 0xfd;\n      if (sum < 0xfe) {\n        input1 = input1 + sum * 0x800000 + (uint)(result1 <= result2);\n        if (result2 - result1 == 0) {\n          input1 = input1 & 0xfffffffe;\n        }\n        return input1;\n      }\n    }\n    if (isZero || (int)finalResult < 0 != isNegative) {\n      isZero = (int)(sum + 0x19) < 0;\n      if (sum == 0xffffffe7 || isZero != SCARRY4(sum,0x19)) {\n        input1 = input1 & 0x80000000;\n      }\n      if (sum == 0xffffffe7 || isZero != SCARRY4(sum,0x19)) {\n        return input1;\n      }\n      finalResult = (input1 << 1) >> (-sum & 0xff);\n      sum = input1 << (sum + 0x20 & 0xff);\n      finalResult = ((uint)((input1 & 0x80000000) != 0) << 0x1f | finalResult >> 1) + (uint)((byte)finalResult & 1);\n      if ((result2 | sum << 1) == 0) {\n        finalResult = finalResult & ~(sum >> 0x1f);\n      }\n      return finalResult;\n    }\n  }\n  return input1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e20": "float_to_uint_08000e20",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result1",
                "uVar2": "result2",
                "iVar3": "diff",
                "uVar4": "sum",
                "iVar5": "temp",
                "uVar6": "finalResult",
                "bVar7": "isZero",
                "bVar8": "isNegative",
                "bVar9": "overflow"
            },
            "calling": [
                "mpu6050_calibrate",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f68": {
            "entrypoint": "0x08000f68",
            "current_name": "check_overflow_condition_08000f68",
            "code": "\nuint check_overflow_condition_08000f68(uint input_1,uint input_2)\n\n{\n  bool overflow_check;\n  uint input_1_doubled;\n  uint input_2_doubled;\n  uint combined;\n  bool combined_is_zero;\n  \n  input_1_doubled = input_1 * 2;\n  input_2_doubled = input_2 * 2;\n  if (((int)input_1_doubled >> 0x18 == -1 || (int)input_2_doubled >> 0x18 == -1) &&\n     ((((int)input_1_doubled >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)input_2_doubled >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    result 1;\n  }\n  combined = input_1_doubled | input_2 & 0x7fffffff;\n  combined_is_zero = combined == 0;\n  if (!combined_is_zero) {\n    combined = input_1 ^ input_2;\n    combined_is_zero = combined == 0;\n  }\n  overflow_check = -1 < (int)combined;\n  if (overflow_check) {\n    input_1 = input_1_doubled + input_2 * -2;\n    combined_is_zero = input_1 == 0;\n  }\n  if ((overflow_check && input_2_doubled <= input_1_doubled) && !combined_is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!overflow_check || input_2_doubled > input_1_doubled) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!combined_is_zero) {\n    input_1 = input_1 | 1;\n  }\n  result input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f68": "check_overflow_condition_08000f68",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "overflow_check",
                "uVar2": "input_1_doubled",
                "uVar3": "input_2_doubled",
                "uVar4": "combined",
                "bVar5": "combined_is_zero",
                "return": "result"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fc8": {
            "entrypoint": "0x08000fc8",
            "current_name": "compare_float_values_08000fc8",
            "code": "\nvoid compareFloatValues_08000fc8(undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cfcmpeq(value2,value1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fc8": "compare_float_values_08000fc8",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "__aeabi_fcmpgt"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fd0": {
            "entrypoint": "0x08000fd0",
            "current_name": "concatenate_parameters_08000fd0",
            "code": "\nundefined8 concatenateParameters_08000fd0(undefined4 input1,undefined4 input2)\n\n{\n  __cmpsf2();\n  return CONCAT44(input2,input1);\n}\n\n",
            "renaming": {
                "FUN_08000fd0": "concatenate_parameters_08000fd0",
                "param_1": "input1",
                "param_2": "input2"
            },
            "calling": [
                "__aeabi_cfrcmple",
                "__aeabi_fcmplt"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ff4": {
            "entrypoint": "0x08000ff4",
            "current_name": "is_cy_null_08000ff4",
            "code": "\nbool is_CY_null_08000ff4(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfcmpeq();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000ff4": "is_cy_null_08000ff4",
                "in_CY": "input_char"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001030": {
            "entrypoint": "0x08001030",
            "current_name": "is_zero_check_08001030",
            "code": "\nbool is_zero_check_08001030(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001030": "is_zero_check_08001030",
                "in_CY": "input_character"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001044": {
            "entrypoint": "0x08001044",
            "current_name": "check_value_08001044",
            "code": "\nuint checkValue_08001044(uint value)\n\n{\n  uint shiftCount;\n  \n  if (((value & 0x80000000) != 0) || (value << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shiftCount = 0x9e - ((value << 1) >> 0x18);\n  if (-1 < (int)shiftCount) {\n    return (value << 8 | 0x80000000) >> (shiftCount & 0xff);\n  }\n  if ((shiftCount == 0xffffff9f) && ((value & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08001044": "check_value_08001044",
                "param_1": "value",
                "uVar1": "shiftCount"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001084": {
            "entrypoint": "0x08001084",
            "current_name": "copy_memory_08001084",
            "code": "\nundefined4 * copyMemory_08001084(undefined4 *destination,undefined4 *source,uint size)\n\n{\n  undefined4 *destPtr;\n  undefined4 *dest;\n  undefined4 *src;\n  uint remainingSize;\n  uint tempSize;\n  bool isRemaining;\n  \n  dest = destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      tempSize = size - 4;\n      if (3 < size) {\n        do {\n          destPtr = source;\n          src = dest;\n          isRemaining = tempSize != 0;\n          tempSize = tempSize - 1;\n          *(undefined *)src = *(undefined *)destPtr;\n          dest = (undefined4 *)((int)src + 1);\n          source = (undefined4 *)((int)destPtr + 1);\n        } while (isRemaining);\n        *(undefined *)(undefined4 *)((int)src + 1) =\n             *(undefined *)(undefined4 *)((int)destPtr + 1);\n        *(undefined *)((int)src + 2) = *(undefined *)((int)destPtr + 2);\n        *(undefined *)((int)src + 3) = *(undefined *)((int)destPtr + 3);\n        return destination;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      tempSize = 4 - ((uint)destination & 3);\n      size = size - tempSize;\n      destPtr = destination;\n      src = source;\n      if (((uint)destination & 1) != 0) {\n        src = (undefined4 *)((int)source + 1);\n        destPtr = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *(undefined *)source;\n      }\n      dest = destPtr;\n      source = src;\n      if ((tempSize & 2) != 0) {\n        source = (undefined4 *)((int)src + 2);\n        dest = (undefined4 *)((int)destPtr + 2);\n        *(undefined2 *)destPtr = *(undefined2 *)src;\n      }\n    }\n  }\n  while (0x3f < size) {\n    *dest = *source;\n    dest[1] = source[1];\n    dest[2] = source[2];\n    dest[3] = source[3];\n    dest[4] = source[4];\n    dest[5] = source[5];\n    dest[6] = source[6];\n    dest[7] = source[7];\n    dest[8] = source[8];\n    dest[9] = source[9];\n    dest[10] = source[10];\n    dest[0xb] = source[0xb];\n    dest[0xc] = source[0xc];\n    dest[0xd] = source[0xd];\n    dest[0xe] = source[0xe];\n    dest[0xf] = source[0xf];\n    dest = dest + 0x10;\n    source = source + 0x10;\n    size = size - 0x40;\n  }\n  remainingSize = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n      *dest = *source;\n      dest[1] = source[1];\n      dest[2] = source[2];\n      dest[3] = source[3];\n      dest = dest + 4;\n      source = source + 4;\n      isRemaining = 0xf < remainingSize;\n      remainingSize = remainingSize - 0x10;\n    } while (isRemaining);\n  }\n  tempSize = remainingSize + 0xc;\n  src = dest;\n  destPtr = source;\n  if (0xfffffff3 < remainingSize) {\n    do {\n      source = destPtr + 1;\n      *src = *destPtr;\n      isRemaining = 3 < tempSize;\n      tempSize = tempSize - 4;\n      dest = src + 1;\n      src = src + 1;\n      destPtr = source;\n    } while (isRemaining);\n  }\nLAB_08001108:\n  if (tempSize + 4 != 0) {\n    destPtr = dest;\n    src = source;\n    if ((tempSize & 1) != 0) {\n      src = (undefined4 *)((int)source + 1);\n      destPtr = (undefined4 *)((int)dest + 1);\n      *(undefined *)dest = *(undefined *)source;\n    }\n    if ((tempSize + 4 & 2) != 0) {\n      *(undefined2 *)destPtr = *(undefined2 *)src;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "puVar1": "destPtr",
                "puVar2": "dest",
                "puVar3": "src",
                "uVar4": "remainingSize",
                "uVar5": "tempSize",
                "bVar6": "isRemaining"
            },
            "calling": [
                "_dtoa_r",
                "__ssprint_r",
                "__multadd"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "check_params_08001170",
            "code": "\nundefined4 checkParams_08001170(uint value1,int value2,uint value3,int value4)\n\n{\n  if ((((value2 << 1) >> 0x15 != -1) || ((value1 | value2 << 0xc) == 0)) &&\n     (((value4 << 1) >> 0x15 != -1 || ((value3 | value4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001170": "check_params_08001170",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800119c": {
            "entrypoint": "0x0800119c",
            "current_name": "calculate_inverse_0800119c",
            "code": "\nuint calculateInverse_0800119c(uint input1,uint input2)\n\n{\n  uint result;\n  int tempVar;\n  uint shiftAmount;\n  \n  tempVar = input2 * 2 + 0x200000;\n  if (input2 * 2 < 0xffe00000) {\n    if (-1 < tempVar) {\n      return 0;\n    }\n    result = tempVar >> 0x15;\n    shiftAmount = -result - 0x3e1;\n    if (result < 0xfffffc20 && shiftAmount != 0) {\n      result = (input2 << 0xb | 0x80000000 | input1 >> 0x15) >> (shiftAmount & 0xff);\n      if ((input2 & 0x80000000) != 0) {\n        result = -result;\n      }\n      return result;\n    }\n  }\n  else if ((input1 | input2 << 0xc) != 0) {\n    return 0;\n  }\n  input2 = input2 & 0x80000000;\n  if (input2 == 0) {\n    input2 = 0x7fffffff;\n  }\n  return input2;\n}\n\n",
            "renaming": {
                "FUN_0800119c": "calculate_inverse_0800119c",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result",
                "iVar2": "tempVar",
                "uVar3": "shiftAmount"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011ec": {
            "entrypoint": "0x080011ec",
            "current_name": "calculate_division_080011ec",
            "code": "\nundefined8 calculateDivision_080011ec(int dividend,int divisor,int unusedParam,int unusedParam2)\n\n{\n  undefined8 quotient;\n  \n  if ((unusedParam2 == 0) && (unusedParam == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      divisor = -1;\n      dividend = -1;\n    }\n    return combineIntegers(divisor,dividend);\n  }\n  quotient = __udivmoddi4();\n  return quotient;\n}\n\n",
            "renaming": {
                "FUN_080011ec": "calculate_division_080011ec",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "unusedParam",
                "param_4": "unusedParam2",
                "uVar1": "quotient",
                "CONCAT44": "combineIntegers"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800121c": {
            "entrypoint": "0x0800121c",
            "current_name": "calculate_division_0800121c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 calculateDivision_0800121c(uint dividend,uint divisor,uint quotient,uint remainder,uint *result)\n\n{\n  code *jumpTable;\n  ulonglong partialProduct;\n  uint partialQuotient1;\n  uint partialQuotient2;\n  uint partialQuotient3;\n  int shiftAmount;\n  uint quotientResult;\n  uint temp1;\n  uint temp2;\n  uint *puVar9;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  bool isCarry;\n  undefined8 partialProduct4;\n  \n  if (remainder == 0) {\n    if (divisor < quotient) {\n      shiftAmount = LZCOUNT(quotient);\n      temp1 = quotient;\n      if (shiftAmount != 0) {\n        temp1 = quotient << shiftAmount;\n        divisor = dividend >> (0x20U - shiftAmount & 0xff) | divisor << shiftAmount;\n        dividend = dividend << shiftAmount;\n      }\n      temp4 = temp1 >> 0x10;\n      temp2 = divisor / temp4;\n      temp3 = temp2 * (temp1 & 0xffff);\n      quotientResult = dividend >> 0x10 | (divisor - temp4 * temp2) * 0x10000;\n      partialQuotient2 = temp2;\n      if (quotientResult <= temp3 && temp3 - quotientResult != 0) {\n        isCarry = CARRY4(temp1,quotientResult);\n        quotientResult = temp1 + quotientResult;\n        partialQuotient2 = temp2 - 1;\n        if ((isCarry == false) && (quotientResult <= temp3 && temp3 - quotientResult != 0)) {\n          partialQuotient2 = temp2 - 2;\n          quotientResult = quotientResult + temp1;\n        }\n      }\n      partialQuotient1 = (quotientResult - temp3) / temp4;\n      partialQuotient3 = partialQuotient1 * (temp1 & 0xffff);\n      temp2 = dividend & 0xffff | ((quotientResult - temp3) - temp4 * partialQuotient1) * 0x10000;\n      quotientResult = partialQuotient1;\n      if (temp2 <= partialQuotient3 && partialQuotient3 - temp2 != 0) {\n        isCarry = CARRY4(temp1,temp2);\n        temp2 = temp1 + temp2;\n        quotientResult = partialQuotient1 - 1;\n        if ((isCarry == false) && (temp2 <= partialQuotient3 && partialQuotient3 - temp2 != 0)) {\n          quotientResult = partialQuotient1 - 2;\n          temp2 = temp2 + temp1;\n        }\n      }\n      quotientResult = quotientResult | partialQuotient2 << 0x10;\n      puVar9 = (uint *)0x0;\n      temp2 = temp2 - partialQuotient3;\n    }\n    else {\n      if (quotient == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        jumpTable = (code *)software_udf(0xff,0x8001302);\n        partialProduct4 = (*jumpTable)();\n        return partialProduct4;\n      }\n      shiftAmount = LZCOUNT(quotient);\n      if (shiftAmount == 0) {\n        puVar9 = (uint *)0x1;\n        divisor = divisor - quotient;\n        temp4 = quotient >> 0x10;\n        partialQuotient1 = quotient & 0xffff;\n        temp1 = quotient;\n      }\n      else {\n        temp1 = quotient << shiftAmount;\n        quotientResult = divisor >> (0x20U - shiftAmount & 0xff);\n        temp4 = temp1 >> 0x10;\n        temp3 = quotientResult / temp4;\n        partialQuotient1 = temp1 & 0xffff;\n        partialQuotient3 = temp3 * partialQuotient1;\n        temp2 = dividend >> (0x20U - shiftAmount & 0xff) | divisor << shiftAmount;\n        partialQuotient2 = temp2 >> 0x10 | (quotientResult - temp4 * temp3) * 0x10000;\n        dividend = dividend << shiftAmount;\n        quotientResult = temp3;\n        if (partialQuotient2 <= partialQuotient3 && partialQuotient3 - partialQuotient2 != 0) {\n          isCarry = CARRY4(temp1,partialQuotient2);\n          partialQuotient2 = temp1 + partialQuotient2;\n          quotientResult = temp3 - 1;\n          if ((isCarry == false) && (partialQuotient2 <= partialQuotient3 && partialQuotient3 - partialQuotient2 != 0)) {\n            quotientResult = temp3 - 2;\n            partialQuotient2 = partialQuotient2 + temp1;\n          }\n        }\n        temp3 = (partialQuotient2 - partialQuotient3) / temp4;\n        temp5 = temp3 * partialQuotient1;\n        divisor = temp2 & 0xffff | ((partialQuotient2 - partialQuotient3) - temp4 * temp3) * 0x10000;\n        partialQuotient2 = temp3;\n        if (divisor <= temp5 && temp5 - divisor != 0) {\n          isCarry = CARRY4(temp1,divisor);\n          divisor = temp1 + divisor;\n          partialQuotient2 = temp3 - 1;\n          if ((isCarry == false) && (divisor <= temp5 && temp5 - divisor != 0)) {\n            partialQuotient2 = temp3 - 2;\n            divisor = divisor + temp1;\n          }\n        }\n        divisor = divisor - temp5;\n        puVar9 = (uint *)(partialQuotient2 | quotientResult << 0x10);\n      }\n      temp3 = divisor / temp4;\n      quotientResult = partialQuotient1 * temp3;\n      temp2 = dividend >> 0x10 | (divisor - temp4 * temp3) * 0x10000;\n      partialQuotient2 = temp3;\n      if (temp2 <= quotientResult && quotientResult - temp2 != 0) {\n        isCarry = CARRY4(temp1,temp2);\n        temp2 = temp1 + temp2;\n        partialQuotient2 = temp3 - 1;\n        if ((isCarry == false) && (temp2 <= quotientResult && quotientResult - temp2 != 0)) {\n          partialQuotient2 = temp3 - 2;\n          temp2 = temp2 + temp1;\n        }\n      }\n      temp3 = (temp2 - quotientResult) / temp4;\n      partialQuotient1 = partialQuotient1 * temp3;\n      temp2 = dividend & 0xffff | ((temp2 - quotientResult) - temp4 * temp3) * 0x10000;\n      quotientResult = temp3;\n      if (temp2 <= partialQuotient1 && partialQuotient1 - temp2 != 0) {\n        isCarry = CARRY4(temp1,temp2);\n        temp2 = temp1 + temp2;\n        quotientResult = temp3 - 1;\n        if ((isCarry == false) && (temp2 <= partialQuotient1 && partialQuotient1 - temp2 != 0)) {\n          quotientResult = temp3 - 2;\n          temp2 = temp2 + temp1;\n        }\n      }\n      temp2 = temp2 - partialQuotient1;\n      quotientResult = quotientResult | partialQuotient2 << 0x10;\n    }\n    if (result != (uint *)0x0) {\n      *result = temp2 >> LZCOUNT(quotient);\n      result[1] = 0;\n    }\n  }\n  else {\n    puVar9 = result;\n    if (divisor < remainder) {\n      if (result != (uint *)0x0) {\n        *result = dividend;\n        result[1] = divisor;\n        return 0;\n      }\n      quotientResult = 0;\n    }\n    else {\n      shiftAmount = LZCOUNT(remainder);\n      if (shiftAmount == 0) {\n        if ((remainder < divisor) || (quotient <= dividend)) {\n          isCarry = dividend < quotient;\n          dividend = dividend - quotient;\n          divisor = (divisor - remainder) - (uint)isCarry;\n          quotientResult = 1;\n        }\n        else {\n          quotientResult = 0;\n        }\n        puVar9 = (uint *)0x0;\n        if (result != (uint *)0x0) {\n          *result = dividend;\n          result[1] = divisor;\n        }\n      }\n      else {\n        temp2 = 0x20 - shiftAmount;\n        partialQuotient1 = quotient >> (temp2 & 0xff) | remainder << shiftAmount;\n        temp1 = divisor >> (temp2 & 0xff);\n        partialQuotient3 = partialQuotient1 >> 0x10;\n        temp3 = temp1 / partialQuotient3;\n        temp4 = temp3 * (partialQuotient1 & 0xffff);\n        quotientResult = divisor << shiftAmount | dividend >> (temp2 & 0xff);\n        partialQuotient2 = quotientResult >> 0x10 | (temp1 - partialQuotient3 * temp3) * 0x10000;\n        dividend = dividend << shiftAmount;\n        temp1 = temp3;\n        if (partialQuotient2 <= temp4 && temp4 - partialQuotient2 != 0) {\n          isCarry = CARRY4(partialQuotient1,partialQuotient2);\n          partialQuotient2 = partialQuotient1 + partialQuotient2;\n          temp1 = temp3 - 1;\n          if ((isCarry == false) && (partialQuotient2 <= temp4 && temp4 - partialQuotient2 != 0)) {\n            temp1 = temp3 - 2;\n            partialQuotient2 = partialQuotient2 + partialQuotient1;\n          }\n        }\n        temp3 = (partialQuotient2 - temp4) / partialQuotient3;\n        temp5 = temp3 * (partialQuotient1 & 0xffff);\n        partialQuotient2 = quotientResult & 0xffff | ((partialQuotient2 - temp4) - partialQuotient3 * temp3) * 0x10000;\n        quotientResult = temp3;\n        if (partialQuotient2 <= temp5 && temp5 - partialQuotient2 != 0) {\n          isCarry = CARRY4(partialQuotient1,partialQuotient2);\n          partialQuotient2 = partialQuotient1 + partialQuotient2;\n          quotientResult = temp3 - 1;\n          if ((isCarry == false) && (partialQuotient2 <= temp5 && temp5 - partialQuotient2 != 0)) {\n            quotientResult = temp3 - 2;\n            partialQuotient2 = partialQuotient2 + partialQuotient1;\n          }\n        }\n        quotientResult = quotientResult | temp1 << 0x10;\n        partialProduct = (ulonglong)quotientResult * (ulonglong)(quotient << shiftAmount);\n        if (CONCAT44(partialQuotient2 - temp5,dividend) < partialProduct) {\n          quotientResult = quotientResult - 1;\n          partialProduct = partialProduct - CONCAT44(partialQuotient1,quotient << shiftAmount);\n        }\n        if (result != (uint *)0x0) {\n          temp1 = ((partialQuotient2 - temp5) - (int)(partialProduct >> 0x20)) - (uint)(dividend < (uint)partialProduct);\n          *result = temp1 << (temp2 & 0xff) | dividend - (uint)partialProduct >> shiftAmount;\n          result[1] = temp1 >> shiftAmount;\n          puVar9 = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(puVar9,quotientResult);\n}\n\n",
            "renaming": {
                "FUN_0800121c": "calculate_division_0800121c",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "param_5": "result",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "uVar1": "partialProduct",
                "uVar2": "partialQuotient1",
                "uVar3": "partialQuotient2",
                "uVar4": "partialQuotient3",
                "iVar5": "shiftAmount",
                "uVar6": "quotientResult",
                "uVar7": "temp1",
                "uVar8": "temp2",
                "uVar10": "temp3",
                "uVar11": "temp4",
                "uVar12": "temp5",
                "bVar13": "isCarry"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014f0": {
            "entrypoint": "0x080014f0",
            "current_name": "initialize_hardware_080014f0",
            "code": "\n\n\nundefined4 initializeHardware_080014f0(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  configureInterruptPriority(3);\n  initializeTick(0xf);\n  initializeHardware_080014f0Specific();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080014f0": "initialize_hardware_080014f0",
                "HAL_NVIC_SetPriorityGrouping": "configureInterruptPriority",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializeHardwareSpecific"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800151c": {
            "entrypoint": "0x0800151c",
            "current_name": "configure_systick_0800151c",
            "code": "\nundefined4 configureSystick_0800151c(uint priority)\n\n{\n  int systickConfigResult;\n  undefined4 returnValue;\n  \n  systickConfigResult = HAL_SYSTICK_Config((int)((ulonglong)DAT_20000018 / (1000 / (ulonglong)DAT_20000004)));\n  if (systickConfigResult == 0) {\n    if (priority < 0x10) {\n      HAL_NVIC_SetPriority(0xffffffff,priority,0);\n      returnValue = 0;\n      DAT_20000000 = priority;\n    }\n    else {\n      returnValue = 1;\n    }\n  }\n  else {\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800151c": "configure_systick_0800151c",
                "param_1": "priority",
                "iVar1": "systickConfigResult",
                "uVar2": "returnValue"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "update_data_0800157c",
            "code": "\nvoid updateData_0800157c(void)\n\n{\n  DAT_20000a48 = DAT_20000a48 + (uint)DAT_20000004;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "update_data_0800157c"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015a0": {
            "entrypoint": "0x080015a0",
            "current_name": "get_data_value_080015a0",
            "code": "\nundefined4 get_data_value_080015a0(void)\n\n{\n  return DAT_20000a48;\n}\n\n",
            "renaming": {
                "FUN_080015a0": "get_data_value_080015a0"
            },
            "calling": [
                "_get_ms_tick",
                "HAL_I2C_Mem_Read",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "HAL_RCC_ClockConfig",
                "I2C_RequestMemoryRead",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_WaitOnBTFFlagUntilTimeout",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_UART_Transmit",
                "HAL_RCC_OscConfig",
                "I2C_RequestMemoryWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b4": {
            "entrypoint": "0x080015b4",
            "current_name": "set_memory_configuration_080015b4",
            "code": "\n\n\nvoid setMemoryConfiguration_080015b4(uint inputValue)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (inputValue & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b4": "set_memory_configuration_080015b4",
                "param_1": "inputValue"
            },
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015fc": {
            "entrypoint": "0x080015fc",
            "current_name": "get_three_bits_from_right_080015fc",
            "code": "\n\n\nuint getThreeBitsFromRight_080015fc(void)\n\n{\n  return _DAT_e000ed0c >> 8 & 7;\n}\n\n",
            "renaming": {
                "FUN_080015fc": "get_three_bits_from_right_080015fc"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001618": {
            "entrypoint": "0x08001618",
            "current_name": "set_byte_in_memory_08001618",
            "code": "\nvoid setByteInMemory_08001618(byte byteValue,uint newValue)\n\n{\n  if ((char)byteValue < '\\0') {\n    *(char *)((byteValue & 0xf) + 0xe000ed14) = (char)((newValue & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)byteValue + -0x1fff1c00) = (char)((newValue & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001618": "set_byte_in_memory_08001618",
                "param_1": "byteValue",
                "param_2": "newValue"
            },
            "calling": [
                "HAL_NVIC_SetPriority",
                "SysTick_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800166c": {
            "entrypoint": "0x0800166c",
            "current_name": "bitmask_operation_0800166c",
            "code": "\nuint bitmaskOperation_0800166c(uint inputBitPosition,uint inputBitMask,uint outputBitMask)\n\n{\n  uint tempVariable;\n  \n  inputBitPosition = inputBitPosition & 7;\n  tempVariable = 7 - inputBitPosition;\n  if (3 < tempVariable) {\n    tempVariable = 4;\n  }\n  if (inputBitPosition + 4 < 7) {\n    inputBitPosition = 0;\n  }\n  else {\n    inputBitPosition = inputBitPosition - 3;\n  }\n  return outputBitMask & ~(-1 << (inputBitPosition & 0xff)) |\n         (~(-1 << (tempVariable & 0xff)) & inputBitMask) << (inputBitPosition & 0xff);\n}\n\n",
            "renaming": {
                "FUN_0800166c": "bitmask_operation_0800166c",
                "param_1": "inputBitPosition",
                "param_2": "inputBitMask",
                "param_3": "outputBitMask",
                "uVar1": "tempVariable"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016d0": {
            "entrypoint": "0x080016d0",
            "current_name": "check_validity_080016d0",
            "code": "\n\n\nbool checkValidity_080016d0(int input)\n\n{\n  bool isValid;\n  \n  isValid = input - 1U < 0x1000000;\n  if (isValid) {\n    _DAT_e000e014 = input + -1;\n    NVIC_SetPriority(0xffffffff,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return !isValid;\n}\n\n",
            "renaming": {
                "FUN_080016d0": "check_validity_080016d0",
                "param_1": "input",
                "bVar1": "isValid"
            },
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001714": {
            "entrypoint": "0x08001714",
            "current_name": "set_priority_grouping_08001714",
            "code": "\nvoid setPriorityGrouping_08001714(undefined4 priorityGroup)\n\n{\n  setPriorityGrouping_08001714(priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001714": "set_priority_grouping_08001714",
                "param_1": "priorityGroup",
                "NVIC_SetPriorityGrouping": "setPriorityGrouping"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800172a": {
            "entrypoint": "0x0800172a",
            "current_name": "set_interrupt_priority_0800172a",
            "code": "\nvoid setInterruptPriority_0800172a(char interruptNumber,undefined4 priorityGrouping,undefined4 interruptPriority)\n\n{\n  undefined4 priorityGroup;\n  \n  priorityGroup = getPriorityGroup();\n  priorityGroup = encodePriority(priorityGroup,priorityGrouping,interruptPriority);\n  setPriority((int)interruptNumber,priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800172a": "set_interrupt_priority_0800172a",
                "param_1": "interruptNumber",
                "param_2": "priorityGrouping",
                "param_3": "interruptPriority",
                "uVar1": "priorityGroup",
                "NVIC_GetPriorityGrouping": "getPriorityGroup",
                "NVIC_EncodePriority": "encodePriority",
                "NVIC_SetPriority": "setPriority"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "NVIC_SetPriority",
                "NVIC_GetPriorityGrouping",
                "NVIC_EncodePriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001762": {
            "entrypoint": "0x08001762",
            "current_name": "initialize_sys_tick_08001762",
            "code": "\nundefined4 initializeSysTick_08001762(undefined4 configValue)\n\n{\n  undefined4 result;\n  \n  result = SysTick_Config(configValue);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001762": "initialize_sys_tick_08001762",
                "param_1": "configValue",
                "uVar1": "result"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "SysTick_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800177c": {
            "entrypoint": "0x0800177c",
            "current_name": "set_flag_0800177c",
            "code": "\n\n\nvoid setFlag_0800177c(int flagValue)\n\n{\n  if (flagValue == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800177c": "set_flag_0800177c",
                "param_1": "flagValue"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017b4": {
            "entrypoint": "0x080017b4",
            "current_name": "update_timer_period_080017b4",
            "code": "\nvoid updateTimerPeriod_080017b4(void)\n\n{\n  handlePeriodElapsed(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080017b4": "update_timer_period_080017b4",
                "HAL_TIM_PeriodElapsedCallback": "handlePeriodElapsed"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017c4": {
            "entrypoint": "0x080017c4",
            "current_name": "set_bits_based_on_conditions_080017c4",
            "code": "\n\n\nvoid setBitsBasedOnConditions_080017c4(uint *outputArr,uint *inputArr)\n\n{\n  uint bitMask;\n  uint bitValue;\n  uint condition;\n  uint *outputPtr;\n  int index;\n  uint newValue;\n  uint indexCounter;\n  \n  newValue = 0;\n  indexCounter = 0;\n  do {\n    if (0xf < indexCounter) {\n      return;\n    }\n    bitMask = 1 << (indexCounter & 0xff);\n    bitValue = *inputArr & bitMask;\n    if (bitValue == bitMask) {\n      condition = inputArr[1];\n      if (condition == 0x12) {\n        newValue = inputArr[3] + 0xc;\n      }\n      else if (condition < 0x13) {\n        if (condition == 2) {\n          newValue = inputArr[3] + 8;\n        }\n        else if (condition < 3) {\n          if (condition == 0) goto LAB_08001882;\n          if (condition == 1) {\n            newValue = inputArr[3];\n          }\n        }\n        else if (condition == 3) {\n          newValue = 0;\n        }\n        else if (condition == 0x11) {\n          newValue = inputArr[3] + 4;\n        }\n      }\n      else if (condition == 0x10210000) {\nLAB_08001882:\n        if (inputArr[2] == 0) {\n          newValue = 4;\n        }\n        else if (inputArr[2] == 1) {\n          newValue = 8;\n          outputArr[4] = bitMask;\n        }\n        else {\n          newValue = 8;\n          outputArr[5] = bitMask;\n        }\n      }\n      else if (condition < 0x10210001) {\n        if ((condition == 0x10110000) || (condition == 0x10120000)) goto LAB_08001882;\n      }\n      else if (((condition == 0x10310000) || (condition == 0x10320000)) || (condition == 0x10220000))\n      goto LAB_08001882;\n      if (bitValue < 0x100) {\n        bitMask = indexCounter << 2;\n        outputPtr = outputArr;\n      }\n      else {\n        outputPtr = outputArr + 1;\n        bitMask = (indexCounter - 8) * 4;\n      }\n      *outputPtr = *outputPtr & ~(0xf << (bitMask & 0xff)) | newValue << (bitMask & 0xff);\n      if ((inputArr[1] & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        if (outputArr == (uint *)0x40010800) {\n          index = 0;\n        }\n        else if (outputArr == (uint *)0x40010c00) {\n          index = 1;\n        }\n        else if (outputArr == (uint *)0x40011000) {\n          index = 2;\n        }\n        else if (outputArr == (uint *)0x40011400) {\n          index = 3;\n        }\n        else {\n          index = 4;\n        }\n        *(uint *)(((indexCounter >> 2) + 2) * 4 + 0x40010000) =\n             index << ((indexCounter & 3) << 2) |\n             ~(0xf << ((indexCounter & 3) << 2)) & *(uint *)(((indexCounter >> 2) + 2) * 4 + 0x40010000);\n        if ((inputArr[1] & 0x10000) == 0) {\n          _DAT_40010400 = ~bitValue & _DAT_40010400;\n        }\n        else {\n          _DAT_40010400 = bitValue | _DAT_40010400;\n        }\n        if ((inputArr[1] & 0x20000) == 0) {\n          _DAT_40010404 = ~bitValue & _DAT_40010404;\n        }\n        else {\n          _DAT_40010404 = bitValue | _DAT_40010404;\n        }\n        if ((inputArr[1] & 0x100000) == 0) {\n          _DAT_40010408 = ~bitValue & _DAT_40010408;\n        }\n        else {\n          _DAT_40010408 = bitValue | _DAT_40010408;\n        }\n        if ((inputArr[1] & 0x200000) == 0) {\n          _DAT_4001040c = ~bitValue & _DAT_4001040c;\n        }\n        else {\n          _DAT_4001040c = bitValue | _DAT_4001040c;\n        }\n      }\n    }\n    indexCounter = indexCounter + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080017c4": "set_bits_based_on_conditions_080017c4",
                "param_1": "outputArr",
                "param_2": "inputArr",
                "uVar1": "bitMask",
                "uVar2": "bitValue",
                "uVar3": "condition",
                "puVar4": "outputPtr",
                "iVar5": "index",
                "local_10": "newValue",
                "local_c": "indexCounter"
            },
            "calling": [
                "MX_GPIO_Init",
                "HAL_TIM_MspPostInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a80": {
            "entrypoint": "0x08001a80",
            "current_name": "set_param_value_08001a80",
            "code": "\nvoid setParamValue_08001a80(int objectAddress,ushort value,char flag)\n\n{\n  if (flag == '\\0') {\n    *(uint *)(objectAddress + 0x10) = (uint)value << 0x10;\n  }\n  else {\n    *(uint *)(objectAddress + 0x10) = (uint)value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a80": "set_param_value_08001a80",
                "param_1": "objectAddress",
                "param_2": "value",
                "param_3": "flag"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "MX_GPIO_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_i2_c_peripheral_08001ab0",
            "code": "\nundefined4 initializeI2CPeripheral_08001ab0(uint **peripheralPointer)\n\n{\n  uint pclkFreq;\n  char isValidClock;\n  undefined4 returnValue;\n  uint tempValue;\n  bool isZero;\n  \n  if (peripheralPointer == (uint **)0x0) {\n    returnValue = 1;\n  }\n  else {\n    if (*(char *)((int)peripheralPointer + 0x3d) == '\\0') {\n      *(undefined *)(peripheralPointer + 0xf) = 0;\n      initializeI2CPeripheral_08001ab0Dependencies(peripheralPointer);\n    }\n    *(undefined *)((int)peripheralPointer + 0x3d) = 0x24;\n    **peripheralPointer = **peripheralPointer & 0xfffffffe;\n    pclkFreq = HAL_RCC_GetPCLK1Freq();\n    if (peripheralPointer[1] < (uint *)0x186a1) {\n      tempValue = pclkFreq;\n      if (pclkFreq < 2000000) {\n        tempValue = 1;\n      }\n      isValidClock = (char)tempValue;\n      if (1999999 < pclkFreq) {\n        isValidClock = '\\0';\n      }\n    }\n    else {\n      tempValue = pclkFreq;\n      if (pclkFreq < 4000000) {\n        tempValue = 1;\n      }\n      isValidClock = (char)tempValue;\n      if (3999999 < pclkFreq) {\n        isValidClock = '\\0';\n      }\n    }\n    if (isValidClock == '\\0') {\n      tempValue = pclkFreq / 1000000;\n      (*peripheralPointer)[1] = tempValue;\n      if ((uint *)0x186a0 < peripheralPointer[1]) {\n        tempValue = (tempValue * 300) / 1000;\n      }\n      (*peripheralPointer)[8] = tempValue + 1;\n      if (peripheralPointer[1] < (uint *)0x186a1) {\n        pclkFreq = (pclkFreq - 1) / (uint)((int)peripheralPointer[1] << 1) + 1 & 0xfff;\n        if (pclkFreq < 4) {\n          pclkFreq = 4;\n        }\n      }\n      else {\n        if (peripheralPointer[2] == (uint *)0x0) {\n          tempValue = (pclkFreq - 1) / (uint)((int)peripheralPointer[1] * 3) + 1 & 0xfff;\n          isZero = tempValue == 0;\n          if (isZero) {\n            tempValue = 1;\n          }\n          isValidClock = (char)tempValue;\n          if (!isZero) {\n            isValidClock = '\\0';\n          }\n        }\n        else {\n          tempValue = (pclkFreq - 1) / (uint)((int)peripheralPointer[1] * 0x19) + 1 & 0xfff;\n          isZero = tempValue == 0;\n          if (isZero) {\n            tempValue = 1;\n          }\n          isValidClock = (char)tempValue;\n          if (!isZero) {\n            isValidClock = '\\0';\n          }\n        }\n        if (isValidClock == '\\0') {\n          if (peripheralPointer[2] == (uint *)0x0) {\n            pclkFreq = (pclkFreq - 1) / (uint)((int)peripheralPointer[1] * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            pclkFreq = (pclkFreq - 1) / (uint)((int)peripheralPointer[1] * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          pclkFreq = 1;\n        }\n      }\n      (*peripheralPointer)[7] = pclkFreq;\n      **peripheralPointer = (uint)peripheralPointer[8] | (uint)peripheralPointer[7];\n      (*peripheralPointer)[2] = (uint)peripheralPointer[3] | (uint)peripheralPointer[4];\n      (*peripheralPointer)[3] = (uint)peripheralPointer[6] | (uint)peripheralPointer[5];\n      **peripheralPointer = **peripheralPointer | 1;\n      peripheralPointer[0x10] = (uint *)0x0;\n      *(undefined *)((int)peripheralPointer + 0x3d) = 0x20;\n      peripheralPointer[0xc] = (uint *)0x0;\n      *(undefined *)((int)peripheralPointer + 0x3e) = 0;\n      returnValue = 0;\n    }\n    else {\n      returnValue = 1;\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "initialize_i2_c_peripheral_08001ab0",
                "param_1": "peripheralPointer",
                "uVar1": "pclkFreq",
                "cVar2": "isValidClock",
                "uVar3": "returnValue",
                "uVar4": "tempValue",
                "bVar5": "isZero",
                "HAL_I2C_MspInit": "initializeI2CPeripheralDependencies"
            },
            "calling": [
                "MX_I2C1_Init"
            ],
            "called": [
                "HAL_I2C_MspInit",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cb8": {
            "entrypoint": "0x08001cb8",
            "current_name": "FUNC_08001cb8",
            "code": "\nvoid FUNC_08001cb8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cb8": "FUNC_08001cb8"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ccc": {
            "entrypoint": "0x08001ccc",
            "current_name": "write_data_to_i2_c_device_08001ccc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001d5e) */\n/* WARNING: Removing unreachable block (ram,0x08001d70) */\n/* WARNING: Removing unreachable block (ram,0x08001d72) */\n/* WARNING: Removing unreachable block (ram,0x08001d74) */\n\nundefined4\nwriteDataToI2CDevice_08001ccc(uint **deviceParams,undefined2 registerAddress,undefined2 dataLength,undefined2 timeout,uint *dataBuffer,\n            undefined2 memoryAddress,undefined4 tickCount)\n\n{\n  int startTime;\n  int currentTime;\n  undefined4 returnStatus;\n  uint *bufferPointer;\n  \n  startTime = HAL_GetTick();\n  if (*(char *)((int)deviceParams + 0x3d) == ' ') {\n    do {\n      if ((~(*deviceParams)[6] & 2) != 0) {\n        currentTime = 0;\n        goto LAB_08001d9c;\n      }\n      currentTime = HAL_GetTick();\n    } while ((uint)(currentTime - startTime) < 0x1a);\n    deviceParams[0xc] = (uint *)0x0;\n    *(undefined *)((int)deviceParams + 0x3d) = 0x20;\n    *(undefined *)((int)deviceParams + 0x3e) = 0;\n    *(undefined *)(deviceParams + 0xf) = 0;\n    currentTime = 3;\nLAB_08001d9c:\n    if (currentTime == 0) {\n      if (*(char *)(deviceParams + 0xf) == '\\x01') {\n        returnStatus = 2;\n      }\n      else {\n        *(undefined *)(deviceParams + 0xf) = 1;\n        if ((**deviceParams & 1) != 1) {\n          **deviceParams = **deviceParams | 1;\n        }\n        **deviceParams = **deviceParams & 0xfffff7ff;\n        *(undefined *)((int)deviceParams + 0x3d) = 0x21;\n        *(undefined *)((int)deviceParams + 0x3e) = 0x40;\n        deviceParams[0x10] = (uint *)0x0;\n        deviceParams[9] = dataBuffer;\n        *(undefined2 *)((int)deviceParams + 0x2a) = memoryAddress;\n        deviceParams[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(deviceParams + 10) = *(undefined2 *)((int)deviceParams + 0x2a);\n        currentTime = I2C_RequestMemoryWrite(deviceParams,registerAddress,dataLength,timeout,tickCount,startTime);\n        if (currentTime == 0) {\n          while (*(short *)(deviceParams + 10) != 0) {\n            currentTime = I2C_WaitOnTXEFlagUntilTimeout(deviceParams,tickCount,startTime);\n            if (currentTime != 0) {\n              if (deviceParams[0x10] == (uint *)0x4) {\n                **deviceParams = **deviceParams | 0x200;\n                return 1;\n              }\n              return 3;\n            }\n            bufferPointer = deviceParams[9];\n            deviceParams[9] = (uint *)((int)bufferPointer + 1);\n            (*deviceParams)[4] = (uint)*(byte *)bufferPointer;\n            *(short *)(deviceParams + 10) = *(short *)(deviceParams + 10) + -1;\n            *(short *)((int)deviceParams + 0x2a) = *(short *)((int)deviceParams + 0x2a) + -1;\n            if ((((*deviceParams)[5] & 4) == 4) && (*(short *)(deviceParams + 10) != 0)) {\n              bufferPointer = deviceParams[9];\n              deviceParams[9] = (uint *)((int)bufferPointer + 1);\n              (*deviceParams)[4] = (uint)*(byte *)bufferPointer;\n              *(short *)(deviceParams + 10) = *(short *)(deviceParams + 10) + -1;\n              *(short *)((int)deviceParams + 0x2a) = *(short *)((int)deviceParams + 0x2a) + -1;\n            }\n          }\n          startTime = I2C_WaitOnBTFFlagUntilTimeout(deviceParams,tickCount,startTime);\n          if (startTime == 0) {\n            **deviceParams = **deviceParams | 0x200;\n            *(undefined *)((int)deviceParams + 0x3d) = 0x20;\n            *(undefined *)((int)deviceParams + 0x3e) = 0;\n            *(undefined *)(deviceParams + 0xf) = 0;\n            returnStatus = 0;\n          }\n          else if (deviceParams[0x10] == (uint *)0x4) {\n            **deviceParams = **deviceParams | 0x200;\n            returnStatus = 1;\n          }\n          else {\n            returnStatus = 3;\n          }\n        }\n        else if (deviceParams[0x10] == (uint *)0x4) {\n          *(undefined *)(deviceParams + 0xf) = 0;\n          returnStatus = 1;\n        }\n        else {\n          *(undefined *)(deviceParams + 0xf) = 0;\n          returnStatus = 3;\n        }\n      }\n    }\n    else {\n      returnStatus = 2;\n    }\n  }\n  else {\n    returnStatus = 2;\n  }\n  return returnStatus;\n}\n\n",
            "renaming": {
                "FUN_08001ccc": "write_data_to_i2_c_device_08001ccc",
                "param_1": "deviceParams",
                "param_2": "registerAddress",
                "param_3": "dataLength",
                "param_4": "timeout",
                "param_5": "dataBuffer",
                "param_6": "memoryAddress",
                "param_7": "tickCount",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "returnStatus",
                "puVar4": "bufferPointer"
            },
            "calling": [
                "_i2c_write_reg"
            ],
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_WaitOnBTFFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_RequestMemoryWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f6c": {
            "entrypoint": "0x08001f6c",
            "current_name": "process_i2_c_request_08001f6c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080024e6) */\n/* WARNING: Removing unreachable block (ram,0x080024f8) */\n/* WARNING: Removing unreachable block (ram,0x080024fa) */\n/* WARNING: Removing unreachable block (ram,0x080024fc) */\n/* WARNING: Removing unreachable block (ram,0x08002000) */\n/* WARNING: Removing unreachable block (ram,0x08002012) */\n/* WARNING: Removing unreachable block (ram,0x08002014) */\n/* WARNING: Removing unreachable block (ram,0x08002016) */\n/* WARNING: Removing unreachable block (ram,0x080023f4) */\n/* WARNING: Removing unreachable block (ram,0x08002406) */\n/* WARNING: Removing unreachable block (ram,0x08002408) */\n/* WARNING: Removing unreachable block (ram,0x0800240a) */\n/* WARNING: Removing unreachable block (ram,0x080022d6) */\n/* WARNING: Removing unreachable block (ram,0x080022e8) */\n/* WARNING: Removing unreachable block (ram,0x080022ea) */\n/* WARNING: Removing unreachable block (ram,0x080022ec) */\n\nundefined4\nprocess_I2C_request_08001f6c(uint **request,undefined2 param_2,undefined2 param_3,undefined2 param_4,uint *data_buffer,\n            undefined2 param_6,uint timeout)\n\n{\n  int init_time;\n  uint temp;\n  int elapsed_time;\n  undefined4 result;\n  uint *ptr;\n  \n  init_time = HAL_GetTick();\n  if (*(char *)((int)request + 0x3d) == ' ') {\n    do {\n      if ((~(*request)[6] & 2) != 0) {\n        elapsed_time = 0;\n        goto LAB_08002040;\n      }\n      elapsed_time = HAL_GetTick();\n    } while ((uint)(elapsed_time - init_time) < 0x1a);\n    request[0xc] = (uint *)0x0;\n    *(undefined *)((int)request + 0x3d) = 0x20;\n    *(undefined *)((int)request + 0x3e) = 0;\n    *(undefined *)(request + 0xf) = 0;\n    elapsed_time = 3;\nLAB_08002040:\n    if (elapsed_time == 0) {\n      if (*(char *)(request + 0xf) == '\\x01') {\n        result = 2;\n      }\n      else {\n        *(undefined *)(request + 0xf) = 1;\n        if ((**request & 1) != 1) {\n          **request = **request | 1;\n        }\n        **request = **request & 0xfffff7ff;\n        *(undefined *)((int)request + 0x3d) = 0x22;\n        *(undefined *)((int)request + 0x3e) = 0x40;\n        request[0x10] = (uint *)0x0;\n        request[9] = data_buffer;\n        *(undefined2 *)((int)request + 0x2a) = param_6;\n        request[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(request + 10) = *(undefined2 *)((int)request + 0x2a);\n        elapsed_time = I2C_RequestMemoryRead(request,param_2,param_3,param_4,timeout,init_time);\n        if (elapsed_time == 0) {\n          if (*(short *)(request + 10) == 0) {\n            **request = **request | 0x200;\n          }\n          else if (*(short *)(request + 10) == 1) {\n            **request = **request & 0xfffffbff;\n            disableIRQinterrupts();\n            **request = **request | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (*(short *)(request + 10) == 2) {\n            **request = **request | 0x800;\n            disableIRQinterrupts();\n            **request = **request & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            **request = **request | 0x400;\n          }\n          while (*(short *)(request + 10) != 0) {\n            if (*(ushort *)(request + 10) < 4) {\n              if (*(short *)(request + 10) == 1) {\n                elapsed_time = I2C_WaitOnRXNEFlagUntilTimeout(request,timeout,init_time);\n                if (elapsed_time != 0) {\n                  if (request[0x10] == (uint *)0x20) {\n                    return 3;\n                  }\n                  return 1;\n                }\n                temp = (*request)[4];\n                ptr = request[9];\n                request[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)temp;\n                *(short *)(request + 10) = *(short *)(request + 10) + -1;\n                *(short *)((int)request + 0x2a) = *(short *)((int)request + 0x2a) + -1;\n              }\n              else if (*(short *)(request + 10) == 2) {\n                do {\n                  if ((~(*request)[5] & 4) == 0) {\n                    elapsed_time = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (elapsed_time = HAL_GetTick(), (uint)(elapsed_time - init_time) <= timeout))\n                        ));\n                request[0xc] = (uint *)0x0;\n                *(undefined *)((int)request + 0x3d) = 0x20;\n                *(undefined *)((int)request + 0x3e) = 0;\n                *(undefined *)(request + 0xf) = 0;\n                elapsed_time = 3;\nLAB_080022fa:\n                if (elapsed_time != 0) {\n                  return 3;\n                }\n                disableIRQinterrupts();\n                **request = **request | 0x200;\n                temp = (*request)[4];\n                ptr = request[9];\n                request[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)temp;\n                *(short *)(request + 10) = *(short *)(request + 10) + -1;\n                *(short *)((int)request + 0x2a) = *(short *)((int)request + 0x2a) + -1;\n                enableIRQinterrupts();\n                temp = (*request)[4];\n                ptr = request[9];\n                request[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)temp;\n                *(short *)(request + 10) = *(short *)(request + 10) + -1;\n                *(short *)((int)request + 0x2a) = *(short *)((int)request + 0x2a) + -1;\n              }\n              else {\n                do {\n                  if ((~(*request)[5] & 4) == 0) {\n                    elapsed_time = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (elapsed_time = HAL_GetTick(), (uint)(elapsed_time - init_time) <= timeout))\n                        ));\n                request[0xc] = (uint *)0x0;\n                *(undefined *)((int)request + 0x3d) = 0x20;\n                *(undefined *)((int)request + 0x3e) = 0;\n                *(undefined *)(request + 0xf) = 0;\n                elapsed_time = 3;\nLAB_08002418:\n                if (elapsed_time != 0) {\n                  return 3;\n                }\n                **request = **request & 0xfffffbff;\n                disableIRQinterrupts();\n                temp = (*request)[4];\n                ptr = request[9];\n                request[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)temp;\n                *(short *)(request + 10) = *(short *)(request + 10) + -1;\n                *(short *)((int)request + 0x2a) = *(short *)((int)request + 0x2a) + -1;\n                do {\n                  if ((~(*request)[5] & 4) == 0) {\n                    elapsed_time = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (elapsed_time = HAL_GetTick(), (uint)(elapsed_time - init_time) <= timeout))\n                        ));\n                request[0xc] = (uint *)0x0;\n                *(undefined *)((int)request + 0x3d) = 0x20;\n                *(undefined *)((int)request + 0x3e) = 0;\n                *(undefined *)(request + 0xf) = 0;\n                elapsed_time = 3;\nLAB_0800250a:\n                if (elapsed_time != 0) {\n                  return 3;\n                }\n                **request = **request | 0x200;\n                temp = (*request)[4];\n                ptr = request[9];\n                request[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)temp;\n                *(short *)(request + 10) = *(short *)(request + 10) + -1;\n                *(short *)((int)request + 0x2a) = *(short *)((int)request + 0x2a) + -1;\n                enableIRQinterrupts();\n                temp = (*request)[4];\n                ptr = request[9];\n                request[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)temp;\n                *(short *)(request + 10) = *(short *)(request + 10) + -1;\n                *(short *)((int)request + 0x2a) = *(short *)((int)request + 0x2a) + -1;\n              }\n            }\n            else {\n              elapsed_time = I2C_WaitOnRXNEFlagUntilTimeout(request,timeout,init_time);\n              if (elapsed_time != 0) {\n                if (request[0x10] == (uint *)0x20) {\n                  return 3;\n                }\n                return 1;\n              }\n              temp = (*request)[4];\n              ptr = request[9];\n              request[9] = (uint *)((int)ptr + 1);\n              *(char *)ptr = (char)temp;\n              *(short *)(request + 10) = *(short *)(request + 10) + -1;\n              *(short *)((int)request + 0x2a) = *(short *)((int)request + 0x2a) + -1;\n              if (((*request)[5] & 4) == 4) {\n                temp = (*request)[4];\n                ptr = request[9];\n                request[9] = (uint *)((int)ptr + 1);\n                *(char *)ptr = (char)temp;\n                *(short *)(request + 10) = *(short *)(request + 10) + -1;\n                *(short *)((int)request + 0x2a) = *(short *)((int)request + 0x2a) + -1;\n              }\n            }\n          }\n          *(undefined *)((int)request + 0x3d) = 0x20;\n          *(undefined *)((int)request + 0x3e) = 0;\n          *(undefined *)(request + 0xf) = 0;\n          result = 0;\n        }\n        else if (request[0x10] == (uint *)0x4) {\n          *(undefined *)(request + 0xf) = 0;\n          result = 1;\n        }\n        else {\n          *(undefined *)(request + 0xf) = 0;\n          result = 3;\n        }\n      }\n    }\n    else {\n      result = 2;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001f6c": "process_i2_c_request_08001f6c",
                "param_1": "request",
                "param_5": "data_buffer",
                "param_7": "timeout",
                "iVar1": "init_time",
                "uVar2": "temp",
                "iVar3": "elapsed_time",
                "uVar4": "result",
                "puVar5": "ptr"
            },
            "calling": [
                "_i2c_read_reg"
            ],
            "called": [
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_RequestMemoryRead",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002640": {
            "entrypoint": "0x08002640",
            "current_name": "perform_i2_c_transaction_08002640",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nundefined4\nperformI2CTransaction_08002640(uint **i2cData,byte slaveAddress,undefined2 data,short dataLength,uint timeout,int startTime)\n\n{\n  int result;\n  undefined4 returnValue;\n  \n  **i2cData = **i2cData | 0x100;\n  do {\n    if ((~(*i2cData)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_0800270a;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (result = HAL_GetTick(), (uint)(result - startTime) <= timeout))));\n  i2cData[0xc] = (uint *)0x0;\n  *(undefined *)((int)i2cData + 0x3d) = 0x20;\n  *(undefined *)((int)i2cData + 0x3e) = 0;\n  *(undefined *)(i2cData + 0xf) = 0;\n  result = 3;\nLAB_0800270a:\n  if (result == 0) {\n    (*i2cData)[4] = slaveAddress & 0xfe;\n    result = I2C_WaitOnMasterAddressFlagUntilTimeout(i2cData,0x10002,timeout,startTime);\n    if (result == 0) {\n      result = I2C_WaitOnTXEFlagUntilTimeout(i2cData,timeout,startTime,(*i2cData)[6]);\n      if (result == 0) {\n        if (dataLength == 1) {\n          (*i2cData)[4] = (uint)(byte)data;\n        }\n        else {\n          (*i2cData)[4] = (uint)(byte)((ushort)data >> 8);\n          result = I2C_WaitOnTXEFlagUntilTimeout(i2cData,timeout,startTime);\n          if (result != 0) {\n            if (i2cData[0x10] == (uint *)0x4) {\n              **i2cData = **i2cData | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*i2cData)[4] = (uint)(byte)data;\n        }\n        returnValue = 0;\n      }\n      else if (i2cData[0x10] == (uint *)0x4) {\n        **i2cData = **i2cData | 0x200;\n        returnValue = 1;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n    else if (i2cData[0x10] == (uint *)0x4) {\n      returnValue = 1;\n    }\n    else {\n      returnValue = 3;\n    }\n  }\n  else {\n    returnValue = 3;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08002640": "perform_i2_c_transaction_08002640",
                "param_1": "i2cData",
                "param_2": "slaveAddress",
                "param_3": "data",
                "param_4": "dataLength",
                "param_5": "timeout",
                "param_6": "startTime",
                "iVar1": "result",
                "uVar2": "returnValue"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f4": {
            "entrypoint": "0x080027f4",
            "current_name": "perform_i2_c_transaction_080027f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nundefined4\nperformI2CTransaction_080027f4(uint **i2cTransaction,byte deviceID,undefined2 registerAddress,short numBytes,uint timeout,int startTime)\n\n{\n  int result;\n  undefined4 returnCode;\n  \n  **i2cTransaction = **i2cTransaction | 0x400;\n  **i2cTransaction = **i2cTransaction | 0x100;\n  do {\n    if ((~(*i2cTransaction)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_080028d2;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (result = HAL_GetTick(), (uint)(result - startTime) <= timeout))));\n  i2cTransaction[0xc] = (uint *)0x0;\n  *(undefined *)((int)i2cTransaction + 0x3d) = 0x20;\n  *(undefined *)((int)i2cTransaction + 0x3e) = 0;\n  *(undefined *)(i2cTransaction + 0xf) = 0;\n  result = 3;\nLAB_080028d2:\n  if (result == 0) {\n    (*i2cTransaction)[4] = deviceID & 0xfe;\n    result = I2C_WaitOnMasterAddressFlagUntilTimeout(i2cTransaction,0x10002,timeout,startTime);\n    if (result == 0) {\n      result = I2C_WaitOnTXEFlagUntilTimeout(i2cTransaction,timeout,startTime,(*i2cTransaction)[6]);\n      if (result == 0) {\n        if (numBytes == 1) {\n          (*i2cTransaction)[4] = (uint)(byte)registerAddress;\n        }\n        else {\n          (*i2cTransaction)[4] = (uint)(byte)((ushort)registerAddress >> 8);\n          result = I2C_WaitOnTXEFlagUntilTimeout(i2cTransaction,timeout,startTime);\n          if (result != 0) {\n            if (i2cTransaction[0x10] == (uint *)0x4) {\n              **i2cTransaction = **i2cTransaction | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*i2cTransaction)[4] = (uint)(byte)registerAddress;\n        }\n        result = I2C_WaitOnTXEFlagUntilTimeout(i2cTransaction,timeout,startTime);\n        if (result == 0) {\n          **i2cTransaction = **i2cTransaction | 0x100;\n          do {\n            if ((~(*i2cTransaction)[5] & 1) == 0) {\n              result = 0;\n              goto LAB_08002a90;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (result = HAL_GetTick(), (uint)(result - startTime) <= timeout))));\n          i2cTransaction[0xc] = (uint *)0x0;\n          *(undefined *)((int)i2cTransaction + 0x3d) = 0x20;\n          *(undefined *)((int)i2cTransaction + 0x3e) = 0;\n          *(undefined *)(i2cTransaction + 0xf) = 0;\n          result = 3;\nLAB_08002a90:\n          if (result == 0) {\n            (*i2cTransaction)[4] = (uint)(deviceID | 1);\n            result = I2C_WaitOnMasterAddressFlagUntilTimeout(i2cTransaction,0x10002,timeout,startTime);\n            if (result == 0) {\n              returnCode = 0;\n            }\n            else if (i2cTransaction[0x10] == (uint *)0x4) {\n              returnCode = 1;\n            }\n            else {\n              returnCode = 3;\n            }\n          }\n          else {\n            returnCode = 3;\n          }\n        }\n        else if (i2cTransaction[0x10] == (uint *)0x4) {\n          **i2cTransaction = **i2cTransaction | 0x200;\n          returnCode = 1;\n        }\n        else {\n          returnCode = 3;\n        }\n      }\n      else if (i2cTransaction[0x10] == (uint *)0x4) {\n        **i2cTransaction = **i2cTransaction | 0x200;\n        returnCode = 1;\n      }\n      else {\n        returnCode = 3;\n      }\n    }\n    else if (i2cTransaction[0x10] == (uint *)0x4) {\n      returnCode = 1;\n    }\n    else {\n      returnCode = 3;\n    }\n  }\n  else {\n    returnCode = 3;\n  }\n  return returnCode;\n}\n\n",
            "renaming": {
                "FUN_080027f4": "perform_i2_c_transaction_080027f4",
                "param_1": "i2cTransaction",
                "param_2": "deviceID",
                "param_3": "registerAddress",
                "param_4": "numBytes",
                "param_5": "timeout",
                "param_6": "startTime",
                "iVar1": "result",
                "uVar2": "returnCode"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "check_and_update_flags_08002ad8",
            "code": "\nundefined4 check_and_update_flags_08002ad8(uint **data_ptr,uint value,uint timeout,int start_time)\n\n{\n  int current_time;\n  char flag;\n  uint temp_value;\n  bool is_nonzero;\n  \n  do {\n    if ((value >> 0x10 & 0xff) == 1) {\n      temp_value = value & ~(*data_ptr)[5] & 0xffff;\n      is_nonzero = temp_value != 0;\n      if (is_nonzero) {\n        temp_value = 1;\n      }\n      flag = (char)temp_value;\n      if (!is_nonzero) {\n        flag = '\\0';\n      }\n    }\n    else {\n      temp_value = value & ~(*data_ptr)[6] & 0xffff;\n      is_nonzero = temp_value != 0;\n      if (is_nonzero) {\n        temp_value = 1;\n      }\n      flag = (char)temp_value;\n      if (!is_nonzero) {\n        flag = '\\0';\n      }\n    }\n    if (flag == '\\0') {\n      return 0;\n    }\n    if (((*data_ptr)[5] & 0x400) == 0x400) {\n      **data_ptr = **data_ptr | 0x200;\n      (*data_ptr)[5] = 0xfffffbff;\n      data_ptr[0x10] = (uint *)0x4;\n      data_ptr[0xc] = (uint *)0x0;\n      *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n      *(undefined *)(data_ptr + 0xf) = 0;\n      return 1;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (current_time = HAL_GetTick(), (uint)(current_time - start_time) <= timeout))));\n  data_ptr[0xc] = (uint *)0x0;\n  *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n  *(undefined *)(data_ptr + 0xf) = 0;\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "check_and_update_flags_08002ad8",
                "param_1": "data_ptr",
                "param_2": "value",
                "param_3": "timeout",
                "param_4": "start_time",
                "iVar1": "current_time",
                "cVar2": "flag",
                "uVar3": "temp_value",
                "bVar4": "is_nonzero"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bb4": {
            "entrypoint": "0x08002bb4",
            "current_name": "check_i2_c_acknowledge_08002bb4",
            "code": "\nundefined4 checkI2CAcknowledge_08002bb4(int *data,uint timeout,int start_time)\n\n{\n  int isAcknowledgeFailed;\n  \n  while( true ) {\n    if ((*(uint *)(*data + 0x14) & 0x80) == 0x80) {\n      return 0;\n    }\n    isAcknowledgeFailed = checkI2CAcknowledge_08002bb4Failed(data);\n    if (isAcknowledgeFailed != 0) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (isAcknowledgeFailed = getCurrentTime(), timeout < (uint)(isAcknowledgeFailed - start_time))))) {\n      data[0x10] = data[0x10] | 0x20;\n      data[0xc] = 0;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      *(undefined *)(data + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002bb4": "check_i2_c_acknowledge_08002bb4",
                "param_1": "data",
                "param_2": "timeout",
                "param_3": "start_time",
                "iVar1": "isAcknowledgeFailed",
                "I2C_IsAcknowledgeFailed": "checkI2CAcknowledgeFailed",
                "HAL_GetTick": "getCurrentTime"
            },
            "calling": [
                "HAL_I2C_Mem_Write",
                "I2C_RequestMemoryRead",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "I2C_IsAcknowledgeFailed",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2e": {
            "entrypoint": "0x08002c2e",
            "current_name": "check_i2_c_acknowledge_08002c2e",
            "code": "\nundefined4 checkI2CAcknowledge_08002c2e(int *i2cRegisters,uint timeout,int startTime)\n\n{\n  int isAcknowledgeFailed;\n  \n  while( true ) {\n    if ((*(uint *)(*i2cRegisters + 0x14) & 4) == 4) {\n      return 0;\n    }\n    isAcknowledgeFailed = I2C_IsAcknowledgeFailed(i2cRegisters);\n    if (isAcknowledgeFailed != 0) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (isAcknowledgeFailed = getCurrentTime(), timeout < (uint)(isAcknowledgeFailed - startTime))))) {\n      i2cRegisters[0x10] = i2cRegisters[0x10] | 0x20;\n      i2cRegisters[0xc] = 0;\n      *(undefined *)((int)i2cRegisters + 0x3d) = 0x20;\n      *(undefined *)(i2cRegisters + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002c2e": "check_i2_c_acknowledge_08002c2e",
                "param_1": "i2cRegisters",
                "param_2": "timeout",
                "param_3": "startTime",
                "iVar1": "isAcknowledgeFailed",
                "HAL_GetTick": "getCurrentTime"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "I2C_IsAcknowledgeFailed",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca8": {
            "entrypoint": "0x08002ca8",
            "current_name": "check_timeout_08002ca8",
            "code": "\nundefined4 checkTimeout_08002ca8(int *dataPtr,uint timeout,int startTime)\n\n{\n  int currentTick;\n  \n  while( true ) {\n    if ((*(uint *)(*dataPtr + 0x14) & 0x40) == 0x40) {\n      return 0;\n    }\n    if ((*(uint *)(*dataPtr + 0x14) & 0x10) == 0x10) break;\n    if ((timeout == 0) || (currentTick = HAL_GetTick(), timeout < (uint)(currentTick - startTime))) {\n      dataPtr[0x10] = dataPtr[0x10] | 0x20;\n      *(undefined *)((int)dataPtr + 0x3d) = 0x20;\n      *(undefined *)(dataPtr + 0xf) = 0;\n      return 3;\n    }\n  }\n  *(undefined4 *)(*dataPtr + 0x14) = 0xffffffef;\n  dataPtr[0x10] = 0;\n  dataPtr[0xc] = 0;\n  *(undefined *)((int)dataPtr + 0x3d) = 0x20;\n  *(undefined *)(dataPtr + 0xf) = 0;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002ca8": "check_timeout_08002ca8",
                "param_1": "dataPtr",
                "param_2": "timeout",
                "param_3": "startTime",
                "iVar1": "currentTick"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d3c": {
            "entrypoint": "0x08002d3c",
            "current_name": "reset_params_08002d3c",
            "code": "\nbool resetParams_08002d3c(int *params)\n\n{\n  bool flag;\n  \n  flag = (*(uint *)(*params + 0x14) & 0x400) == 0x400;\n  if (flag) {\n    *(undefined4 *)(*params + 0x14) = 0xfffffbff;\n    errorCode = 4;\n    counter = 0;\n    *(undefined *)((int)params + 0x3d) = 0x20;\n    *(undefined *)(params + 0xf) = 0;\n  }\n  return flag;\n}\n\n",
            "renaming": {
                "FUN_08002d3c": "reset_params_08002d3c",
                "param_1": "params",
                "bVar1": "flag",
                "param_1[0x10]": "errorCode",
                "param_1[0xc]": "counter"
            },
            "calling": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_WaitOnBTFFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d8a": {
            "entrypoint": "0x08002d8a",
            "current_name": "FUNC_08002d8a",
            "code": "\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d98": {
            "entrypoint": "0x08002d98",
            "current_name": "process_data_08002d98",
            "code": "\n\n\nundefined4 processData_08002d98(uint *data)\n\n{\n  int startTick;\n  int currentTick;\n  undefined4 result;\n  bool isFlagSet;\n  \n  if ((*data & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0x10000)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (data[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      if (data[1] == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (data[1] == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (data[1] == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (data[1] == 0) {\n        startTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTick = HAL_GetTick();\n          if (100 < (uint)(currentTick - startTick)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        startTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTick = HAL_GetTick();\n          if (100 < (uint)(currentTick - startTick)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*data & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (data[4] != 1)) {\n        return 1;\n      }\n      _DAT_40021000 = data[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n    else if (data[4] == 0) {\n      _DAT_42420000 = 0;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < (uint)(currentTick - startTick)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < (uint)(currentTick - startTick)) {\n          return 3;\n        }\n      }\n      _DAT_40021000 = data[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n  }\n  if ((*data & 8) != 0) {\n    if (data[6] == 0) {\n      _DAT_42420480 = 0;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (2 < (uint)(currentTick - startTick)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTick = HAL_GetTick();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (2 < (uint)(currentTick - startTick)) {\n          return 3;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((*data & 4) != 0) {\n    isFlagSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isFlagSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTick = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTick = HAL_GetTick();\n        if (100 < (uint)(currentTick - startTick)) {\n          return 3;\n        }\n      }\n    }\n    if (data[3] == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (data[3] == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (data[3] == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (data[3] == 0) {\n      startTick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < (uint)(currentTick - startTick)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      startTick = HAL_GetTick();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTick = HAL_GetTick();\n        if (5000 < (uint)(currentTick - startTick)) {\n          return 3;\n        }\n      }\n    }\n    if (isFlagSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if (data[7] == 0) {\nLAB_0800324a:\n    result = 0;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    result = 1;\n  }\n  else if (data[7] == 2) {\n    _DAT_42420060 = 0;\n    startTick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if (data[8] == 0x10000) {\n          _DAT_40021004 = data[2] | _DAT_40021004 & 0xfffdffff;\n        }\n        _DAT_40021004 = data[9] | data[8] | _DAT_40021004 & 0xffc2ffff;\n        _DAT_42420060 = 1;\n        startTick = HAL_GetTick();\n        while ((_DAT_40021000 & 0x2000000) == 0) {\n          currentTick = HAL_GetTick();\n          if (2 < (uint)(currentTick - startTick)) {\n            return 3;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      currentTick = HAL_GetTick();\n    } while ((uint)(currentTick - startTick) < 3);\n    result = 3;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTick = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) goto LAB_0800324a;\n      currentTick = HAL_GetTick();\n    } while ((uint)(currentTick - startTick) < 3);\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002d98": "process_data_08002d98",
                "param_1": "data",
                "iVar1": "startTick",
                "iVar2": "currentTick",
                "uVar3": "result",
                "bVar4": "isFlagSet"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003260": {
            "entrypoint": "0x08003260",
            "current_name": "initialize_system_08003260",
            "code": "\n\n\nundefined4 initializeSystem_08003260(uint *systemConfig,uint sysClock)\n\n{\n  int startTime;\n  int currentTime;\n  uint sysClockFreq;\n  undefined4 returnValue;\n  \n  if (((_DAT_40022000 & 7) < sysClock) &&\n     (_DAT_40022000 = sysClock | _DAT_40022000 & 0xfffffff8, sysClock != (sysClock & 7))) {\n    returnValue = 1;\n  }\n  else {\n    if ((*systemConfig & 2) != 0) {\n      _DAT_40021004 = systemConfig[2] | _DAT_40021004 & 0xffffff0f;\n    }\n    if ((*systemConfig & 1) == 0) {\nLAB_08003394:\n      if ((sysClock < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = sysClock | _DAT_40022000 & 0xfffffff8, sysClock != (sysClock & 7))) {\n        returnValue = 1;\n      }\n      else {\n        if ((*systemConfig & 4) != 0) {\n          _DAT_40021004 = systemConfig[3] | _DAT_40021004 & 0xfffff8ff;\n        }\n        if ((*systemConfig & 8) != 0) {\n          _DAT_40021004 = systemConfig[4] << 3 | _DAT_40021004 & 0xffffc7ff;\n        }\n        sysClockFreq = getSysClockFreq();\n        DAT_20000018 = sysClockFreq >> (&DAT_08009eb0)[_DAT_40021004 >> 4 & 0xf];\n        initializeTick(0xf);\n        returnValue = 0;\n      }\n    }\n    else {\n      if (systemConfig[1] == 1) {\n        if ((_DAT_40021000 & 0x20000) == 0) {\n          return 1;\n        }\n      }\n      else if ((systemConfig[1] != 2) && ((_DAT_40021000 & 2) == 0)) {\n        return 1;\n      }\n      _DAT_40021004 = systemConfig[1] | _DAT_40021004 & 0xfffffffc;\n      startTime = getTick();\n      if (systemConfig[1] == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_08003394;\n          currentTime = getTick();\n        } while ((uint)(currentTime - startTime) < 0x1389);\n        returnValue = 3;\n      }\n      else if (systemConfig[1] == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_08003394;\n          currentTime = getTick();\n        } while ((uint)(currentTime - startTime) < 0x1389);\n        returnValue = 3;\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_08003394;\n          currentTime = getTick();\n        } while ((uint)(currentTime - startTime) < 0x1389);\n        returnValue = 3;\n      }\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08003260": "initialize_system_08003260",
                "param_1": "systemConfig",
                "param_2": "sysClock",
                "uVar3": "sysClockFreq",
                "uVar4": "returnValue",
                "HAL_RCC_GetSysClockFreq": "getSysClockFreq",
                "HAL_InitTick": "initializeTick",
                "HAL_GetTick": "getTick",
                "iVar1": "startTime",
                "iVar2": "currentTime"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003440": {
            "entrypoint": "0x08003440",
            "current_name": "calculate_execution_time_08003440",
            "code": "\n\n\nuint calculateExecutionTime_08003440(void)\n\n{\n  undefined2 numberOfCycles;\n  undefined4 constantA;\n  undefined4 constantB;\n  undefined4 constantC;\n  undefined4 constantD;\n  uint conditionA;\n  undefined4 conditionB;\n  uint unknownValue;\n  uint executionTime;\n  uint tempValue;\n  \n  constantA = 0x5040302;\n  constantB = 0x9080706;\n  constantC = 0xd0c0b0a;\n  constantD = 0x10100f0e;\n  numberOfCycles = 0x201;\n  conditionB = 0;\n  tempValue = 0;\n  conditionA = 0;\n  executionTime = 0;\n  unknownValue = _DAT_40021004;\n  if ((_DAT_40021004 & 0xc) == 4) {\n    executionTime = 8000000;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    conditionA = (uint)*(byte *)((int)&constantA + (_DAT_40021004 >> 0x12 & 0xf));\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      tempValue = conditionA * 4000000;\n    }\n    else {\n      tempValue = (conditionA * 8000000) / (uint)*(byte *)((int)&numberOfCycles + (_DAT_40021004 >> 0x11 & 1))\n      ;\n    }\n    executionTime = tempValue;\n  }\n  else {\n    executionTime = 8000000;\n  }\n  return executionTime;\n}\n\n",
            "renaming": {
                "FUN_08003440": "calculate_execution_time_08003440",
                "local_30": "numberOfCycles",
                "local_2c": "constantA",
                "uStack_28": "constantB",
                "uStack_24": "constantC",
                "uStack_20": "constantD",
                "local_1c": "conditionA",
                "local_18": "conditionB",
                "local_14": "unknownValue",
                "local_10": "executionTime",
                "local_c": "tempValue"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003504": {
            "entrypoint": "0x08003504",
            "current_name": "get_global_data_08003504",
            "code": "\nundefined4 getGlobalData_08003504(void)\n\n{\n  return DAT_20000018;\n}\n\n",
            "renaming": {
                "FUN_08003504": "get_global_data_08003504"
            },
            "calling": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003518": {
            "entrypoint": "0x08003518",
            "current_name": "get_adjusted_hclk_freq_08003518",
            "code": "\n\n\nuint getAdjustedHCLKFreq_08003518(void)\n\n{\n  uint hclkFreq;\n  \n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  return hclkFreq >> *(shiftAmount *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 8 & 7));\n}\n\n",
            "renaming": {
                "FUN_08003518": "get_adjusted_hclk_freq_08003518",
                "uVar1": "hclkFreq",
                "sbyte": "shiftAmount"
            },
            "calling": [
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003540": {
            "entrypoint": "0x08003540",
            "current_name": "get_adjusted_hclk_freq_08003540",
            "code": "\n\n\nuint getAdjustedHCLKFreq_08003540(void)\n\n{\n  uint hclkFreq;\n  \n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  return hclkFreq >> *(adjustment *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 0xb & 7));\n}\n\n",
            "renaming": {
                "FUN_08003540": "get_adjusted_hclk_freq_08003540",
                "uVar1": "hclkFreq",
                "sbyte": "adjustment"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003568": {
            "entrypoint": "0x08003568",
            "current_name": "process_param_08003568",
            "code": "\nvoid processParam_08003568(int input)\n\n{\n  bool isNotZero;\n  int result;\n  \n  result = input * (DAT_20000018 / 8000);\n  do {\n    isNotZero = result != 0;\n    result = result + -1;\n  } while (isNotZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003568": "process_param_08003568",
                "param_1": "input",
                "local_c": "result",
                "bVar1": "isNotZero"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035a4": {
            "entrypoint": "0x080035a4",
            "current_name": "initialize_timer_080035a4",
            "code": "\nundefined4 initializeTimer_080035a4(undefined4 *timerConfig)\n\n{\n  undefined4 status;\n  \n  if (timerConfig == (undefined4 *)0x0) {\n    status = 1;\n  }\n  else {\n    if (*(character *)((int)timerConfig + 0x3d) == '\\0') {\n      *(undefined *)(timerConfig + 0xf) = 0;\n      initializeTimer_080035a4Base(timerConfig);\n    }\n    *(undefined *)((int)timerConfig + 0x3d) = 2;\n    setTimerConfig(*timerConfig,timerConfig + 1);\n    *(undefined *)((int)timerConfig + 0x3d) = 1;\n    status = 0;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080035a4": "initialize_timer_080035a4",
                "param_1": "timerConfig",
                "uVar1": "status",
                "char": "character",
                "HAL_TIM_Base_MspInit": "initializeTimerBase",
                "TIM_Base_SetConfig": "setTimerConfig"
            },
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "called": [
                "HAL_TIM_Base_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fa": {
            "entrypoint": "0x080035fa",
            "current_name": "FUNC_080035fa",
            "code": "\nvoid FUNC_080035fa(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fa": "FUNC_080035fa"
            },
            "calling": [
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800360c": {
            "entrypoint": "0x0800360c",
            "current_name": "set_flags_and_value_0800360c",
            "code": "\nundefined4 setFlagsAndValue_0800360c(uint **ptrArray)\n\n{\n  (*ptrArray)[3] = (*ptrArray)[3] | 1;\n  **ptrArray = **ptrArray | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800360c": "set_flags_and_value_0800360c",
                "param_1": "ptrArray"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003640": {
            "entrypoint": "0x08003640",
            "current_name": "initialize_pwm_08003640",
            "code": "\nundefined4 initializePWM_08003640(undefined4 *pwmConfig)\n\n{\n  undefined4 returnStatus;\n  \n  if (pwmConfig == (undefined4 *)0x0) {\n    returnStatus = 1;\n  }\n  else {\n    if (*(char *)((int)pwmConfig + 0x3d) == '\\0') {\n      *(undefined *)(pwmConfig + 0xf) = 0;\n      HAL_TIM_PWM_MspInit(pwmConfig);\n    }\n    *(undefined *)((int)pwmConfig + 0x3d) = 2;\n    TIM_Base_SetConfig(*pwmConfig,pwmConfig + 1);\n    *(undefined *)((int)pwmConfig + 0x3d) = 1;\n    returnStatus = 0;\n  }\n  return returnStatus;\n}\n\n",
            "renaming": {
                "FUN_08003640": "initialize_pwm_08003640",
                "param_1": "pwmConfig",
                "uVar1": "returnStatus"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003696": {
            "entrypoint": "0x08003696",
            "current_name": "FUNC_08003696",
            "code": "\nvoid FUNC_08003696(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003696": "FUNC_08003696"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080036a8": {
            "entrypoint": "0x080036a8",
            "current_name": "configure_tim_channel_080036a8",
            "code": "\nundefined4 configure_TIM_channel_080036a8(uint **TIM_registers_ptr,undefined4 channel_num)\n\n{\n  TIM_CCxChannelCmd(*TIM_registers_ptr,channel_num,1);\n  if (*TIM_registers_ptr == (uint *)0x40012c00) {\n    (*TIM_registers_ptr)[0x11] = (*TIM_registers_ptr)[0x11] | 0x8000;\n  }\n  **TIM_registers_ptr = **TIM_registers_ptr | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080036a8": "configure_tim_channel_080036a8",
                "param_1": "TIM_registers_ptr",
                "param_2": "channel_num"
            },
            "calling": [
                "main"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f8": {
            "entrypoint": "0x080036f8",
            "current_name": "process_timers_080036f8",
            "code": "\nvoid processTimers_080036f8(int *timerParams)\n\n{\n  if (((*(uint *)(*timerParams + 0x10) & 2) == 2) && ((*(uint *)(*timerParams + 0xc) & 2) == 2)) {\n    *(undefined4 *)(*timerParams + 0x10) = 0xfffffffd;\n    *(undefined *)(timerParams + 7) = 1;\n    if ((*(uint *)(*timerParams + 0x18) & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerParams);\n      HAL_TIM_PWM_PulseFinishedCallback(timerParams);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerParams);\n    }\n    *(undefined *)(timerParams + 7) = 0;\n  }\n  if (((*(uint *)(*timerParams + 0x10) & 4) == 4) && ((*(uint *)(*timerParams + 0xc) & 4) == 4)) {\n    *(undefined4 *)(*timerParams + 0x10) = 0xfffffffb;\n    *(undefined *)(timerParams + 7) = 2;\n    if ((*(uint *)(*timerParams + 0x18) & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerParams);\n      HAL_TIM_PWM_PulseFinishedCallback(timerParams);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerParams);\n    }\n    *(undefined *)(timerParams + 7) = 0;\n  }\n  if (((*(uint *)(*timerParams + 0x10) & 8) == 8) && ((*(uint *)(*timerParams + 0xc) & 8) == 8)) {\n    *(undefined4 *)(*timerParams + 0x10) = 0xfffffff7;\n    *(undefined *)(timerParams + 7) = 4;\n    if ((*(uint *)(*timerParams + 0x1c) & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerParams);\n      HAL_TIM_PWM_PulseFinishedCallback(timerParams);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerParams);\n    }\n    *(undefined *)(timerParams + 7) = 0;\n  }\n  if (((*(uint *)(*timerParams + 0x10) & 0x10) == 0x10) && ((*(uint *)(*timerParams + 0xc) & 0x10) == 0x10))\n  {\n    *(undefined4 *)(*timerParams + 0x10) = 0xffffffef;\n    *(undefined *)(timerParams + 7) = 8;\n    if ((*(uint *)(*timerParams + 0x1c) & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerParams);\n      HAL_TIM_PWM_PulseFinishedCallback(timerParams);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerParams);\n    }\n    *(undefined *)(timerParams + 7) = 0;\n  }\n  if (((*(uint *)(*timerParams + 0x10) & 1) == 1) && ((*(uint *)(*timerParams + 0xc) & 1) == 1)) {\n    *(undefined4 *)(*timerParams + 0x10) = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(timerParams);\n  }\n  if (((*(uint *)(*timerParams + 0x10) & 0x80) == 0x80) && ((*(uint *)(*timerParams + 0xc) & 0x80) == 0x80))\n  {\n    *(undefined4 *)(*timerParams + 0x10) = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(timerParams);\n  }\n  if (((*(uint *)(*timerParams + 0x10) & 0x40) == 0x40) && ((*(uint *)(*timerParams + 0xc) & 0x40) == 0x40))\n  {\n    *(undefined4 *)(*timerParams + 0x10) = 0xffffffbf;\n    HAL_TIM_TriggerCallback(timerParams);\n  }\n  if (((*(uint *)(*timerParams + 0x10) & 0x20) == 0x20) && ((*(uint *)(*timerParams + 0xc) & 0x20) == 0x20))\n  {\n    *(undefined4 *)(*timerParams + 0x10) = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(timerParams);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036f8": "process_timers_080036f8",
                "param_1": "timerParams"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PWM_PulseFinishedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003908": {
            "entrypoint": "0x08003908",
            "current_name": "configure_timer_output_channel_08003908",
            "code": "\nundefined4 configureTimerOutputChannel_08003908(int *timer,int channel,undefined4 config)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(timer + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(timer + 0xf) = 1;\n    *(undefined *)((int)timer + 0x3d) = 2;\n    switch(config) {\n    case 0:\n      configureTimerOC1(*timer,channel);\n      *(uint *)(*timer + 0x18) = *(uint *)(*timer + 0x18) | 8;\n      *(uint *)(*timer + 0x18) = *(uint *)(*timer + 0x18) & 0xfffffffb;\n      *(uint *)(*timer + 0x18) = *(uint *)(channel + 0x10) | *(uint *)(*timer + 0x18);\n      break;\n    case 4:\n      configureTimerOC2(*timer,channel);\n      *(uint *)(*timer + 0x18) = *(uint *)(*timer + 0x18) | 0x800;\n      *(uint *)(*timer + 0x18) = *(uint *)(*timer + 0x18) & 0xfffffbff;\n      *(uint *)(*timer + 0x18) = *(int *)(channel + 0x10) << 8 | *(uint *)(*timer + 0x18);\n      break;\n    case 8:\n      configureTimerOC3(*timer,channel);\n      *(uint *)(*timer + 0x1c) = *(uint *)(*timer + 0x1c) | 8;\n      *(uint *)(*timer + 0x1c) = *(uint *)(*timer + 0x1c) & 0xfffffffb;\n      *(uint *)(*timer + 0x1c) = *(uint *)(channel + 0x10) | *(uint *)(*timer + 0x1c);\n      break;\n    case 0xc:\n      configureTimerOC4(*timer,channel);\n      *(uint *)(*timer + 0x1c) = *(uint *)(*timer + 0x1c) | 0x800;\n      *(uint *)(*timer + 0x1c) = *(uint *)(*timer + 0x1c) & 0xfffffbff;\n      *(uint *)(*timer + 0x1c) = *(int *)(channel + 0x10) << 8 | *(uint *)(*timer + 0x1c);\n    }\n    *(undefined *)((int)timer + 0x3d) = 1;\n    *(undefined *)(timer + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003908": "configure_timer_output_channel_08003908",
                "param_1": "timer",
                "param_2": "channel",
                "param_3": "config",
                "uVar1": "result",
                "TIM_OC1_SetConfig": "configureTimerOC1",
                "TIM_OC2_SetConfig": "configureTimerOC2",
                "TIM_OC3_SetConfig": "configureTimerOC3",
                "TIM_OC4_SetConfig": "configureTimerOC4"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "TIM_OC2_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC3_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a94": {
            "entrypoint": "0x08003a94",
            "current_name": "configure_timer_08003a94",
            "code": "\nundefined4 configureTimer_08003a94(int *timerConfig,uint *configValues)\n\n{\n  undefined4 result;\n  uint configValue;\n  \n  if (*(char *)(timerConfig + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(timerConfig + 0xf) = 1;\n    *(undefined *)((int)timerConfig + 0x3d) = 2;\n    *(uint *)(*timerConfig + 8) = *(uint *)(*timerConfig + 8) & 0xffff0088;\n    configValue = *configValues;\n    if (configValue == 0x40) {\n      TIM_TI1_ConfigInputStage(*timerConfig,configValues[1],configValues[3]);\n      TIM_ITRx_SetConfig(*timerConfig,0x40);\n    }\n    else if (configValue < 0x41) {\n      if (configValue == 0x10) {\n        TIM_ITRx_SetConfig(*timerConfig,0x10);\n      }\n      else if (configValue < 0x11) {\n        if (configValue == 0) {\n          TIM_ITRx_SetConfig(*timerConfig,0);\n        }\n      }\n      else if (configValue == 0x20) {\n        TIM_ITRx_SetConfig(*timerConfig,0x20);\n      }\n      else if (configValue == 0x30) {\n        TIM_ITRx_SetConfig(*timerConfig,0x30);\n      }\n    }\n    else if (configValue == 0x70) {\n      TIM_ETR_SetConfig(*timerConfig,configValues[2],configValues[1],configValues[3]);\n      *(uint *)(*timerConfig + 8) = *(uint *)(*timerConfig + 8) & 0xffffff88 | 0x77;\n    }\n    else if (configValue < 0x71) {\n      if (configValue == 0x50) {\n        TIM_TI1_ConfigInputStage(*timerConfig,configValues[1],configValues[3]);\n        TIM_ITRx_SetConfig(*timerConfig,0x50);\n      }\n      else if (configValue == 0x60) {\n        TIM_TI2_ConfigInputStage(*timerConfig,configValues[1],configValues[3]);\n        TIM_ITRx_SetConfig(*timerConfig,0x60);\n      }\n    }\n    else if (configValue == 0x1000) {\n      *(uint *)(*timerConfig + 8) = *(uint *)(*timerConfig + 8) & 0xfffffff8;\n    }\n    else if (configValue == 0x2000) {\n      TIM_ETR_SetConfig(*timerConfig,configValues[2],configValues[1],configValues[3]);\n      *(uint *)(*timerConfig + 8) = *(uint *)(*timerConfig + 8) | 0x4000;\n    }\n    *(undefined *)((int)timerConfig + 0x3d) = 1;\n    *(undefined *)(timerConfig + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003a94": "configure_timer_08003a94",
                "param_1": "timerConfig",
                "param_2": "configValues",
                "uVar1": "result",
                "uVar2": "configValue"
            },
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "called": [
                "TIM_ITRx_SetConfig",
                "TIM_TI1_ConfigInputStage",
                "TIM_TI2_ConfigInputStage",
                "TIM_ETR_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c4a": {
            "entrypoint": "0x08003c4a",
            "current_name": "FUNC_08003c4a",
            "code": "\nvoid FUNC_08003c4a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c4a": "FUNC_08003c4a"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c5c": {
            "entrypoint": "0x08003c5c",
            "current_name": "FUNC_08003c5c",
            "code": "\nvoid FUNC_08003c5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c5c": "FUNC_08003c5c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c6e": {
            "entrypoint": "0x08003c6e",
            "current_name": "FUNC_08003c6e",
            "code": "\nvoid FUNC_08003c6e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c6e": "FUNC_08003c6e"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c80": {
            "entrypoint": "0x08003c80",
            "current_name": "FUNC_08003c80",
            "code": "\nvoid FUNC_08003c80(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c80": "FUNC_08003c80"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c94": {
            "entrypoint": "0x08003c94",
            "current_name": "update_config_08003c94",
            "code": "\nvoid updateConfig_08003c94(uint *config,uint *newConfig)\n\n{\n  uint currentValue;\n  \n  currentValue = *config;\n  if ((((config == (uint *)0x40012c00) || (config == (uint *)0x40000000)) ||\n      (config == (uint *)0x40000400)) || (config == (uint *)0x40000800)) {\n    currentValue = newConfig[1] | currentValue & 0xffffff8f;\n  }\n  if (((config == (uint *)0x40012c00) || (config == (uint *)0x40000000)) ||\n     ((config == (uint *)0x40000400 || (config == (uint *)0x40000800)))) {\n    currentValue = newConfig[3] | currentValue & 0xfffffcff;\n  }\n  *config = newConfig[5] | currentValue & 0xffffff7f;\n  config[0xb] = newConfig[2];\n  config[10] = *newConfig;\n  if (config == (uint *)0x40012c00) {\n    specialValue = newConfig[4];\n  }\n  config[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c94": "update_config_08003c94",
                "param_1": "config",
                "param_2": "newConfig",
                "local_c": "currentValue",
                "uRam40012c30": "specialValue"
            },
            "calling": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d60": {
            "entrypoint": "0x08003d60",
            "current_name": "update_flags_and_values_08003d60",
            "code": "\nvoid updateFlagsAndValues_08003d60(int ptr_to_data,uint *data_array)\n\n{\n  uint value_1;\n  uint value_2;\n  uint current_value;\n  \n  *(uint *)(ptr_to_data + 0x20) = *(uint *)(ptr_to_data + 0x20) & 0xfffffffe;\n  current_value = *(uint *)(ptr_to_data + 4);\n  value_1 = *data_array;\n  value_2 = data_value_2 | *(uint *)(ptr_to_data + 0x20) & 0xfffffffd;\n  if (ptr_to_data == 0x40012c00) {\n    value_2 = (data_value_3 | value_2 & 0xfffffff7) & 0xfffffffb;\n    current_value = data_value_6 | data_value_5 | current_value & 0xfffffcff;\n  }\n  *(uint *)(ptr_to_data + 4) = current_value;\n  *(uint *)(ptr_to_data + 0x18) = value_1 | *(uint *)(ptr_to_data + 0x18) & 0xffffff8c;\n  *(uint *)(ptr_to_data + 0x34) = data_array[1];\n  *(uint *)(ptr_to_data + 0x20) = value_2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003d60": "update_flags_and_values_08003d60",
                "param_1": "ptr_to_data",
                "param_2": "data_array",
                "uVar1": "value_1",
                "uVar2": "value_2",
                "local_10": "current_value",
                "param_2[2]": "data_value_2",
                "param_2[3]": "data_value_3",
                "param_2[6]": "data_value_6",
                "param_2[5]": "data_value_5"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e38": {
            "entrypoint": "0x08003e38",
            "current_name": "set_flags_and_values_08003e38",
            "code": "\nvoid setFlagsAndValues_08003e38(int context,int *data)\n\n{\n  int value1;\n  uint value2;\n  uint value3;\n  \n  *(uint *)(context + 0x20) = *(uint *)(context + 0x20) & 0xffffffef;\n  value3 = *(uint *)(context + 4);\n  value1 = *data;\n  value2 = data[2] << 4 | *(uint *)(context + 0x20) & 0xffffffdf;\n  if (context == 0x40012c00) {\n    value2 = (data[3] << 4 | value2 & 0xffffff7f) & 0xffffffbf;\n    value3 = data[6] << 2 | data[5] << 2 | value3 & 0xfffff3ff;\n  }\n  *(uint *)(context + 4) = value3;\n  *(uint *)(context + 0x18) = value1 << 8 | *(uint *)(context + 0x18) & 0xffff8cff;\n  *(int *)(context + 0x38) = data[1];\n  *(uint *)(context + 0x20) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e38": "set_flags_and_values_08003e38",
                "param_1": "context",
                "param_2": "data",
                "iVar1": "value1",
                "uVar2": "value2",
                "local_10": "value3"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "update_param_08003f18",
            "code": "\nvoid updateParam_08003f18(int paramBase,uint *paramArray)\n\n{\n  uint paramArrayVal1;\n  uint paramArrayVal2;\n  uint localVar;\n  \n  *(uint *)(paramBase + 0x20) = *(uint *)(paramBase + 0x20) & 0xfffffeff;\n  localVar = *(uint *)(paramBase + 4);\n  paramArrayVal1 = *paramArray;\n  paramArrayVal2 = paramArrayVal3 << 8 | *(uint *)(paramBase + 0x20) & 0xfffffdff;\n  if (paramBase == 0x40012c00) {\n    paramArrayVal2 = (paramArray[3] << 8 | paramArrayVal2 & 0xfffff7ff) & 0xfffffbff;\n    localVar = paramArray[6] << 4 | paramArray[5] << 4 | localVar & 0xffffcfff;\n  }\n  *(uint *)(paramBase + 4) = localVar;\n  *(uint *)(paramBase + 0x1c) = paramArrayVal1 | *(uint *)(paramBase + 0x1c) & 0xffffff8c;\n  *(uint *)(paramBase + 0x3c) = paramArray[1];\n  *(uint *)(paramBase + 0x20) = paramArrayVal2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "update_param_08003f18",
                "param_1": "paramBase",
                "param_2": "paramArray",
                "uVar1": "paramArrayVal1",
                "uVar2": "paramArrayVal2",
                "local_10": "localVar",
                "param_2[2]": "paramArrayVal3"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff8": {
            "entrypoint": "0x08003ff8",
            "current_name": "update_param_08003ff8",
            "code": "\nvoid updateParam_08003ff8(int baseAddress,int *paramArray)\n\n{\n  int value1;\n  int value2;\n  uint newValue;\n  \n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xffffefff;\n  newValue = *(uint *)(baseAddress + 4);\n  value1 = *paramArray;\n  value2 = paramArray[2];\n  if (baseAddress == 0x40012c00) {\n    newValue = paramArray[5] << 6 | newValue & 0xffffbfff;\n  }\n  *(uint *)(baseAddress + 4) = newValue;\n  *(uint *)(baseAddress + 0x1c) = value1 << 8 | *(uint *)(baseAddress + 0x1c) & 0xffff8cff;\n  *(int *)(baseAddress + 0x40) = paramArray[1];\n  *(uint *)(baseAddress + 0x20) = value2 << 0xc | *(uint *)(baseAddress + 0x20) & 0xffffdfff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff8": "update_param_08003ff8",
                "param_1": "baseAddress",
                "param_2": "paramArray",
                "iVar1": "value1",
                "iVar2": "value2",
                "local_c": "newValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040a0": {
            "entrypoint": "0x080040a0",
            "current_name": "update_flags_and_values_080040a0",
            "code": "\nvoid updateFlagsAndValues_080040a0(int memoryAddress,uint newFlag,int value)\n\n{\n  uint currentFlag;\n  \n  currentFlag = *(uint *)(memoryAddress + 0x20);\n  *(uint *)(memoryAddress + 0x20) = *(uint *)(memoryAddress + 0x20) & 0xfffffffe;\n  *(uint *)(memoryAddress + 0x18) = value << 4 | *(uint *)(memoryAddress + 0x18) & 0xffffff0f;\n  *(uint *)(memoryAddress + 0x20) = newFlag | currentFlag & 0xfffffff5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040a0": "update_flags_and_values_080040a0",
                "param_1": "memoryAddress",
                "param_2": "newFlag",
                "param_3": "value",
                "uVar1": "currentFlag"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004104": {
            "entrypoint": "0x08004104",
            "current_name": "update_param_values_08004104",
            "code": "\nvoid updateParamValues_08004104(int objAddress,int value2,int value3)\n\n{\n  *(uint *)(objAddress + 0x20) = *(uint *)(objAddress + 0x20) & 0xffffffef;\n  *(uint *)(objAddress + 0x18) = value3 << 0xc | *(uint *)(objAddress + 0x18) & 0xffff0fff;\n  *(uint *)(objAddress + 0x20) = value2 << 4 | *(uint *)(objAddress + 0x20) & 0xffffff5f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004104": "update_param_values_08004104",
                "param_1": "objAddress",
                "param_2": "value2",
                "param_3": "value3"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800416a": {
            "entrypoint": "0x0800416a",
            "current_name": "set_param_value_0800416a",
            "code": "\nvoid setParamValue_0800416a(int baseAddress,ushort newValue)\n\n{\n  *(uint *)(baseAddress + 8) = *(uint *)(baseAddress + 8) & 0xffffff8f | (uint)(newValue | 7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800416a": "set_param_value_0800416a",
                "param_1": "baseAddress",
                "param_2": "newValue"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a8": {
            "entrypoint": "0x080041a8",
            "current_name": "update_param_080041a8",
            "code": "\nvoid updateParam_080041a8(int ptr,uint value1,uint value2,int value3)\n\n{\n  *(uint *)(ptr + 8) = value1 | value3 << 8 | value2 | *(uint *)(ptr + 8) & 0xffff00ff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a8": "update_param_080041a8",
                "param_1": "ptr",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ea": {
            "entrypoint": "0x080041ea",
            "current_name": "update_bitmask_080041ea",
            "code": "\nvoid updateBitmask_080041ea(int baseAddress,uint bitPosition,int value)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & ~(1 << (bitPosition & 0xff));\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) | value << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041ea": "update_bitmask_080041ea",
                "param_1": "baseAddress",
                "param_2": "bitPosition",
                "param_3": "value"
            },
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800422e": {
            "entrypoint": "0x0800422e",
            "current_name": "update_parameter_0800422e",
            "code": "\nundefined4 updateParameter_0800422e(int *ptrParam1,uint *ptrParam2)\n\n{\n  undefined4 returnValue;\n  \n  if (*(char *)(ptrParam1 + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(ptrParam1 + 0xf) = 1;\n    *(uint *)(*ptrParam1 + 0x44) =\n         ptrParam2[6] |\n         (ptrParam2[6] |\n         (ptrParam2[5] |\n         (ptrParam2[4] |\n         (*ptrParam2 | (ptrParam2[1] | (ptrParam2[2] | ptrParam2[3] & 0xfffffcff) & 0xfffffbff) & 0xfffff7ff\n         ) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    *(undefined *)(ptrParam1 + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800422e": "update_parameter_0800422e",
                "param_1": "ptrParam1",
                "param_2": "ptrParam2",
                "uVar1": "returnValue"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042de": {
            "entrypoint": "0x080042de",
            "current_name": "update_flags_080042de",
            "code": "\nundefined4 updateFlags_080042de(int *arrayPtr,uint *values)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(arrayPtr + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(arrayPtr + 0xf) = 1;\n    *(undefined *)((int)arrayPtr + 0x3d) = 2;\n    *(uint *)(*arrayPtr + 4) = *(uint *)(*arrayPtr + 4) & 0xffffff8f;\n    *(uint *)(*arrayPtr + 4) = *values | *(uint *)(*arrayPtr + 4);\n    *(uint *)(*arrayPtr + 8) = *(uint *)(*arrayPtr + 8) & 0xffffff7f;\n    *(uint *)(*arrayPtr + 8) = values[1] | *(uint *)(*arrayPtr + 8);\n    *(undefined *)((int)arrayPtr + 0x3d) = 1;\n    *(undefined *)(arrayPtr + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080042de": "update_flags_080042de",
                "param_1": "arrayPtr",
                "param_2": "values",
                "uVar1": "result"
            },
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004366": {
            "entrypoint": "0x08004366",
            "current_name": "FUNC_08004366",
            "code": "\nvoid FUNC_08004366(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004366": "FUNC_08004366"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004378": {
            "entrypoint": "0x08004378",
            "current_name": "FUNC_08004378",
            "code": "\nvoid FUNC_08004378(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004378": "FUNC_08004378"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800438a": {
            "entrypoint": "0x0800438a",
            "current_name": "initialize_communication_0800438a",
            "code": "\nundefined4 initializeCommunication_0800438a(int *communicationHandle)\n\n{\n  undefined4 returnValue;\n  \n  if (communicationHandle == (int *)0x0) {\n    returnValue = 1;\n  }\n  else {\n    if (*(char *)((int)communicationHandle + 0x39) == '\\0') {\n      *(undefined *)(communicationHandle + 0xe) = 0;\n      HAL_UART_MspInit(communicationHandle);\n    }\n    *(undefined *)((int)communicationHandle + 0x39) = 0x24;\n    *(uint *)(*communicationHandle + 0xc) = *(uint *)(*communicationHandle + 0xc) & 0xffffdfff;\n    UART_SetConfig(communicationHandle);\n    *(uint *)(*communicationHandle + 0x10) = *(uint *)(*communicationHandle + 0x10) & 0xffffb7ff;\n    *(uint *)(*communicationHandle + 0x14) = *(uint *)(*communicationHandle + 0x14) & 0xffffffd5;\n    *(uint *)(*communicationHandle + 0xc) = *(uint *)(*communicationHandle + 0xc) | 0x2000;\n    communicationHandle[0xf] = 0;\n    *(undefined *)((int)communicationHandle + 0x39) = 0x20;\n    *(undefined *)((int)communicationHandle + 0x3a) = 0x20;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800438a": "initialize_communication_0800438a",
                "param_1": "communicationHandle",
                "uVar1": "returnValue"
            },
            "calling": [
                "MX_USART1_UART_Init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004424": {
            "entrypoint": "0x08004424",
            "current_name": "FUNC_08004424",
            "code": "\nvoid FUNC_08004424(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004424": "FUNC_08004424"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004436": {
            "entrypoint": "0x08004436",
            "current_name": "process_input_08004436",
            "code": "\nundefined4 processInput_08004436(uint **inputData,ushort *inputArray,short arraySize,uint timeout)\n\n{\n  int currentTime;\n  int elapsedTime;\n  undefined4 returnValue;\n  ushort *currentElement;\n  \n  if (*(char *)((int)inputData + 0x39) == ' ') {\n    if ((inputArray == (ushort *)0x0) || (arraySize == 0)) {\n      returnValue = 1;\n    }\n    else if (*(char *)(inputData + 0xe) == '\\x01') {\n      returnValue = 2;\n    }\n    else {\n      *(undefined *)(inputData + 0xe) = 1;\n      inputData[0xf] = (uint *)0x0;\n      *(undefined *)((int)inputData + 0x39) = 0x21;\n      currentTime = HAL_GetTick();\n      *(short *)(inputData + 9) = arraySize;\n      *(short *)((int)inputData + 0x26) = arraySize;\n      currentElement = inputArray;\n      while (*(short *)((int)inputData + 0x26) != 0) {\n        *(short *)((int)inputData + 0x26) = *(short *)((int)inputData + 0x26) + -1;\n        if (inputData[2] == (uint *)0x1000) {\n          do {\n            if ((**inputData & 0x80) == 0x80) {\n              elapsedTime = 0;\n              goto LAB_0800454c;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (elapsedTime = HAL_GetTick(), (uint)(elapsedTime - currentTime) <= timeout))));\n          (*inputData)[3] = (*inputData)[3] & 0xfffffe5f;\n          (*inputData)[5] = (*inputData)[5] & 0xfffffffe;\n          *(undefined *)((int)inputData + 0x39) = 0x20;\n          *(undefined *)((int)inputData + 0x3a) = 0x20;\n          *(undefined *)(inputData + 0xe) = 0;\n          elapsedTime = 3;\nLAB_0800454c:\n          if (elapsedTime != 0) {\n            return 3;\n          }\n          (*inputData)[1] = *currentElement & 0x1ff;\n          if (inputData[4] == (uint *)0x0) {\n            currentElement = currentElement + 1;\n          }\n          else {\n            currentElement = (ushort *)((int)currentElement + 1);\n          }\n        }\n        else {\n          do {\n            if ((**inputData & 0x80) == 0x80) {\n              elapsedTime = 0;\n              goto LAB_08004614;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (elapsedTime = HAL_GetTick(), (uint)(elapsedTime - currentTime) <= timeout))));\n          (*inputData)[3] = (*inputData)[3] & 0xfffffe5f;\n          (*inputData)[5] = (*inputData)[5] & 0xfffffffe;\n          *(undefined *)((int)inputData + 0x39) = 0x20;\n          *(undefined *)((int)inputData + 0x3a) = 0x20;\n          *(undefined *)(inputData + 0xe) = 0;\n          elapsedTime = 3;\nLAB_08004614:\n          if (elapsedTime != 0) {\n            return 3;\n          }\n          (*inputData)[1] = (uint)*(byte *)currentElement;\n          currentElement = (ushort *)((int)currentElement + 1);\n        }\n      }\n      do {\n        if ((**inputData & 0x40) == 0x40) {\n          currentTime = 0;\n          goto LAB_080046c6;\n        }\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (elapsedTime = HAL_GetTick(), (uint)(elapsedTime - currentTime) <= timeout))));\n      (*inputData)[3] = (*inputData)[3] & 0xfffffe5f;\n      (*inputData)[5] = (*inputData)[5] & 0xfffffffe;\n      *(undefined *)((int)inputData + 0x39) = 0x20;\n      *(undefined *)((int)inputData + 0x3a) = 0x20;\n      *(undefined *)(inputData + 0xe) = 0;\n      currentTime = 3;\nLAB_080046c6:\n      if (currentTime == 0) {\n        *(undefined *)((int)inputData + 0x39) = 0x20;\n        *(undefined *)(inputData + 0xe) = 0;\n        returnValue = 0;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004436": "process_input_08004436",
                "param_1": "inputData",
                "param_2": "inputArray",
                "param_3": "arraySize",
                "param_4": "timeout",
                "iVar1": "currentTime",
                "iVar2": "elapsedTime",
                "uVar3": "returnValue",
                "local_58": "currentElement"
            },
            "calling": [
                "uart_print"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046ec": {
            "entrypoint": "0x080046ec",
            "current_name": "calculate_clock_divider_080046ec",
            "code": "\nvoid calculateClockDivider_080046ec(int *clockConfig)\n\n{\n  ulonglong pclkDivider;\n  int pclk2Freq;\n  int clockConfig1;\n  uint temp;\n  int clockConfig2;\n  undefined8 pclkFreq;\n  \n  *(uint *)(*clockConfig + 0x10) = clockConfig[3] | *(uint *)(*clockConfig + 0x10) & 0xffffcfff;\n  *(uint *)(*clockConfig + 0xc) =\n       *(uint *)(*clockConfig + 0xc) & 0xffffe9f3 | clockConfig[5] | clockConfig[2] | clockConfig[4];\n  *(uint *)(*clockConfig + 0x14) = clockConfig[6] | *(uint *)(*clockConfig + 0x14) & 0xfffffcff;\n  if (*clockConfig == 0x40013800) {\n    pclkFreq = HAL_RCC_GetPCLK2Freq();\n    pclkDivider = (ulonglong)(uint)((int)pclkFreq * 0x19) / (ulonglong)(uint)(clockConfig[1] << 2);\n    pclk2Freq = HAL_RCC_GetPCLK2Freq\n                      ((int)pclkFreq,(int)((ulonglong)pclkFreq >> 0x20),(int)(pclkDivider * 0x51eb851f));\n    clockConfig1 = clockConfig[1];\n    pclkFreq = HAL_RCC_GetPCLK2Freq();\n    temp = ((uint)(pclk2Freq * 0x19) / (uint)(clockConfig1 << 2) +\n            (int)(((ulonglong)(uint)((int)pclkFreq * 0x19) / (ulonglong)(uint)(clockConfig[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    pclk2Freq = HAL_RCC_GetPCLK2Freq((int)pclkFreq,(int)((ulonglong)pclkFreq >> 0x20),temp * 0x51eb851f);\n    clockConfig2 = clockConfig[1];\n    clockConfig1 = HAL_RCC_GetPCLK2Freq();\n    *(uint *)(*clockConfig + 8) =\n         ((((uint)(pclk2Freq * 0x19) / (uint)(clockConfig2 << 2) +\n           (int)(((ulonglong)(uint)(clockConfig1 * 0x19) / (ulonglong)(uint)(clockConfig[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(pclkDivider / 100) * 0x10 + (temp / 100 & 0xf0);\n  }\n  else {\n    pclkFreq = HAL_RCC_GetPCLK1Freq();\n    pclkDivider = (ulonglong)(uint)((int)pclkFreq * 0x19) / (ulonglong)(uint)(clockConfig[1] << 2);\n    pclk2Freq = HAL_RCC_GetPCLK1Freq\n                      ((int)pclkFreq,(int)((ulonglong)pclkFreq >> 0x20),(int)(pclkDivider * 0x51eb851f));\n    clockConfig1 = clockConfig[1];\n    pclkFreq = HAL_RCC_GetPCLK1Freq();\n    temp = ((uint)(pclk2Freq * 0x19) / (uint)(clockConfig1 << 2) +\n            (int)(((ulonglong)(uint)((int)pclkFreq * 0x19) / (ulonglong)(uint)(clockConfig[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    pclk2Freq = HAL_RCC_GetPCLK1Freq((int)pclkFreq,(int)((ulonglong)pclkFreq >> 0x20),temp * 0x51eb851f);\n    clockConfig2 = clockConfig[1];\n    clockConfig1 = HAL_RCC_GetPCLK1Freq();\n    *(uint *)(*clockConfig + 8) =\n         ((((uint)(pclk2Freq * 0x19) / (uint)(clockConfig2 << 2) +\n           (int)(((ulonglong)(uint)(clockConfig1 * 0x19) / (ulonglong)(uint)(clockConfig[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(pclkDivider / 100) * 0x10 + (temp / 100 & 0xf0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046ec": "calculate_clock_divider_080046ec",
                "param_1": "clockConfig",
                "uVar1": "pclkDivider",
                "iVar2": "pclk2Freq",
                "iVar3": "clockConfig1",
                "uVar4": "temp",
                "iVar5": "clockConfig2",
                "uVar6": "pclkFreq"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800491c": {
            "entrypoint": "0x0800491c",
            "current_name": "initialize_mpu_0800491c",
            "code": "\nvoid initializeMPU_0800491c(undefined4 *outputData)\n\n{\n  undefined byte1;\n  undefined byte2;\n  undefined byteArray [5];\n  \n  byte1 = 0;\n  (*DAT_20000a54)(0xd0,0x6b,&byte1,1);\n  byte2 = 0x10;\n  (*DAT_20000a54)(0xd0,0x1c,&byte2,1);\n  byteArray[0] = 8;\n  (*DAT_20000a54)(0xd0,0x1b,byteArray,1);\n  *outputData = 0;\n  outputData[1] = 0;\n  outputData[2] = 0;\n  outputData[3] = 0;\n  outputData[4] = 0;\n  outputData[5] = 0;\n  outputData[6] = 0;\n  outputData[7] = 0;\n  outputData[8] = 0;\n  outputData[9] = 0;\n  outputData[10] = 0;\n  mpu6050_calibrate(outputData);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800491c": "initialize_mpu_0800491c",
                "param_1": "outputData",
                "local_13": "byte1",
                "local_12": "byte2",
                "local_11": "byteArray"
            },
            "calling": [
                "main"
            ],
            "called": [
                "mpu6050_calibrate"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049cc": {
            "entrypoint": "0x080049cc",
            "current_name": "calculate_average_sensor_data_080049cc",
            "code": "\nvoid calculateAverageSensorData_080049cc(int sensorData)\n\n{\n  undefined4 average;\n  undefined4 roll;\n  undefined4 pitch;\n  undefined4 getCurrentTime;\n  int dataCount;\n  int count;\n  undefined4 sumAccRoll;\n  undefined4 sumAccPitch;\n  undefined4 sumY;\n  undefined4 sumX;\n  \n  dataCount = 1;\n  sumX = 0;\n  sumY = 0;\n  sumAccPitch = 0;\n  sumAccRoll = 0;\n  getCurrentTime = (*DAT_20000a50)();\n  count = 0;\n  while( true ) {\n    if (dataCount <= count) break;\n    pitch = 0;\n    roll = 0;\n    mpu6050_update(sensorData);\n    mpu6050_calc_acc_pitch_roll(sensorData,&pitch,&roll);\n    sumAccPitch = __addsf3(sumAccPitch,pitch);\n    sumAccRoll = __addsf3(sumAccRoll,roll);\n    sumX = __addsf3(sumX,*(undefined4 *)(sensorData + 0x10));\n    sumY = __addsf3(sumY,*(undefined4 *)(sensorData + 0x14));\n    getCurrentTime = (*DAT_20000a50)();\n    count = count + 1;\n  }\n  average = __floatsisf(dataCount);\n  average = __aeabi_fdiv(sumX,average);\n  *(undefined4 *)(sensorData + 0x1c) = average;\n  average = __floatsisf(dataCount);\n  average = __aeabi_fdiv(sumY,average);\n  *(undefined4 *)(sensorData + 0x20) = average;\n  average = __floatsisf(dataCount);\n  average = __aeabi_fdiv(sumAccPitch,average);\n  *(undefined4 *)(sensorData + 0x24) = average;\n  average = __floatsisf(dataCount);\n  average = __aeabi_fdiv(sumAccRoll,average);\n  *(undefined4 *)(sensorData + 0x28) = average;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049cc": "calculate_average_sensor_data_080049cc",
                "param_1": "sensorData",
                "uVar1": "average",
                "local_20": "dataCount",
                "local_c": "sumX",
                "local_10": "sumY",
                "local_14": "sumAccPitch",
                "local_18": "sumAccRoll",
                "local_24": "getCurrentTime",
                "local_1c": "count",
                "local_28": "pitch",
                "local_2c": "roll"
            },
            "calling": [
                "mpu6050_init"
            ],
            "called": [
                "__aeabi_fdiv",
                "__addsf3",
                "mpu6050_update",
                "mpu6050_calc_acc_pitch_roll",
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ae0": {
            "entrypoint": "0x08004ae0",
            "current_name": "convert_to_floats_08004ae0",
            "code": "\nvoid convertToFloats_08004ae0(undefined4 *resultArray)\n\n{\n  undefined4 uVar1;\n  undefined tempVar1;\n  undefined tempVar2;\n  undefined tempVar3;\n  undefined tempVar4;\n  undefined tempVar5;\n  undefined tempVar6;\n  undefined tempVar7;\n  undefined tempVar8;\n  undefined tempVar9;\n  undefined tempVar10;\n  undefined tempVar11;\n  undefined tempVar12;\n  undefined tempVar13;\n  undefined tempVar14;\n  short convertedValue1;\n  short convertedValue2;\n  short convertedValue3;\n  short convertedValue4;\n  short convertedValue5;\n  short convertedValue6;\n  \n  (*DAT_20000a4c)(0xd0,0x3b,&tempVar1,0xe);\n  convertedValue6 = CONCAT11(tempVar3,tempVar4);\n  convertedValue5 = CONCAT11(tempVar5,tempVar6);\n  convertedValue4 = CONCAT11(tempVar7,tempVar8);\n  convertedValue3 = CONCAT11(tempVar9,tempVar10);\n  convertedValue2 = CONCAT11(tempVar11,tempVar12);\n  convertedValue1 = CONCAT11(tempVar13,tempVar14);\n  uVar1 = __floatsisf((int)CONCAT11(tempVar1,tempVar2));\n  *resultArray = uVar1;\n  uVar1 = __floatsisf((int)convertedValue6);\n  resultArray[1] = uVar1;\n  uVar1 = __floatsisf((int)convertedValue5);\n  resultArray[2] = uVar1;\n  uVar1 = __floatsisf((int)convertedValue4);\n  resultArray[3] = uVar1;\n  uVar1 = __floatsisf((int)convertedValue3);\n  resultArray[4] = uVar1;\n  uVar1 = __floatsisf((int)convertedValue2);\n  resultArray[5] = uVar1;\n  uVar1 = __floatsisf((int)convertedValue1);\n  resultArray[6] = uVar1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ae0": "convert_to_floats_08004ae0",
                "param_1": "resultArray",
                "local_2c": "tempVar1",
                "local_2b": "tempVar2",
                "local_2a": "tempVar3",
                "local_29": "tempVar4",
                "local_28": "tempVar5",
                "local_27": "tempVar6",
                "local_26": "tempVar7",
                "local_25": "tempVar8",
                "local_24": "tempVar9",
                "local_23": "tempVar10",
                "local_22": "tempVar11",
                "local_21": "tempVar12",
                "local_20": "tempVar13",
                "local_1f": "tempVar14",
                "local_1e": "convertedValue1",
                "local_1c": "convertedValue2",
                "local_1a": "convertedValue3",
                "local_18": "convertedValue4",
                "local_16": "convertedValue5",
                "local_14": "convertedValue6"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calibrate"
            ],
            "called": [
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bd8": {
            "entrypoint": "0x08004bd8",
            "current_name": "calculate_angles_08004bd8",
            "code": "\nvoid calculateAngles_08004bd8(int inputValues,undefined4 *outputValue)\n\n{\n  undefined4 difference;\n  undefined8 tempVar1;\n  undefined8 tempVar2;\n  \n  difference = __aeabi_fsub(*(undefined4 *)(inputValues + 0x10),*(undefined4 *)(inputValues + 0x1c));\n  tempVar1 = __aeabi_f2d(DAT_200009e4);\n  tempVar2 = __aeabi_f2d(difference);\n  tempVar2 = __muldf3((int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20),0x83f5c366,0x3f340215);\n  tempVar1 = __aeabi_dadd((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),(int)tempVar2,\n                       (int)((ulonglong)tempVar2 >> 0x20));\n  DAT_200009e4 = __truncdfsf2((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20));\n  tempVar1 = __aeabi_f2d(*(undefined4 *)(inputValues + 4));\n  tempVar1 = __divdf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0,0x40b00000);\n  tempVar2 = __aeabi_f2d(*(undefined4 *)(inputValues + 8));\n  tempVar2 = __divdf3((int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20),0,0x40b00000);\n  tempVar1 = atan2((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),(int)tempVar2,\n                (int)((ulonglong)tempVar2 >> 0x20));\n  tempVar1 = __muldf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0,0x40668000);\n  tempVar1 = __divdf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0x54442d18,0x400921fb);\n  tempVar2 = __aeabi_f2d(*(undefined4 *)(inputValues + 0x24));\n  tempVar1 = __subdf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),(int)tempVar2,\n                   (int)((ulonglong)tempVar2 >> 0x20));\n  tempVar1 = __aeabi_dadd((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0,0x40568000);\n  difference = __truncdfsf2((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20));\n  if (DAT_20000005 == '\\0') {\n    tempVar1 = __aeabi_f2d(DAT_200009e4);\n    tempVar1 = __muldf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0x9999999a,0x3fe99999);\n    tempVar2 = __aeabi_f2d(difference);\n    tempVar2 = __muldf3((int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20),0x9999999a,0x3fc99999);\n    tempVar1 = __aeabi_dadd((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),(int)tempVar2,\n                         (int)((ulonglong)tempVar2 >> 0x20));\n    DAT_200009e4 = __truncdfsf2((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20));\n  }\n  else {\n    DAT_20000005 = '\\0';\n    DAT_200009e4 = difference;\n  }\n  *outputValue = DAT_200009e4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bd8": "calculate_angles_08004bd8",
                "param_1": "inputValues",
                "param_2": "outputValue",
                "uVar1": "difference",
                "uVar2": "tempVar1",
                "uVar3": "tempVar2"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_fsub",
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "__truncdfsf2",
                "atan2",
                "__subdf3",
                "__aeabi_f2d"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d78": {
            "entrypoint": "0x08004d78",
            "current_name": "calculate_angles_08004d78",
            "code": "\nvoid calculateAngles_08004d78(undefined4 *inputValues,undefined4 *angle1,undefined4 *angle2)\n\n{\n  undefined4 dividend1;\n  undefined4 dividend2;\n  undefined4 dividend3;\n  undefined8 result1;\n  undefined8 result2;\n  \n  dividend1 = __aeabi_fdiv(*inputValues,0x45800000);\n  dividend2 = __aeabi_fdiv(inputValues[1],0x45800000);\n  dividend3 = __aeabi_fdiv(inputValues[2],0x45800000);\n  result1 = __aeabi_f2d(dividend2);\n  result2 = __aeabi_f2d(dividend3);\n  result1 = atan2((int)result1,(int)((ulonglong)result1 >> 0x20),(int)result2,\n                (int)((ulonglong)result2 >> 0x20));\n  result1 = __muldf3((int)result1,(int)((ulonglong)result1 >> 0x20),0,0x40668000);\n  result1 = __divdf3((int)result1,(int)((ulonglong)result1 >> 0x20),0x54442d18,0x400921fb);\n  dividend2 = __truncdfsf2((int)result1,(int)((ulonglong)result1 >> 0x20));\n  result1 = __aeabi_f2d(dividend1);\n  result2 = __aeabi_f2d(dividend3);\n  result1 = atan2((int)result1,(int)((ulonglong)result1 >> 0x20),(int)result2,\n                (int)((ulonglong)result2 >> 0x20));\n  result1 = __muldf3((int)result1,(int)((ulonglong)result1 >> 0x20),0,0x40668000);\n  result1 = __divdf3((int)result1,(int)((ulonglong)result1 >> 0x20),0x54442d18,0x400921fb);\n  dividend1 = __truncdfsf2((int)result1,(int)((ulonglong)result1 >> 0x20));\n  *angle1 = dividend2;\n  *angle2 = dividend1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d78": "calculate_angles_08004d78",
                "param_1": "inputValues",
                "param_2": "angle1",
                "param_3": "angle2",
                "uVar1": "dividend1",
                "uVar2": "dividend2",
                "uVar3": "dividend3",
                "uVar4": "result1",
                "uVar5": "result2"
            },
            "calling": [
                "mpu6050_calibrate"
            ],
            "called": [
                "__aeabi_fdiv",
                "__muldf3",
                "__divdf3",
                "__truncdfsf2",
                "atan2",
                "__aeabi_f2d"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e6c": {
            "entrypoint": "0x08004e6c",
            "current_name": "execute_software_interrupt_08004e6c",
            "code": "\nvoid execute_software_interrupt_08004e6c(void)\n\n{\n  trigger_system_call(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e6c": "execute_software_interrupt_08004e6c",
                "software_interrupt": "trigger_system_call"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "execute_afl_call_08004e74",
            "code": "\nundefined4 executeAflCall_08004e74(undefined4 inputParam)\n\n{\n  undefined4 returnValue;\n  \n  if (DAT_200009f0 == 0) {\n    returnValue = aflCall(1,inputParam,0);\n  }\n  else {\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "execute_afl_call_08004e74",
                "param_1": "inputParam",
                "uVar1": "returnValue"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ea4": {
            "entrypoint": "0x08004ea4",
            "current_name": "write_to_i2_c_memory_08004ea4",
            "code": "\nvoid write_to_I2C_memory_08004ea4(undefined device_address,undefined register_address,undefined4 data,undefined2 length)\n\n{\n  HAL_I2C_Mem_Write(&DAT_20000a88,device_address,register_address,1,data,length,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ea4": "write_to_i2_c_memory_08004ea4",
                "param_1": "device_address",
                "param_2": "register_address",
                "param_3": "data",
                "param_4": "length"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "read_memory_from_i2_c_08004ee8",
            "code": "\nvoid readMemoryFromI2C_08004ee8(undefined memoryAddress,undefined buffer,undefined4 dataSize,undefined2 registerAddress)\n\n{\n  HAL_I2C_Mem_Read(&DAT_20000a88,memoryAddress,buffer,1,dataSize,registerAddress,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "read_memory_from_i2_c_08004ee8",
                "param_1": "memoryAddress",
                "param_2": "buffer",
                "param_3": "dataSize",
                "param_4": "registerAddress"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "get_current_tick_08004f2c",
            "code": "\nundefined4 getCurrentTick_08004f2c(void)\n\n{\n  undefined4 currentTick;\n  \n  currentTick = HAL_GetTick();\n  return currentTick;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "get_current_tick_08004f2c",
                "uVar1": "currentTick"
            },
            "calling": [],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "transmit_data_over_uart_08004f3c",
            "code": "\nvoid transmitDataOverUART_08004f3c(undefined4 data,undefined2 length)\n\n{\n  HAL_UART_Transmit(&DAT_20000adc,data,length,0x32);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "transmit_data_over_uart_08004f3c",
                "param_1": "data",
                "param_2": "length"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "initialize_data_08004f60",
            "code": "\nvoid initializeData_08004f60(void)\n\n{\n  memset(&DAT_20000ba8,0,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "initialize_data_08004f60"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f78": {
            "entrypoint": "0x08004f78",
            "current_name": "calculate_and_print_pitch_08004f78",
            "code": "\nvoid calculateAndPrintPitch_08004f78(void)\n\n{\n  undefined4 result1;\n  int comparisonResult;\n  undefined4 result2;\n  uint xorResult;\n  undefined8 convertedPitch;\n  byte finalValue;\n  \n  mpu6050_update(&DAT_20000a5c);\n  mpu6050_calc_pitch(&DAT_20000a5c,&DAT_20000ba0);\n  flush_strbuf();\n  convertedPitch = __aeabi_f2d(DAT_20000ba0);\n  sprintf(&DAT_20000ba8,\"Pitch: %f\\n\",(int)convertedPitch,(int)((ulonglong)convertedPitch >> 0x20));\n  result1 = strlen(&DAT_20000ba8);\n  uart_print(&DAT_20000ba8,result1);\n  DAT_200009f8 = __aeabi_fsub(DAT_20000014,DAT_20000ba0);\n  DAT_20000be8 = __aeabi_fmul(DAT_20000a00,DAT_200009f8);\n  result1 = __aeabi_fmul(DAT_20000a04,DAT_200009f8);\n  DAT_20000b5c = __addsf3(result1,DAT_20000b5c);\n  result1 = __floatsisf(DAT_20000010);\n  comparisonResult = __aeabi_fcmplt(result1,DAT_20000b5c);\n  if (comparisonResult == 0) {\n    result1 = __floatsisf(DAT_200009f4);\n    comparisonResult = __aeabi_fcmpgt(result1,DAT_20000b5c);\n    if (comparisonResult != 0) {\n      DAT_20000b5c = __floatunsisf(DAT_200009f4);\n    }\n  }\n  else {\n    DAT_20000b5c = __floatunsisf(DAT_20000010);\n  }\n  xorResult = DAT_20000a08 ^ 0x80000000;\n  result1 = __aeabi_fsub(DAT_200009f8,DAT_200009fc);\n  DAT_20000a58 = __aeabi_fmul(xorResult,result1);\n  result1 = __addsf3(DAT_20000be8,DAT_20000b5c);\n  result1 = __addsf3(result1,DAT_20000a58);\n  result2 = __floatsisf(DAT_20000010);\n  comparisonResult = __aeabi_fcmpgt(result1,result2);\n  if (comparisonResult == 0) {\n    result2 = __floatsisf(DAT_200009f4);\n    comparisonResult = __aeabi_fcmplt(result1,result2);\n    if (comparisonResult == 0) {\n      finalValue = __fixunssfsi(result1);\n    }\n    else {\n      finalValue = DAT_200009f4;\n    }\n  }\n  else {\n    finalValue = DAT_20000010;\n  }\n  DAT_200009fc = DAT_200009f8;\n  comparisonResult = __aeabi_fcmpgt(DAT_200009f8,0);\n  HAL_GPIO_WritePin(0x40010800,2,comparisonResult != 0);\n  comparisonResult = __aeabi_fcmpgt(DAT_200009f8,0);\n  HAL_GPIO_WritePin(0x40010800,4,comparisonResult == 0);\n  comparisonResult = __aeabi_fcmpgt(DAT_200009f8,0);\n  HAL_GPIO_WritePin(0x40010800,8,comparisonResult != 0);\n  comparisonResult = __aeabi_fcmpgt(DAT_200009f8,0);\n  HAL_GPIO_WritePin(0x40010800,0x10,comparisonResult == 0);\n  *(uint *)(DAT_20000b1c + 0x34) = (uint)finalValue;\n  *(uint *)(DAT_20000b1c + 0x40) = (uint)finalValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f78": "calculate_and_print_pitch_08004f78",
                "uVar1": "result1",
                "iVar2": "comparisonResult",
                "uVar3": "result2",
                "uVar4": "xorResult",
                "uVar5": "convertedPitch",
                "local_11": "finalValue"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler",
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "__aeabi_fsub",
                "__aeabi_fmul",
                "HAL_GPIO_WritePin",
                "__aeabi_fcmpgt",
                "__floatunsisf",
                "flush_strbuf",
                "mpu6050_calc_pitch",
                "__aeabi_f2d",
                "__fixunssfsi",
                "__aeabi_fcmplt",
                "sprintf",
                "__addsf3",
                "mpu6050_update",
                "strlen",
                "uart_print",
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005224": {
            "entrypoint": "0x08005224",
            "current_name": "initialize_system_08005224",
            "code": "\nvoid initializeSystem_08005224(void)\n\n{\n  initializeHardware();\n  configureSystemClock();\n  initializeGPIO();\n  initializeI2C1();\n  initializeUSART1_UART();\n  initializeTIM2();\n  initializeTIM1();\n  DAT_20000a54 = 0x8004ea5;\n  DAT_20000a4c = 0x8004ee9;\n  DAT_20000a50 = 0x8004f2d;\n  startPWM(&DAT_20000b1c,0);\n  startPWM(&DAT_20000b1c,0xc);\n  initializeMPU6050(&DAT_20000a5c);\n  startTIM_Base_IT(&DAT_20000b60);\n  startForkServer(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005224": "initialize_system_08005224",
                "HAL_Init": "initializeHardware",
                "SystemClock_Config": "configureSystemClock",
                "MX_GPIO_Init": "initializeGPIO",
                "MX_I2C1_Init": "initializeI2C1",
                "MX_USART1_UART_Init": "initializeUSART1_UART",
                "MX_TIM2_Init": "initializeTIM2",
                "MX_TIM1_Init": "initializeTIM1",
                "HAL_TIM_PWM_Start": "startPWM",
                "mpu6050_init": "initializeMPU6050",
                "HAL_TIM_Base_Start_IT": "startTIM_Base_IT",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "startForkserver",
                "MX_USART1_UART_Init",
                "MX_TIM1_Init",
                "MX_GPIO_Init",
                "mpu6050_init",
                "HAL_TIM_Base_Start_IT",
                "MX_I2C1_Init",
                "HAL_Init",
                "HAL_TIM_PWM_Start",
                "MX_TIM2_Init",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052a0": {
            "entrypoint": "0x080052a0",
            "current_name": "initialize_system_080052a0",
            "code": "\nvoid initializeSystem_080052a0(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined4 oscillatorParameters;\n  undefined4 clockSource;\n  undefined4 apb1Divider;\n  undefined4 apb2Divider;\n  undefined4 ahbDivider;\n  undefined4 oscillatorType;\n  undefined4 oscillatorTimeout;\n  undefined4 flashLatency;\n  undefined4 voltageScaling;\n  undefined4 hseState;\n  undefined4 hclkPrescaler;\n  undefined4 pclk1Prescaler;\n  \n  oscillatorType = 1;\n  oscillatorTimeout = 0x10000;\n  flashLatency = 0;\n  voltageScaling = 1;\n  hseState = 2;\n  hclkPrescaler = 0x10000;\n  pclk1Prescaler = 0x1c0000;\n  iVar1 = HAL_RCC_OscConfig(&oscillatorType);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x151);\n  }\n  oscillatorParameters = 0xf;\n  clockSource = 2;\n  apb1Divider = 0x80;\n  apb2Divider = 0;\n  ahbDivider = 0;\n  iVar1 = HAL_RCC_ClockConfig(&oscillatorParameters,2);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x15e);\n  }\n  uVar2 = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config((uint)uVar2 / 1000,(int)((ulonglong)uVar2 >> 0x20),(uint)uVar2 * 0x10624dd3);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(0xffffffff,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052a0": "initialize_system_080052a0",
                "local_44": "oscillatorParameters",
                "local_40": "clockSource",
                "local_3c": "apb1Divider",
                "local_38": "apb2Divider",
                "local_34": "ahbDivider",
                "local_30": "oscillatorType",
                "local_2c": "oscillatorTimeout",
                "local_28": "flashLatency",
                "local_20": "voltageScaling",
                "local_14": "hseState",
                "local_10": "hclkPrescaler",
                "local_c": "pclk1Prescaler"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq",
                "_Error_Handler",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_ClockConfig",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_SYSTICK_Config",
                "HAL_RCC_OscConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005348": {
            "entrypoint": "0x08005348",
            "current_name": "initialize_i2_c_08005348",
            "code": "\nvoid initializeI2C_08005348(void)\n\n{\n  int initResult;\n  \n  DAT_20000a88 = 0x40005400;\n  DAT_20000a8c = 400000;\n  DAT_20000a90 = 0;\n  DAT_20000a94 = 0;\n  DAT_20000a98 = 0x4000;\n  DAT_20000a9c = 0;\n  DAT_20000aa0 = 0;\n  DAT_20000aa4 = 0;\n  DAT_20000aa8 = 0;\n  initResult = HAL_I2C_Init(&DAT_20000a88);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x17a);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005348": "initialize_i2_c_08005348",
                "iVar1": "initResult"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_I2C_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053b0": {
            "entrypoint": "0x080053b0",
            "current_name": "initialize_timers_080053b0",
            "code": "\nvoid initializeTimers_080053b0(void)\n\n{\n  int iVar1;\n  undefined4 breakDeadTime;\n  undefined4 localVariable1;\n  undefined4 localVariable2;\n  undefined4 localVariable3;\n  undefined4 localVariable4;\n  undefined4 deadTime;\n  undefined4 localVariable5;\n  undefined4 pwmConfig;\n  undefined4 localVariable6;\n  undefined4 localVariable7;\n  undefined4 localVariable8;\n  undefined4 localVariable9;\n  undefined4 localVariable10;\n  undefined4 localVariable11;\n  undefined4 localVariable12;\n  undefined4 localVariable13;\n  undefined4 localVariableArray [4];\n  \n  DAT_20000b1c = 0x40012c00;\n  DAT_20000b20 = 0x708;\n  DAT_20000b24 = 0;\n  DAT_20000b28 = 100;\n  DAT_20000b2c = 0;\n  DAT_20000b30 = 0;\n  DAT_20000b34 = 0;\n  iVar1 = HAL_TIM_Base_Init(&DAT_20000b1c);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",399);\n  }\n  localVariableArray[0] = 0x1000;\n  iVar1 = HAL_TIM_ConfigClockSource(&DAT_20000b1c,localVariableArray);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x194);\n  }\n  iVar1 = HAL_TIM_PWM_Init(&DAT_20000b1c);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x198);\n  }\n  localVariable12 = 0;\n  localVariable13 = 0;\n  iVar1 = HAL_TIMEx_MasterConfigSynchronization(&DAT_20000b1c,&localVariable12);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x19f);\n  }\n  pwmConfig = 0x60;\n  localVariable6 = 0;\n  localVariable7 = 0;\n  localVariable8 = 0;\n  localVariable9 = 0;\n  localVariable10 = 0;\n  localVariable11 = 0;\n  iVar1 = HAL_TIM_PWM_ConfigChannel(&DAT_20000b1c,&pwmConfig,0);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x1ab);\n  }\n  iVar1 = HAL_TIM_PWM_ConfigChannel(&DAT_20000b1c,&pwmConfig,0xc);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x1b0);\n  }\n  breakDeadTime = 0;\n  localVariable1 = 0;\n  localVariable2 = 0;\n  localVariable3 = 0;\n  localVariable4 = 0;\n  deadTime = 0x2000;\n  localVariable5 = 0;\n  iVar1 = HAL_TIMEx_ConfigBreakDeadTime(&DAT_20000b1c,&breakDeadTime);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x1bc);\n  }\n  HAL_TIM_MspPostInit(&DAT_20000b1c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053b0": "initialize_timers_080053b0",
                "local_58": "breakDeadTime",
                "local_54": "localVariable1",
                "local_50": "localVariable2",
                "local_4c": "localVariable3",
                "local_48": "localVariable4",
                "local_44": "deadTime",
                "local_40": "localVariable5",
                "local_3c": "pwmConfig",
                "local_38": "localVariable6",
                "local_34": "localVariable7",
                "local_30": "localVariable8",
                "local_2c": "localVariable9",
                "local_28": "localVariable10",
                "local_24": "localVariable11",
                "local_20": "localVariable12",
                "local_1c": "localVariable13",
                "local_18": "localVariableArray"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_ConfigClockSource",
                "_Error_Handler",
                "HAL_TIM_Base_Init",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_MspPostInit",
                "HAL_TIMEx_MasterConfigSynchronization"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005500": {
            "entrypoint": "0x08005500",
            "current_name": "initialize_timer_08005500",
            "code": "\nvoid initializeTimer_08005500(void)\n\n{\n  int initResult;\n  undefined4 prescaler;\n  undefined4 clockSource;\n  undefined4 configValues [4];\n  \n  DAT_20000b60 = 0x40000000;\n  DAT_20000b64 = 36000;\n  DAT_20000b68 = 0;\n  DAT_20000b6c = 0x14;\n  DAT_20000b70 = 0;\n  DAT_20000b78 = 0;\n  initResult = HAL_TIM_Base_Init(&DAT_20000b60);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x1d0);\n  }\n  configValues[0] = 0x1000;\n  initResult = HAL_TIM_ConfigClockSource(&DAT_20000b60,configValues);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x1d5);\n  }\n  prescaler = 0x20;\n  clockSource = 0;\n  initResult = HAL_TIMEx_MasterConfigSynchronization(&DAT_20000b60,&prescaler);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x1dc);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005500": "initialize_timer_08005500",
                "local_20": "prescaler",
                "local_1c": "clockSource",
                "local_18": "configValues",
                "iVar1": "initResult"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIM_ConfigClockSource",
                "_Error_Handler",
                "HAL_TIM_Base_Init",
                "HAL_TIMEx_MasterConfigSynchronization"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005598": {
            "entrypoint": "0x08005598",
            "current_name": "initialize_uart_08005598",
            "code": "\nvoid initializeUART_08005598(void)\n\n{\n  int initResult;\n  \n  DAT_20000adc = 0x40013800;\n  DAT_20000ae0 = 0x1c200;\n  DAT_20000ae4 = 0;\n  DAT_20000ae8 = 0;\n  DAT_20000aec = 0;\n  DAT_20000af0 = 0xc;\n  DAT_20000af4 = 0;\n  DAT_20000af8 = 0;\n  initResult = HAL_UART_Init(&DAT_20000adc);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x1ed);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005598": "initialize_uart_08005598",
                "iVar1": "initResult"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_UART_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055f4": {
            "entrypoint": "0x080055f4",
            "current_name": "initialize_gpio_080055f4",
            "code": "\n\n\nvoid initializeGPIO_080055f4(void)\n\n{\n  undefined4 pin;\n  undefined4 state;\n  undefined4 mode;\n  \n  _DAT_40021018 = _DAT_40021018 | 0x2c;\n  HAL_GPIO_WritePin(0x40010800,0x1e,0,_DAT_40021018 & 8);\n  pin = 0x1e;\n  state = 1;\n  mode = 2;\n  HAL_GPIO_Init(0x40010800,&pin);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055f4": "initialize_gpio_080055f4",
                "local_18": "pin",
                "local_14": "state",
                "local_c": "mode"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_GPIO_Init",
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005674": {
            "entrypoint": "0x08005674",
            "current_name": "infinite_loop_08005674",
            "code": "\nvoid infiniteLoop_08005674(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005674": "infinite_loop_08005674"
            },
            "calling": [
                "MX_USART1_UART_Init",
                "MX_TIM1_Init",
                "MX_I2C1_Init",
                "SystemClock_Config",
                "MX_TIM2_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005680": {
            "entrypoint": "0x08005680",
            "current_name": "initialize_gpio_08005680",
            "code": "\nvoid initializeGPIO_08005680(int *gpioConfig)\n\n{\n  undefined4 gpioPinConfig;\n  undefined4 gpioMode;\n  undefined4 gpioSpeed;\n  \n  if (*gpioConfig == 0x40012c00) {\n    gpioPinConfig = 0x900;\n    gpioMode = 2;\n    gpioSpeed = 2;\n    HAL_GPIO_Init(0x40010800,&gpioPinConfig);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005680": "initialize_gpio_08005680",
                "param_1": "gpioConfig",
                "local_18": "gpioPinConfig",
                "local_14": "gpioMode",
                "local_c": "gpioSpeed"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005704": {
            "entrypoint": "0x08005704",
            "current_name": "handle_sys_tick_interrupt_08005704",
            "code": "\nvoid handleSysTickInterrupt_08005704(void)\n\n{\n  incrementSystemTick();\n  handleSysTickIRQ();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005704": "handle_sys_tick_interrupt_08005704",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickIRQ"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "handle_tim_interrupt_08005714",
            "code": "\nvoid handle_TIM_interrupt_08005714(void)\n\n{\n  HAL_TIM_IRQHandler(&DAT_20000b60);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005714": "handle_tim_interrupt_08005714"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "allocate_memory_08005728",
            "code": "\nundefined * allocate_memory_08005728(int size)\n\n{\n  undefined4 *errno_ptr;\n  undefined *buffer;\n  undefined stack_buffer [4];\n  int remaining;\n  undefined *default_allocation_ptr;\n  \n  if (DAT_20000a10 == (undefined *)0x0) {\n    DAT_20000a10 = &DAT_20000c18;\n  }\n  default_allocation_ptr = DAT_20000a10;\n  if (stack_buffer < DAT_20000a10 + size) {\n    remaining = size;\n    errno_ptr = (undefined4 *)__errno();\n    *errno_ptr = 0xc;\n    buffer = (undefined *)0xffffffff;\n  }\n  else {\n    buffer = DAT_20000a10;\n    DAT_20000a10 = DAT_20000a10 + size;\n  }\n  return buffer;\n}\n\n",
            "renaming": {
                "FUN_08005728": "allocate_memory_08005728",
                "param_1": "size",
                "puVar1": "errno_ptr",
                "puVar2": "buffer",
                "auStack_18": "stack_buffer",
                "local_14": "remaining",
                "local_c": "default_allocation_ptr"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [
                "__errno"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005780": {
            "entrypoint": "0x08005780",
            "current_name": "initialize_hardware_08005780",
            "code": "\n\n\nvoid initializeHardware_08005780(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005780": "initialize_hardware_08005780"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057e8": {
            "entrypoint": "0x080057e8",
            "current_name": "initialize_memory_080057e8",
            "code": "\nvoid initializeMemory_080057e8(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &DAT_200009c8; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(index + 0x800a1a4);\n  }\n  for (ptr = &DAT_200009c8; ptr < &DAT_20000c14; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x800581a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057e8": "initialize_memory_080057e8",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005834": {
            "entrypoint": "0x08005834",
            "current_name": "FUN_08005834",
            "code": "\nuint __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  undefined8 uVar6;\n  \n  uVar4 = param_4 & 0x7fffffff;\n  if ((0x7ff00000 < (uVar4 | (-param_3 | param_3) >> 0x1f)) ||\n     (uVar5 = param_2 & 0x7fffffff, 0x7ff00000 < (uVar5 | (-param_1 | param_1) >> 0x1f))) {\n    uVar4 = __aeabi_dadd(param_3,param_4,param_1,param_2);\n    return uVar4;\n  }\n  if ((param_4 + 0xc0100000 | param_3) == 0) {\n    uVar4 = atan();\n    return uVar4;\n  }\n  uVar3 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n  if ((uVar5 | param_1) == 0) {\n    if (uVar3 == 2) {\n      return 0x54442d18;\n    }\n    if (uVar3 != 3) {\n      return param_1;\n    }\n  }\n  else if ((uVar4 | param_3) != 0) {\n    if (uVar4 == 0x7ff00000) {\n      if (uVar5 == 0x7ff00000) {\n        if (uVar3 == 2) {\n          return 0x7f3321d2;\n        }\n        if (uVar3 == 3) {\n          return 0x7f3321d2;\n        }\n        if (uVar3 == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (uVar3 == 2) {\n        return 0x54442d18;\n      }\n      if (uVar3 != 3) {\n        if (uVar3 != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (uVar5 != 0x7ff00000) {\n      iVar1 = (int)(uVar5 - uVar4) >> 0x14;\n      if (iVar1 < 0x3d) {\n        if (((int)param_4 < 0) && (iVar1 + 0x3c < 0 != SCARRY4(iVar1,0x3c))) {\n          uVar6 = 0;\n        }\n        else {\n          __divdf3(param_1,param_2,param_3,param_4,param_4);\n          fabs();\n          uVar6 = atan();\n        }\n      }\n      else {\n        uVar6 = 0x3ff921fb54442d18;\n      }\n      uVar2 = (undefined4)((ulonglong)uVar6 >> 0x20);\n      uVar4 = (uint)uVar6;\n      if (uVar3 == 1) {\n        return uVar4;\n      }\n      if (uVar3 == 2) {\n        uVar6 = __subdf3(uVar4,uVar2,0x33145c07,0x3ca1a626);\n        uVar4 = __subdf3(0x54442d18,0x400921fb,(int)uVar6,(int)((ulonglong)uVar6 >> 0x20));\n        return uVar4;\n      }\n      if (uVar3 != 0) {\n        uVar6 = __subdf3(uVar4,uVar2,0x33145c07,0x3ca1a626);\n        uVar4 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),0x54442d18,0x400921fb);\n        return uVar4;\n      }\n      return uVar4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {},
            "calling": [
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005838": {
            "entrypoint": "0x08005838",
            "current_name": "calculate_arc_tangent_08005838",
            "code": "\nuint calculateArcTangent_08005838(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int difference;\n  undefined4 result1;\n  uint shiftedResult;\n  uint shiftedInput4;\n  uint shiftedInput2;\n  undefined8 tempResult;\n  \n  shiftedInput4 = input4 & 0x7fffffff;\n  if ((0x7ff00000 < (shiftedInput4 | (-input3 | input3) >> 0x1f)) ||\n     (shiftedInput2 = input2 & 0x7fffffff, 0x7ff00000 < (shiftedInput2 | (-input1 | input1) >> 0x1f))) {\n    shiftedInput4 = __aeabi_dadd(input3,input4,input1,input2);\n    return shiftedInput4;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    shiftedInput4 = atan();\n    return shiftedInput4;\n  }\n  shiftedResult = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((shiftedInput2 | input1) == 0) {\n    if (shiftedResult == 2) {\n      return 0x54442d18;\n    }\n    if (shiftedResult != 3) {\n      return input1;\n    }\n  }\n  else if ((shiftedInput4 | input3) != 0) {\n    if (shiftedInput4 == 0x7ff00000) {\n      if (shiftedInput2 == 0x7ff00000) {\n        if (shiftedResult == 2) {\n          return 0x7f3321d2;\n        }\n        if (shiftedResult == 3) {\n          return 0x7f3321d2;\n        }\n        if (shiftedResult == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (shiftedResult == 2) {\n        return 0x54442d18;\n      }\n      if (shiftedResult != 3) {\n        if (shiftedResult != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (shiftedInput2 != 0x7ff00000) {\n      difference = (int)(shiftedInput2 - shiftedInput4) >> 0x14;\n      if (difference < 0x3d) {\n        if (((int)input4 < 0) && (difference + 0x3c < 0 != SCARRY4(difference,0x3c))) {\n          tempResult = 0;\n        }\n        else {\n          __divdf3(input1,input2,input3,input4,input4);\n          fabs();\n          tempResult = atan();\n        }\n      }\n      else {\n        tempResult = 0x3ff921fb54442d18;\n      }\n      result1 = (undefined4)((ulonglong)tempResult >> 0x20);\n      shiftedInput4 = (uint)tempResult;\n      if (shiftedResult == 1) {\n        return shiftedInput4;\n      }\n      if (shiftedResult == 2) {\n        tempResult = __subdf3(shiftedInput4,result1,0x33145c07,0x3ca1a626);\n        shiftedInput4 = __subdf3(0x54442d18,0x400921fb,(int)tempResult,(int)((ulonglong)tempResult >> 0x20));\n        return shiftedInput4;\n      }\n      if (shiftedResult != 0) {\n        tempResult = __subdf3(shiftedInput4,result1,0x33145c07,0x3ca1a626);\n        shiftedInput4 = __subdf3((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0x54442d18,0x400921fb);\n        return shiftedInput4;\n      }\n      return shiftedInput4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "FUN_08005838": "calculate_arc_tangent_08005838",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "difference",
                "uVar2": "result1",
                "uVar3": "shiftedResult",
                "uVar4": "shiftedInput4",
                "uVar5": "shiftedInput2",
                "uVar6": "tempResult"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "__aeabi_dadd",
                "atan",
                "__divdf3",
                "fabs",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f0": {
            "entrypoint": "0x080059f0",
            "current_name": "calculate_square_root_080059f0",
            "code": "\nundefined8 calculate_square_root_080059f0(int input_1,uint input_2,undefined4 input_3,undefined4 input_4)\n\n{\n  undefined4 temp_var_1;\n  undefined4 temp_var_2;\n  undefined4 temp_var_3;\n  undefined4 temp_var_4;\n  undefined4 temp_var_5;\n  undefined4 temp_var_6;\n  uint abs_input_2;\n  int operation;\n  undefined8 result_1;\n  undefined8 result_2;\n  \n  result_2 = CONCAT44(input_2,input_1);\n  abs_input_2 = input_2 & 0x7fffffff;\n  if (abs_input_2 < 0x44100000) {\n    if (abs_input_2 < 0x3fdc0000) {\n      if (abs_input_2 < 0x3e200000) {\n        result_1 = __aeabi_dadd(input_1,input_2,0x8800759c,0x7e37e43c,input_4);\n        operation = __aeabi_dcmpgt((int)result_1,(int)((ulonglong)result_1 >> 0x20),0,0x3ff00000);\n        if (operation != 0) {\n          return CONCAT44(input_2,input_1);\n        }\n      }\n      operation = -1;\n    }\n    else {\n      result_2 = fabs();\n      temp_var_4 = (undefined4)((ulonglong)result_2 >> 0x20);\n      temp_var_1 = (undefined4)result_2;\n      if (abs_input_2 < 0x3ff30000) {\n        if (abs_input_2 < 0x3fe60000) {\n          result_2 = __aeabi_dadd(temp_var_1,temp_var_4,temp_var_1,temp_var_4);\n          result_2 = __subdf3((int)result_2,(int)((ulonglong)result_2 >> 0x20),0,0x3ff00000);\n          result_1 = __aeabi_dadd(temp_var_1,temp_var_4,0,0x40000000);\n          result_2 = __divdf3((int)result_2,(int)((ulonglong)result_2 >> 0x20),(int)result_1,\n                            (int)((ulonglong)result_1 >> 0x20));\n          operation = 0;\n        }\n        else {\n          result_2 = __subdf3(temp_var_1,temp_var_4,0,0x3ff00000);\n          result_1 = __aeabi_dadd(temp_var_1,temp_var_4,0,0x3ff00000);\n          result_2 = __divdf3((int)result_2,(int)((ulonglong)result_2 >> 0x20),(int)result_1,\n                            (int)((ulonglong)result_1 >> 0x20));\n          operation = 1;\n        }\n      }\n      else if (abs_input_2 < 0x40038000) {\n        result_2 = __subdf3(temp_var_1,temp_var_4,0,0x3ff80000);\n        result_1 = __muldf3(temp_var_1,temp_var_4,0,0x3ff80000);\n        result_1 = __aeabi_dadd((int)result_1,(int)((ulonglong)result_1 >> 0x20),0,0x3ff00000);\n        result_2 = __divdf3((int)result_2,(int)((ulonglong)result_2 >> 0x20),(int)result_1,\n                          (int)((ulonglong)result_1 >> 0x20));\n        operation = 2;\n      }\n      else {\n        result_2 = __divdf3(0,0xbff00000,temp_var_1,temp_var_4);\n        operation = 3;\n      }\n    }\n    temp_var_6 = (undefined4)((ulonglong)result_2 >> 0x20);\n    temp_var_5 = (undefined4)result_2;\n    result_2 = __muldf3(temp_var_5,temp_var_6,temp_var_5,temp_var_6);\n    temp_var_2 = (undefined4)((ulonglong)result_2 >> 0x20);\n    temp_var_1 = (undefined4)result_2;\n    result_2 = __muldf3(temp_var_1,temp_var_2,temp_var_1,temp_var_2);\n    temp_var_3 = (undefined4)((ulonglong)result_2 >> 0x20);\n    temp_var_4 = (undefined4)result_2;\n    result_2 = __muldf3(temp_var_4,temp_var_3,0xe322da11,0x3f90ad3a);\n    result_2 = __aeabi_dadd((int)result_2,(int)((ulonglong)result_2 >> 0x20),0x24760deb,0x3fa97b4b);\n    result_2 = __muldf3((int)result_2,(int)((ulonglong)result_2 >> 0x20),temp_var_4,temp_var_3);\n    result_2 = __aeabi_dadd((int)result_2,(int)((ulonglong)result_2 >> 0x20),0xa0d03d51,0x3fb10d66);\n    result_2 = __muldf3((int)result_2,(int)((ulonglong)result_2 >> 0x20),temp_var_4,temp_var_3);\n    result_2 = __aeabi_dadd((int)result_2,(int)((ulonglong)result_2 >> 0x20),0xc54c206e,0x3fb745cd);\n    result_2 = __muldf3((int)result_2,(int)((ulonglong)result_2 >> 0x20),temp_var_4,temp_var_3);\n    result_2 = __aeabi_dadd((int)result_2,(int)((ulonglong)result_2 >> 0x20),0x920083ff,0x3fc24924);\n    result_2 = __muldf3((int)result_2,(int)((ulonglong)result_2 >> 0x20),temp_var_4,temp_var_3);\n    result_2 = __aeabi_dadd((int)result_2,(int)((ulonglong)result_2 >> 0x20),0x5555550d,0x3fd55555);\n    result_2 = __muldf3((int)result_2,(int)((ulonglong)result_2 >> 0x20),temp_var_1,temp_var_2);\n    result_1 = __muldf3(temp_var_4,temp_var_3,0x2c6a6c2f,0xbfa2b444);\n    result_1 = __subdf3((int)result_1,(int)((ulonglong)result_1 >> 0x20),0x52defd9a,0x3fadde2d);\n    result_1 = __muldf3((int)result_1,(int)((ulonglong)result_1 >> 0x20),temp_var_4,temp_var_3);\n    result_1 = __subdf3((int)result_1,(int)((ulonglong)result_1 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    result_1 = __muldf3((int)result_1,(int)((ulonglong)result_1 >> 0x20),temp_var_4,temp_var_3);\n    result_1 = __subdf3((int)result_1,(int)((ulonglong)result_1 >> 0x20),0xfe231671,0x3fbc71c6);\n    result_1 = __muldf3((int)result_1,(int)((ulonglong)result_1 >> 0x20),temp_var_4,temp_var_3);\n    result_1 = __subdf3((int)result_1,(int)((ulonglong)result_1 >> 0x20),0x9998ebc4,0x3fc99999);\n    result_1 = __muldf3((int)result_1,(int)((ulonglong)result_1 >> 0x20),temp_var_4,temp_var_3);\n    result_2 = __aeabi_dadd((int)result_2,(int)((ulonglong)result_2 >> 0x20),(int)result_1,\n                          (int)((ulonglong)result_1 >> 0x20));\n    result_2 = __muldf3((int)result_2,(int)((ulonglong)result_2 >> 0x20),temp_var_5,temp_var_6);\n    temp_var_1 = (undefined4)((ulonglong)result_2 >> 0x20);\n    if (operation == -1) {\n      result_2 = __subdf3(temp_var_5,temp_var_6,(int)result_2,temp_var_1);\n      return result_2;\n    }\n    operation = operation * 8;\n    result_2 = __subdf3((int)result_2,temp_var_1,*(undefined4 *)(&UNK_08009ee8 + operation),\n                      *(undefined4 *)(&UNK_08009eec + operation));\n    result_2 = __subdf3((int)result_2,(int)((ulonglong)result_2 >> 0x20),temp_var_5,temp_var_6);\n    result_2 = __subdf3(*(undefined4 *)(&UNK_08009ec8 + operation),*(undefined4 *)(&UNK_08009ecc + operation),\n                      (int)result_2,(int)((ulonglong)result_2 >> 0x20));\n    if ((int)input_2 < 0) {\n      return CONCAT44((int)((ulonglong)result_2 >> 0x20) + -0x80000000,(int)result_2);\n    }\n  }\n  else {\n    if ((abs_input_2 < 0x7ff00001) && ((abs_input_2 != 0x7ff00000 || (input_1 == 0)))) {\n      temp_var_1 = 0xbff921fb;\n      if (0 < (int)input_2) {\n        temp_var_1 = 0x3ff921fb;\n      }\n      return CONCAT44(temp_var_1,0x54442d18);\n    }\n    result_2 = __aeabi_dadd(input_1,input_2,input_1,input_2,input_4);\n  }\n  return result_2;\n}\n\n",
            "renaming": {
                "FUN_080059f0": "calculate_square_root_080059f0",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "temp_var_1",
                "uVar2": "temp_var_2",
                "uVar3": "temp_var_3",
                "uVar4": "temp_var_4",
                "uVar5": "temp_var_5",
                "uVar6": "temp_var_6",
                "uVar7": "abs_input_2",
                "iVar8": "operation",
                "uVar9": "result_1",
                "uVar10": "result_2"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "fabs",
                "__subdf3",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d0c": {
            "entrypoint": "0x08005d0c",
            "current_name": "FUNC_08005d0c",
            "code": "\nvoid FUNC_08005d0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d0c": "FUNC_08005d0c"
            },
            "calling": [
                "atan",
                "__ieee754_atan2"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005d14": {
            "entrypoint": "0x08005d14",
            "current_name": "get_data_08005d14",
            "code": "\nundefined4 get_data_08005d14(void)\n\n{\n  return DAT_2000001c;\n}\n\n",
            "renaming": {
                "FUN_08005d14": "get_data_08005d14"
            },
            "calling": [
                "_sbrk"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d20": {
            "entrypoint": "0x08005d20",
            "current_name": "initialize_and_execute_08005d20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005d2c) */\n/* WARNING: Removing unreachable block (ram,0x08005d2e) */\n\nvoid initializeAndExecute_08005d20(void)\n\n{\n  int iterationCount;\n  code **functionArray;\n  \n  _init();\n  iterationCount = 0;\n  functionArray = (code **)&DAT_0800a198;\n  do {\n    iterationCount = iterationCount + 1;\n    (**functionArray)();\n    functionArray = functionArray + 1;\n  } while (iterationCount != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d20": "initialize_and_execute_08005d20",
                "iVar1": "iterationCount",
                "ppcVar2": "functionArray"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "register_fini",
                "frame_dummy",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d68": {
            "entrypoint": "0x08005d68",
            "current_name": "fill_buffer_with_byte_08005d68",
            "code": "\nvoid fillBufferWithByte_08005d68(undefined4 *buffer,undefined byte,uint size)\n\n{\n  undefined4 *ptr1;\n  undefined4 *ptr2;\n  uint remainingSize;\n  undefined4 byte16;\n  bool isSizeZero;\n  \n  if (((uint)buffer & 3) != 0) {\n    remainingSize = size - 1;\n    ptr1 = buffer;\n    if (size == 0) {\n      return;\n    }\n    while( true ) {\n      buffer = (undefined4 *)((int)ptr1 + 1);\n      *(undefined *)ptr1 = byte;\n      size = remainingSize;\n      if (((uint)buffer & 3) == 0) break;\n      isSizeZero = remainingSize == 0;\n      remainingSize = remainingSize - 1;\n      ptr1 = buffer;\n      if (isSizeZero) {\n        return;\n      }\n    }\n  }\n  if (3 < size) {\n    byte16 = CONCAT22(CONCAT11(byte,byte),CONCAT11(byte,byte));\n    remainingSize = size;\n    ptr1 = buffer;\n    if (0xf < size) {\n      remainingSize = size - 0x10;\n      ptr1 = buffer + 4;\n      do {\n        ptr1[-4] = byte16;\n        ptr1[-3] = byte16;\n        ptr1[-2] = byte16;\n        ptr1[-1] = byte16;\n        ptr1 = ptr1 + 4;\n      } while (ptr1 != (undefined4 *)((int)buffer + (remainingSize & 0xfffffff0) + 0x20));\n      size = size & 0xf;\n      buffer = buffer + ((remainingSize >> 4) + 1) * 4;\n      remainingSize = size;\n      ptr1 = buffer;\n      if (size < 4) goto LAB_08005de4;\n    }\n    do {\n      size = size - 4;\n      *buffer = byte16;\n      buffer = buffer + 1;\n    } while (3 < size);\n    buffer = (undefined4 *)((int)ptr1 + (remainingSize - 4 & 0xfffffffc) + 4);\n    size = remainingSize & 3;\n  }\nLAB_08005de4:\n  if (size != 0) {\n    ptr1 = buffer;\n    do {\n      ptr2 = (undefined4 *)((int)ptr1 + 1);\n      *(undefined *)ptr1 = byte;\n      ptr1 = ptr2;\n    } while ((undefined4 *)(size + (int)buffer) != ptr2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d68": "fill_buffer_with_byte_08005d68",
                "param_1": "buffer",
                "param_2": "byte",
                "param_3": "size",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "uVar3": "remainingSize",
                "uVar4": "byte16",
                "bVar5": "isSizeZero"
            },
            "calling": [
                "_calloc_r",
                "flush_strbuf"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dfc": {
            "entrypoint": "0x08005dfc",
            "current_name": "print_formatted_text_08005dfc",
            "code": "\nvoid printFormattedText_08005dfc(undefined *buffer,undefined4 formatString,undefined4 param3,undefined4 param4)\n\n{\n  undefined *bufferArray [2];\n  undefined4 maxBufferSize;\n  undefined4 constantValue;\n  undefined *currentBuffer;\n  undefined4 maxArraySize;\n  undefined4 param3Copy;\n  undefined4 param4Copy;\n  \n  maxArraySize = 0x7fffffff;\n  maxBufferSize = 0x7fffffff;\n  constantValue = 0xffff0208;\n  bufferArray[0] = buffer;\n  currentBuffer = buffer;\n  param3Copy = param3;\n  param4Copy = param4;\n  _svfprintf_r(DAT_2000001c,bufferArray,formatString,&param3Copy);\n  *bufferArray[0] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005dfc": "print_formatted_text_08005dfc",
                "param_1": "buffer",
                "param_2": "formatString",
                "param_3": "param3",
                "param_4": "param4",
                "local_80": "bufferArray",
                "local_78": "maxBufferSize",
                "uStack_74": "constantValue",
                "local_70": "currentBuffer",
                "local_6c": "maxArraySize",
                "uStack_8": "param3Copy",
                "uStack_4": "param4Copy"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "_svfprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e40": {
            "entrypoint": "0x08005e40",
            "current_name": "find_last_set_bit_index_08005e40",
            "code": "\nint findLastSetBitIndex_08005e40(uint inputValue)\n\n{\n  int leadingZeros;\n  uint *dataPointer;\n  uint tempValue;\n  \n  dataPointer = (uint *)(inputValue & 0xfffffffc);\n  leadingZeros = -(inputValue & 3);\n  tempValue = *dataPointer;\n  if ((inputValue & 3) != 0) {\n    tempValue = tempValue | 0xffffffffU >> ((leadingZeros + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    dataPointer = dataPointer + 1;\n    tempValue = tempValue + 0xfefefeff & ~tempValue & 0x80808080;\n    if (tempValue != 0) break;\n    tempValue = *dataPointer;\n    leadingZeros = leadingZeros + 4;\n  }\n  return leadingZeros + (0x1fU - LZCOUNT(tempValue & -tempValue) >> 3);\n}\n\n",
            "renaming": {
                "FUN_08005e40": "find_last_set_bit_index_08005e40",
                "param_1": "inputValue",
                "iVar1": "leadingZeros",
                "puVar2": "dataPointer",
                "uVar3": "tempValue"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e9c": {
            "entrypoint": "0x08005e9c",
            "current_name": "FUNC_08005e9c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  int iVar8;\n  int *piVar9;\n  undefined4 uVar10;\n  int **ppiVar11;\n  undefined uVar12;\n  ushort uVar13;\n  int **ppiVar14;\n  byte **ppbVar15;\n  int *piVar16;\n  int **ppiVar17;\n  char *pcVar18;\n  uint uVar19;\n  undefined *puVar20;\n  int *piVar21;\n  int *piVar22;\n  int *piVar23;\n  int *piVar24;\n  int *piVar25;\n  byte *pbVar26;\n  int *piVar27;\n  int *piVar28;\n  undefined4 *puVar29;\n  byte *pbVar30;\n  bool bVar31;\n  longlong lVar32;\n  undefined8 uVar33;\n  undefined8 uVar34;\n  undefined4 local_188;\n  int *piStack_184;\n  int **local_180;\n  undefined *puStack_17c;\n  int **local_178;\n  undefined4 *local_16c;\n  int *local_168;\n  byte *local_164;\n  int *local_160;\n  int *local_15c;\n  char *local_158;\n  int **local_154;\n  undefined8 local_150;\n  int *local_148;\n  int *local_144;\n  int *local_140;\n  int **local_13c;\n  int *local_138;\n  int *local_134;\n  int *local_130;\n  uint local_12c;\n  undefined4 local_128;\n  undefined4 local_124;\n  undefined4 local_120;\n  char *local_11c;\n  int *local_118;\n  int *local_114;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  int *local_100;\n  int *local_fc;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0;\n  undefined auStack_ec [4];\n  char local_e8;\n  undefined local_e7;\n  char local_e6 [6];\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int *local_d4;\n  int *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  local_16c = param_1;\n  local_160 = param_2;\n  local_154 = param_4;\n  ppiVar2 = (int **)_localeconv_r();\n  local_114 = *ppiVar2;\n  local_118 = (int *)strlen(local_114);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar3 = _malloc_r(local_16c,0x40);\n    *local_160 = iVar3;\n    local_160[4] = iVar3;\n    if (iVar3 == 0) {\n      *local_16c = 0xc;\n      return (byte *)0xffffffff;\n    }\n    local_160[5] = 0x40;\n  }\n  local_128 = 0;\n  local_138 = (int *)0x0;\n  local_12c = 0;\n  local_d4 = (int *)0x0;\n  local_d0 = (int *)0x0;\n  local_11c = (char *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  local_124 = 0;\n  local_120 = 0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = local_164 + (int)piVar27;\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    piVar25 = (int *)0x0;\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    puVar29 = local_16c;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    switch(piVar24) {\n    case (int *)0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (piVar24 == (int *)0x0) goto LAB_08006216;\n      piVar16 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_158 = (char *)0x1;\n      piVar23 = (int *)&local_8c;\n      piVar22 = piVar16;\n      local_8c = (char)piVar24;\n      goto LAB_08006298;\n    case (int *)0x23:\n      piVar25 = (int *)((uint)piVar25 | 1);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x27:\n      iVar3 = _localeconv_r(local_16c);\n      local_110 = *(int **)(iVar3 + 4);\n      piVar24 = (int *)strlen(local_110);\n      local_104 = piVar24;\n      iVar3 = _localeconv_r(puVar29);\n      local_108 = *(byte **)(iVar3 + 8);\n      if (piVar24 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 0x400);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2a:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2b:\n      local_f5 = 0x2b;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x2d:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\nLAB_08006602:\n      piVar25 = (int *)((uint)piVar25 | 4);\n      goto LAB_08005f4a;\n    case (int *)0x2e:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x2a) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (piVar24 + -0xc < (int *)0xa) {\n        piVar27 = (int *)((int)(piVar24 + -0xc) + (int)piVar27 * 10);\n        piVar24 = (int *)(uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case (int *)0x30:\n      piVar25 = (int *)((uint)piVar25 | 0x80);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x31:\n    case (int *)0x32:\n    case (int *)0x33:\n    case (int *)0x34:\n    case (int *)0x35:\n    case (int *)0x36:\n    case (int *)0x37:\n    case (int *)0x38:\n    case (int *)0x39:\n      goto switchD_08005f58_caseD_31;\n    case (int *)0x41:\n    case (int *)0x45:\n    case (int *)0x46:\n    case (int *)0x47:\n    case (int *)0x61:\n    case (int *)0x65:\n    case (int *)0x66:\n    case (int *)0x67:\n      puVar29 = (undefined4 *)((int)local_154 + 7U & 0xfffffff8);\n      uVar10 = *puVar29;\n      local_12c = puVar29[1];\n      local_168 = (int *)(local_12c & 0x7fffffff);\n      local_154 = (int **)(puVar29 + 2);\n      local_128 = uVar10;\n      iVar3 = __unorddf2(uVar10,local_168,0xffffffff,0x7fefffff);\n      if ((iVar3 == 0) &&\n         (iVar3 = __aeabi_dcmple(uVar10,local_168,0xffffffff,0x7fefffff), iVar3 == 0)) {\n        iVar3 = __aeabi_dcmplt(local_128,local_12c,local_124,local_120);\n        if (iVar3 == 0) {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        piVar23 = (int *)&UNK_08009f10;\n        piVar27 = (int *)&UNK_08009f0c;\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (piVar24 < (int *)0x48) {\n          piVar23 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar25 = (int *)((uint)piVar25 & 0xffffff7f);\n        local_158 = (char *)0x3;\n        local_13c = (int **)0x0;\n        piVar22 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      iVar3 = __unorddf2(local_128,local_12c,local_128,local_12c);\n      if (iVar3 != 0) {\n        if ((int)local_12c < 0) {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        piVar23 = (int *)&UNK_08009f18;\n        piVar27 = (int *)&UNK_08009f14;\n        goto LAB_08006524;\n      }\n      if (piVar24 == (int *)0x61) {\n        uVar12 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar12,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          piVar25 = (int *)((uint)piVar25 | 2);\n        }\n        else {\n          param_3 = (int *)_malloc_r(local_16c,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar13 = *(ushort *)(local_160 + 3) | 0x40;\n            *(ushort *)(local_160 + 3) = uVar13;\n            goto LAB_0800604e;\n          }\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          piVar25 = (int *)((uint)piVar25 | 2);\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = (int *)0x2d;\n          uVar19 = local_12c + 0x80000000;\n        }\n        else {\n          local_144 = (int *)0x0;\n          uVar19 = local_12c;\n        }\n        local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n        piVar22 = piVar27;\n        local_158 = (char *)local_128;\n        if (piVar24 == (int *)0x61) {\n          uVar33 = frexp(local_128,uVar19,&local_f0);\n          local_150 = __muldf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = __aeabi_dcmpeq((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                                 local_120);\n          if (iVar3 != 0) {\n            local_f0 = (int *)0x1;\n          }\n          local_158 = \"0123456789abcdef\";\n          local_13c = ppiVar2;\n          local_138 = piVar28;\n          local_134 = piVar24;\n          local_130 = piVar27;\n          local_100 = piVar25;\n          local_fc = param_3;\n          pcVar18 = local_158;\n          uVar33 = local_150;\n          goto LAB_080072ba;\n        }\n        if (piVar24 == (int *)0x41) {\n          uVar33 = frexp(local_128,uVar19,&local_f0);\n          local_150 = __muldf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = __aeabi_dcmpeq((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                                 local_120);\n          if (iVar3 == 0) {\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          else {\n            local_f0 = (int *)0x1;\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (piVar24 == (int *)0x41) {\n          uVar12 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = (int *)((uint)piVar25 | 0x100);\n        local_148 = (int *)0x0;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar27 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if (((uint)piVar24 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar27 = (int *)0x1;\n            local_148 = (int *)0x0;\n          }\n          goto LAB_0800724a;\n        }\n        if ((int)local_12c < 0) goto LAB_08007414;\n        local_144 = (int *)0x0;\n        uVar19 = local_12c;\n      }\n      local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n      piStack_184 = piVar27;\n      local_158 = (char *)local_128;\n      if (piVar24 == (int *)0x66) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)_dtoa_r(local_16c,local_180,local_128,uVar19);\n        piVar22 = (int *)((int)piVar23 + (int)piVar27);\n        local_150._0_4_ = piVar27;\nLAB_0800764c:\n        if ((*(byte *)piVar23 == 0x30) &&\n           (iVar3 = __aeabi_dcmpeq(local_158,uVar19,local_124,local_120), iVar3 == 0)) {\n          local_f0 = (int *)(1 - (int)(int *)local_150);\n        }\n        piVar22 = (int *)((int)piVar22 + (int)local_f0);\n      }\n      else if (piVar24 == (int *)0x46) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)_dtoa_r(local_16c,local_180,local_128,uVar19);\n        local_150._0_4_ = piVar27;\nLAB_08007760:\n        piVar22 = (int *)((int)piVar23 + (int)(int *)local_150);\n        if (piVar24 == (int *)0x46) goto LAB_0800764c;\n      }\n      else {\n        local_178 = &local_e0;\n        local_150._0_4_ = piVar27;\n        if (local_168 == (int *)0x45) {\n          local_150._0_4_ = (int *)((int)piVar27 + 1);\n        }\n        local_188 = 2;\n        piStack_184 = (int *)local_150;\n        local_180 = &local_f0;\n        puStack_17c = auStack_ec;\n        piVar23 = (int *)_dtoa_r(local_16c,local_180,local_128,uVar19);\n        piVar16 = local_e0;\n        if (piVar24 == (int *)0x67) {\n          if (((uint)piVar25 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (piVar24 == (int *)0x47) {\n          if (((uint)piVar25 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar22 = (int *)((int)(int *)local_150 + (int)piVar23);\n      }\n      iVar3 = __aeabi_dcmpeq(local_158,uVar19,local_124,local_120);\n      piVar16 = piVar22;\n      if (iVar3 == 0) {\n        for (; piVar16 = local_e0, local_e0 < piVar22; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)piVar16 - (int)piVar23);\n      goto LAB_08006cb0;\n    case (int *)0x43:\n    case (int *)0x63:\n      piVar16 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar22 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (char *)0x1;\n      local_8c = SUB41(piVar27,0);\n      piVar23 = (int *)&local_8c;\n      goto LAB_08006298;\n    case (int *)0x44:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_08006102;\n    case (int *)0x4c:\n      piVar25 = (int *)((uint)piVar25 | 8);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x4f:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n    case (int *)0x6f:\n      if (((uint)piVar25 & 0x20) == 0) {\n        ppiVar14 = local_154 + 1;\n        if (((uint)piVar25 & 0x10) == 0) {\n          if (((uint)piVar25 & 0x40) == 0) {\n            if (((uint)piVar25 & 0x200) == 0) goto LAB_08006be2;\n            piVar22 = (int *)(uint)*(byte *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n          else {\n            piVar22 = (int *)(uint)*(ushort *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar22 = *local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\n        ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar22 = *ppiVar14;\n        piVar16 = ppiVar14[1];\n        local_154 = ppiVar14 + 2;\n      }\n      iVar3 = 0;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n      break;\n    case (int *)0x53:\n    case (int *)0x73:\n      local_f5 = 0;\n      piVar23 = *local_154;\n      ppiVar14 = local_154 + 1;\n      if (piVar23 == (int *)0x0) {\n        if ((int *)0x5 < piVar27) {\n          piVar27 = (int *)0x6;\n        }\n        piVar23 = (int *)&UNK_08009f44;\n        piVar16 = (int *)0x0;\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar22 = (int *)0x0;\n        local_168 = piVar27;\n        local_158 = (char *)piVar27;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (piVar27 == (int *)0xffffffff) {\n          local_158 = (char *)strlen(piVar23);\n        }\n        else {\n          iVar3 = memchr(piVar23,0,piVar27);\n          if (iVar3 == 0) {\n            piVar16 = (int *)(uint)local_f5;\n            local_148 = (int *)0x0;\n            local_13c = (int **)0x0;\n            local_134 = (int *)0x0;\n            local_130 = (int *)0x0;\n            piVar22 = (int *)0x0;\n            local_168 = piVar27;\n            local_158 = (char *)piVar27;\n            local_154 = ppiVar14;\n            goto LAB_08006538;\n          }\n          local_158 = (char *)(iVar3 - (int)piVar23);\n        }\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar16 = (int *)(uint)local_f5;\n        piVar22 = (int *)0x0;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        local_154 = ppiVar14;\n      }\n      goto LAB_08006538;\n    case (int *)0x55:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      iVar3 = 1;\n      local_154 = ppiVar14 + 2;\n      break;\n    case (int *)0x58:\n      local_11c = \"0123456789ABCDEF\";\n      if (((uint)piVar25 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_080061be;\n    case (int *)0x64:\n    case (int *)0x69:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bcc:\n        piVar22 = *local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(int)*(short *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bcc;\n        piVar22 = (int *)(int)*(char *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\nLAB_08006102:\n      if ((int)piVar16 < 0) {\n        bVar31 = piVar22 != (int *)0x0;\n        piVar22 = (int *)-(int)piVar22;\n        piVar16 = (int *)(-(int)piVar16 - (uint)bVar31);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar3 = 1;\n        iVar8 = 1;\n        piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n        if (((uint)piVar22 | (uint)piVar16) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      piVar21 = piVar25;\n      if (piVar16 != (int *)0x0 || (int *)0x9 < piVar22) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case (int *)0x68:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x68) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar25 = (int *)((uint)piVar25 | 0x200);\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        piVar25 = (int *)((uint)piVar25 | 0x40);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x6a:\n    case (int *)0x71:\n      piVar25 = (int *)((uint)piVar25 | 0x20);\n    case (int *)0x74:\n    case (int *)0x7a:\nswitchD_08005f58_caseD_74:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case (int *)0x6e:\n      ppiVar14 = local_154 + 1;\n      ppbVar15 = (byte **)*local_154;\n      local_154 = ppiVar14;\n      if (((uint)piVar25 & 0x20) != 0) {\n        *ppbVar15 = local_164;\n        ppbVar15[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) != 0) {\n          *(short *)ppbVar15 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if (((uint)piVar25 & 0x200) != 0) {\n          *(char *)ppbVar15 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar15 = local_164;\n      goto LAB_0800620e;\n    case (int *)0x70:\n      local_f4 = 0x7830;\n      piVar22 = *local_154;\n      local_11c = \"0123456789abcdef\";\n      piVar25 = (int *)((uint)piVar25 | 2);\n      piVar16 = (int *)0x0;\n      iVar3 = 2;\n      piVar24 = (int *)0x78;\n      local_154 = local_154 + 1;\n      break;\n    case (int *)0x75:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bf2:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(uint)*(ushort *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bf2;\n        piVar22 = (int *)(uint)*(byte *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      break;\n    case (int *)0x78:\n      local_11c = \"0123456789abcdef\";\n      if (((uint)piVar25 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar14 = local_154 + 1;\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) == 0) {\n          if (((uint)piVar25 & 0x200) == 0) goto LAB_08006bbc;\n          piVar22 = (int *)(uint)*(byte *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n        else {\n          piVar22 = (int *)(uint)*(ushort *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        local_154 = ppiVar14;\n      }\nLAB_080061be:\n      if ((((uint)piVar25 & 1) != 0) && (((uint)piVar22 | (uint)piVar16) != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 2);\n        local_f4 = CONCAT11((char)piVar24,0x30);\n      }\n      iVar3 = 2;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      if (iVar3 != 1) goto LAB_08006136;\nLAB_08006980:\n      piVar21 = piVar25;\n      if (piVar16 == (int *)0x0 && piVar22 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar32 = CONCAT44(piVar16,piVar22);\n      piVar23 = (int *)(&bStack_2a + 2);\n      piVar22 = (int *)0x0;\n      pbVar26 = local_108;\n      local_168 = piVar23;\n      local_158 = (char *)ppiVar2;\n      local_150._0_4_ = piVar25;\n      local_148 = piVar24;\n      do {\n        iVar3 = (int)((ulonglong)lVar32 >> 0x20);\n        uVar19 = (uint)lVar32;\n        cVar6 = '\\n';\n        __aeabi_uldivmod(uVar19,iVar3,10,0);\n        *(byte *)((int)piVar23 + -1) = cVar6 + 0x30;\n        piVar22 = (int *)((int)piVar22 + 1);\n        piVar23 = (int *)((int)piVar23 + -1);\n        if ((((((uint)piVar25 & 0x400) != 0) && (piVar22 == (int *)(uint)*pbVar26)) &&\n            (piVar22 != (int *)0xff)) && (iVar3 != 0 || 9 < uVar19)) {\n          piVar23 = (int *)((int)piVar23 - (int)local_104);\n          strncpy(piVar23,local_110,local_104);\n          if (pbVar26[1] == 0) {\n            piVar22 = (int *)0x0;\n          }\n          else {\n            pbVar26 = pbVar26 + 1;\n            piVar22 = (int *)0x0;\n          }\n        }\n        lVar32 = __aeabi_uldivmod(uVar19,iVar3,10,0);\n      } while (lVar32 != 0);\n      piVar24 = local_148;\n      piVar25 = (int *)local_150;\n      ppiVar2 = (int **)local_158;\n      local_158 = (char *)((int)local_168 - (int)piVar23);\n      local_138 = piVar22;\n      local_108 = pbVar26;\n    }\n    else {\n      piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n      iVar8 = iVar3;\n      if (((uint)piVar22 | (uint)piVar16) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar3 == 0) {\n            local_158 = (char *)((uint)piVar25 & 1);\n            if ((int *)local_158 == (int *)0x0) {\n              piVar23 = (int *)(&bStack_2a + 2);\n              piVar25 = piVar21;\n            }\n            else {\n              piVar23 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n              piVar25 = piVar21;\n            }\n          }\n          else {\n            piVar23 = (int *)(&bStack_2a + 2);\n            piVar25 = piVar21;\n            local_158 = (char *)piVar27;\n          }\n        }\n        else {\n          piVar25 = piVar21;\n          if (iVar3 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar22 + '0';\n          piVar23 = (int *)(&bStack_2a + 1);\n          local_158 = (char *)0x1;\n          piVar25 = piVar21;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar3 = iVar8;\n        piVar25 = piVar21;\n        if (iVar8 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar3 == 2) {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = (int *)((uint)piVar22 >> 4 | (int)piVar16 << 0x1c);\n            piVar16 = (int *)((uint)piVar16 >> 4);\n            piVar23 = (int *)((int)piVar23 + -1);\n            *(char *)piVar23 = local_11c[(uint)piVar22 & 0xf];\n            piVar22 = piVar21;\n          } while (((uint)piVar21 | (uint)piVar16) != 0);\n        }\n        else {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = piVar23;\n            piVar9 = (int *)((uint)piVar22 >> 3 | (int)piVar16 << 0x1d);\n            piVar16 = (int *)((uint)piVar16 >> 3);\n            iVar3 = ((uint)piVar22 & 7) + 0x30;\n            *(byte *)((int)piVar21 + -1) = (byte)iVar3;\n            piVar23 = (int *)((int)piVar21 + -1);\n            piVar22 = piVar9;\n          } while (((uint)piVar9 | (uint)piVar16) != 0);\n          if ((((uint)piVar25 & 1) != 0) && (iVar3 != 0x30)) {\n            piVar23 = (int *)((int)piVar21 + -2);\n            *(byte *)((int)piVar21 + -2) = 0x30;\n            local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  piVar28 = local_160;\n  if (local_d0 == (int *)0x0) {\nLAB_0800604a:\n    uVar13 = *(ushort *)(local_160 + 3);\n  }\n  else {\n    __ssprint_r(local_16c,local_160,&local_d8);\n    uVar13 = *(ushort *)(piVar28 + 3);\n  }\nLAB_0800604e:\n  if ((uVar13 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (piVar24 == (int *)0x6c) {\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    piVar25 = (int *)((uint)piVar25 | 0x20);\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    piVar25 = (int *)((uint)piVar25 | 0x10);\n  }\n  goto LAB_08005f4a;\n  while( true ) {\n    iVar8 = __aeabi_dcmpeq((int)uVar33,uVar10,local_124,local_120);\n    if (iVar8 != 0) break;\nLAB_080072ba:\n    piVar16 = param_3;\n    piVar22 = (int *)((int)piVar22 + -1);\n    uVar33 = __muldf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x40300000);\n    iVar3 = __aeabi_d2iz();\n    uVar34 = __aeabi_i2d();\n    uVar33 = __subdf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar34,\n                      (int)((ulonglong)uVar34 >> 0x20));\n    uVar10 = (undefined4)((ulonglong)uVar33 >> 0x20);\n    param_3 = (int *)((int)piVar16 + 1);\n    *(char *)piVar16 = pcVar18[iVar3];\n    if (piVar22 == (int *)0xffffffff) break;\n  }\n  piVar23 = local_fc;\n  piVar25 = local_100;\n  piVar27 = local_130;\n  piVar24 = local_134;\n  piVar28 = local_138;\n  ppiVar2 = local_13c;\n  local_13c = (int **)piVar22;\n  local_134 = piVar16;\n  local_150 = uVar33;\n  iVar8 = __aeabi_dcmpgt((int)uVar33,uVar10,0,0x3fe00000);\n  if (iVar8 == 0) {\n    iVar8 = __aeabi_dcmpeq((int *)local_150,local_150._4_4_,0,0x3fe00000);\n    if ((iVar8 != 0) && (iVar3 << 0x1f < 0)) goto LAB_0800748a;\n    if (-1 < (int)local_13c) {\n      piVar16 = (int *)((byte *)((int)local_13c + 1) + (int)param_3);\n      piVar22 = param_3;\n      do {\n        param_3 = (int *)((int)piVar22 + 1);\n        *(byte *)piVar22 = 0x30;\n        piVar22 = param_3;\n      } while (piVar16 != param_3);\n    }\n  }\n  else {\nLAB_0800748a:\n    bVar1 = local_158[0xf];\n    bVar7 = *(byte *)piVar16;\n    piVar22 = param_3;\n    local_e0 = local_134;\n    while (bVar1 == bVar7) {\n      *(byte *)((int)piVar22 + -1) = 0x30;\n      bVar7 = *(byte *)((int)local_e0 + -1);\n      piVar22 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar7 == 0x39) {\n      bVar7 = local_158[10];\n    }\n    else {\n      bVar7 = bVar7 + 1;\n    }\n    *(byte *)((int)piVar22 + -1) = bVar7;\n  }\n  local_138 = (int *)((int)param_3 - (int)piVar23);\nLAB_08006cb0:\n  local_134 = local_f0;\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0 + 3) < 0 == SCARRY4((int)local_f0,3)) &&\n       ((int)local_f0 <= (int)piVar27)) {\n      if ((int)local_f0 < (int)local_138) {\n        local_158 = (char *)((int)local_138 + (int)local_118);\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (char *)((int)local_158 + (1 - (int)local_f0));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        piVar24 = (int *)0x67;\n      }\n      else {\n        if ((int)piVar25 << 0x1f < 0) {\n          local_158 = (char *)((int)local_f0 + (int)local_118);\n        }\n        else {\n          local_158 = (char *)local_f0;\n        }\n        if (-1 < (int)piVar25 << 0x15) {\n          piVar24 = (int *)0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074fc;\n        }\n        piVar24 = (int *)0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    piVar24 = (int *)((int)piVar24 + -2);\n    local_168 = (int *)((uint)piVar24 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8 = (char)piVar24;\n    if (local_168 == (int *)0x41) {\n      local_e8 = local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0 + -1);\n    if ((int)piVar27 < 0) {\n      local_e7 = 0x2d;\n      local_f0 = (int *)(1 - (int)local_f0);\n    }\n    else {\n      local_e7 = 0x2b;\n      local_f0 = piVar27;\n    }\n    if ((int)local_f0 < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e6[0] = 0x30;\n        pcVar18 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar18 = (char)local_f0 + '0';\n      pcVar18 = pcVar18 + 1;\n    }\n    else {\n      pbVar30 = abStack_dc + 3;\n      pbVar26 = pbVar30;\n      do {\n        pbVar5 = pbVar26;\n        piVar22 = (int *)((uint)local_f0 / 10);\n        pbVar5[-1] = (char)local_f0 + (char)piVar22 * -10 + 0x30;\n        pbVar26 = pbVar5 + -1;\n        local_f0 = piVar22;\n      } while ((int *)0x9 < piVar22);\n      uVar19 = (uint)(piVar22 + 0xc) & 0xff;\n      pbVar5[-2] = (byte)uVar19;\n      if (pbVar5 + -2 < pbVar30) {\n        pbVar5 = pbVar26;\n        puVar20 = (undefined *)((int)&local_e8 + 2);\n        while( true ) {\n          *puVar20 = (char)uVar19;\n          if (pbVar30 == pbVar5) break;\n          uVar19 = (uint)*pbVar5;\n          pbVar5 = pbVar5 + 1;\n          puVar20 = puVar20 + 1;\n        }\n        pcVar18 = (char *)(((int)&local_188 * 2 - (int)pbVar26) + 0x152);\n      }\n      else {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar18 + -(int)&local_e8);\n    local_158 = (char *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)piVar25 << 0x1f < 0)) {\n      local_158 = (char *)((int)local_158 + (int)local_118);\n    }\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    piVar25 = (int *)((uint)piVar25 & 0xfffffbff | 0x100);\n    local_f0 = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0 < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_168 = (int *)0x1;\n        local_158 = (char *)0x1;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_118 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      piVar25 = local_140;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)local_f0;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_f0 + (int)local_118) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)piVar25 << 0x15) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      uVar19 = (uint)*local_108;\n      while (uVar19 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar19) goto LAB_08007524;\n          uVar4 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar19);\n          if (uVar4 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = (int *)((int)local_130 + 1);\n          uVar19 = uVar4;\n          if (uVar4 == 0xff) goto LAB_08007524;\n        }\n        local_13c = (int **)((int)local_13c + 1);\n      }\nLAB_08007524:\n      local_158 = (char *)((int)local_158 + (int)local_104 * ((int)local_130 + (int)local_13c));\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      piVar25 = local_140;\n    }\n  }\n  if (local_144 == (int *)0x0) {\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = (int *)0x0;\nLAB_08006538:\n    if (piVar16 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar16 = (int *)0x2d;\n    piVar22 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n  }\nLAB_08006298:\n  piVar27 = local_160;\n  puVar29 = local_16c;\n  local_150._0_4_ = (int *)((uint)piVar25 & 2);\n  if ((int *)local_150 != (int *)0x0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  local_144 = (int *)((uint)piVar25 & 0x84);\n  if ((local_144 == (int *)0x0) &&\n     (piVar21 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar21)) {\n    if (0x10 < (int)piVar21) {\n      piVar16 = (int *)0x10;\n      local_100 = piVar24;\n      do {\n        piVar9 = piVar21;\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = piVar16;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n          piVar24 = local_100;\n        }\n        else {\n          local_140 = piVar16;\n          iVar3 = __ssprint_r(puVar29,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = local_140;\n          piVar24 = local_100;\n        }\n        piVar21 = piVar9 + -4;\n        local_100 = piVar24;\n      } while (0x10 < (int)piVar21);\n      piVar21 = piVar9 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar21);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar21;\n    if ((int)local_d4 < 8) {\n      piVar16 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar16 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar16 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 1);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((int *)local_150 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 2);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  if ((local_144 == (int *)0x80) &&\n     (piVar16 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar16)) {\n    if (0x10 < (int)piVar16) {\n      do {\n        while( true ) {\n          piVar21 = piVar16;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = __ssprint_r(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = piVar21 + -4;\n          if ((int)(piVar21 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar16 = piVar21 + -4;\n      } while (0x10 < (int)(piVar21 + -4));\nLAB_08006882:\n      piVar16 = piVar21 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar16);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar16;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  piVar22 = (int *)((int)piVar22 - (int)local_158);\n  if (0 < (int)piVar22) {\n    if (0x10 < (int)piVar22) {\n      do {\n        while( true ) {\n          piVar16 = piVar22;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = __ssprint_r(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar22 = piVar16 + -4;\n          if ((int)(piVar16 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar22 = piVar16 + -4;\n      } while (0x10 < (int)(piVar16 + -4));\nLAB_080063d2:\n      piVar22 = piVar16 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar22);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar22;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_d0;\n  if (((uint)piVar25 & 0x100) == 0) {\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)local_158);\n    *ppiVar2 = piVar23;\n    ppiVar2[1] = (int *)local_158;\n    if ((int)local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else if ((int)piVar24 < 0x66) {\n    local_158 = (char *)((int)local_d0 + 1);\n    piVar27 = (int *)((int)local_d4 + 1);\n    ppiVar14 = ppiVar2 + 2;\n    local_d0 = (int *)local_158;\n    if (((int)local_138 < 2) && (((uint)piVar25 & 1) == 0)) {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)piVar27 < 8) {\n        local_150._0_4_ = (int *)((int)local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = piVar27;\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        local_150._0_4_ = (int *)((int)local_d4 + 1);\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = piVar27;\n      if (7 < (int)piVar27) {\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n      }\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_158 = (char *)((int)local_158 + (int)local_118);\n      *ppiVar14 = local_114;\n      ppiVar14[1] = local_118;\n      local_d0 = (int *)local_158;\n      if ((int)local_d4 < 8) {\n        ppiVar17 = ppiVar14 + 2;\n      }\n      else {\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar17 = local_cc;\n      }\n      piVar24 = local_d4;\n      local_150._0_4_ = (int *)((int)local_d4 + 1);\n      piVar22 = (int *)((int)local_138 + -1);\n      ppiVar11 = ppiVar17 + 2;\n      local_158 = (char *)local_d0;\n      local_144 = (int *)local_150;\n      iVar3 = __aeabi_dcmpeq(local_128,local_12c,local_124,local_120);\n      piVar27 = local_160;\n      puVar29 = local_16c;\n      if (iVar3 == 0) {\n        local_158 = (char *)((int)local_158 + (int)piVar22);\n        *ppiVar17 = (int *)((int)piVar23 + 1);\n        ppiVar17[1] = piVar22;\n        local_d0 = (int *)local_158;\n        if ((int)(int *)local_150 < 8) {\n          local_150._0_4_ = (int *)((int)piVar24 + 2);\n          ppiVar14 = ppiVar11;\n          ppiVar2 = ppiVar17 + 4;\n        }\n        else {\nLAB_08006d9c:\n          local_158 = (char *)local_d0;\n          local_d4 = (int *)local_150;\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          local_150._0_4_ = (int *)((int)local_d4 + 1);\n          local_158 = (char *)local_d0;\n          ppiVar14 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar14 = ppiVar17;\n        ppiVar2 = ppiVar11;\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)local_158;\n          local_d4 = local_144;\n          if (0x10 < (int)piVar22) {\n            while( true ) {\n              local_d0 = local_d0 + 4;\n              *ppiVar17 = (int *)0x8009f60;\n              ppiVar17[1] = (int *)0x10;\n              if ((int)local_d4 < 8) {\n                ppiVar17 = ppiVar17 + 2;\n              }\n              else {\n                iVar3 = __ssprint_r(puVar29,piVar27,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar17 = local_cc;\n              }\n              piVar22 = piVar22 + -4;\n              if ((int)piVar22 < 0x11) break;\n              local_d4 = (int *)((int)local_d4 + 1);\n            }\n            local_150._0_4_ = (int *)((int)local_d4 + 1);\n            ppiVar11 = ppiVar17 + 2;\n            local_158 = (char *)local_d0;\n          }\n          *ppiVar17 = (int *)0x8009f60;\n          ppiVar17[1] = piVar22;\n          local_158 = (char *)((int)local_158 + (int)piVar22);\n          local_d0 = (int *)local_158;\n          if (7 < (int)(int *)local_150) goto LAB_08006d9c;\n          local_150._0_4_ = (int *)((int)(int *)local_150 + 1);\n          ppiVar2 = ppiVar11 + 2;\n          ppiVar14 = ppiVar11;\n        }\n      }\n    }\n    ppiVar14[1] = local_10c;\n    local_d0 = (int *)((int)local_158 + (int)local_10c);\n    local_d4 = (int *)local_150;\n    *ppiVar14 = (int *)&local_e8;\n    piVar27 = local_d0;\n    if (7 < (int)(int *)local_150) {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else {\n    iVar3 = __aeabi_dcmpeq(local_128,local_12c,local_124,local_120);\n    if (iVar3 == 0) {\n      if ((int)local_f0 < 1) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)piVar27 + 1);\n        *ppiVar2 = (int *)&DAT_08009f4c;\n        ppiVar2[1] = (int *)0x1;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0 != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)local_d0 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          puVar29 = local_16c;\n          if ((int)local_f0 < 0) {\n            piVar27 = (int *)-(int)local_f0;\n            if ((int)(local_f0 + 4) < 0 != SCARRY4((int)local_f0,0x10)) {\n              do {\n                local_d4 = (int *)((int)local_d4 + 1);\n                local_d0 = local_d0 + 4;\n                *ppiVar2 = (int *)0x8009f60;\n                ppiVar2[1] = (int *)0x10;\n                if ((int)local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar3 = __ssprint_r(puVar29,local_160,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)local_d0 + (int)piVar27);\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = piVar27;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = (int *)((int)local_d0 + (int)local_138);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar24 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar24 = local_138;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar24);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = piVar24;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        piVar22 = local_134;\n        if (-1 < (int)piVar24) {\n          piVar22 = (int *)((int)local_134 - (int)piVar24);\n        }\n        if (0 < (int)piVar22) {\n          for (; 0x10 < (int)piVar22; piVar22 = piVar22 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = piVar27 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          local_d4 = (int *)((int)local_d4 + 1);\n          piVar27 = (int *)((int)piVar27 + (int)piVar22);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar22;\n          local_d0 = piVar27;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar22 = local_104;\n        piVar24 = local_160;\n        puVar29 = local_16c;\n        piVar16 = (int *)((int)local_134 + (int)piVar23);\n        if (((uint)piVar25 & 0x400) != 0) {\n          local_158 = (char *)((int)piVar23 + (int)local_138);\n          pbVar26 = local_108;\n          local_150._0_4_ = piVar28;\n          local_144 = piVar25;\n          local_140 = piVar23;\n          if (local_130 == (int *)0x0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != (int **)0x0) goto LAB_0800717e;\n          pbVar26 = pbVar26 + -1;\n          local_130 = (int *)((int)local_130 + -1);\n          do {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)piVar27 + (int)piVar22);\n            *ppiVar2 = local_110;\n            ppiVar2[1] = piVar22;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = (int *)(uint)*pbVar26;\n            piVar28 = (int *)((int)local_158 - (int)piVar16);\n            if ((int)piVar27 <= (int)(int *)((int)local_158 - (int)piVar16)) {\n              piVar28 = piVar27;\n            }\n            if (0 < (int)piVar28) {\n              local_d0 = (int *)((int)local_d0 + (int)piVar28);\n              local_d4 = (int *)((int)local_d4 + 1);\n              *ppiVar2 = piVar16;\n              ppiVar2[1] = piVar28;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar27 = (int *)(uint)*pbVar26;\n              }\n            }\n            piVar25 = piVar27;\n            if (-1 < (int)piVar28) {\n              piVar25 = (int *)((int)piVar27 - (int)piVar28);\n            }\n            if (0 < (int)piVar25) {\n              for (; 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n                while( true ) {\n                  local_d4 = (int *)((int)local_d4 + 1);\n                  local_d0 = local_d0 + 4;\n                  *ppiVar2 = (int *)0x8009f60;\n                  ppiVar2[1] = (int *)0x10;\n                  if ((int)local_d4 < 8) break;\n                  iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  piVar25 = piVar25 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar25 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = (int *)((int)local_d4 + 1);\n              local_d0 = (int *)((int)local_d0 + (int)piVar25);\n              *ppiVar2 = (int *)0x8009f60;\n              ppiVar2[1] = piVar25;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = local_cc;\n              }\n            }\n            piVar16 = (int *)((int)piVar16 + (int)piVar27);\n            piVar27 = local_d0;\n            if (local_130 != (int *)0x0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == (int **)0x0) {\n              piVar23 = local_140;\n              piVar25 = local_144;\n              piVar28 = (int *)local_150;\n              local_108 = pbVar26;\n              if ((int *)((int)local_140 + (int)local_138) <= piVar16) {\n                piVar16 = (int *)((int)local_140 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = (int **)((int)local_13c + -1);\n          } while( true );\n        }\n        if (((int)local_f0 < (int)local_138) || (((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)piVar27 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar24 = (int *)((int)local_138 - (int)local_f0);\n        piVar22 = (int *)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16);\n        if ((int)piVar24 <= (int)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16)) {\n          piVar22 = piVar24;\n        }\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar22);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar16;\n          ppiVar2[1] = piVar22;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar24 = (int *)((int)local_138 - (int)local_f0);\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        if (-1 < (int)piVar22) {\n          piVar24 = (int *)((int)piVar24 - (int)piVar22);\n        }\n        if (0 < (int)piVar24) {\n          for (; local_d0 = piVar27, 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_d0 = (int *)((int)piVar27 + 1);\n      *ppiVar2 = (int *)&DAT_08009f4c;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0 < (int)local_138) || (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)local_118);\n        *ppiVar2 = local_114;\n        ppiVar2[1] = local_118;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar22 = local_160;\n        puVar29 = local_16c;\n        piVar24 = (int *)((int)local_138 + -1);\n        piVar27 = local_d0;\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar22,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\nLAB_08007014:\n          local_d0 = (int *)((int)local_d0 + (int)piVar24);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar24;\njoined_r0x08006a1c:\n          local_d4 = (int *)((int)local_d4 + 1);\n          if (7 < (int)local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  piVar24 = local_160;\n  puVar29 = local_16c;\n  if ((((uint)piVar25 & 4) != 0) &&\n     (piVar25 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar25)) {\n    for (; local_d0 = piVar27, 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n      while( true ) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if ((int)local_d4 < 8) break;\n        iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        piVar25 = piVar25 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar25 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar25);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar25;\n    piVar27 = local_d0;\n    if ((7 < (int)local_d4) &&\n       (iVar3 = __ssprint_r(local_16c,local_160,&local_d8), piVar27 = local_d0, iVar3 != 0))\n    goto LAB_0800603e;\n  }\n  piVar24 = local_15c;\n  if ((int)local_15c < (int)local_168) {\n    piVar24 = local_168;\n  }\n  local_164 = local_164 + (int)piVar24;\n  if ((piVar27 == (int *)0x0) || (iVar3 = __ssprint_r(local_16c,local_160,&local_d8), iVar3 == 0)) {\n    local_d4 = (int *)0x0;\n    if (local_148 != (int *)0x0) {\n      _free_r(local_16c,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    _free_r(local_16c,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  piVar16 = piVar24 + -0xc;\n  piVar22 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar22 + 1);\n    piVar24 = (int *)(uint)*(byte *)piVar22;\n    local_15c = (int *)((int)piVar16 + (int)local_15c * 10);\n    piVar16 = piVar24 + -0xc;\n    piVar22 = piVar28;\n  } while (piVar16 < (int *)0xa);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "calling": [
                "sprintf"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__ssprint_r",
                "__aeabi_dcmpgt",
                "__unorddf2",
                "__aeabi_dcmple",
                "__aeabi_dcmpeq",
                "memchr",
                "__muldf3",
                "frexp",
                "_dtoa_r",
                "__aeabi_i2d",
                "_malloc_r",
                "__aeabi_uldivmod",
                "__aeabi_d2iz",
                "__subdf3",
                "strncpy",
                "strlen",
                "_free_r",
                "_localeconv_r"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078a0": {
            "entrypoint": "0x080078a0",
            "current_name": "FUNC_080078a0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080078a4) */\n\nvoid FUNC_080078a0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078a0": "FUNC_080078a0"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078c0": {
            "entrypoint": "0x080078c0",
            "current_name": "calculate_quotient_080078c0",
            "code": "\nuint calculateQuotient_080078c0(int dividend,int divisor)\n\n{\n  uint temp1;\n  uint *dividendPtr;\n  int temp2;\n  int divisorLength;\n  int index;\n  uint quotient;\n  uint *divisorPtr;\n  uint *dividendPtr;\n  uint *divisorPtr;\n  uint temp10;\n  uint *divisorPtr;\n  uint *divisorPtr;\n  \n  divisorLength = *(int *)(divisor + 0x10);\n  if (*(int *)(dividend + 0x10) < divisorLength) {\n    return 0;\n  }\n  index = divisorLength + -1;\n  divisorPtr = (uint *)(divisor + 0x14);\n  dividendPtr = (uint *)(dividend + 0x14);\n  quotient = dividendPtr[index] / (divisorPtr[index] + 1);\n  divisorPtr = divisorPtr + index;\n  if (quotient != 0) {\n    temp1 = 0;\n    temp2 = 0;\n    dividendPtr = dividendPtr;\n    divisorPtr = divisorPtr;\n    do {\n      divisorPtr = divisorPtr + 1;\n      temp1 = quotient * (*divisorPtr & 0xffff) + temp1;\n      temp10 = quotient * (*divisorPtr >> 0x10) + (temp1 >> 0x10);\n      temp1 = (temp2 - (temp1 & 0xffff)) + (*dividendPtr & 0xffff);\n      temp2 = ((*dividendPtr >> 0x10) - (temp10 & 0xffff)) + ((int)temp1 >> 0x10);\n      *dividendPtr = temp1 & 0xffff | temp2 * 0x10000;\n      temp2 = temp2 >> 0x10;\n      temp1 = temp10 >> 0x10;\n      dividendPtr = dividendPtr + 1;\n      divisorPtr = divisorPtr;\n    } while (divisorPtr <= divisorPtr);\n    if (dividendPtr[index] == 0) {\n      if ((dividendPtr < dividendPtr + divisorLength + -2) && (dividendPtr[divisorLength + -2] == 0)) {\n        dividendPtr = dividendPtr + divisorLength + -3;\n        do {\n          index = index + -1;\n          if (dividendPtr <= dividendPtr) break;\n          temp1 = *dividendPtr;\n          dividendPtr = dividendPtr + -1;\n        } while (temp1 == 0);\n      }\n      *(int *)(dividend + 0x10) = index;\n    }\n  }\n  divisorLength = __mcmp();\n  if (-1 < divisorLength) {\n    divisorLength = 0;\n    quotient = quotient + 1;\n    dividendPtr = dividendPtr;\n    do {\n      divisorPtr = divisorPtr + 1;\n      temp1 = (divisorLength - (*divisorPtr & 0xffff)) + (*dividendPtr & 0xffff);\n      divisorLength = ((*dividendPtr >> 0x10) - (*divisorPtr >> 0x10)) + ((int)temp1 >> 0x10);\n      *dividendPtr = temp1 & 0xffff | divisorLength * 0x10000;\n      divisorLength = divisorLength >> 0x10;\n      dividendPtr = dividendPtr + 1;\n      divisorPtr = divisorPtr;\n    } while (divisorPtr <= divisorPtr);\n    if (dividendPtr[index] == 0) {\n      if ((dividendPtr < dividendPtr + index + -1) && (dividendPtr[index + -1] == 0)) {\n        divisorPtr = dividendPtr + index + -2;\n        do {\n          index = index + -1;\n          if (divisorPtr <= dividendPtr) break;\n          temp1 = *divisorPtr;\n          divisorPtr = divisorPtr + -1;\n        } while (temp1 == 0);\n      }\n      *(int *)(dividend + 0x10) = index;\n    }\n  }\n  return quotient;\n}\n\n",
            "renaming": {
                "FUN_080078c0": "calculate_quotient_080078c0",
                "param_1": "dividend",
                "param_2": "divisor",
                "iVar4": "divisorLength",
                "iVar5": "index",
                "uVar1": "temp1",
                "puVar2": "dividendPtr",
                "puVar7": "divisorPtr",
                "puVar8": "dividendPtr",
                "puVar9": "divisorPtr",
                "uVar6": "quotient",
                "puVar11": "divisorPtr",
                "puVar12": "divisorPtr",
                "iVar3": "temp2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__mcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e8": {
            "entrypoint": "0x080079e8",
            "current_name": "format_double_080079e8",
            "code": "\nchar * formatDouble_080079e8(int buffer,undefined4 paramCount,uint mantissa,uint exponent,uint decimalDigits,\n                   uint width,int *written,uint *overflow,char **result)\n\n{\n  bool isInfinity;\n  bool exponentLessThanMantissa;\n  bool isNegative;\n  char digit;\n  byte bVar5;\n  undefined4 mantissaTemp;\n  int digitsCount;\n  int iVar8;\n  int iVar9;\n  char *resultPtr;\n  uint bVar25;\n  undefined4 roundingDigit;\n  undefined4 exponentTemp;\n  int exponentDiff;\n  int digitShift;\n  undefined4 uVar16;\n  uint uVar17;\n  uint uVar18;\n  int exponentAdjustment;\n  char *pcVar20;\n  char *pcVar21;\n  undefined4 *puVar22;\n  undefined4 uVar23;\n  int digitValue;\n  bool isNegative;\n  undefined8 resultDouble;\n  undefined8 tempDouble1;\n  undefined8 tempDouble2;\n  uint mantissaPowerOf5;\n  uint adjustedExponent;\n  uint log10AdjustedExponent;\n  int adjustedMantissaDigits;\n  uint totalDigits;\n  int fractionalDigits;\n  int adjustedExponentDifference;\n  uint isExponentPositive;\n  uint roundingDigitIndex;\n  uint decimalPoint;\n  uint numDigitsToFree;\n  uint tempExponent;\n  int numBits;\n  int tempIntArray [2];\n  \n  exponentDiff = *(int *)(buffer + 0x40);\n  if (exponentDiff != 0) {\n    uVar18 = *(uint *)(buffer + 0x44);\n    *(uint *)(exponentDiff + 4) = uVar18;\n    *(int *)(exponentDiff + 8) = 1 << (uVar18 & 0xff);\n    _Bfree(buffer,exponentDiff);\n    *(undefined4 *)(buffer + 0x40) = 0;\n  }\n  isNegative = (int)exponent < 0;\n  uVar18 = exponent;\n  if (isNegative) {\n    uVar18 = exponent & 0x7fffffff;\n  }\n  *overflow = (uint)isNegative;\n  adjustedExponent = exponent;\n  if (isNegative) {\n    adjustedExponent = uVar18;\n  }\n  uVar17 = adjustedExponent;\n  if ((~uVar18 & 0x7ff00000) == 0) {\n    *written = 9999;\n    if ((mantissa == 0) && ((uVar18 & 0xfffff) == 0)) {\n      resultPtr = \"Infinity\";\n      if (result == (char **)0x0) {\n        return resultPtr;\n      }\n      pcVar21 = \"\";\n    }\n    else {\n      resultPtr = \"NaN\";\n      if (result == (char **)0x0) {\n        return resultPtr;\n      }\n      pcVar21 = \"\";\n    }\n    *result = pcVar21;\n    return resultPtr;\n  }\n  resultDouble = __aeabi_dcmpeq(mantissa,adjustedExponent,0,0);\n  if ((int)resultDouble != 0) {\n    *written = 1;\n    if (result != (char **)0x0) {\n      *result = \"\";\n      return \"0\";\n    }\n    return \"0\";\n  }\n  mantissaTemp = __d2b(buffer,(int)((ulonglong)resultDouble >> 0x20),mantissa,adjustedExponent,tempIntArray,&numBits);\n  exponentDiff = numBits;\n  if (uVar18 >> 0x14 == 0) {\n    exponentAdjustment = tempIntArray[0] + numBits;\n    digitShift = exponentAdjustment + 0x432;\n    if (digitShift < 0x21) {\n      uVar18 = mantissa << (0x20U - digitShift & 0xff);\n    }\n    else {\n      uVar18 = mantissa >> (exponentAdjustment + 0x412U & 0xff) | uVar18 << (0x40U - digitShift & 0xff);\n    }\n    resultDouble = __floatunsidf(uVar18);\n    exponentAdjustment = exponentAdjustment + -1;\n    isNegative = true;\n    bVar25 = (int)((ulonglong)resultDouble >> 0x20) + 0xfe100000;\n    uVar18 = (uint)resultDouble;\n  }\n  else {\n    exponentAdjustment = (uVar18 >> 0x14) - 0x3ff;\n    bVar25 = adjustedExponent & 0xfffff | 0x3ff00000;\n    isNegative = false;\n    uVar18 = mantissa;\n  }\n  resultDouble = __subdf3(uVar18,bVar25,0,0x3ff80000);\n  resultDouble = __muldf3((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),0x636f4361,0x3fd287a7);\n  resultDouble = __aeabi_dadd((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),0x8b60c8b3,0x3fc68a28);\n  tempDouble1 = __aeabi_i2d(exponentAdjustment);\n  tempDouble1 = __muldf3((int)tempDouble1,(int)((ulonglong)tempDouble1 >> 0x20),0x509f79fb,0x3fd34413);\n  resultDouble = __aeabi_dadd((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),(int)tempDouble1,\n                        (int)((ulonglong)tempDouble1 >> 0x20));\n  exponentTemp = (undefined4)((ulonglong)resultDouble >> 0x20);\n  log10AdjustedExponent = __aeabi_d2iz();\n  digitShift = __aeabi_dcmplt((int)resultDouble,exponentTemp,0,0);\n  if (digitShift != 0) {\n    tempDouble1 = __aeabi_i2d(log10AdjustedExponent);\n    digitShift = __aeabi_dcmpeq((int)tempDouble1,(int)((ulonglong)tempDouble1 >> 0x20),(int)resultDouble,exponentTemp);\n    if (digitShift == 0) {\n      log10AdjustedExponent = log10AdjustedExponent - 1;\n    }\n  }\n  if (log10AdjustedExponent < 0x17) {\n    digitShift = __aeabi_dcmpgt(*(undefined4 *)(&DAT_08009fa8 + log10AdjustedExponent * 8),\n                            *(undefined4 *)(&DAT_08009fac + log10AdjustedExponent * 8),mantissa,adjustedExponent);\n    if (digitShift == 0) {\n      exponentLessThanMantissa = false;\n    }\n    else {\n      log10AdjustedExponent = log10AdjustedExponent - 1;\n      exponentLessThanMantissa = false;\n    }\n  }\n  else {\n    exponentLessThanMantissa = true;\n  }\n  digitShift = (exponentDiff - exponentAdjustment) + -1;\n  if (digitShift < 0) {\n    adjustedMantissaDigits = 1 - (exponentDiff - exponentAdjustment);\n    digitShift = 0;\n  }\n  else {\n    adjustedMantissaDigits = 0;\n  }\n  if ((int)log10AdjustedExponent < 0) {\n    isExponentPositive = 0;\n    adjustedMantissaDigits = adjustedMantissaDigits - log10AdjustedExponent;\n    adjustedExponentDifference = -log10AdjustedExponent;\n  }\n  else {\n    digitShift = digitShift + log10AdjustedExponent;\n    isExponentPositive = log10AdjustedExponent;\n    adjustedExponentDifference = 0;\n  }\n  if (9 < decimalDigits) {\n    numDigitsToFree = 0xffffffff;\n    isInfinity = true;\n    totalDigits = 0xffffffff;\n    isNegative = true;\n    decimalDigits = 0;\n    width = 0;\n    goto LAB_08007c24;\n  }\n  isInfinity = (int)decimalDigits < 6;\n  if (!isInfinity) {\n    decimalDigits = decimalDigits - 4;\n  }\n  switch(decimalDigits) {\n  case 2:\n    isNegative = false;\n    break;\n  case 3:\n    isNegative = false;\n    goto LAB_08008300;\n  case 4:\n    isNegative = true;\n    break;\n  case 5:\n    isNegative = true;\nLAB_08008300:\n    numDigitsToFree = log10AdjustedExponent + width;\n    totalDigits = numDigitsToFree + 1;\n    uVar18 = totalDigits;\n    if ((int)totalDigits < 1) {\n      uVar18 = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(buffer + 0x44) = 0;\n    resultPtr = (char *)_Balloc(buffer,0);\n    numDigitsToFree = 0xffffffff;\n    totalDigits = 0xffffffff;\n    width = 0;\n    *(char **)(buffer + 0x40) = resultPtr;\n    isNegative = true;\n    goto LAB_08007e36;\n  }\n  if ((int)width < 1) {\n    numDigitsToFree = 1;\n    width = 1;\n    totalDigits = 1;\nLAB_08007c24:\n    *(undefined4 *)(buffer + 0x44) = 0;\n    bVar25 = numDigitsToFree;\n  }\n  else {\n    numDigitsToFree = width;\n    totalDigits = width;\n    uVar18 = width;\nLAB_08008314:\n    *(undefined4 *)(buffer + 0x44) = 0;\n    bVar25 = totalDigits;\n    if (0x17 < (int)uVar18) {\n      exponentAdjustment = 4;\n      exponentDiff = 1;\n      do {\n        digitsCount = exponentDiff;\n        exponentAdjustment = exponentAdjustment * 2;\n        exponentDiff = digitsCount + 1;\n      } while (exponentAdjustment + 0x14U <= uVar18);\n      *(int *)(buffer + 0x44) = digitsCount;\n    }\n  }\n  resultPtr = (char *)_Balloc(buffer);\n  *(char **)(buffer + 0x40) = resultPtr;\n  if ((bVar25 < 0xf) && (isInfinity)) {\n    if ((int)log10AdjustedExponent < 1) {\n      if (log10AdjustedExponent == 0) {\n        exponentDiff = 2;\n        mantissaPowerOf5 = mantissa;\n      }\n      else {\n        exponentDiff = (-log10AdjustedExponent & 0xf) * 8;\n        resultDouble = __muldf3(mantissa,adjustedExponent,*(undefined4 *)(&DAT_08009fa8 + exponentDiff),\n                          *(undefined4 *)(&DAT_08009fac + exponentDiff));\n        adjustedExponent = (uint)((ulonglong)resultDouble >> 0x20);\n        mantissaPowerOf5 = (uint)resultDouble;\n        exponentAdjustment = (int)-log10AdjustedExponent >> 4;\n        if (exponentAdjustment == 0) {\n          exponentDiff = 2;\n        }\n        else {\n          isInfinity = false;\n          exponentDiff = 2;\n          puVar22 = &DAT_08009f80;\n          do {\n            if (exponentAdjustment << 0x1f < 0) {\n              resultDouble = __muldf3((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),*puVar22,puVar22[1]);\n              isInfinity = true;\n              exponentDiff = exponentDiff + 1;\n            }\n            exponentAdjustment = exponentAdjustment >> 1;\n            puVar22 = puVar22 + 2;\n          } while (exponentAdjustment != 0);\n          if (isInfinity) {\n            mantissaPowerOf5 = (uint)resultDouble;\n            adjustedExponent = (uint)((ulonglong)resultDouble >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      uVar18 = (int)log10AdjustedExponent >> 4;\n      tempDouble1 = *(undefined8 *)(&DAT_08009fa8 + (log10AdjustedExponent & 0xf) * 8);\n      resultDouble = *(undefined8 *)(&DAT_08009fa8 + (log10AdjustedExponent & 0xf) * 8);\n      if ((int)(uVar18 << 0x1b) < 0) {\n        tempDouble2 = __divdf3(mantissa,adjustedExponent,0x7f73bf3c,0x75154fdd);\n        decimalPoint = (uint)((ulonglong)tempDouble2 >> 0x20);\n        roundingDigitIndex = (uint)tempDouble2;\n        exponentDiff = 3;\n        uVar18 = uVar18 & 0xf;\n      }\n      else {\n        exponentDiff = 2;\n        decimalPoint = adjustedExponent;\n        roundingDigitIndex = mantissa;\n      }\n      if (uVar18 != 0) {\n        puVar22 = &DAT_08009f80;\n        do {\n          if ((int)(uVar18 << 0x1f) < 0) {\n            resultDouble = __muldf3((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),*puVar22,puVar22[1]);\n            exponentDiff = exponentDiff + 1;\n          }\n          uVar18 = (int)uVar18 >> 1;\n          puVar22 = puVar22 + 2;\n          tempDouble1 = resultDouble;\n        } while (uVar18 != 0);\n      }\n      adjustedExponent = (uint)((ulonglong)tempDouble1 >> 0x20);\n      mantissaPowerOf5 = (uint)tempDouble1;\n      resultDouble = __divdf3(roundingDigitIndex,decimalPoint,mantissaPowerOf5,adjustedExponent);\n      mantissaPowerOf5 = (uint)resultDouble;\n      adjustedExponent = (uint)((ulonglong)resultDouble >> 0x20);\n    }\n    resultDouble = CONCAT44(adjustedExponent,mantissaPowerOf5);\n    if ((exponentLessThanMantissa) && (exponentAdjustment = __aeabi_dcmplt(mantissaPowerOf5,adjustedExponent,0,0x3ff00000), exponentAdjustment != 0)) {\n      if (totalDigits == 0) {\n        resultDouble = __aeabi_i2d(exponentDiff);\n        resultDouble = __muldf3((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),mantissaPowerOf5,adjustedExponent);\n        resultDouble = __aeabi_dadd((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),0,0x401c0000);\n        exponentTemp = (undefined4)resultDouble;\n        exponentDiff = (int)((ulonglong)resultDouble >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)numDigitsToFree) {\n        resultDouble = __muldf3(mantissaPowerOf5,adjustedExponent,0,0x40240000);\n        tempDouble1 = __aeabi_i2d(exponentDiff + 1);\n        tempDouble1 = __muldf3((int)tempDouble1,(int)((ulonglong)tempDouble1 >> 0x20),(int)resultDouble,\n                          (int)((ulonglong)resultDouble >> 0x20));\n        tempDouble1 = __aeabi_dadd((int)tempDouble1,(int)((ulonglong)tempDouble1 >> 0x20),0,0x401c0000);\n        exponentTemp = (undefined4)tempDouble1;\n        roundingDigitIndex = numDigitsToFree;\n        tempExponent = log10AdjustedExponent - 1;\n        exponentDiff = (int)((ulonglong)tempDouble1 >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    tempDouble1 = __aeabi_i2d(exponentDiff);\n    tempDouble1 = __muldf3((int)tempDouble1,(int)((ulonglong)tempDouble1 >> 0x20),mantissaPowerOf5,adjustedExponent);\n    tempDouble1 = __aeabi_dadd((int)tempDouble1,(int)((ulonglong)tempDouble1 >> 0x20),0,0x401c0000);\n    exponentTemp = (undefined4)tempDouble1;\n    exponentDiff = (int)((ulonglong)tempDouble1 >> 0x20) + -0x3400000;\n    if (totalDigits != 0) {\n      tempExponent = log10AdjustedExponent;\n      roundingDigitIndex = totalDigits;\nLAB_08007cfa:\n      adjustedExponent = (uint)((ulonglong)resultDouble >> 0x20);\n      mantissaPowerOf5 = (uint)resultDouble;\n      digit = __aeabi_d2iz(mantissaPowerOf5,adjustedExponent);\n      digit = digit + '0';\n      uVar16 = (&DAT_08009fa0)[roundingDigitIndex * 2];\n      roundingDigit = (&DAT_08009fa4)[roundingDigitIndex * 2];\n      resultDouble = __aeabi_i2d();\n      resultDouble = __subdf3(mantissaPowerOf5,adjustedExponent,(int)resultDouble,(int)((ulonglong)resultDouble >> 0x20));\n      uVar23 = (undefined4)((ulonglong)resultDouble >> 0x20);\n      pcVar21 = resultPtr + 1;\n      if (isNegative) {\n        tempDouble1 = __divdf3(0,0x3fe00000,uVar16,roundingDigit);\n        tempDouble1 = __subdf3((int)tempDouble1,(int)((ulonglong)tempDouble1 >> 0x20),exponentTemp,exponentDiff);\n        exponentTemp = (undefined4)((ulonglong)tempDouble1 >> 0x20);\n        *resultPtr = digit;\n        exponentDiff = __aeabi_dcmpgt((int)tempDouble1,exponentTemp,(int)resultDouble,uVar23);\n        if (exponentDiff != 0) {\nLAB_08008784:\n          log10AdjustedExponent = tempExponent;\n          goto LAB_08008294;\n        }\n        tempDouble2 = __subdf3(0,0x3ff00000,(int)resultDouble,uVar23);\n        exponentDiff = __aeabi_dcmpgt((int)tempDouble1,exponentTemp,(int)tempDouble2,(int)((ulonglong)tempDouble2 >> 0x20));\n        if (exponentDiff == 0) {\n          if (roundingDigitIndex != 1) {\n            pcVar20 = pcVar21;\n            do {\n              tempDouble1 = __muldf3((int)tempDouble1,(int)((ulonglong)tempDouble1 >> 0x20),0,0x40240000);\n              exponentTemp = (undefined4)((ulonglong)tempDouble1 >> 0x20);\n              resultDouble = __muldf3((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),0,0x40240000);\n              digit = __aeabi_d2iz();\n              tempDouble2 = __aeabi_i2d();\n              resultDouble = __subdf3((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),(int)tempDouble2,\n                                (int)((ulonglong)tempDouble2 >> 0x20));\n              uVar16 = (undefined4)((ulonglong)resultDouble >> 0x20);\n              digit = digit + '0';\n              pcVar21 = pcVar20 + 1;\n              *pcVar20 = digit;\n              exponentDiff = __aeabi_dcmplt((int)resultDouble,uVar16,(int)tempDouble1,exponentTemp);\n              if (exponentDiff != 0) {\n                log10AdjustedExponent = tempExponent;\n                goto LAB_08008294;\n              }\n              tempDouble2 = __subdf3(0,0x3ff00000,(int)resultDouble,uVar16);\n              exponentDiff = __aeabi_dcmplt((int)tempDouble2,(int)((ulonglong)tempDouble2 >> 0x20),(int)tempDouble1,\n                                      exponentTemp);\n              if (exponentDiff != 0) goto LAB_08008798;\n              pcVar20 = pcVar21;\n            } while (pcVar21 != resultPtr + roundingDigitIndex);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        log10AdjustedExponent = tempExponent;\n      }\n      else {\n        tempDouble1 = __muldf3(exponentTemp,exponentDiff,uVar16,roundingDigit);\n        exponentTemp = (undefined4)((ulonglong)tempDouble1 >> 0x20);\n        *resultPtr = digit;\n        if (roundingDigitIndex != 1) {\n          pcVar20 = pcVar21;\n          do {\n            resultDouble = __muldf3((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),0,0x40240000);\n            digit = __aeabi_d2iz();\n            tempDouble2 = __aeabi_i2d();\n            resultDouble = __subdf3((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),(int)tempDouble2,\n                              (int)((ulonglong)tempDouble2 >> 0x20));\n            pcVar21 = pcVar20 + 1;\n            *pcVar20 = digit + '0';\n            pcVar20 = pcVar21;\n          } while (pcVar21 != resultPtr + roundingDigitIndex);\n        }\n        uVar16 = (undefined4)((ulonglong)resultDouble >> 0x20);\n        tempDouble2 = __aeabi_dadd((int)tempDouble1,exponentTemp,0,0x3fe00000);\n        exponentDiff = __aeabi_dcmplt((int)tempDouble2,(int)((ulonglong)tempDouble2 >> 0x20),(int)resultDouble,uVar16);\n        if (exponentDiff == 0) {\n          tempDouble1 = __subdf3(0,0x3fe00000,(int)tempDouble1,exponentTemp);\n          exponentDiff = __aeabi_dcmpgt((int)tempDouble1,(int)((ulonglong)tempDouble1 >> 0x20),(int)resultDouble,uVar16);\n          pcVar20 = pcVar21;\n          if (exponentDiff == 0) goto LAB_08007e36;\n          do {\n            pcVar21 = pcVar20;\n            pcVar20 = pcVar21 + -1;\n          } while (pcVar21[-1] == '0');\n          goto LAB_08008784;\n        }\n        log10AdjustedExponent = tempExponent;\n        digit = pcVar21[-1];\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    resultDouble = __subdf3(mantissaPowerOf5,adjustedExponent,0,0x40140000);\n    uVar16 = (undefined4)((ulonglong)resultDouble >> 0x20);\n    exponentAdjustment = __aeabi_dcmpgt((int)resultDouble,uVar16,exponentTemp,exponentDiff);\n    if (exponentAdjustment == 0) {\n      exponentDiff = __aeabi_dcmplt((int)resultDouble,uVar16,exponentTemp,exponentDiff + -0x80000000);\n      if (exponentDiff == 0) goto LAB_08007e36;\n      exponentAdjustment = 0;\n      exponentDiff = 0;\n      pcVar21 = resultPtr;\n      goto LAB_080084f0;\n    }\n    digitShift = 0;\n    digitsCount = 0;\nLAB_08008406:\n    *resultPtr = '1';\n    log10AdjustedExponent = log10AdjustedExponent + 1;\n    pcVar21 = resultPtr + 1;\n    exponentAdjustment = digitsCount;\n    exponentDiff = digitShift;\nLAB_08008416:\n    _Bfree(buffer,exponentDiff);\n    if (exponentAdjustment == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pcVar21 = resultPtr;\n    if ((-1 < tempIntArray[0]) && ((int)log10AdjustedExponent < 0xf)) {\n      exponentTemp = *(undefined4 *)(&DAT_08009fa8 + log10AdjustedExponent * 8);\n      uVar16 = *(undefined4 *)(&DAT_08009fac + log10AdjustedExponent * 8);\n      if ((-1 < (int)width) || (0 < (int)totalDigits)) {\n        __divdf3(mantissa,uVar17,exponentTemp,uVar16);\n        bVar5 = __aeabi_d2iz();\n        resultDouble = __aeabi_i2d();\n        resultDouble = __muldf3((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),exponentTemp,uVar16);\n        resultDouble = __subdf3(mantissa,uVar17,(int)resultDouble,(int)((ulonglong)resultDouble >> 0x20));\n        *resultPtr = bVar5 + 0x30;\n        pcVar21 = resultPtr + 1;\n        if (totalDigits != 1) {\n          resultDouble = __muldf3((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),0,0x40240000);\n          exponentDiff = __aeabi_dcmpeq((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),0,0);\n          while (exponentDiff == 0) {\n            uVar23 = (undefined4)((ulonglong)resultDouble >> 0x20);\n            __divdf3((int)resultDouble,uVar23,exponentTemp,uVar16);\n            bVar5 = __aeabi_d2iz();\n            tempDouble1 = __aeabi_i2d();\n            tempDouble1 = __muldf3((int)tempDouble1,(int)((ulonglong)tempDouble1 >> 0x20),exponentTemp,uVar16);\n            resultDouble = __subdf3((int)resultDouble,uVar23,(int)tempDouble1,(int)((ulonglong)tempDouble1 >> 0x20));\n            pcVar20 = pcVar21 + 1;\n            *pcVar21 = bVar5 + 0x30;\n            pcVar21 = pcVar20;\n            if (totalDigits == (int)pcVar20 - (int)resultPtr) goto LAB_08007f3a;\n            resultDouble = __muldf3((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),0,0x40240000);\n            exponentDiff = __aeabi_dcmpeq((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        resultDouble = __aeabi_dadd((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20));\n        uVar23 = (undefined4)((ulonglong)resultDouble >> 0x20);\n        exponentDiff = __aeabi_dcmpgt((int)resultDouble,uVar23,exponentTemp,uVar16);\n        if ((exponentDiff == 0) &&\n           ((exponentDiff = __aeabi_dcmpeq((int)resultDouble,uVar23,exponentTemp,uVar16), exponentDiff == 0 ||\n            ((bVar5 & 1) == 0)))) goto LAB_08008294;\n        digit = pcVar21[-1];\nLAB_08007f7c:\n        while (pcVar20 = pcVar21 + -1, digit == '9') {\n          if (resultPtr == pcVar20) {\n            *resultPtr = '0';\n            digit = pcVar21[-1];\n            log10AdjustedExponent = log10AdjustedExponent + 1;\n            pcVar20 = resultPtr;\n            break;\n          }\n          digit = pcVar21[-2];\n          pcVar21 = pcVar20;\n        }\n        *pcVar20 = digit + '\\x01';\n        goto LAB_08008294;\n      }\n      if (totalDigits == 0) {\n        resultDouble = __muldf3(exponentTemp,uVar16,0,0x40140000);\n        iVar9 = __aeabi_dcmpge((int)resultDouble,(int)((ulonglong)resultDouble >> 0x20),mantissa,uVar17);\n        exponentAdjustment = 0;\n        digitShift = 0;\n        digitsCount = 0;\n        exponentDiff = 0;\n        if (iVar9 == 0) goto LAB_08008406;\n      }\n      else {\n        exponentAdjustment = 0;\n        exponentDiff = 0;\n      }\nLAB_080084f0:\n      log10AdjustedExponent = ~width;\n      resultPtr = pcVar21;\n      goto LAB_08008416;\n    }\n    exponentDiff = adjustedExponentDifference;\n    if (isNegative) {\n      if ((int)decimalDigits < 2) {\n        if (isNegative) {\n          fractionalDigits = adjustedMantissaDigits;\n          adjustedMantissaDigits = adjustedMantissaDigits + tempIntArray[0] + 0x433;\n          digitShift = digitShift + tempIntArray[0] + 0x433;\n        }\n        else {\n          fractionalDigits = adjustedMantissaDigits;\n          adjustedMantissaDigits = adjustedMantissaDigits + (0x36 - numBits);\n          digitShift = digitShift + (0x36 - numBits);\n        }\n      }\n      else {\n        exponentAdjustment = totalDigits - 1;\n        if (adjustedExponentDifference < exponentAdjustment) {\n          isExponentPositive = isExponentPositive + (exponentAdjustment - adjustedExponentDifference);\n          exponentDiff = 0;\n          adjustedExponentDifference = exponentAdjustment;\n        }\n        else {\n          exponentDiff = adjustedExponentDifference - exponentAdjustment;\n        }\n        if ((int)totalDigits < 0) {\n          fractionalDigits = adjustedMantissaDigits - totalDigits;\n        }\n        else {\n          digitShift = digitShift + totalDigits;\n          fractionalDigits = adjustedMantissaDigits;\n          adjustedMantissaDigits = adjustedMantissaDigits + totalDigits;\n        }\n      }\n      exponentAdjustment = __i2b(buffer,1);\n    }\n    else {\n      fractionalDigits = adjustedMantissaDigits;\n      exponentAdjustment = 0;\n    }\n    if ((0 < fractionalDigits) && (0 < digitShift)) {\n      digitsCount = fractionalDigits;\n      if (digitShift <= fractionalDigits) {\n        digitsCount = digitShift;\n      }\n      digitShift = digitShift - digitsCount;\n      adjustedMantissaDigits = adjustedMantissaDigits - digitsCount;\n      fractionalDigits = fractionalDigits - digitsCount;\n    }\n    if (adjustedExponentDifference != 0) {\n      if (isNegative) {\n        exponentTemp = mantissaTemp;\n        if (exponentDiff != 0) {\n          exponentAdjustment = __pow5mult(buffer,exponentAdjustment,exponentDiff);\n          exponentTemp = __multiply(buffer,exponentAdjustment,mantissaTemp);\n          _Bfree(buffer,mantissaTemp);\n          mantissaTemp = exponentTemp;\n          if (adjustedExponentDifference - exponentDiff == 0) goto LAB_08008062;\n        }\n        mantissaTemp = __pow5mult(buffer,exponentTemp,adjustedExponentDifference - exponentDiff);\n      }\n      else {\n        mantissaTemp = __pow5mult(buffer,mantissaTemp,adjustedExponentDifference);\n      }\n    }\nLAB_08008062:\n    exponentDiff = __i2b(buffer,1);\n    if (isExponentPositive == 0) {\n      if (((int)decimalDigits < 2) && (mantissa == 0)) {\nLAB_0800835a:\n        if ((uVar17 & 0xfffff) == 0) {\n          uVar17 = uVar17 & 0x7ff00000;\n          if (uVar17 != 0) {\n            digitShift = digitShift + 1;\n            adjustedMantissaDigits = adjustedMantissaDigits + 1;\n            uVar17 = 1;\n          }\n        }\n        else {\n          uVar17 = 0;\n        }\n        isNegative = isExponentPositive != 0;\n        uVar18 = mantissa;\n        isExponentPositive = uVar17;\n        if (isNegative) goto LAB_080082d4;\n      }\n      digitsCount = 1;\n    }\n    else {\n      resultDouble = __pow5mult(buffer,exponentDiff);\n      exponentDiff = (int)resultDouble;\n      if (((int)decimalDigits < 2) && (mantissa == 0)) goto LAB_0800835a;\n      isExponentPositive = 0;\n      uVar18 = (uint)((ulonglong)resultDouble >> 0x20);\nLAB_080082d4:\n      digitsCount = __hi0bits(*(undefined4 *)(exponentDiff + *(int *)(exponentDiff + 0x10) * 4 + 0x10),uVar18);\n      digitsCount = 0x20 - digitsCount;\n    }\n    uVar18 = digitsCount + digitShift & 0x1f;\n    if (uVar18 == 0) {\n      digitsCount = 0x1c;\nLAB_08008096:\n      digitShift = digitShift + digitsCount;\n      adjustedMantissaDigits = adjustedMantissaDigits + digitsCount;\n      fractionalDigits = fractionalDigits + digitsCount;\n    }\n    else {\n      if (4 < (int)(0x20 - uVar18)) {\n        digitsCount = 0x1c - uVar18;\n        goto LAB_08008096;\n      }\n      if (0x20 - uVar18 != 4) {\n        digitsCount = 0x3c - uVar18;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < adjustedMantissaDigits) {\n      mantissaTemp = __lshift(buffer,mantissaTemp,adjustedMantissaDigits);\n    }\n    if (0 < digitShift) {\n      exponentDiff = __lshift(buffer,exponentDiff,digitShift);\n    }\n    pcVar20 = resultPtr;\n    if ((exponentLessThanMantissa) && (digitShift = __mcmp(mantissaTemp,exponentDiff), digitShift < 0)) {\n      log10AdjustedExponent = log10AdjustedExponent - 1;\n      mantissaTemp = __multadd(buffer,mantissaTemp,10,0);\n      if (isNegative) {\n        exponentAdjustment = __multadd(buffer,exponentAdjustment,10,0);\n        if ((0 < (int)numDigitsToFree) || ((int)decimalDigits < 3)) {\n          totalDigits = numDigitsToFree;\n          goto LAB_080080de;\n        }\n      }\n      else if ((0 < (int)numDigitsToFree) || ((int)decimalDigits < 3)) {\n        totalDigits = numDigitsToFree;\n        goto LAB_0800820a;\n      }\n      totalDigits = numDigitsToFree;\nLAB_080084e8:\n      if (totalDigits == 0) {\n        digitShift = __multadd(buffer,exponentDiff,5);\n        iVar9 = __mcmp(mantissaTemp,digitShift);\n        digitsCount = exponentAdjustment;\n        exponentDiff = digitShift;\n        if (0 < iVar9) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)totalDigits < 1) && (2 < (int)decimalDigits)) goto LAB_080084e8;\n    if (isNegative) {\nLAB_080080de:\n      mantissaPowerOf5 = exponentAdjustment;\n      if (0 < fractionalDigits) {\n        mantissaPowerOf5 = __lshift(buffer,exponentAdjustment,fractionalDigits);\n      }\n      exponentAdjustment = mantissaPowerOf5;\n      if (isExponentPositive != 0) {\n        exponentAdjustment = _Balloc(buffer,*(undefined4 *)(mantissaPowerOf5 + 4));\n        memcpy(exponentAdjustment + 0xc,mantissaPowerOf5 + 0xc,(*(int *)(mantissaPowerOf5 + 0x10) + 2) * 4);\n        exponentAdjustment = __lshift(buffer,exponentAdjustment,1);\n      }\nLAB_08008108:\n      digitShift = quorem(mantissaTemp,exponentDiff);\n      digitsCount = __mcmp(mantissaTemp,mantissaPowerOf5);\n      iVar9 = __mdiff(buffer,exponentDiff,exponentAdjustment);\n      digitValue = digitShift + 0x30;\n      if (*(int *)(iVar9 + 0xc) == 0) {\n        iVar8 = __mcmp(mantissaTemp);\n        _Bfree(buffer,iVar9);\n        if ((iVar8 != 0) || (decimalDigits != 0)) goto LAB_0800815a;\n        if ((mantissa & 1) != 0) {\n          iVar8 = 0;\n          goto LAB_0800815a;\n        }\n        if (digitValue != 0x39) {\n          if (0 < digitsCount) goto LAB_0800874c;\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pcVar21 = pcVar20 + 1;\n        digit = '9';\n        *pcVar20 = '9';\n        goto LAB_08008268;\n      }\n      _Bfree(buffer,iVar9);\n      iVar8 = 1;\nLAB_0800815a:\n      if ((digitsCount < 0) || (((digitsCount == 0 && (decimalDigits == 0)) && ((mantissa & 1) == 0)))) {\n        if (0 < iVar8) {\n          mantissaTemp = __lshift(buffer,mantissaTemp,1);\n          digitsCount = __mcmp(mantissaTemp,exponentDiff);\n          if ((0 < digitsCount) || ((digitsCount == 0 && (digitShift << 0x1f < 0)))) {\n            if (digitValue == 0x39) goto LAB_08008752;\nLAB_0800874c:\n            digitValue = digitShift + 0x31;\n          }\n        }\nLAB_080085a4:\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)digitValue;\n        goto LAB_08008274;\n      }\n      pcVar21 = pcVar20 + 1;\n      if (0 < iVar8) {\n        if (digitValue == 0x39) goto LAB_08008752;\n        *pcVar20 = (char)digitShift + '1';\n        goto LAB_08008274;\n      }\n      *pcVar20 = (char)digitValue;\n      if (resultPtr + (totalDigits - 1) != pcVar20) {\n        mantissaTemp = __multadd(buffer,mantissaTemp,10,0);\n        pcVar20 = pcVar21;\n        if (mantissaPowerOf5 == exponentAdjustment) {\n          mantissaPowerOf5 = __multadd(buffer,mantissaPowerOf5,10,0);\n          exponentAdjustment = mantissaPowerOf5;\n        }\n        else {\n          mantissaPowerOf5 = __multadd(buffer,mantissaPowerOf5,10,0);\n          exponentAdjustment = __multadd(buffer,exponentAdjustment,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    else {\nLAB_0800820a:\n      while( true ) {\n        digitValue = quorem(mantissaTemp,exponentDiff);\n        digitValue = digitValue + 0x30;\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)digitValue;\n        if ((int)totalDigits <= (int)pcVar21 - (int)resultPtr) break;\n        mantissaTemp = __multadd(buffer,mantissaTemp,10,0);\n        pcVar20 = pcVar21;\n      }\n      mantissaPowerOf5 = 0;\n    }\n    mantissaTemp = __lshift(buffer,mantissaTemp,1);\n    digitShift = __mcmp(mantissaTemp,exponentDiff);\n    digit = pcVar21[-1];\n    if ((0 < digitShift) || ((digitShift == 0 && (digitValue << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pcVar20 = pcVar21 + -1;\n        if (digit != '9') goto code_r0x08008270;\n        if (resultPtr == pcVar20) {\n          *resultPtr = '1';\n          log10AdjustedExponent = log10AdjustedExponent + 1;\n          goto LAB_08008274;\n        }\n        digit = pcVar21[-2];\n        pcVar21 = pcVar20;\n      } while( true );\n    }\n    while (digit == '0') {\n      digit = pcVar21[-2];\n      pcVar21 = pcVar21 + -1;\n    }\nLAB_08008274:\n    _Bfree(buffer,exponentDiff);\n    if (exponentAdjustment == 0) goto LAB_08008294;\n    if ((mantissaPowerOf5 != 0) && (mantissaPowerOf5 != exponentAdjustment)) {\n      _Bfree(buffer);\n    }\n  }\n  _Bfree(buffer,exponentAdjustment);\nLAB_08008294:\n  _Bfree(buffer,mantissaTemp);\n  *pcVar21 = '\\0';\n  *written = log10AdjustedExponent + 1;\n  if (result == (char **)0x0) {\n    return resultPtr;\n  }\n  *result = pcVar21;\n  return resultPtr;\ncode_r0x08008270:\n  *pcVar20 = digit + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "renaming": {
                "FUN_080079e8": "format_double_080079e8",
                "param_1": "buffer",
                "param_2": "paramCount",
                "param_3": "mantissa",
                "param_4": "exponent",
                "param_5": "decimalDigits",
                "param_6": "width",
                "param_7": "written",
                "param_8": "overflow",
                "param_9": "result",
                "bVar1": "isInfinity",
                "bVar2": "exponentLessThanMantissa",
                "bVar3": "isNegative",
                "cVar4": "digit",
                "uVar6": "mantissaTemp",
                "iVar7": "digitsCount",
                "pcVar10": "resultPtr",
                "uVar11": "bVar25",
                "uVar12": "roundingDigit",
                "uVar13": "exponentTemp",
                "iVar14": "exponentDiff",
                "iVar15": "digitShift",
                "iVar19": "exponentAdjustment",
                "iVar24": "digitValue",
                "uStack_44": "decimalPoint",
                "bVar25": "isNegative",
                "uVar26": "resultDouble",
                "uVar27": "tempDouble1",
                "uVar28": "tempDouble2",
                "local_80": "mantissaPowerOf5",
                "local_7c": "adjustedExponent",
                "local_74": "log10AdjustedExponent",
                "local_70": "adjustedMantissaDigits",
                "local_68": "totalDigits",
                "local_60": "fractionalDigits",
                "local_5c": "adjustedExponentDifference",
                "local_58": "isExponentPositive",
                "local_48": "roundingDigitIndex",
                "local_38": "numDigitsToFree",
                "local_34": "tempExponent",
                "local_30": "numBits",
                "local_2c": "tempIntArray"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "_Bfree",
                "__floatunsidf",
                "memcpy",
                "quorem",
                "__aeabi_dcmplt",
                "__multiply",
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt",
                "_Balloc",
                "__pow5mult",
                "__i2b",
                "__mcmp",
                "__hi0bits",
                "__aeabi_dcmpeq",
                "__d2b",
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "__aeabi_i2d",
                "__aeabi_d2iz",
                "__subdf3",
                "__mdiff",
                "__multadd",
                "__lshift"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800884c": {
            "entrypoint": "0x0800884c",
            "current_name": "allocate_memory_0800884c",
            "code": "\nundefined4 allocate_memory_0800884c(undefined4 param,int size)\n\n{\n  int malloc_result;\n  int adjusted_address;\n  uint heap_size;\n  \n  lock();\n  heap_size = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  adjusted_address = ((0xfef - size) + heap_size & 0xfffff000) - 0x1000;\n  if (0xfff < adjusted_address) {\n    malloc_result = allocate_from_heap(param,0);\n    if (malloc_result == DAT_20000454 + heap_size) {\n      malloc_result = allocate_from_heap(param,-adjusted_address);\n      if (malloc_result != -1) {\n        DAT_20000a14 = DAT_20000a14 - adjusted_address;\n        *(uint *)(DAT_20000454 + 4) = heap_size - adjusted_address | 1;\n        unlock(param);\n        return 1;\n      }\n      adjusted_address = allocate_from_heap(param,0);\n      if (0xf < adjusted_address - DAT_20000454) {\n        DAT_20000a14 = adjusted_address - DAT_20000854;\n        *(uint *)(DAT_20000454 + 4) = adjusted_address - DAT_20000454 | 1;\n      }\n    }\n  }\n  unlock(param);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800884c": "allocate_memory_0800884c",
                "param_1": "param",
                "param_2": "size",
                "iVar1": "malloc_result",
                "iVar2": "adjusted_address",
                "uVar3": "heap_size",
                "_sbrk_r": "allocate_from_heap",
                "__malloc_lock": "lock",
                "__malloc_unlock": "unlock"
            },
            "calling": [
                "_free_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088ec": {
            "entrypoint": "0x080088ec",
            "current_name": "defragment_memory_080088ec",
            "code": "\nvoid defragmentMemory_080088ec(undefined4 lock,int ptr,undefined4 unknown1,undefined4 unknown2)\n\n{\n  int index;\n  uint *prevBlock;\n  uint *currentBlock;\n  undefined *tempPtr;\n  uint blockSize;\n  uint nextBlockSize;\n  undefined *tempPtr2;\n  undefined *tempPtr3;\n  undefined4 *tempPtr4;\n  int numChunks;\n  uint flag;\n  uint tempSize;\n  \n  if (ptr == 0) {\n    return;\n  }\n  __malloc_lock();\n  flag = *(uint *)(ptr + -4);\n  prevBlock = (uint *)(ptr + -8);\n  blockSize = flag & 0xfffffffe;\n  currentBlock = (uint *)((int)prevBlock + blockSize);\n  nextBlockSize = currentBlock[1] & 0xfffffffc;\n  if (DAT_20000454 == currentBlock) {\n    blockSize = blockSize + nextBlockSize;\n    if ((flag & 1) == 0) {\n      prevBlock = (uint *)((int)prevBlock - *(int *)(ptr + -8));\n      nextBlockSize = prevBlock[2];\n      flag = prevBlock[3];\n      blockSize = blockSize + *(int *)(ptr + -8);\n      *(uint *)(nextBlockSize + 0xc) = flag;\n      *(uint *)(flag + 8) = nextBlockSize;\n    }\n    nextBlockSize = DAT_20000858;\n    prevBlock[1] = blockSize | 1;\n    DAT_20000454 = prevBlock;\n    if (nextBlockSize <= blockSize) {\n      _malloc_trim_r(lock,DAT_20000a44);\n    }\nLAB_080089f0:\n    __malloc_unlock(lock);\n    return;\n  }\n  currentBlock[1] = nextBlockSize;\n  if ((flag & 1) == 0) {\n    prevBlock = (uint *)((int)prevBlock - *(int *)(ptr + -8));\n    tempPtr4 = (undefined4 *)prevBlock[2];\n    blockSize = blockSize + *(int *)(ptr + -8);\n    flag = *(uint *)((int)currentBlock + nextBlockSize + 4) & 1;\n    if ((uint **)tempPtr4 == &DAT_20000454) {\n      if (flag == 0) {\n        flag = currentBlock[2];\n        tempSize = currentBlock[3];\n        blockSize = blockSize + nextBlockSize;\n        *(uint *)(flag + 0xc) = tempSize;\n        *(uint *)(tempSize + 8) = flag;\n        prevBlock[1] = blockSize | 1;\n        *(uint *)((int)prevBlock + blockSize) = blockSize;\n      }\n      else {\n        prevBlock[1] = blockSize | 1;\n        *currentBlock = blockSize;\n      }\n      goto LAB_080089f0;\n    }\n    tempSize = prevBlock[3];\n    tempPtr4[3] = tempSize;\n    *(undefined4 **)(tempSize + 8) = tempPtr4;\n  }\n  else {\n    flag = *(uint *)((int)currentBlock + nextBlockSize + 4) & 1;\n  }\n  if (flag == 0) {\n    tempPtr4 = (undefined4 *)currentBlock[2];\n    blockSize = blockSize + nextBlockSize;\n    if ((uint **)tempPtr4 == &DAT_20000454) {\n      DAT_2000045c = prevBlock;\n      DAT_20000460 = prevBlock;\n      prevBlock[2] = (uint)&DAT_20000454;\n      prevBlock[3] = (uint)&DAT_20000454;\n      prevBlock[1] = blockSize | 1;\n      *(uint *)((int)prevBlock + blockSize) = blockSize;\n      goto LAB_080089f0;\n    }\n    nextBlockSize = currentBlock[3];\n    tempPtr4[3] = nextBlockSize;\n    *(undefined4 **)(nextBlockSize + 8) = tempPtr4;\n    prevBlock[1] = blockSize | 1;\n    *(uint *)((int)prevBlock + blockSize) = blockSize;\n  }\n  else {\n    prevBlock[1] = blockSize | 1;\n    *(uint *)((int)prevBlock + blockSize) = blockSize;\n  }\n  if (blockSize < 0x200) {\n    numChunks = (blockSize >> 3) + 1;\n    blockSize = 1 << ((int)(blockSize >> 3) >> 2 & 0xffU) | (uint)DAT_20000450;\n    nextBlockSize = *(uint *)(&DAT_2000044c + numChunks * 8);\n    prevBlock[2] = nextBlockSize;\n    prevBlock[3] = (uint)(&DAT_20000444 + numChunks * 8);\n    DAT_20000450 = (undefined *)blockSize;\n    *(uint **)(&DAT_2000044c + numChunks * 8) = prevBlock;\n    *(uint **)(nextBlockSize + 0xc) = prevBlock;\n    __malloc_unlock(lock,prevBlock,blockSize,unknown2);\n    return;\n  }\n  nextBlockSize = blockSize >> 9;\n  if (nextBlockSize < 5) {\n    numChunks = ((blockSize >> 6) + 0x39) * 8;\n    index = (blockSize >> 6) + 0x38;\n  }\n  else if (nextBlockSize < 0x15) {\n    numChunks = (nextBlockSize + 0x5c) * 8;\n    index = nextBlockSize + 0x5b;\n  }\n  else if (nextBlockSize < 0x55) {\n    numChunks = ((blockSize >> 0xc) + 0x6f) * 8;\n    index = (blockSize >> 0xc) + 0x6e;\n  }\n  else if (nextBlockSize < 0x155) {\n    numChunks = ((blockSize >> 0xf) + 0x78) * 8;\n    index = (blockSize >> 0xf) + 0x77;\n  }\n  else if (nextBlockSize < 0x555) {\n    numChunks = ((blockSize >> 0x12) + 0x7d) * 8;\n    index = (blockSize >> 0x12) + 0x7c;\n  }\n  else {\n    numChunks = 0x3f8;\n    index = 0x7e;\n  }\n  tempPtr = *(undefined **)(&DAT_2000044c + numChunks);\n  tempPtr2 = &DAT_20000444 + numChunks;\n  if (tempPtr2 == tempPtr) {\n    tempPtr = (undefined *)(1 << (index >> 2 & 0xffU) | (uint)DAT_20000450);\n    tempPtr3 = tempPtr2;\n    DAT_20000450 = tempPtr;\n  }\n  else {\n    do {\n      tempPtr3 = tempPtr;\n      if ((*(uint *)(tempPtr + 4) & 0xfffffffc) <= blockSize) break;\n      tempPtr = *(undefined **)(tempPtr + 8);\n      tempPtr3 = tempPtr2;\n    } while (tempPtr2 != tempPtr);\n    tempPtr2 = *(undefined **)(tempPtr3 + 0xc);\n  }\n  prevBlock[2] = (uint)tempPtr3;\n  prevBlock[3] = (uint)tempPtr2;\n  *(uint **)(tempPtr2 + 8) = prevBlock;\n  *(uint **)(tempPtr3 + 0xc) = prevBlock;\n  __malloc_unlock(lock,prevBlock,tempPtr,unknown2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088ec": "defragment_memory_080088ec",
                "param_1": "lock",
                "param_2": "ptr",
                "param_3": "unknown1",
                "param_4": "unknown2",
                "iVar1": "index",
                "puVar2": "prevBlock",
                "puVar3": "currentBlock",
                "puVar4": "tempPtr",
                "uVar5": "blockSize",
                "uVar6": "nextBlockSize",
                "puVar7": "tempPtr2",
                "puVar8": "tempPtr3",
                "puVar9": "tempPtr4",
                "iVar10": "numChunks",
                "uVar11": "flag",
                "uVar12": "tempSize"
            },
            "calling": [
                "_malloc_r",
                "__ssprint_r",
                "_svfprintf_r",
                "_realloc_r"
            ],
            "called": [
                "_malloc_trim_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ad4": {
            "entrypoint": "0x08008ad4",
            "current_name": "get_initialized_value_08008ad4",
            "code": "\nint get_initialized_value_08008ad4(void)\n\n{\n  int initialized_value;\n  \n  initialized_value = *(int *)(DAT_2000001c + 0x34);\n  if (initialized_value == 0) {\n    initialized_value = 0x2000085c;\n  }\n  return initialized_value + 0xf0;\n}\n\n",
            "renaming": {
                "FUN_08008ad4": "get_initialized_value_08008ad4",
                "iVar1": "initialized_value"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "FUNC_08008af0",
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_lock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af4": {
            "entrypoint": "0x08008af4",
            "current_name": "FUNC_08008af4",
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af8": {
            "entrypoint": "0x08008af8",
            "current_name": "allocate_memory_08008af8",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocateMemory_08008af8(undefined4 *lock,uint size)\n\n{\n  undefined *ptr;\n  uint flag;\n  uint temp;\n  int index;\n  undefined *block;\n  uint num;\n  uint limit;\n  undefined4 *current;\n  undefined *next;\n  undefined *base;\n  int *result;\n  uint adjustedSize;\n  uint alignedSize;\n  int prevIndex;\n  undefined4 *newPtr;\n  undefined4 *list;\n  \n  adjustedSize = size + 0xb;\n  if (adjustedSize < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    __malloc_lock();\n    alignedSize = 0x10;\n    index = 0x18;\n    adjustedSize = 2;\nLAB_08008b18:\n    base = *(undefined **)((int)&DAT_20000450 + index);\n    if ((base != &DAT_20000444 + index) ||\n       (base = *(undefined **)((int)&DAT_20000458 + index), &DAT_2000044c + index != base)) {\n      index = *(int *)(base + 0xc);\n      block = base + (*(uint *)(base + 4) & 0xfffffffc);\n      adjustedSize = *(uint *)(block + 4);\nLAB_08008b34:\n      prevIndex = *(int *)(base + 8);\n      *(int *)(prevIndex + 0xc) = index;\n      *(int *)(index + 8) = prevIndex;\n      *(uint *)(block + 4) = adjustedSize | 1;\n      __malloc_unlock(lock);\n      return (int *)(base + 8);\n    }\n    adjustedSize = adjustedSize + 2;\n  }\n  else {\n    alignedSize = adjustedSize & 0xfffffff8;\n    if (((int)alignedSize < 0) || (alignedSize < size)) {\nLAB_08008c7a:\n      *lock = 0xc;\n      return (int *)0x0;\n    }\n    __malloc_lock();\n    if (alignedSize < 0x1f8) {\n      adjustedSize = adjustedSize >> 3;\n      index = alignedSize + 8;\n      goto LAB_08008b18;\n    }\n    flag = adjustedSize >> 9;\n    if (flag == 0) {\n      index = 0x200;\n      num = 0x40;\n      flag = 0x3f;\n    }\n    else if (flag < 5) {\n      num = (adjustedSize >> 6) + 0x39;\n      flag = (adjustedSize >> 6) + 0x38;\n      index = num * 8;\n    }\n    else if (flag < 0x15) {\n      num = flag + 0x5c;\n      flag = flag + 0x5b;\n      index = num * 8;\n    }\n    else if (flag < 0x55) {\n      num = (adjustedSize >> 0xc) + 0x6f;\n      flag = (adjustedSize >> 0xc) + 0x6e;\n      index = num * 8;\n    }\n    else if (flag < 0x155) {\n      num = (adjustedSize >> 0xf) + 0x78;\n      flag = (adjustedSize >> 0xf) + 0x77;\n      index = num * 8;\n    }\n    else if (flag < 0x555) {\n      num = (adjustedSize >> 0x12) + 0x7d;\n      flag = (adjustedSize >> 0x12) + 0x7c;\n      index = num * 8;\n    }\n    else {\n      index = 0x3f8;\n      num = 0x7f;\n      flag = 0x7e;\n    }\n    for (base = *(undefined **)((int)&DAT_20000450 + index); adjustedSize = num,\n        &DAT_20000444 + index != base; base = *(undefined **)(base + 0xc)) {\n      prevIndex = (*(uint *)(base + 4) & 0xfffffffc) - alignedSize;\n      adjustedSize = flag;\n      if (0xf < prevIndex) break;\n      if (-1 < prevIndex) {\n        block = base + (*(uint *)(base + 4) & 0xfffffffc);\n        adjustedSize = *(uint *)(block + 4);\n        index = *(int *)(base + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  newPtr = DAT_2000045c;\n  if ((undefined **)DAT_2000045c == &DAT_20000454) {\n    num = 1 << ((int)adjustedSize >> 2 & 0xffU);\n    flag = DAT_20000450;\n    if (num <= DAT_20000450) goto LAB_08008c06;\n  }\n  else {\n    num = DAT_2000045c[1];\n    limit = num & 0xfffffffc;\n    flag = limit - alignedSize;\n    if (0xf < (int)flag) {\n      list = (undefined4 *)(alignedSize + (int)DAT_2000045c);\n      DAT_2000045c[1] = alignedSize | 1;\n      DAT_2000045c = list;\n      DAT_20000460 = list;\n      list[2] = &DAT_20000454;\n      list[3] = &DAT_20000454;\n      list[1] = flag | 1;\n      *(uint *)((int)newPtr + limit) = flag;\n      __malloc_unlock(lock);\n      return newPtr + 2;\n    }\n    DAT_2000045c = &DAT_20000454;\n    DAT_20000460 = &DAT_20000454;\n    if (-1 < (int)flag) {\n      *(uint *)((int)newPtr + limit + 4) = *(uint *)((int)newPtr + limit + 4) | 1;\n      __malloc_unlock(lock);\n      return newPtr + 2;\n    }\n    if (limit < 0x200) {\n      index = (num >> 3) + 1;\n      prevIndex = *(int *)(&DAT_2000044c + index * 8);\n      flag = 1 << ((int)(num >> 3) >> 2 & 0xffU) | DAT_20000450;\n      newPtr[2] = prevIndex;\n      newPtr[3] = &DAT_20000444 + index * 8;\n      DAT_20000450 = flag;\n      *(undefined4 **)(&DAT_2000044c + index * 8) = newPtr;\n      *(undefined4 **)(prevIndex + 0xc) = newPtr;\n    }\n    else {\n      flag = num >> 9;\n      if (flag < 5) {\n        index = ((num >> 6) + 0x39) * 8;\n        prevIndex = (num >> 6) + 0x38;\n      }\n      else if (flag < 0x15) {\n        index = (flag + 0x5c) * 8;\n        prevIndex = flag + 0x5b;\n      }\n      else if (flag < 0x55) {\n        index = ((num >> 0xc) + 0x6f) * 8;\n        prevIndex = (num >> 0xc) + 0x6e;\n      }\n      else if (flag < 0x155) {\n        index = ((num >> 0xf) + 0x78) * 8;\n        prevIndex = (num >> 0xf) + 0x77;\n      }\n      else if (flag < 0x555) {\n        index = ((num >> 0x12) + 0x7d) * 8;\n        prevIndex = (num >> 0x12) + 0x7c;\n      }\n      else {\n        index = 0x3f8;\n        prevIndex = 0x7e;\n      }\n      base = *(undefined **)(&DAT_2000044c + index);\n      block = &DAT_20000444 + index;\n      if (block == base) {\n        DAT_20000450 = 1 << (prevIndex >> 2 & 0xffU) | DAT_20000450;\n      }\n      else {\n        do {\n          if ((*(uint *)(base + 4) & 0xfffffffc) <= limit) break;\n          base = *(undefined **)(base + 8);\n        } while (block != base);\n        block = *(undefined **)(base + 0xc);\n      }\n      flag = DAT_20000450;\n      newPtr[2] = base;\n      newPtr[3] = block;\n      *(undefined4 **)(block + 8) = newPtr;\n      *(undefined4 **)(base + 0xc) = newPtr;\n    }\n    num = 1 << ((int)adjustedSize >> 2 & 0xffU);\n    if (num <= flag) {\nLAB_08008c06:\n      if ((num & flag) == 0) {\n        adjustedSize = adjustedSize & 0xfffffffc;\n        do {\n          num = num << 1;\n          adjustedSize = adjustedSize + 4;\n        } while ((num & flag) == 0);\n      }\n      do {\n        list = (undefined4 *)(&DAT_2000044c + adjustedSize * 8);\n        flag = adjustedSize;\n        newPtr = list;\n        do {\n          for (current = (undefined4 *)newPtr[3]; newPtr != current;\n              current = (undefined4 *)current[3]) {\n            limit = current[1] & 0xfffffffc;\n            temp = limit - alignedSize;\n            if (0xf < (int)temp) {\n              prevIndex = current[2];\n              index = current[3];\n              newPtr = (undefined4 *)(alignedSize + (int)current);\n              current[1] = alignedSize | 1;\n              *(int *)(prevIndex + 0xc) = index;\n              *(int *)(index + 8) = prevIndex;\n              DAT_2000045c = newPtr;\n              DAT_20000460 = newPtr;\n              newPtr[2] = &DAT_20000454;\n              newPtr[3] = &DAT_20000454;\n              newPtr[1] = temp | 1;\n              *(uint *)((int)current + limit) = temp;\n              __malloc_unlock(lock);\n              return current + 2;\n            }\n            if (-1 < (int)temp) {\n              index = current[3];\n              prevIndex = current[2];\n              *(uint *)((int)current + limit + 4) = *(uint *)((int)current + limit + 4) | 1;\n              *(int *)(prevIndex + 0xc) = index;\n              *(int *)(index + 8) = prevIndex;\n              __malloc_unlock(lock);\n              return current + 2;\n            }\n          }\n          flag = flag + 1;\n          newPtr = newPtr + 2;\n        } while ((flag & 3) != 0);\n        do {\n          limit = adjustedSize & 3;\n          newPtr = list + -2;\n          adjustedSize = adjustedSize - 1;\n          if (limit == 0) {\n            DAT_20000450 = DAT_20000450 & ~num;\n            break;\n          }\n          list = (undefined4 *)*list;\n        } while (list == newPtr);\n        num = num * 2;\n        if ((DAT_20000450 <= num && num - DAT_20000450 != 0) || (adjustedSize = flag, num == 0))\n        break;\n        for (; (num & DAT_20000450) == 0; num = num << 1) {\n          adjustedSize = adjustedSize + 4;\n        }\n      } while( true );\n    }\n  }\n  base = DAT_20000454;\n  adjustedSize = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  if ((alignedSize <= adjustedSize) && (flag = adjustedSize - alignedSize, 0xf < (int)flag)) goto LAB_08008dac;\n  if (DAT_20000854 == (undefined *)0xffffffff) {\n    flag = alignedSize + DAT_20000a44 + 0x10;\n  }\n  else {\n    flag = alignedSize + DAT_20000a44 + 0x100f & 0xfffff000;\n  }\n  block = (undefined *)_sbrk_r(lock,flag);\n  if (block == (undefined *)0xffffffff) {\nLAB_08008ed8:\n    adjustedSize = *(uint *)(DAT_20000454 + 4);\n  }\n  else {\n    ptr = base + adjustedSize;\n    if (ptr < block || ptr == block) {\n      next = DAT_20000a14 + flag;\n      if ((ptr != block) || (((uint)ptr & 0xfff) != 0)) goto LAB_08008d02;\n      DAT_20000a14 = next;\n      *(uint *)(DAT_20000454 + 4) = adjustedSize + flag | 1;\n    }\n    else {\n      if (base != &DAT_2000044c) goto LAB_08008ed8;\nLAB_08008d02:\n      DAT_20000a14 = DAT_20000a14 + flag;\n      next = block;\n      if (DAT_20000854 != (undefined *)0xffffffff) {\n        DAT_20000a14 = DAT_20000a14 + ((int)block - (int)ptr);\n        next = DAT_20000854;\n      }\n      DAT_20000854 = next;\n      num = (uint)block & 7;\n      if (num == 0) {\n        index = 0x1000;\n      }\n      else {\n        block = block + (8 - num);\n        index = 0x1008 - num;\n      }\n      index = index - ((uint)(block + flag) & 0xfff);\n      prevIndex = _sbrk_r(lock,index);\n      if (prevIndex == -1) {\n        flag = 1;\n        index = 0;\n      }\n      else {\n        flag = (prevIndex - (int)block) + index | 1;\n      }\n      next = DAT_20000a14 + index;\n      DAT_20000454 = block;\n      DAT_20000a14 = next;\n      *(uint *)(block + 4) = flag;\n      if (base != &DAT_2000044c) {\n        if (adjustedSize < 0x10) {\n          *(undefined4 *)(block + 4) = 1;\n          goto LAB_08008eee;\n        }\n        adjustedSize = adjustedSize - 0xc & 0xfffffff8;\n        *(uint *)(base + 4) = *(uint *)(base + 4) & 1 | adjustedSize;\n        *(undefined4 *)(base + adjustedSize + 4) = 5;\n        *(undefined4 *)(base + adjustedSize + 8) = 5;\n        if (0xf < adjustedSize) {\n          _free_r(lock,base + 8);\n          next = DAT_20000a14;\n        }\n      }\n    }\n    if (DAT_20000a3c < next) {\n      DAT_20000a3c = next;\n    }\n    adjustedSize = *(uint *)(DAT_20000454 + 4);\n    if (DAT_20000a40 < next) {\n      DAT_20000a40 = next;\n    }\n  }\n  flag = (adjustedSize & 0xfffffffc) - alignedSize;\n  if ((alignedSize <= (adjustedSize & 0xfffffffc)) && (0xf < (int)flag)) {\nLAB_08008dac:\n    base = DAT_20000454 + alignedSize;\n    *(uint *)(DAT_20000454 + 4) = alignedSize | 1;\n    result = (int *)(DAT_20000454 + 8);\n    DAT_20000454 = base;\n    *(uint *)(base + 4) = flag | 1;\n    __malloc_unlock(lock);\n    return result;\n  }\nLAB_08008eee:\n  __malloc_unlock(lock);\n  return (int *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08008af8": "allocate_memory_08008af8",
                "param_1": "lock",
                "param_2": "size",
                "puVar1": "ptr",
                "uVar2": "flag",
                "uVar3": "temp",
                "iVar4": "index",
                "puVar5": "block",
                "uVar6": "num",
                "uVar7": "limit",
                "puVar8": "current",
                "puVar9": "next",
                "puVar10": "base",
                "piVar11": "result",
                "uVar12": "adjustedSize",
                "uVar13": "alignedSize",
                "iVar14": "prevIndex",
                "puVar15": "newPtr",
                "puVar16": "list"
            },
            "calling": [
                "_calloc_r",
                "__ssprint_r",
                "_svfprintf_r",
                "_realloc_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "_free_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800901c": {
            "entrypoint": "0x0800901c",
            "current_name": "find_byte_sequence_0800901c",
            "code": "\nuint * find_byte_sequence_0800901c(uint *sequence,uint byte,uint length)\n\n{\n  uint temp;\n  uint masked_byte;\n  uint *current_ptr;\n  uint masked_lower_byte;\n  bool is_end;\n  \n  masked_lower_byte = byte & 0xff;\n  if (((uint)sequence & 3) == 0) {\nstart_loop:\n    if (3 < length) {\n      masked_byte = (byte & 0xff) << 8 | masked_lower_byte;\n      current_ptr = sequence;\n      do {\n        temp = *current_ptr ^ (masked_byte | masked_byte << 0x10);\n        sequence = current_ptr + 1;\n        if ((temp + 0xfefefeff & ~temp & 0x80808080) != 0) goto check_next_byte;\n        length = length - 4;\n        current_ptr = sequence;\n      } while (3 < length);\n    }\n    current_ptr = sequence;\n    if (length == 0) {\n      sequence = (uint *)0x0;\n    }\n    else {\ncheck_next_byte:\n      sequence = current_ptr;\n      if (*(search_byte *)sequence != masked_lower_byte) {\n        current_ptr = (uint *)(length + (int)sequence);\n        do {\n          sequence = (uint *)((int)sequence + 1);\n          if (current_ptr == sequence) goto not_found;\n        } while (*(search_byte *)sequence != masked_lower_byte);\n      }\n    }\n  }\n  else {\n    masked_byte = length - 1;\n    if (length == 0) {\nnot_found:\n      sequence = (uint *)0x0;\n    }\n    else if (*(search_byte *)sequence != masked_lower_byte) {\n      current_ptr = (uint *)((int)sequence + 1);\n      do {\n        sequence = current_ptr;\n        length = masked_byte;\n        if (((uint)sequence & 3) == 0) goto start_loop;\n        is_end = masked_byte == 0;\n        masked_byte = masked_byte - 1;\n        if (is_end) goto not_found;\n        current_ptr = (uint *)((int)sequence + 1);\n      } while (*(search_byte *)sequence != masked_lower_byte);\n    }\n  }\n  return sequence;\n}\n\n",
            "renaming": {
                "FUN_0800901c": "find_byte_sequence_0800901c",
                "param_1": "sequence",
                "param_2": "byte",
                "param_3": "length",
                "uVar1": "temp",
                "uVar2": "masked_byte",
                "puVar3": "current_ptr",
                "uVar4": "masked_lower_byte",
                "bVar5": "is_end",
                "LAB_0800904a": "start_loop",
                "LAB_08009050": "check_next_byte",
                "LAB_0800906c": "not_found",
                "byte": "search_byte"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090a8": {
            "entrypoint": "0x080090a8",
            "current_name": "acquire_recursive_lock_080090a8",
            "code": "\nvoid acquire_recursive_lock_080090a8(void)\n\n{\n  acquire_recursive_lock_080090a8(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090a8": "acquire_recursive_lock_080090a8",
                "__retarget_lock_acquire_recursive": "acquire_recursive_lock"
            },
            "calling": [
                "_malloc_trim_r",
                "_malloc_r",
                "_free_r",
                "_realloc_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "release_recursive_lock_080090b4",
            "code": "\nvoid releaseRecursiveLock_080090b4(void)\n\n{\n  __retarget_lock_release_recursive(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "release_recursive_lock_080090b4"
            },
            "calling": [
                "_malloc_trim_r",
                "_malloc_r",
                "_realloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c0": {
            "entrypoint": "0x080090c0",
            "current_name": "allocate_or_retrieve_value_080090c0",
            "code": "\nundefined4 * allocateOrRetrieveValue_080090c0(int paramPtr,uint index)\n\n{\n  undefined4 *valuePtr;\n  int dataArrayPtr;\n  \n  dataArrayPtr = *(int *)(paramPtr + 0x4c);\n  if (dataArrayPtr == 0) {\n    dataArrayPtr = _calloc_r(paramPtr,4,0x21);\n    *(int *)(paramPtr + 0x4c) = dataArrayPtr;\n    if (dataArrayPtr == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  valuePtr = *(undefined4 **)(dataArrayPtr + index * 4);\n  if (valuePtr == (undefined4 *)0x0) {\n    dataArrayPtr = 1 << (index & 0xff);\n    valuePtr = (undefined4 *)_calloc_r(paramPtr,1,(dataArrayPtr + 5) * 4);\n    if (valuePtr == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    valuePtr[1] = index;\n    valuePtr[2] = dataArrayPtr;\n  }\n  else {\n    *(undefined4 *)(dataArrayPtr + index * 4) = *valuePtr;\n  }\n  valuePtr[3] = 0;\n  valuePtr[4] = 0;\n  return valuePtr;\n}\n\n",
            "renaming": {
                "FUN_080090c0": "allocate_or_retrieve_value_080090c0",
                "param_1": "paramPtr",
                "param_2": "index",
                "puVar1": "valuePtr",
                "iVar2": "dataArrayPtr"
            },
            "calling": [
                "__d2b",
                "_dtoa_r",
                "__multiply",
                "__i2b",
                "__mdiff",
                "__pow5mult",
                "__multadd",
                "__lshift"
            ],
            "called": [
                "_calloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800910c": {
            "entrypoint": "0x0800910c",
            "current_name": "copy_value_and_set_pointer_0800910c",
            "code": "\nvoid copyValueAndSetPointer_0800910c(int originalPointer,undefined4 *newPointer)\n\n{\n  int baseAddress;\n  \n  if (newPointer != (undefined4 *)0x0) {\n    baseAddress = *(int *)(originalPointer + 0x4c);\n    *newPointer = *(undefined4 *)(baseAddress + newPointer[1] * 4);\n    *(undefined4 **)(baseAddress + newPointer[1] * 4) = newPointer;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800910c": "copy_value_and_set_pointer_0800910c",
                "param_1": "originalPointer",
                "param_2": "newPointer",
                "iVar1": "baseAddress"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009120": {
            "entrypoint": "0x08009120",
            "current_name": "calculate_checksum_08009120",
            "code": "\nundefined4 * calculateChecksum_08009120(int param1,undefined4 *array,int multiplier,uint checksum)\n\n{\n  undefined4 *result;\n  uint temp;\n  int arrayLength;\n  uint *currentElement;\n  int index;\n  \n  index = 0;\n  arrayLength = array[4];\n  currentElement = array + 5;\n  do {\n    index = index + 1;\n    checksum = multiplier * (*currentElement & 0xffff) + checksum;\n    temp = multiplier * (*currentElement >> 0x10) + (checksum >> 0x10);\n    *currentElement = (checksum & 0xffff) + temp * 0x10000;\n    checksum = temp >> 0x10;\n    currentElement = currentElement + 1;\n  } while (index < arrayLength);\n  result = array;\n  if (checksum != 0) {\n    if ((int)array[2] <= arrayLength) {\n      result = (undefined4 *)_Balloc(param1,array[1] + 1);\n      memcpy(result + 3,array + 3,(array[4] + 2) * 4);\n      index = *(int *)(param1 + 0x4c);\n      *array = *(undefined4 *)(index + array[1] * 4);\n      *(undefined4 **)(index + array[1] * 4) = array;\n    }\n    result[arrayLength + 5] = checksum;\n    result[4] = arrayLength + 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009120": "calculate_checksum_08009120",
                "param_1": "param1",
                "param_2": "array",
                "param_3": "multiplier",
                "param_4": "checksum",
                "puVar1": "result",
                "uVar2": "temp",
                "iVar3": "arrayLength",
                "puVar4": "currentElement",
                "iVar5": "index"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "memcpy",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a4": {
            "entrypoint": "0x080091a4",
            "current_name": "count_leading_zeros_080091a4",
            "code": "\nint countLeadingZeros_080091a4(uint input)\n\n{\n  int leadingZeros;\n  \n  if ((input & 0xffff0000) == 0) {\n    input = input << 0x10;\n    leadingZeros = 0x10;\n  }\n  else {\n    leadingZeros = 0;\n  }\n  if ((input & 0xff000000) == 0) {\n    input = input << 8;\n    leadingZeros = leadingZeros + 8;\n  }\n  if ((input & 0xf0000000) == 0) {\n    input = input << 4;\n    leadingZeros = leadingZeros + 4;\n  }\n  if ((input & 0xc0000000) == 0) {\n    input = input << 2;\n    leadingZeros = leadingZeros + 2;\n  }\n  if (-1 < (int)input) {\n    if ((int)(input << 1) < 0) {\n      return leadingZeros + 1;\n    }\n    leadingZeros = 0x20;\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_080091a4": "count_leading_zeros_080091a4",
                "param_1": "input",
                "iVar1": "leadingZeros"
            },
            "calling": [
                "__d2b",
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091e4": {
            "entrypoint": "0x080091e4",
            "current_name": "count_leading_zeros_080091e4",
            "code": "\nint countLeadingZeros_080091e4(uint *value)\n\n{\n  int leadingZeros;\n  uint temp;\n  \n  temp = *value;\n  if ((temp & 7) == 0) {\n    if ((temp & 0xffff) == 0) {\n      temp = temp >> 0x10;\n      leadingZeros = 0x10;\n    }\n    else {\n      leadingZeros = 0;\n    }\n    if ((temp & 0xff) == 0) {\n      temp = temp >> 8;\n      leadingZeros = leadingZeros + 8;\n    }\n    if ((temp & 0xf) == 0) {\n      temp = temp >> 4;\n      leadingZeros = leadingZeros + 4;\n    }\n    if ((temp & 3) == 0) {\n      temp = temp >> 2;\n      leadingZeros = leadingZeros + 2;\n    }\n    if (-1 < (int)(temp << 0x1f)) {\n      temp = temp >> 1;\n      if (temp == 0) {\n        return 0x20;\n      }\n      leadingZeros = leadingZeros + 1;\n    }\n    *value = temp;\n    return leadingZeros;\n  }\n  if ((int)(temp << 0x1f) < 0) {\n    return 0;\n  }\n  if (-1 < (int)(temp << 0x1e)) {\n    *value = temp >> 2;\n    return 2;\n  }\n  *value = temp >> 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080091e4": "count_leading_zeros_080091e4",
                "param_1": "value",
                "iVar1": "leadingZeros",
                "uVar2": "temp"
            },
            "calling": [
                "__d2b"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009244": {
            "entrypoint": "0x08009244",
            "current_name": "initialize_buffer_08009244",
            "code": "\nvoid initializeBuffer_08009244(undefined4 bufferSize,undefined4 data)\n\n{\n  int buffer;\n  \n  buffer = allocateBuffer(bufferSize,1);\n  *(undefined4 *)(buffer + 0x10) = 1;\n  *(undefined4 *)(buffer + 0x14) = data;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009244": "initialize_buffer_08009244",
                "param_1": "bufferSize",
                "param_2": "data",
                "iVar1": "buffer",
                "_Balloc": "allocateBuffer"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009258": {
            "entrypoint": "0x08009258",
            "current_name": "calculate_checksum_08009258",
            "code": "\nvoid calculateChecksum_08009258(undefined4 result,int array1,int array2)\n\n{\n  uint *tempPtr1;\n  uint *tempPtr2;\n  int array2Size;\n  uint tempVar;\n  uint *tempPtr3;\n  uint tempVar2;\n  uint *tempPtr4;\n  uint tempVar3;\n  int minSize;\n  int maxSize;\n  uint tempVar4;\n  int array1Size;\n  int tempVar5;\n  uint *tempPtr5;\n  uint *tempPtr6;\n  uint *tempPtr7;\n  uint *tempPtr8;\n  uint *tempPtr9;\n  \n  array1Size = *(int *)(array1 + 0x10);\n  minSize = *(int *)(array2 + 0x10);\n  maxSize = minSize;\n  tempVar5 = array1;\n  if (array1Size < minSize) {\n    maxSize = array1Size;\n    array1Size = minSize;\n    tempVar5 = array2;\n    array2 = array1;\n  }\n  minSize = array1Size + maxSize;\n  array2Size = *(int *)(tempVar5 + 4);\n  if (*(int *)(tempVar5 + 8) < minSize) {\n    array2Size = array2Size + 1;\n  }\n  array2Size = _Balloc(result,array2Size);\n  tempPtr9 = (uint *)(array2Size + 0x14);\n  tempPtr8 = tempPtr9 + minSize;\n  for (tempPtr3 = tempPtr9; tempPtr3 < tempPtr8; tempPtr3 = tempPtr3 + 1) {\n    *tempPtr3 = 0;\n  }\n  tempVar2 = array2 + 0x14;\n  tempVar4 = tempVar2 + maxSize * 4;\n  tempPtr3 = (uint *)(tempVar5 + 0x14);\n  if (tempVar2 < tempVar4) {\n    tempPtr4 = (uint *)(tempVar2 + ((tempVar4 - array2) - 0x15 & 0xfffffffc));\n    tempPtr7 = (uint *)(array2 + 0x10);\n    do {\n      while( true ) {\n        tempPtr7 = tempPtr7 + 1;\n        tempVar2 = *tempPtr7 & 0xffff;\n        if (tempVar2 != 0) break;\n        tempVar2 = *tempPtr7 >> 0x10;\n        if (tempVar2 == 0) goto LAB_080092d2;\nLAB_0800932c:\n        tempVar3 = *tempPtr9;\n        tempVar = 0;\n        tempPtr1 = tempPtr3;\n        tempPtr5 = tempPtr9;\n        tempVar4 = tempVar3;\n        do {\n          tempPtr6 = tempPtr5;\n          tempVar = tempVar + tempVar2 * *(ushort *)tempPtr1 + (tempVar4 >> 0x10);\n          *tempPtr6 = tempVar3 & 0xffff | tempVar * 0x10000;\n          tempPtr2 = tempPtr1 + 1;\n          tempVar4 = tempPtr6[1];\n          tempVar3 = tempVar2 * (*tempPtr1 >> 0x10) + (tempVar4 & 0xffff) + (tempVar >> 0x10);\n          tempVar = tempVar3 >> 0x10;\n          tempPtr1 = tempPtr2;\n          tempPtr5 = tempPtr6 + 1;\n        } while (tempPtr2 < tempPtr3 + array1Size);\n        tempPtr6[1] = tempVar3;\n        tempPtr9 = tempPtr9 + 1;\n        if (tempPtr4 == tempPtr7) goto LAB_0800937a;\n      }\n      tempVar4 = 0;\n      tempPtr1 = tempPtr9;\n      tempPtr5 = tempPtr3;\n      do {\n        tempPtr2 = tempPtr1;\n        tempPtr6 = tempPtr5 + 1;\n        tempVar3 = tempVar2 * (*tempPtr5 & 0xffff) + (*tempPtr2 & 0xffff) + tempVar4;\n        tempVar = tempVar2 * (*tempPtr5 >> 0x10) + (*tempPtr2 >> 0x10) + (tempVar3 >> 0x10);\n        tempVar4 = tempVar >> 0x10;\n        *tempPtr2 = tempVar3 & 0xffff | tempVar * 0x10000;\n        tempPtr1 = tempPtr2 + 1;\n        tempPtr5 = tempPtr6;\n      } while (tempPtr6 < tempPtr3 + array1Size);\n      tempPtr2[1] = tempVar4;\n      tempVar2 = *tempPtr7 >> 0x10;\n      if (tempVar2 != 0) goto LAB_0800932c;\nLAB_080092d2:\n      tempPtr9 = tempPtr9 + 1;\n    } while (tempPtr4 != tempPtr7);\n  }\nLAB_0800937a:\n  if (0 < minSize) {\n    tempVar2 = tempPtr8[-1];\n    tempPtr8 = tempPtr8 + -1;\n    while ((tempVar2 == 0 && (minSize = minSize + -1, minSize != 0))) {\n      tempPtr8 = tempPtr8 + -1;\n      tempVar2 = *tempPtr8;\n    }\n  }\n  *(int *)(array2Size + 0x10) = minSize;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009258": "calculate_checksum_08009258",
                "param_1": "result",
                "param_2": "array1",
                "param_3": "array2",
                "puVar1": "tempPtr1",
                "puVar2": "tempPtr2",
                "iVar3": "array2Size",
                "uVar4": "tempVar",
                "puVar5": "tempPtr3",
                "uVar6": "tempVar2",
                "puVar7": "tempPtr4",
                "uVar8": "tempVar3",
                "iVar9": "minSize",
                "iVar10": "maxSize",
                "uVar11": "tempVar4",
                "iVar12": "array1Size",
                "iVar13": "tempVar5",
                "puVar14": "tempPtr5",
                "puVar15": "tempPtr6",
                "puVar16": "tempPtr7",
                "puVar17": "tempPtr8",
                "puVar18": "tempPtr9"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080093a4": {
            "entrypoint": "0x080093a4",
            "current_name": "calculate_product_080093a4",
            "code": "\nundefined4 * calculateProduct_080093a4(int num1,undefined4 *result,uint num2)\n\n{\n  int index;\n  int num2_div_4;\n  undefined4 *ptr1;\n  undefined4 *ptr2;\n  \n  if ((num2 & 3) != 0) {\n    result = (undefined4 *)\n              __multadd(num1,result,*(undefined4 *)(&DAT_0800a070 + ((num2 & 3) - 1) * 4),0);\n  }\n  num2_div_4 = (int)num2 >> 2;\n  if (num2_div_4 != 0) {\n    ptr2 = *(undefined4 **)(num1 + 0x48);\n    if (ptr2 == (undefined4 *)0x0) {\n      ptr2 = (undefined4 *)_Balloc(num1,1);\n      ptr2[4] = 1;\n      ptr2[5] = 0x271;\n      *(undefined4 **)(num1 + 0x48) = ptr2;\n      *ptr2 = 0;\n    }\n    ptr1 = result;\n    if (num2_div_4 << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    num2_div_4 = num2_div_4 >> 1;\n    ptr1 = ptr2;\n    if (num2_div_4 != 0) {\n      while( true ) {\n        ptr2 = (undefined4 *)*ptr1;\n        if (ptr2 == (undefined4 *)0x0) {\n          ptr2 = (undefined4 *)__multiply(num1,ptr1,ptr1);\n          *ptr1 = ptr2;\n          *ptr2 = 0;\n        }\n        ptr1 = result;\n        if (-1 < num2_div_4 << 0x1f) break;\nLAB_080093d2:\n        result = (undefined4 *)__multiply(num1,ptr1,ptr2);\n        if (ptr1 == (undefined4 *)0x0) break;\n        index = *(int *)(num1 + 0x4c);\n        num2_div_4 = num2_div_4 >> 1;\n        *ptr1 = *(undefined4 *)(index + ptr1[1] * 4);\n        *(undefined4 **)(index + ptr1[1] * 4) = ptr1;\n        ptr1 = ptr2;\n        if (num2_div_4 == 0) {\n          return result;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080093a4": "calculate_product_080093a4",
                "param_1": "num1",
                "param_2": "result",
                "param_3": "num2",
                "iVar1": "index",
                "iVar2": "num2_div_4",
                "puVar3": "ptr1",
                "puVar4": "ptr2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__multiply",
                "_Balloc",
                "__multadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009444": {
            "entrypoint": "0x08009444",
            "current_name": "rearrange_data_08009444",
            "code": "\nvoid rearrangeData_08009444(int dataPointer,undefined4 *paramArray,uint length)\n\n{\n  int increment;\n  int multiplier;\n  int index;\n  undefined4 tempVar;\n  int offset;\n  int tempVar2;\n  uint *targetArray;\n  uint *sourceArray;\n  uint *sourcePointer2;\n  uint *sourcePointer1;\n  int offsetDivisor;\n  int newOffset;\n  uint shiftedBits;\n  uint *sourcePointer;\n  \n  offset = paramArray[4];\n  offsetDivisor = (int)length >> 5;\n  newOffset = offsetDivisor + offset + 1;\n  index = paramArray[1];\n  multiplier = paramArray[2];\n  if ((int)paramArray[2] < newOffset) {\n    do {\n      tempVar2 = multiplier * 2;\n      increment = multiplier * -2;\n      index = index + 1;\n      multiplier = tempVar2;\n    } while (newOffset != tempVar2 && newOffset + increment < 0 == SBORROW4(newOffset,tempVar2));\n  }\n  multiplier = _Balloc(dataPointer,index);\n  targetArray = (uint *)(multiplier + 0x14);\n  if (0 < offsetDivisor) {\n    sourcePointer1 = targetArray + offsetDivisor;\n    sourceArray = targetArray;\n    do {\n      sourcePointer = sourceArray + 1;\n      *sourceArray = 0;\n      targetArray = sourcePointer1;\n      sourceArray = sourcePointer;\n    } while (sourcePointer != sourcePointer1);\n  }\n  index = paramArray[4];\n  sourceArray = paramArray + 5;\n  length = length & 0x1f;\n  if (length == 0) {\n    targetArray = targetArray + -1;\n    sourcePointer1 = sourceArray;\n    do {\n      sourcePointer = sourcePointer1 + 1;\n      targetArray = targetArray + 1;\n      *targetArray = *sourcePointer1;\n      sourcePointer1 = sourcePointer;\n    } while (sourcePointer < sourceArray + index);\n  }\n  else {\n    shiftedBits = 0;\n    sourcePointer1 = sourceArray;\n    do {\n      sourcePointer = targetArray;\n      *sourcePointer = *sourcePointer1 << length | shiftedBits;\n      sourcePointer2 = sourcePointer1 + 1;\n      shiftedBits = *sourcePointer1 >> (0x20 - length & 0xff);\n      targetArray = sourcePointer + 1;\n      sourcePointer1 = sourcePointer2;\n    } while (sourcePointer2 < sourceArray + index);\n    sourcePointer[1] = shiftedBits;\n    if (shiftedBits != 0) {\n      newOffset = offsetDivisor + offset + 2;\n    }\n  }\n  offset = *(int *)(dataPointer + 0x4c);\n  index = paramArray[1];\n  tempVar = *(undefined4 *)(offset + index * 4);\n  *(int *)(multiplier + 0x10) = newOffset + -1;\n  *paramArray = tempVar;\n  *(undefined4 **)(offset + index * 4) = paramArray;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009444": "rearrange_data_08009444",
                "param_1": "dataPointer",
                "param_2": "paramArray",
                "param_3": "length",
                "iVar1": "increment",
                "iVar2": "multiplier",
                "iVar3": "index",
                "uVar4": "tempVar",
                "iVar5": "offset",
                "iVar6": "tempVar2",
                "puVar7": "targetArray",
                "puVar8": "sourceArray",
                "puVar9": "sourcePointer",
                "puVar10": "sourcePointer2",
                "puVar11": "sourcePointer1",
                "iVar12": "offsetDivisor",
                "iVar13": "newOffset",
                "uVar14": "shiftedBits"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094f8": {
            "entrypoint": "0x080094f8",
            "current_name": "compare_arrays_080094f8",
            "code": "\nint compare_arrays_080094f8(int array1,int array2)\n\n{\n  int difference;\n  uint *ptr_array2;\n  int offset;\n  uint *ptr_array1;\n  \n  offset = *(int *)(array2 + 0x10);\n  difference = *(int *)(array1 + 0x10) - offset;\n  if (difference == 0) {\n    ptr_array2 = (uint *)(array2 + 0x14 + offset * 4);\n    ptr_array1 = (uint *)(array1 + 0x14) + offset;\n    do {\n      ptr_array1 = ptr_array1 + -1;\n      ptr_array2 = ptr_array2 + -1;\n      if (*ptr_array1 != *ptr_array2) {\n        if (*ptr_array2 <= *ptr_array1) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1 + 0x14) < ptr_array1);\n  }\n  return difference;\n}\n\n",
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1",
                "param_2": "array2",
                "iVar1": "difference",
                "puVar2": "ptr_array2",
                "iVar3": "offset",
                "puVar4": "ptr_array1"
            },
            "calling": [
                "_dtoa_r",
                "quorem"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009530": {
            "entrypoint": "0x08009530",
            "current_name": "validate_and_copy_data_08009530",
            "code": "\nvoid validateAndCopyData_08009530(undefined4 param1,uint *sourceArray,uint *destinationArray,undefined4 param4)\n\n{\n  int result;\n  uint *sourceArrayLength;\n  uint temp1;\n  uint temp2;\n  undefined4 isLessEqual;\n  uint *destinationArray;\n  uint *sourcePointer;\n  uint *destinationPointer;\n  uint *destinationPointer;\n  uint *sourceArrayStart;\n  int carry;\n  uint *destinationArrayStart;\n  uint sourceArraySize;\n  uint *sourcePointer;\n  \n  sourceArrayLength = (uint *)destinationArray[4];\n  sourceArrayStart = sourceArray + 5;\n  destinationArrayStart = destinationArray + 5;\n  sourcePointer = sourceArrayStart;\n  destinationPointer = sourceArray;\n  if ((uint *)sourceArray[4] == sourceArrayLength) {\n    destinationArray = sourceArrayStart + (int)sourceArrayLength;\n    sourceArrayLength = destinationArrayStart + (int)sourceArrayLength;\n    while( true ) {\n      destinationArray = destinationArray + -1;\n      sourceArrayLength = sourceArrayLength + -1;\n      if (*destinationArray != *sourceArrayLength) break;\n      if (destinationArray <= sourceArrayStart) {\n        carry = _Balloc(param1,0,destinationArray,sourceArrayLength,param4);\n        *(undefined4 *)(carry + 0x10) = 1;\n        *(undefined4 *)(carry + 0x14) = 0;\n        return;\n      }\n    }\n    isLessEqual = 0;\n    if (*sourceArrayLength <= *destinationArray) goto LAB_08009578;\n  }\n  else if (-1 < (int)(uint *)sourceArray[4] - (int)sourceArrayLength) {\n    isLessEqual = 0;\n    destinationArray = destinationArray;\n    goto LAB_08009578;\n  }\n  isLessEqual = 1;\n  destinationArray = sourceArrayStart;\n  sourceArrayLength = sourceArray;\n  sourcePointer = destinationArrayStart;\n  destinationPointer = destinationArray;\n  destinationArray = sourceArray;\n  destinationArrayStart = sourceArrayStart;\nLAB_08009578:\n  result = _Balloc(param1,destinationPointer[1],destinationArray,sourceArrayLength,param4);\n  carry = 0;\n  sourceArraySize = destinationPointer[4];\n  temp1 = destinationArray[4];\n  *(undefined4 *)(result + 0xc) = isLessEqual;\n  sourceArrayStart = sourcePointer + sourceArraySize;\n  sourceArrayLength = (uint *)(result + 0x14);\n  destinationPointer = destinationArrayStart;\n  do {\n    sourcePointer = sourcePointer + 1;\n    destinationPointer = destinationPointer + 1;\n    temp2 = ((*sourcePointer & 0xffff) + carry) - (*destinationPointer & 0xffff);\n    carry = ((*sourcePointer >> 0x10) - (*destinationPointer >> 0x10)) + ((int)temp2 >> 0x10);\n    temp2 = temp2 & 0xffff | carry * 0x10000;\n    destinationArray = sourceArrayLength + 1;\n    *sourceArrayLength = temp2;\n    carry = carry >> 0x10;\n    sourceArrayLength = destinationArray;\n    sourcePointer = sourcePointer;\n    destinationPointer = destinationPointer;\n  } while (destinationPointer < destinationArrayStart + temp1);\n  sourceArrayLength = sourcePointer;\n  sourcePointer = destinationArray;\n  if (sourcePointer < sourceArrayStart) {\n    do {\n      destinationPointer = sourceArrayLength + 1;\n      temp1 = (*sourceArrayLength & 0xffff) + carry;\n      carry = ((int)temp1 >> 0x10) + (*sourceArrayLength >> 0x10);\n      temp2 = temp1 & 0xffff | carry * 0x10000;\n      *sourcePointer = temp2;\n      carry = carry >> 0x10;\n      sourceArrayLength = destinationPointer;\n      sourcePointer = sourcePointer + 1;\n    } while (destinationPointer < sourceArrayStart);\n    destinationArray = (uint *)((int)destinationArray + ((int)sourceArrayStart + ~(uint)sourcePointer & 0xfffffffc) + 4);\n  }\n  destinationArray = destinationArray + -1;\n  while (temp2 == 0) {\n    destinationArray = destinationArray + -1;\n    sourceArraySize = sourceArraySize - 1;\n    temp2 = *destinationArray;\n  }\n  *(uint *)(result + 0x10) = sourceArraySize;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009530": "validate_and_copy_data_08009530",
                "param_1": "param1",
                "param_2": "sourceArray",
                "param_3": "destinationArray",
                "param_4": "param4",
                "iVar1": "result",
                "puVar2": "sourceArrayLength",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "isLessEqual",
                "puVar6": "destinationArray",
                "puVar7": "sourcePointer",
                "puVar9": "destinationPointer",
                "puVar10": "destinationPointer",
                "puVar11": "sourceArrayStart",
                "iVar12": "carry",
                "puVar13": "destinationArrayStart",
                "uVar14": "sourceArraySize",
                "puVar8": "sourcePointer"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009630": {
            "entrypoint": "0x08009630",
            "current_name": "extract_bits_08009630",
            "code": "\nint extract_bits_08009630(undefined4 size,undefined4 option,uint value1,uint value2,int *result1,\n                int *result2)\n\n{\n  int buffer;\n  uint bits;\n  int index;\n  int count;\n  uint shifted;\n  uint shift_amount;\n  undefined8 hi_bits;\n  uint temp_value1;\n  uint temp_value2;\n  \n  buffer = _Balloc(size,1);\n  shift_amount = (value2 << 1) >> 0x15;\n  temp_value2 = value2 & 0xfffff;\n  if (shift_amount != 0) {\n    temp_value2 = temp_value2 | 0x100000;\n  }\n  if (value1 == 0) {\n    index = __lo0bits(&temp_value2);\n    count = 1;\n    bits = index + 0x20;\n    *(undefined4 *)(buffer + 0x10) = 1;\n    *(uint *)(buffer + 0x14) = temp_value2;\n  }\n  else {\n    temp_value1 = value1;\n    bits = __lo0bits(&temp_value1);\n    if (bits == 0) {\n      *(uint *)(buffer + 0x14) = temp_value1;\n    }\n    else {\n      shifted = temp_value2 << (0x20 - bits & 0xff);\n      temp_value2 = temp_value2 >> (bits & 0xff);\n      *(uint *)(buffer + 0x14) = shifted | temp_value1;\n    }\n    if (temp_value2 == 0) {\n      count = 1;\n    }\n    else {\n      count = 2;\n    }\n    *(uint *)(buffer + 0x18) = temp_value2;\n    *(int *)(buffer + 0x10) = count;\n  }\n  if (shift_amount == 0) {\n    *result1 = bits - 0x432;\n    hi_bits = __hi0bits(*(undefined4 *)(buffer + count * 4 + 0x10));\n    *result2 = (int)((ulonglong)hi_bits >> 0x20) * 0x20 - (int)hi_bits;\n    return buffer;\n  }\n  *result1 = (shift_amount - 0x433) + bits;\n  *result2 = 0x35 - bits;\n  return buffer;\n}\n\n",
            "renaming": {
                "FUN_08009630": "extract_bits_08009630",
                "param_1": "size",
                "param_2": "option",
                "param_3": "value1",
                "param_4": "value2",
                "param_5": "result1",
                "param_6": "result2",
                "iVar1": "buffer",
                "uVar2": "bits",
                "iVar3": "index",
                "iVar4": "count",
                "uVar5": "shifted",
                "uVar6": "shift_amount",
                "uVar7": "hi_bits",
                "local_20": "temp_value1",
                "local_1c": "temp_value2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__lo0bits",
                "_Balloc",
                "__hi0bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e0": {
            "entrypoint": "0x080096e0",
            "current_name": "calculate_floating_point_080096e0",
            "code": "\nundefined8 calculateFloatingPoint_080096e0(uint input1Updated,uint input2Updated,int *result,undefined4 constant)\n\n{\n  int variable1;\n  uint variable2;\n  undefined8 combinedInputs;\n  \n  combinedInputs = CONCAT44(input2Updated,input1Updated);\n  variable1 = 0;\n  variable2 = input2Updated & 0x7fffffff;\n  *result = 0;\n  if ((variable2 < 0x7ff00000) && ((variable2 | input1Updated) != 0)) {\n    if (variable2 < 0x100000) {\n      combinedInputs = __muldf3(input1Updated,input2Updated,0,0x43500000,constant);\n      variable1 = -0x36;\n      variable2 = (uint)((ulonglong)combinedInputs >> 0x20) & 0x7fffffff;\n    }\n    input1Updated = (uint)combinedInputs;\n    input2Updated = (uint)((ulonglong)combinedInputs >> 0x20) & 0x800fffff | 0x3fe00000;\n    *result = ((int)variable2 >> 0x14) + -0x3fe + variable1;\n  }\n  return CONCAT44(input2Updated,input1Updated);\n}\n\n",
            "renaming": {
                "FUN_080096e0": "calculate_floating_point_080096e0",
                "param_1": "input1Updated",
                "param_2": "input2Updated",
                "param_3": "result",
                "param_4": "constant",
                "uVar3": "combinedInputs",
                "iVar1": "variable1",
                "uVar2": "variable2"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__muldf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009744": {
            "entrypoint": "0x08009744",
            "current_name": "allocate_memory_08009744",
            "code": "\nvoid allocateMemory_08009744(int *resultPtr,undefined4 size)\n\n{\n  int allocationResult;\n  \n  DAT_20000c10 = 0;\n  allocationResult = _sbrk(size);\n  if ((allocationResult == -1) && (DAT_20000c10 != 0)) {\n    *resultPtr = DAT_20000c10;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009744": "allocate_memory_08009744",
                "param_1": "resultPtr",
                "param_2": "size",
                "iVar1": "allocationResult"
            },
            "calling": [
                "_malloc_trim_r",
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009768": {
            "entrypoint": "0x08009768",
            "current_name": "copy_string_with_null_terminator_08009768",
            "code": "\nvoid copyStringWithNullTerminator_08009768(uint *source,uint *destination,uint size)\n\n{\n  char currentChar;\n  uint *sourcePtr;\n  uint *destinationPtr;\n  uint currentValue;\n  \n  if (((((uint)source | (uint)destination) & 3) == 0) &&\n     (destinationPtr = source, sourcePtr = destination, 3 < size)) {\n    do {\n      destination = sourcePtr + 1;\n      currentValue = *sourcePtr;\n      source = destinationPtr;\n      if ((currentValue + 0xfefefeff & ~currentValue & 0x80808080) != 0) goto LAB_0800979c;\n      size = size - 4;\n      source = destinationPtr + 1;\n      *destinationPtr = currentValue;\n      destinationPtr = source;\n      sourcePtr = destination;\n    } while (3 < size);\n  }\n  sourcePtr = destination;\n  if (size != 0) {\nLAB_0800979c:\n    currentChar = *(char *)sourcePtr;\n    *(char *)source = currentChar;\n    while( true ) {\n      source = (uint *)((int)source + 1);\n      size = size - 1;\n      if (currentChar == '\\0') break;\n      if (size == 0) {\n        return;\n      }\n      sourcePtr = (uint *)((int)sourcePtr + 1);\n      currentChar = *(char *)sourcePtr;\n      *(char *)source = currentChar;\n    }\n    if (size != 0) {\n      sourcePtr = source;\n      do {\n        destinationPtr = (uint *)((int)sourcePtr + 1);\n        *(char *)sourcePtr = '\\0';\n        sourcePtr = destinationPtr;\n      } while (destinationPtr != (uint *)(size + (int)source));\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009768": "copy_string_with_null_terminator_08009768",
                "param_1": "source",
                "param_2": "destination",
                "param_3": "size",
                "cVar1": "currentChar",
                "puVar2": "sourcePtr",
                "puVar3": "destinationPtr",
                "uVar4": "currentValue"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080097cc": {
            "entrypoint": "0x080097cc",
            "current_name": "copy_and_resize_data_080097cc",
            "code": "\nundefined4 copyAndResizeData_080097cc(undefined4 *error,int *source,int *destination)\n\n{\n  int srcPtr;\n  uint lenToCopy;\n  int newPtr;\n  int srcOffset;\n  uint newSize;\n  uint remainingData;\n  undefined4 *currentSrc;\n  undefined4 *nextSrc;\n  undefined4 currentData;\n  \n  if (destination[2] != 0) {\n    srcPtr = *source;\n    newSize = source[2];\n    nextSrc = (undefined4 *)*destination;\n    do {\n      do {\n        currentSrc = nextSrc + 2;\n        currentData = *nextSrc;\n        remainingData = nextSrc[1];\n        nextSrc = currentSrc;\n      } while (remainingData == 0);\n      lenToCopy = remainingData;\n      if ((newSize <= remainingData) && (lenToCopy = newSize, (*(ushort *)(source + 3) & 0x480) != 0)) {\n        srcOffset = srcPtr - source[4];\n        newSize = (source[5] * 3) / 2;\n        lenToCopy = remainingData + 1 + srcOffset;\n        if (newSize < lenToCopy) {\n          newSize = lenToCopy;\n        }\n        if ((int)((uint)*(ushort *)(source + 3) << 0x15) < 0) {\n          newPtr = _malloc_r(error,newSize);\n          if (newPtr == 0) {\nLAB_08009896:\n            *error = 0xc;\n            *(ushort *)(source + 3) = *(ushort *)(source + 3) | 0x40;\n            destination[1] = 0;\n            destination[2] = 0;\n            return 0xffffffff;\n          }\n          memcpy(newPtr,source[4],srcOffset);\n          *(ushort *)(source + 3) = *(ushort *)(source + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          newPtr = _realloc_r(error);\n          if (newPtr == 0) {\n            _free_r(error,source[4]);\n            goto LAB_08009896;\n          }\n        }\n        srcPtr = newPtr + srcOffset;\n        source[5] = newSize;\n        source[4] = newPtr;\n        *source = srcPtr;\n        source[2] = newSize - srcOffset;\n        lenToCopy = remainingData;\n      }\n      memmove(srcPtr,currentData,lenToCopy);\n      srcOffset = destination[2];\n      newSize = source[2] - lenToCopy;\n      srcPtr = *source + lenToCopy;\n      source[2] = newSize;\n      *source = srcPtr;\n      destination[2] = srcOffset - remainingData;\n    } while (srcOffset - remainingData != 0);\n  }\n  destination[1] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080097cc": "copy_and_resize_data_080097cc",
                "param_1": "error",
                "param_2": "source",
                "param_3": "destination",
                "iVar1": "srcPtr",
                "uVar2": "lenToCopy",
                "iVar3": "newPtr",
                "iVar4": "srcOffset",
                "uVar5": "newSize",
                "uVar6": "remainingData",
                "puVar7": "currentSrc",
                "puVar8": "nextSrc",
                "uVar9": "currentData"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "memcpy",
                "_malloc_r",
                "memmove",
                "_free_r",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098c0": {
            "entrypoint": "0x080098c0",
            "current_name": "update_data_080098c0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009906) */\n/* WARNING: Removing unreachable block (ram,0x08009912) */\n\nundefined4 updateData_080098c0(int dataFlag,undefined4 newData,undefined4 data1,undefined4 data2)\n\n{\n  undefined *dataPtr;\n  undefined4 returnValue;\n  uint bitMask;\n  uint index;\n  \n  __retarget_lock_acquire_recursive(DAT_20000448);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  dataPtr = DAT_20000168;\n  index = *(uint *)(DAT_20000168 + 4);\n  if ((int)index < 0x20) {\n    if (dataFlag != 0) {\n      *(undefined4 *)(DAT_20000168 + index * 4 + 0x88) = data1;\n      bitMask = 1 << (index & 0xff);\n      *(uint *)(dataPtr + 0x188) = *(uint *)(dataPtr + 0x188) | bitMask;\n      *(undefined4 *)(dataPtr + index * 4 + 0x108) = data2;\n      if (dataFlag == 2) {\n        *(uint *)(dataPtr + 0x18c) = bitMask | *(uint *)(dataPtr + 0x18c);\n      }\n    }\n    *(uint *)(dataPtr + 4) = index + 1;\n    returnValue = DAT_20000448;\n    *(undefined4 *)(dataPtr + (index + 2) * 4) = newData;\n    __retarget_lock_release_recursive(returnValue);\n    returnValue = 0;\n  }\n  else {\n    __retarget_lock_release_recursive(DAT_20000448);\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080098c0": "update_data_080098c0",
                "param_1": "dataFlag",
                "param_2": "newData",
                "param_3": "data1",
                "param_4": "data2",
                "puVar1": "dataPtr",
                "uVar2": "returnValue",
                "uVar3": "bitMask",
                "uVar4": "index"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009980": {
            "entrypoint": "0x08009980",
            "current_name": "allocate_memory_08009980",
            "code": "\nundefined4 * allocate_memory_08009980(undefined4 size,int element_size,int num_elements)\n\n{\n  undefined4 *ptr_result;\n  uint total_size;\n  undefined4 *ptr_end;\n  \n  ptr_result = (undefined4 *)_malloc_r(size,num_elements * element_size);\n  if (ptr_result == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  total_size = (ptr_result[-1] & 0xfffffffc) - 4;\n  if (total_size < 0x25) {\n    ptr_end = ptr_result;\n    if (0x13 < total_size) {\n      *ptr_result = 0;\n      ptr_result[1] = 0;\n      if (0x1b < total_size) {\n        ptr_result[2] = 0;\n        ptr_result[3] = 0;\n        if (total_size == 0x24) {\n          ptr_result[4] = 0;\n          ptr_result[5] = 0;\n          ptr_end = ptr_result + 6;\n        }\n        else {\n          ptr_end = ptr_result + 4;\n        }\n        *ptr_end = 0;\n        ptr_end[1] = 0;\n        ptr_end[2] = 0;\n        return ptr_result;\n      }\n      ptr_end = ptr_result + 2;\n    }\n    *ptr_end = 0;\n    ptr_end[1] = 0;\n    ptr_end[2] = 0;\n    return ptr_result;\n  }\n  memset(ptr_result,0);\n  return ptr_result;\n}\n\n",
            "renaming": {
                "FUN_08009980": "allocate_memory_08009980",
                "param_1": "size",
                "param_2": "element_size",
                "param_3": "num_elements",
                "puVar1": "ptr_result",
                "uVar2": "total_size",
                "puVar3": "ptr_end"
            },
            "calling": [
                "_Balloc"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a18": {
            "entrypoint": "0x08009a18",
            "current_name": "copy_reverse_memory_08009a18",
            "code": "\nvoid copyReverseMemory_08009a18(undefined4 *destination,undefined4 *source,uint size)\n\n{\n  undefined4 *destPtr;\n  undefined4 *srcPtr;\n  int iteration;\n  undefined *destPtrByte;\n  undefined4 *srcPtrByte;\n  uint remainingSize;\n  uint tempSize;\n  \n  if ((source < destination) && (srcPtr = (undefined4 *)((int)source + size), destination < srcPtr)) {\n    destPtrByte = (undefined *)((int)destination + size);\n    if (size != 0) {\n      do {\n        srcPtr = (undefined4 *)((int)srcPtr + -1);\n        destPtrByte = destPtrByte + -1;\n        *destPtrByte = *(undefined *)srcPtr;\n      } while (source != srcPtr);\n    }\n  }\n  else {\n    tempSize = size;\n    if (0xf < size) {\n      if ((((uint)destination | (uint)source) & 3) != 0) goto LAB_08009abc;\n      srcPtr = source + 4;\n      destPtr = destination + 4;\n      do {\n        srcPtrByte = srcPtr + 4;\n        destPtr[-4] = srcPtr[-4];\n        destPtr[-3] = srcPtr[-3];\n        destPtr[-2] = srcPtr[-2];\n        destPtr[-1] = srcPtr[-1];\n        srcPtr = srcPtrByte;\n        destPtr = destPtr + 4;\n      } while (srcPtrByte != (undefined4 *)((int)source + (size - 0x10 & 0xfffffff0) + 0x20));\n      iteration = (size - 0x10 >> 4) + 1;\n      tempSize = size & 0xf;\n      source = source + iteration * 4;\n      destination = destination + iteration * 4;\n      if (3 < tempSize) {\n        srcPtr = destination + -1;\n        remainingSize = tempSize;\n        destPtr = source;\n        do {\n          remainingSize = remainingSize - 4;\n          srcPtr = srcPtr + 1;\n          *srcPtr = *destPtr;\n          destPtr = destPtr + 1;\n        } while (3 < remainingSize);\n        iteration = (tempSize - 4 & 0xfffffffc) + 4;\n        destination = (undefined4 *)((int)destination + iteration);\n        source = (undefined4 *)((int)source + iteration);\n        tempSize = size & 3;\n      }\n    }\n    size = tempSize;\n    if (tempSize != 0) {\nLAB_08009abc:\n      destPtrByte = (undefined *)((int)destination + -1);\n      srcPtr = source;\n      do {\n        destPtr = (undefined4 *)((int)srcPtr + 1);\n        destPtrByte = destPtrByte + 1;\n        *destPtrByte = *(undefined *)srcPtr;\n        srcPtr = destPtr;\n      } while (destPtr != (undefined4 *)(size + (int)source));\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009a18": "copy_reverse_memory_08009a18",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "puVar1": "destPtr",
                "puVar2": "srcPtr",
                "iVar3": "iteration",
                "puVar4": "destPtrByte",
                "puVar5": "srcPtrByte",
                "uVar6": "remainingSize",
                "uVar7": "tempSize"
            },
            "calling": [
                "__ssprint_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009adc": {
            "entrypoint": "0x08009adc",
            "current_name": "allocate_memory_08009adc",
            "code": "\nint * allocate_memory_08009adc(undefined4 *error_ptr,int *ptr,uint size)\n\n{\n  int *ptr1;\n  int var2;\n  int *ptr2;\n  uint var4;\n  int var5;\n  uint var6;\n  int *ptr3;\n  uint var8;\n  uint var9;\n  uint var10;\n  int var11;\n  \n  if (ptr == (int *)0x0) {\n    ptr2 = (int *)_malloc_r(error_ptr,size);\n    return ptr2;\n  }\n  __malloc_lock();\n  var6 = ptr[-1];\n  var9 = var6 & 0xfffffffc;\n  ptr2 = ptr + -2;\n  if (size + 0xb < 0x17) {\n    var8 = 0x10;\n  }\n  else {\n    var8 = size + 0xb & 0xfffffff8;\n    if ((int)var8 < 0) goto LAB_08009b8e;\n  }\n  if (var8 < size) {\nLAB_08009b8e:\n    *error_ptr = 0xc;\n    return (int *)0x0;\n  }\n  var11 = (int)ptr2 + var9;\n  var10 = var9;\n  if ((int)var9 < (int)var8) {\n    if (DAT_20000454 == var11) {\n      var11 = (*(uint *)(DAT_20000454 + 4) & 0xfffffffc) + var9;\n      if ((int)(var8 + 0x10) <= var11) {\n        DAT_20000454 = (int)ptr2 + var8;\n        *(uint *)(DAT_20000454 + 4) = var11 - var8 | 1;\n        ptr[-1] = var8 | ptr[-1] & 1U;\n        __malloc_unlock(error_ptr);\n        return ptr;\n      }\n      if (-1 < (int)(var6 << 0x1f)) {\n        ptr1 = (int *)((int)ptr2 - ptr[-2]);\n        var6 = ptr1[1] & 0xfffffffc;\n        if ((int)(var8 + 0x10) <= (int)(var11 + var6)) {\n          var5 = ptr1[3];\n          ptr2 = ptr1 + 2;\n          var2 = *ptr2;\n          var9 = var9 - 4;\n          *(int *)(var2 + 0xc) = var5;\n          *(int *)(var5 + 8) = var2;\n          if (var9 < 0x25) {\n            var2 = *ptr;\n            ptr3 = ptr2;\n            if (0x13 < var9) {\n              ptr1[2] = var2;\n              ptr1[3] = ptr[1];\n              var2 = ptr[2];\n              if (var9 < 0x1c) {\n                ptr = ptr + 2;\n                ptr3 = ptr1 + 4;\n              }\n              else {\n                ptr1[4] = var2;\n                ptr1[5] = ptr[3];\n                var2 = ptr[4];\n                if (var9 == 0x24) {\n                  ptr1[6] = var2;\n                  ptr1[7] = ptr[5];\n                  var2 = ptr[6];\n                  ptr = ptr + 6;\n                  ptr3 = ptr1 + 8;\n                }\n                else {\n                  ptr = ptr + 4;\n                  ptr3 = ptr1 + 6;\n                }\n              }\n            }\n            *ptr3 = var2;\n            ptr3[1] = ptr[1];\n            ptr3[2] = ptr[2];\n          }\n          else {\n            memmove(ptr2,ptr);\n          }\n          DAT_20000454 = (int)ptr1 + var8;\n          *(uint *)(DAT_20000454 + 4) = (var11 + var6) - var8 | 1;\n          ptr1[1] = var8 | ptr1[1] & 1U;\n          __malloc_unlock(error_ptr);\n          return ptr2;\n        }\nLAB_08009bb0:\n        var10 = var9 + var6;\n        if ((int)var8 <= (int)var10) {\n          var5 = ptr1[3];\n          ptr3 = ptr1 + 2;\n          var2 = *ptr3;\n          *(int *)(var2 + 0xc) = var5;\n          var11 = (int)ptr1 + var10;\n          *(int *)(var5 + 8) = var2;\n          ptr2 = ptr1;\n          if (var9 - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          memmove(ptr3,ptr);\n          ptr = ptr3;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(var11 + 4) & 0xfffffffe) + var11 + 4) << 0x1f) {\n        var4 = *(uint *)(var11 + 4) & 0xfffffffc;\n        var10 = var9 + var4;\n        if ((int)var10 < (int)var8) {\n          if ((int)(var6 << 0x1f) < 0) goto LAB_08009b36;\n          ptr1 = (int *)((int)ptr2 - ptr[-2]);\n          var6 = ptr1[1] & 0xfffffffc;\n          var10 = var4 + var6 + var9;\n          if ((int)var10 < (int)var8) goto LAB_08009bb0;\n          var2 = *(int *)(var11 + 8);\n          var11 = *(int *)(var11 + 0xc);\n          *(int *)(var2 + 0xc) = var11;\n          *(int *)(var11 + 8) = var2;\n          ptr3 = ptr1 + 2;\n          var2 = *ptr3;\n          var5 = ptr1[3];\n          *(int *)(var2 + 0xc) = var5;\n          var11 = (int)ptr1 + var10;\n          *(int *)(var5 + 8) = var2;\n          ptr2 = ptr1;\n          if (0x24 < var9 - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          var9 = var9 - 4;\n          var2 = *ptr;\n          ptr1 = ptr3;\n          if (0x13 < var9) {\n            ptr2[2] = var2;\n            ptr2[3] = ptr[1];\n            var2 = ptr[2];\n            if (var9 < 0x1c) {\n              ptr = ptr + 2;\n              ptr1 = ptr2 + 4;\n            }\n            else {\n              ptr2[4] = var2;\n              ptr2[5] = ptr[3];\n              var2 = ptr[4];\n              if (var9 == 0x24) {\n                ptr2[6] = var2;\n                ptr2[7] = ptr[5];\n                var2 = ptr[6];\n                ptr = ptr + 6;\n                ptr1 = ptr2 + 8;\n              }\n              else {\n                ptr = ptr + 4;\n                ptr1 = ptr2 + 6;\n              }\n            }\n          }\n          *ptr1 = var2;\n          ptr1[1] = ptr[1];\n          ptr1[2] = ptr[2];\n          ptr = ptr3;\n        }\n        else {\n          var2 = *(int *)(var11 + 8);\n          var5 = *(int *)(var11 + 0xc);\n          *(int *)(var2 + 0xc) = var5;\n          var11 = (int)ptr2 + var10;\n          *(int *)(var5 + 8) = var2;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(var6 << 0x1f)) {\n        ptr1 = (int *)((int)ptr2 - ptr[-2]);\n        var6 = ptr1[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    ptr1 = (int *)_malloc_r(error_ptr,size);\n    if (ptr1 != (int *)0x0) {\n      if ((int *)((ptr[-1] & 0xfffffffeU) + (int)ptr2) == ptr1 + -2) {\n        var10 = var9 + (ptr1[-1] & 0xfffffffcU);\n        var11 = (int)ptr2 + var10;\n        goto LAB_08009c00;\n      }\n      var9 = var9 - 4;\n      if (var9 < 0x25) {\n        var11 = *ptr;\n        ptr2 = ptr;\n        ptr3 = ptr1;\n        if (0x13 < var9) {\n          *ptr1 = var11;\n          ptr1[1] = ptr[1];\n          if (var9 < 0x1c) {\n            var11 = ptr[2];\n            ptr2 = ptr + 2;\n            ptr3 = ptr1 + 2;\n          }\n          else {\n            ptr1[2] = ptr[2];\n            ptr1[3] = ptr[3];\n            if (var9 == 0x24) {\n              ptr1[4] = ptr[4];\n              ptr1[5] = ptr[5];\n              var11 = ptr[6];\n              ptr2 = ptr + 6;\n              ptr3 = ptr1 + 6;\n            }\n            else {\n              var11 = ptr[4];\n              ptr2 = ptr + 4;\n              ptr3 = ptr1 + 4;\n            }\n          }\n        }\n        *ptr3 = var11;\n        ptr3[1] = ptr2[1];\n        ptr3[2] = ptr2[2];\n      }\n      else {\n        memmove(ptr1,ptr);\n      }\n      _free_r(error_ptr,ptr);\n    }\n    __malloc_unlock(error_ptr);\n    ptr = ptr1;\n  }\n  else {\nLAB_08009c00:\n    if (var10 - var8 < 0x10) {\n      ptr2[1] = ptr2[1] & 1U | var10;\n      *(uint *)(var11 + 4) = *(uint *)(var11 + 4) | 1;\n    }\n    else {\n      ptr2[1] = ptr2[1] & 1U | var8;\n      *(uint *)((int)ptr2 + var8 + 4) = var10 - var8 | 1;\n      *(uint *)(var11 + 4) = *(uint *)(var11 + 4) | 1;\n      _free_r(error_ptr,(int)ptr2 + var8 + 8);\n    }\n    __malloc_unlock(error_ptr);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08009adc": "allocate_memory_08009adc",
                "param_1": "error_ptr",
                "param_2": "ptr",
                "param_3": "size",
                "piVar1": "ptr1",
                "iVar2": "var2",
                "piVar3": "ptr2",
                "uVar4": "var4",
                "iVar5": "var5",
                "uVar6": "var6",
                "piVar7": "ptr3",
                "uVar8": "var8",
                "uVar9": "var9",
                "uVar10": "var10",
                "iVar11": "var11"
            },
            "calling": [
                "__ssprint_r"
            ],
            "called": [
                "_malloc_r",
                "memmove",
                "__malloc_unlock",
                "_free_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e68": {
            "entrypoint": "0x08009e68",
            "current_name": "FUNC_08009e68",
            "code": "\nvoid FUNC_08009e68(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e68": "FUNC_08009e68"
            },
            "calling": [
                "__libc_init_array",
                "frame_dummy",
                "__do_global_dtors_aux"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009e74": {
            "entrypoint": "0x08009e74",
            "current_name": "FUNC_08009e74",
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 150072,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000158",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_080003f4",
            "FUN_08000418",
            "FUN_080006a4",
            "FUN_0800088a",
            "FUN_080008fc",
            "FUN_08000978",
            "FUN_08000988",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_080009c0",
            "FUN_080009d4",
            "FUN_080009e8",
            "FUN_080009fc",
            "FUN_08000aa4",
            "FUN_08000aa8",
            "FUN_08000c08",
            "FUN_08000c10",
            "FUN_08000cb8",
            "FUN_08000e20",
            "FUN_08000f68",
            "FUN_08000fc8",
            "FUN_08000fd0",
            "FUN_08000ff4",
            "FUN_08001030",
            "FUN_08001044",
            "FUN_08001084",
            "FUN_08001170",
            "FUN_0800119c",
            "FUN_080011ec",
            "FUN_0800121c",
            "FUN_080014f0",
            "FUN_0800151c",
            "FUN_0800157c",
            "FUN_080015a0",
            "FUN_080015b4",
            "FUN_080015fc",
            "FUN_08001618",
            "FUN_0800166c",
            "FUN_080016d0",
            "FUN_08001714",
            "FUN_0800172a",
            "FUN_08001762",
            "FUN_0800177c",
            "FUN_080017b4",
            "FUN_080017c4",
            "FUN_08001a80",
            "FUN_08001ab0",
            "FUN_08001ccc",
            "FUN_08001f6c",
            "FUN_08002640",
            "FUN_080027f4",
            "FUN_08002ad8",
            "FUN_08002bb4",
            "FUN_08002c2e",
            "FUN_08002ca8",
            "FUN_08002d3c",
            "FUN_08002d98",
            "FUN_08003260",
            "FUN_08003440",
            "FUN_08003504",
            "FUN_08003518",
            "FUN_08003540",
            "FUN_08003568",
            "FUN_080035a4",
            "FUN_0800360c",
            "FUN_08003640",
            "FUN_080036a8",
            "FUN_080036f8",
            "FUN_08003908",
            "FUN_08003a94",
            "FUN_08003c94",
            "FUN_08003d60",
            "FUN_08003e38",
            "FUN_08003f18",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08004104",
            "FUN_0800416a",
            "FUN_080041a8",
            "FUN_080041ea",
            "FUN_0800422e",
            "FUN_080042de",
            "FUN_0800438a",
            "FUN_08004436",
            "FUN_080046ec",
            "FUN_0800491c",
            "FUN_080049cc",
            "FUN_08004ae0",
            "FUN_08004bd8",
            "FUN_08004d78",
            "FUN_08004e6c",
            "FUN_08004e74",
            "FUN_08004ea4",
            "FUN_08004ee8",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f60",
            "FUN_08004f78",
            "FUN_08005224",
            "FUN_080052a0",
            "FUN_08005348",
            "FUN_080053b0",
            "FUN_08005500",
            "FUN_08005598",
            "FUN_080055f4",
            "FUN_08005674",
            "FUN_08005680",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_08005728",
            "FUN_08005780",
            "FUN_080057e8",
            "FUN_08005838",
            "FUN_080059f0",
            "FUN_08005d14",
            "FUN_08005d20",
            "FUN_08005d68",
            "FUN_08005dfc",
            "FUN_08005e40",
            "FUN_080078c0",
            "FUN_080079e8",
            "FUN_0800884c",
            "FUN_080088ec",
            "FUN_08008ad4",
            "FUN_08008af8",
            "FUN_0800901c",
            "FUN_080090a8",
            "FUN_080090b4",
            "FUN_080090c0",
            "FUN_0800910c",
            "FUN_08009120",
            "FUN_080091a4",
            "FUN_080091e4",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_080093a4",
            "FUN_08009444",
            "FUN_080094f8",
            "FUN_08009530",
            "FUN_08009630",
            "FUN_080096e0",
            "FUN_08009744",
            "FUN_08009768",
            "FUN_080097cc",
            "FUN_080098c0",
            "FUN_08009980",
            "FUN_08009a18",
            "FUN_08009adc"
        ],
        [
            "FUN_080004c8",
            "FUN_0800071c"
        ]
    ],
    "locked_functions": []
}